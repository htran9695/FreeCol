<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColonyPlan.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.ai</a> &gt; <span class="el_source">ColonyPlan.java</span></div><h1>ColonyPlan.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.ai;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.AbstractGoods;
import net.sf.freecol.common.model.BuildableType;
import net.sf.freecol.common.model.BuildingType;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.FreeColObject;
import net.sf.freecol.common.model.GoodsContainer;
import net.sf.freecol.common.model.GoodsType;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.Market;
import net.sf.freecol.common.model.Modifier;
import net.sf.freecol.common.model.NationType;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Scope;
import net.sf.freecol.common.model.Specification;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.Role;
import net.sf.freecol.common.model.UnitType;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import net.sf.freecol.common.model.WorkLocation;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.LogBuilder;


/**
 * Objects of this class describes the plan the AI has for a
 * &lt;code&gt;Colony&lt;/code&gt;.
 *
 * A &lt;code&gt;ColonyPlan&lt;/code&gt; contains a list of
 * {@link WorkLocationPlan}s which suggests the food and non-food
 * production of each {@link WorkLocation}, and a list of
 * {@link BuildableType}s to build.  It takes account of the available
 * tiles and building production, but does not make decisions to claim
 * tiles or change the current buildable.  It does takes account of
 * goods present in the colony, and overall colony size but not the
 * exact composition of the units involved.  However there is
 * extensive structure for making a trial assignment of workers in
 * {@link #assignWorkers}.
 *
 * {@link AIColony#rearrangeWorkers} is responsible for making
 * the real decisions.
 *
 * @see Colony
 */
public class ColonyPlan {

<span class="fc" id="L79">    private static final Logger logger = Logger.getLogger(ColonyPlan.class.getName());</span>

    /** Require production plans to always produce an amount exceeding this. */
    private static final int LOW_PRODUCTION_THRESHOLD = 1;

    /**
     * Number of turns to require production of without exhausting the
     * input goods.
     */
    private static final int PRODUCTION_TURNOVER_TURNS = 5;

    /** The profile of the colony (a sort of general flavour). */
<span class="pc" id="L91">    private static enum ProfileType {</span>
<span class="fc" id="L92">        OUTPOST,</span>
<span class="fc" id="L93">        SMALL,</span>
<span class="fc" id="L94">        MEDIUM,</span>
<span class="fc" id="L95">        LARGE,</span>
<span class="fc" id="L96">        CAPITAL;</span>

        /**
         * Chooses a suitable profile type given a size of colony.
         *
         * @param size A proposed colony size.
         */
        public static ProfileType getProfileTypeFromSize(int size) {
<span class="pc bpc" id="L104" title="2 of 8 branches missed.">            return (size &lt;= 1) ? ProfileType.OUTPOST</span>
                : (size &lt;= 2) ? ProfileType.SMALL
                : (size &lt;= 4) ? ProfileType.MEDIUM
                : (size &lt;= 8) ? ProfileType.LARGE
                : ProfileType.CAPITAL;
        }
    };
    private ProfileType profileType;

    /** Private copy of the AIMain. */
    private final AIMain aiMain;

    /** The colony this AIColony manages. */
    private final Colony colony;

    /** The things to build, and their priority. */
    private static class BuildPlan {

        public final BuildableType type;
        public double weight;
        public double support;
        public double difficulty;

<span class="fc" id="L127">        public BuildPlan(BuildableType type, double weight, double support) {</span>
<span class="fc" id="L128">            this.type = type;</span>
<span class="fc" id="L129">            this.weight = weight;</span>
<span class="fc" id="L130">            this.support = support;</span>
<span class="fc" id="L131">            this.difficulty = 1.0f;</span>
<span class="fc" id="L132">        }</span>

        public double getValue() {
<span class="fc" id="L135">            return weight * support / difficulty;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L143">            return String.format(&quot;%s (%1.3f * %1.3f / %1.3f = %1.3f)&quot;,</span>
<span class="nc" id="L144">                                 type.getSuffix(), weight, support,</span>
<span class="nc" id="L145">                                 difficulty, getValue());</span>
        }
    };
<span class="fc" id="L148">    private final List&lt;BuildPlan&gt; buildPlans = new ArrayList&lt;&gt;();</span>

    /**
     * Comparator to sort buildable types on their priority in the
     * buildPlan map.
     */
<span class="fc" id="L154">    private static final Comparator&lt;BuildPlan&gt; buildPlanComparator</span>
<span class="fc" id="L155">        = new Comparator&lt;BuildPlan&gt;() {</span>
            @Override
            public int compare(BuildPlan b1, BuildPlan b2) {
<span class="fc" id="L158">                double d = b1.getValue() - b2.getValue();</span>
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">                return (d &gt; 0.0) ? -1 : (d &lt; 0.0) ? 1 : 0;</span>
            }
        };

    /** Plans for work locations available to this colony. */
<span class="fc" id="L164">    private final List&lt;WorkLocationPlan&gt; workPlans = new ArrayList&lt;&gt;();</span>

    /** The goods types to produce. */
<span class="fc" id="L167">    private final List&lt;GoodsType&gt; produce = new ArrayList&lt;&gt;();</span>

    /**
     * Lists of goods types to be produced in this colony.
     * Temporary variables that do not need to be serialized.
     */
<span class="fc" id="L173">    private final List&lt;GoodsType&gt; foodGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L174">    private final List&lt;GoodsType&gt; libertyGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L175">    private final List&lt;GoodsType&gt; immigrationGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L176">    private final List&lt;GoodsType&gt; militaryGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">    private final List&lt;GoodsType&gt; rawBuildingGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L178">    private final List&lt;GoodsType&gt; buildingGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L179">    private final List&lt;GoodsType&gt; rawLuxuryGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L180">    private final List&lt;GoodsType&gt; luxuryGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L181">    private final List&lt;GoodsType&gt; otherRawGoodsTypes = new ArrayList&lt;&gt;();</span>


    /**
     * Creates a new &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @param aiMain The main AI-object.
     * @param colony The colony to make a &lt;code&gt;ColonyPlan&lt;/code&gt; for.
     */
<span class="fc" id="L190">    public ColonyPlan(AIMain aiMain, Colony colony) {</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (aiMain == null) throw new IllegalArgumentException(&quot;Null AIMain&quot;);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (colony == null) throw new IllegalArgumentException(&quot;Null colony&quot;);</span>

<span class="fc" id="L194">        this.aiMain = aiMain;</span>
<span class="fc" id="L195">        this.colony = colony;</span>
<span class="fc" id="L196">        this.profileType = ProfileType</span>
<span class="fc" id="L197">            .getProfileTypeFromSize(colony.getUnitCount());</span>
<span class="fc" id="L198">    }</span>


    /**
     * Gets the main AI-object.
     *
     * @return The main AI-object.
     */
    private AIMain getAIMain() {
<span class="fc" id="L207">        return aiMain;</span>
    }

    /**
     * Gets the specification.
     *
     * @return The specification.
     */
    private Specification spec() {
<span class="fc" id="L216">        return aiMain.getGame().getSpecification();</span>
    }


    // Public functionality.

    /**
     * Gets the preferred goods to produce.
     *
     * @return A copy of the preferred goods production list in this plan.
     */
    public List&lt;GoodsType&gt; getPreferredProduction() {
<span class="fc" id="L228">        return new ArrayList&lt;&gt;(produce);</span>
    }

    /**
     * Gets a copy of the current list of buildable types associated
     * with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @return A copy of the of &lt;code&gt;BuildableType&lt;/code&gt;s list.
     */
    public List&lt;BuildableType&gt; getBuildableTypes() {
<span class="fc" id="L238">        List&lt;BuildableType&gt; build = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (BuildPlan b : buildPlans) build.add(b.type);</span>
<span class="fc" id="L240">        return build;</span>
    }

    /**
     * Gets the best buildable type from this plan that can currently
     * be built by the colony.
     *
     * @return The best current &lt;code&gt;BuildableType&lt;/code&gt;.
     */
    public BuildableType getBestBuildableType() {
<span class="fc" id="L250">        BuildPlan bp = find(buildPlans, p -&gt; colony.canBuild(p.type));</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        return (bp == null) ? null : bp.type;</span>
    }

    /**
     * Get a report on the build plans.
     *
     * @return A build plan report.
     */
    public String getBuildableReport() {
<span class="nc" id="L260">        LogBuilder lb = new LogBuilder(64);</span>
<span class="nc" id="L261">        lb.add(&quot;Buildables:\n&quot;);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        for (BuildPlan b : buildPlans) lb.add(b, &quot;\n&quot;);</span>
<span class="nc" id="L263">        return lb.toString();</span>
    }

    /**
     * Gets the food-producing and non-autoproducing work location
     * plans associated with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @return A list of food producing plans.
     */
    public List&lt;WorkLocationPlan&gt; getFoodPlans() {
<span class="fc" id="L273">        return workPlans.stream()</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            .filter(wp -&gt; wp.isFoodPlan()</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                &amp;&amp; !wp.getWorkLocation().canAutoProduce())</span>
<span class="fc" id="L276">            .collect(Collectors.toList());</span>
    }

    /**
     * Gets the non-food-producing/non-autoproducing work location
     * plans associated with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @return A list of non-food producing plans.
     */
    public List&lt;WorkLocationPlan&gt; getWorkPlans() {
<span class="fc" id="L286">        return workPlans.stream()</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            .filter(wp -&gt; !wp.isFoodPlan()</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">                &amp;&amp; !wp.getWorkLocation().canAutoProduce())</span>
<span class="fc" id="L289">            .collect(Collectors.toList());</span>
    }

    /**
     * Refines this plan given the colony choice of what to build.
     *
     * @param build The &lt;code&gt;BuildableType&lt;/code&gt; to be built (may be null).
     * @param lb A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     */
    public void refine(BuildableType build, LogBuilder lb) {
<span class="fc" id="L299">        List&lt;GoodsType&gt; required = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        for (AbstractGoods ag : colony.getFullRequiredGoods(build)) {</span>
<span class="fc" id="L301">            required.add(ag.getType());</span>
<span class="fc" id="L302">        }</span>
<span class="fc" id="L303">        Map&lt;GoodsType, List&lt;WorkLocationPlan&gt;&gt; suppressed = new HashMap&lt;&gt;();</span>

        // Examine a copy of the work plans, but operate on the
        // original list.  Maintain a offset between the index in the
        // copied list and the original to aid reinsertion.
        //
        // Remove any work plans to make raw/building goods that are
        // not required to complete the current buildable, but take
        // care to put such plans back again if a plan is encountered
        // that makes goods that are made from a type that was removed
        // and there is less than CARGO_SIZE/2 of that type in stock.
        // Note though in such cases the position of the
        // building-goods plans in the work plans list will have moved
        // from their usual high priority to immediately before the
        // position of the manufactured goods.
        //
        // So, for example, we should suppress tool building when a
        // colony is building a warehouse, unless we find a plan to
        // make muskets and the tool stock is low.
        //
        // FIXME: generalize this further to make tools for pioneers.
        //
<span class="fc" id="L325">        List&lt;WorkLocationPlan&gt; plans = new ArrayList&lt;&gt;(workPlans);</span>
<span class="fc" id="L326">        int offset = 0;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int i = 0; i &lt; plans.size(); i++) {</span>
            List&lt;WorkLocationPlan&gt; wls;
<span class="fc" id="L329">            WorkLocationPlan wlp = plans.get(i);</span>
<span class="fc" id="L330">            GoodsType g = wlp.getGoodsType();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if ((rawBuildingGoodsTypes.contains(g)</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                    &amp;&amp; !required.contains(g.getOutputType()))</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                || (buildingGoodsTypes.contains(g)</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    &amp;&amp; !required.contains(g))) {</span>
<span class="fc" id="L335">                workPlans.remove(i - offset);</span>
<span class="fc" id="L336">                offset++;</span>
<span class="fc" id="L337">                wls = suppressed.get(g);</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                if (wls == null) wls = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L339">                wls.add(0, wlp); // reverses list</span>
<span class="fc" id="L340">                suppressed.put(g, wls);</span>
<span class="fc" id="L341">                produce.remove(g);</span>
<span class="fc" id="L342">                lb.add(&quot;, suppress production of &quot;, g);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            } else if (g.isRefined()</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                &amp;&amp; (rawBuildingGoodsTypes.contains(g.getInputType())</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                    || buildingGoodsTypes.contains(g.getInputType()))) {</span>
<span class="fc" id="L346">                int n = 0, idx = produce.indexOf(g);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                for (GoodsType type = g.getInputType(); type != null;</span>
<span class="nc" id="L348">                     type = type.getInputType()) {</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                    if ((wls = suppressed.get(type)) == null) break;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    if (colony.getGoodsCount(type)</span>
<span class="nc" id="L351">                        &gt;= GoodsContainer.CARGO_SIZE/2) break;</span>
<span class="nc" id="L352">                    n += wls.size();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                    while (!wls.isEmpty()) {</span>
                        // reverses again when adding, cancelling reversal above
<span class="nc" id="L355">                        workPlans.add(i - offset, wls.remove(0));</span>
                    }
<span class="nc" id="L357">                    produce.add(idx, type);</span>
<span class="nc" id="L358">                    lb.add(&quot;, restore production of &quot;, type);</span>
                }
<span class="fc" id="L360">                offset -= n;</span>
            }
        }
<span class="fc" id="L363">    }</span>

    /**
     * Recreates the buildables and work location plans for this
     * colony.
     */
    public void update() {
        // Update the profile type.
<span class="fc" id="L371">        profileType = ProfileType.getProfileTypeFromSize(colony.getUnitCount());</span>

        // Build the total map of all possible production with standard units.
<span class="fc" id="L374">        Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production</span>
<span class="fc" id="L375">            = createProductionMap();</span>

        // Set the goods type lists, and prune production of manufactured
        // goods that are missing raw materials and other non-interesting.
<span class="fc" id="L379">        updateGoodsTypeLists(production);</span>

        // Set the preferred raw materials.  Prune production and
        // goods lists further removing the non-preferred new world
        // raw and refined materials.
<span class="fc" id="L384">        updateRawMaterials(production);</span>

        // The buildables depend on the profile type, the goods type lists
        // and/or goods-to-produce list.
<span class="fc" id="L388">        updateBuildableTypes();</span>

        // Make plans for each valid &lt;goods, location&gt; production and
        // complete the list of goods to produce.
<span class="fc" id="L392">        updatePlans(production);</span>
<span class="fc" id="L393">    }</span>


    // Internals

    /**
     * Creates a map of potential production of all goods types
     * from all available work locations using the default unit type.
     * Includes non-workable locations (e.g. chapel, colony-center-tile)
     * as their production can influence the choice of goods to produce.
     *
     * @return The map of potential production.
     */
    private Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; createProductionMap() {
<span class="fc" id="L407">        Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (WorkLocation wl : colony.getAvailableWorkLocations()) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">            for (GoodsType g : spec().getGoodsTypeList()) {</span>
<span class="fc" id="L410">                int p = wl.getGenericPotential(g);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">                if (p &gt; 0) {</span>
<span class="fc" id="L412">                    Map&lt;WorkLocation, Integer&gt; m = production.get(g);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">                    if (m == null) {</span>
<span class="fc" id="L414">                        m = new HashMap&lt;&gt;();</span>
<span class="fc" id="L415">                        production.put(g, m);</span>
                    }
<span class="fc" id="L417">                    m.put(wl, p);</span>
                }
<span class="fc" id="L419">            }</span>
<span class="fc" id="L420">        }</span>
<span class="fc" id="L421">        return production;</span>
    }

    /**
     * Updates the goods type lists.  The categories are:&lt;UL&gt;
     * &lt;LI&gt;food&lt;/LI&gt;
     * &lt;LI&gt;liberty&lt;/LI&gt;
     * &lt;LI&gt;immigration&lt;/LI&gt;
     * &lt;LI&gt;military&lt;/LI&gt;
     * &lt;LI&gt;raw building&lt;/LI&gt;
     * &lt;LI&gt;building&lt;/LI&gt;
     * &lt;LI&gt;raw luxury&lt;/LI&gt;
     * &lt;LI&gt;luxury&lt;/LI&gt;
     * &lt;LI&gt;raw other&lt;/LI&gt;
     * &lt;/UL&gt;
     *
     * Ignore raw materials which can not be refined and refined goods
     * that have no raw materials available.  Also ignore other goods
     * that do not fit these categories (e.g. trade goods).
     *
     * @param production The production map.
     */
    private void updateGoodsTypeLists(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L444">        foodGoodsTypes.clear();</span>
<span class="fc" id="L445">        libertyGoodsTypes.clear();</span>
<span class="fc" id="L446">        immigrationGoodsTypes.clear();</span>
<span class="fc" id="L447">        militaryGoodsTypes.clear();</span>
<span class="fc" id="L448">        rawBuildingGoodsTypes.clear();</span>
<span class="fc" id="L449">        buildingGoodsTypes.clear();</span>
<span class="fc" id="L450">        rawLuxuryGoodsTypes.clear();</span>
<span class="fc" id="L451">        luxuryGoodsTypes.clear();</span>
<span class="fc" id="L452">        otherRawGoodsTypes.clear();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        for (GoodsType g : new ArrayList&lt;&gt;(production.keySet())) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (g.isFoodType()) {</span>
<span class="fc" id="L455">                foodGoodsTypes.add(g);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            } else if (g.isLibertyType()) {</span>
<span class="fc" id="L457">                libertyGoodsTypes.add(g);</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">            } else if (g.isImmigrationType()) {</span>
<span class="nc" id="L459">                immigrationGoodsTypes.add(g);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">            } else if (g.isMilitaryGoods()) {</span>
<span class="fc" id="L461">                militaryGoodsTypes.add(g);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            } else if (g.isRawBuildingMaterial()) {</span>
<span class="fc" id="L463">                rawBuildingGoodsTypes.add(g);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            } else if (g.isBuildingMaterial()</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                &amp;&amp; g.getInputType().isRawBuildingMaterial()) {</span>
<span class="fc" id="L466">                buildingGoodsTypes.add(g);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            } else if (g.isNewWorldGoodsType()) {</span>
<span class="fc" id="L468">                rawLuxuryGoodsTypes.add(g);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            } else if (g.isRefined()</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                &amp;&amp; g.getInputType().isNewWorldGoodsType()) {</span>
<span class="fc" id="L471">                luxuryGoodsTypes.add(g);</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">            } else if (g.isFarmed()) {</span>
<span class="fc" id="L473">                otherRawGoodsTypes.add(g);</span>
            } else { // Not interested in this goods type.  Should not happen.
<span class="nc" id="L475">                logger.warning(&quot;Ignoring goods type &quot; + g</span>
<span class="nc" id="L476">                    + &quot; at &quot; + colony.getName());</span>
<span class="nc" id="L477">                production.remove(g);</span>
            }
<span class="fc" id="L479">        }</span>
<span class="fc" id="L480">    }</span>

    /**
     * Chooses the two best raw materials, updating the production
     * map and lists.
     *
     * FIXME: scale with colony size.
     *
     * @param production The production map.
     */
    private void updateRawMaterials(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L491">        Player player = colony.getOwner();</span>
<span class="fc" id="L492">        Market market = player.getMarket();</span>
<span class="fc" id="L493">        NationType nationType = player.getNationType();</span>
<span class="fc" id="L494">        GoodsType primaryRawMaterial = null;</span>
<span class="fc" id="L495">        GoodsType secondaryRawMaterial = null;</span>
<span class="fc" id="L496">        int primaryValue = -1;</span>
<span class="fc" id="L497">        int secondaryValue = -1;</span>

<span class="fc" id="L499">        produce.clear();</span>
<span class="fc" id="L500">        List&lt;GoodsType&gt; rawMaterials = new ArrayList&lt;&gt;(rawLuxuryGoodsTypes);</span>
<span class="fc" id="L501">        rawMaterials.addAll(otherRawGoodsTypes);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (GoodsType g : rawMaterials) {</span>
<span class="fc" id="L503">            int value = production.get(g).entrySet().stream()</span>
<span class="fc" id="L504">                .mapToInt(e -&gt; e.getValue()).sum();</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (value &lt;= LOW_PRODUCTION_THRESHOLD) {</span>
<span class="fc" id="L506">                production.remove(g);</span>
<span class="fc" id="L507">                continue;</span>
            }
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">            if (market != null) {</span>
                // If the market is available, weight by sale price of
                // the material, or if it is the raw material for a
                // refined goods type, the average of the raw and
                // refined goods prices.
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                if (g.getOutputType() == null) {</span>
<span class="nc" id="L515">                    value *= market.getSalePrice(g, 1);</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                } else if (production.containsKey(g.getOutputType())) {</span>
<span class="fc" id="L517">                    value *= (market.getSalePrice(g, 1)</span>
<span class="fc" id="L518">                        + market.getSalePrice(g.getOutputType(), 1)) / 2;</span>
                }
            }
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            if (nationType.hasModifier(g.getId())) {</span>
<span class="nc" id="L522">                value = (value * 12) / 10; // Bonus for national advantages</span>
            }
<span class="pc bpc" id="L524" title="2 of 4 branches missed.">            if (value &gt; secondaryValue &amp;&amp; secondaryRawMaterial != null) {</span>
<span class="nc" id="L525">                production.remove(secondaryRawMaterial);</span>
<span class="nc" id="L526">                production.remove(secondaryRawMaterial.getOutputType());</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (rawLuxuryGoodsTypes.contains(secondaryRawMaterial)) {</span>
<span class="nc" id="L528">                    rawLuxuryGoodsTypes.remove(secondaryRawMaterial);</span>
<span class="nc" id="L529">                    luxuryGoodsTypes.remove(secondaryRawMaterial.getOutputType());</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                } else if (otherRawGoodsTypes.contains(secondaryRawMaterial)) {</span>
<span class="nc" id="L531">                    otherRawGoodsTypes.remove(secondaryRawMaterial);</span>
                }
            }
<span class="fc bfc" id="L534" title="All 2 branches covered.">            if (value &gt; primaryValue) {</span>
<span class="fc" id="L535">                secondaryRawMaterial = primaryRawMaterial;</span>
<span class="fc" id="L536">                secondaryValue = primaryValue;</span>
<span class="fc" id="L537">                primaryRawMaterial = g;</span>
<span class="fc" id="L538">                primaryValue = value;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            } else if (value &gt; secondaryValue) {</span>
<span class="fc" id="L540">                secondaryRawMaterial = g;</span>
<span class="fc" id="L541">                secondaryValue = value;</span>
            }
<span class="fc" id="L543">        }</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        if (primaryRawMaterial != null) {</span>
<span class="fc" id="L545">            produce.add(primaryRawMaterial);</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            if (primaryRawMaterial.getOutputType() != null) {</span>
<span class="fc" id="L547">                produce.add(primaryRawMaterial.getOutputType());</span>
            }
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (secondaryRawMaterial != null) {</span>
<span class="fc" id="L550">                produce.add(secondaryRawMaterial);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (secondaryRawMaterial.getOutputType() != null) {</span>
<span class="fc" id="L552">                    produce.add(secondaryRawMaterial.getOutputType());</span>
                }
            }
        }
<span class="fc" id="L556">    }</span>


    // Relative weights of the various building categories.
    // FIXME: split out/parameterize into a &quot;building strategy&quot;
    //
    // BuildableTypes that improve breeding.
    private static final double BREEDING_WEIGHT    = 0.1;
    // BuildableTypes that improve building production.
    private static final double BUILDING_WEIGHT    = 0.9;
    // BuildableTypes that produce defensive units.
    private static final double DEFENCE_WEIGHT     = 0.1;
    // BuildableTypes that provide export ability.
    private static final double EXPORT_WEIGHT      = 0.6;
    // BuildableTypes that allow water to be used.
    private static final double FISH_WEIGHT        = 0.25;
    // BuildableTypes that improve the colony fortifications.
    private static final double FORTIFY_WEIGHT     = 0.3;
    // BuildableTypes that improve immigration production.
    private static final double IMMIGRATION_WEIGHT = 0.05;
    // BuildableTypes that improve liberty production.
    private static final double LIBERTY_WEIGHT     = 0.75;
    // BuildableTypes that improve military goods production.
    private static final double MILITARY_WEIGHT    = 0.4;
    // BuildableTypes that improve luxury goods production.
    private static final double PRODUCTION_WEIGHT  = 0.25;
    // BuildableTypes that improve colony storage.
    private static final double REPAIR_WEIGHT      = 0.1;
    // BuildableTypes that improve colony storage.
    private static final double STORAGE_WEIGHT     = 0.85;
    // BuildableTypes that improve education.
    private static final double TEACH_WEIGHT       = 0.2;
    // BuildableTypes that improve transport.
    private static final double TRANSPORT_WEIGHT   = 0.15;

    /**
     * Finds a build plan for this type.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to search for.
     * @return A &lt;code&gt;BuildPlan&lt;/code&gt; with this type, or null if not found.
     */
    private BuildPlan findBuildPlan(BuildableType type) {
<span class="fc bfc" id="L598" title="All 2 branches covered.">        return find(buildPlans, bp -&gt; bp.type == type);</span>
    }

    /**
     * Adds or improves the priority of a buildable in a list.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to use.
     * @param weight The relative weight of this class of buildable with
     *     respect to other buildable classes.
     * @param support The support for this buildable within its class.
     * @return True if this type was prioritized.
     */
    private boolean prioritize(BuildableType type,
                               double weight, double support) {
<span class="fc" id="L612">        BuildPlan bp = findBuildPlan(type);</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (bp == null) {</span>
<span class="fc" id="L614">            buildPlans.add(new BuildPlan(type, weight, support));</span>
<span class="fc" id="L615">            return true;</span>
        }
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (bp.weight * bp.support &lt; weight * support) {</span>
<span class="fc" id="L618">            bp.weight = weight;</span>
<span class="fc" id="L619">            bp.support = support;</span>
<span class="fc" id="L620">            return true;</span>
        }
<span class="nc" id="L622">        return false;</span>
    }

    /**
     * Given a buildable that improves production of a goods type,
     * prioritize it.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to consider.
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; improved by the buildable.
     * @return True if this type was prioritized.
     */
    private boolean prioritizeProduction(BuildableType type,
                                         GoodsType goodsType) {
<span class="fc" id="L635">        Player player = colony.getOwner();</span>
<span class="fc" id="L636">        NationType nationType = player.getNationType();</span>
<span class="fc" id="L637">        String advantage = getAIMain().getAIPlayer(player).getAIAdvantage();</span>
<span class="fc" id="L638">        boolean ret = false;</span>
<span class="fc" id="L639">        double factor = 1.0;</span>
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">        if (nationType.hasModifier(goodsType.getId())) {</span>
            // Handles building, agriculture, furTrapping advantages
<span class="nc" id="L642">            factor *= 1.2;</span>
        }
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (goodsType.isMilitaryGoods()) {</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">            if (&quot;conquest&quot;.equals(advantage)) factor = 1.2;</span>
<span class="fc" id="L646">            ret = prioritize(type, MILITARY_WEIGHT * factor,</span>
                1.0/*FIXME: amount present wrt amount to equip*/);
<span class="fc bfc" id="L648" title="All 2 branches covered.">        } else if (goodsType.isBuildingMaterial()) {</span>
<span class="fc" id="L649">            ret = prioritize(type, BUILDING_WEIGHT * factor,</span>
                1.0/*FIXME: need for this type*/);
<span class="fc bfc" id="L651" title="All 2 branches covered.">        } else if (goodsType.isLibertyType()) {</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            if (player.isREF()) return false; // no bells for REF colonies</span>
<span class="fc" id="L653">            ret = prioritize(type, LIBERTY_WEIGHT,</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                (colony.getSoL() &gt;= 100) ? 0.01 : 1.0);</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        } else if (goodsType.isImmigrationType()) {</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">            if (&quot;immigration&quot;.equals(advantage)) factor = 1.2;</span>
<span class="fc" id="L657">            ret = prioritize(type, IMMIGRATION_WEIGHT * factor,</span>
                1.0/*FIXME: Brewster?*/);
<span class="fc bfc" id="L659" title="All 2 branches covered.">        } else if (produce.contains(goodsType)) {</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">            if (&quot;trade&quot;.equals(advantage)) factor = 1.2;</span>
<span class="fc" id="L661">            double f = 0.1 * colony.getTotalProductionOf(goodsType.getInputType());</span>
<span class="fc" id="L662">            ret = prioritize(type, PRODUCTION_WEIGHT,</span>
                f/*FIXME: improvement?*/);
        }
<span class="fc" id="L665">        return ret;</span>
    }

    /**
     * Updates the build plans for this colony.
     */
    private void updateBuildableTypes() {
<span class="fc" id="L672">        final EuropeanAIPlayer euaip = (EuropeanAIPlayer)getAIMain()</span>
<span class="fc" id="L673">            .getAIPlayer(colony.getOwner());</span>
<span class="fc" id="L674">        String advantage = euaip.getAIAdvantage();</span>
<span class="fc" id="L675">        buildPlans.clear();</span>

        int maxLevel;
<span class="pc bpc" id="L678" title="2 of 5 branches missed.">        switch (profileType) {</span>
        case OUTPOST:
<span class="fc" id="L680">        case SMALL:   maxLevel = 1; break;</span>
<span class="fc" id="L681">        case MEDIUM:  maxLevel = 2; break;</span>
<span class="fc" id="L682">        case LARGE:   maxLevel = 3; break;</span>
<span class="nc" id="L683">        case CAPITAL: maxLevel = 4; break;</span>
        default:
<span class="nc" id="L685">            throw new IllegalStateException(&quot;Bogus profile type: &quot;</span>
                + profileType);
        }

<span class="fc" id="L689">        Player player = colony.getOwner();</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">        for (BuildingType type : spec().getBuildingTypeList()) {</span>
<span class="fc" id="L691">            boolean expectFail = false;</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">            if (!colony.canBuild(type)) continue;</span>

            // Exempt defence and export from the level check.
<span class="fc bfc" id="L695" title="All 2 branches covered.">            if (type.hasModifier(Modifier.DEFENCE)) {</span>
<span class="fc" id="L696">                double factor = 1.0;</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                if (&quot;conquest&quot;.equals(advantage)) factor = 1.1;</span>
<span class="fc" id="L698">                prioritize(type, FORTIFY_WEIGHT * factor,</span>
                    1.0/*FIXME: 0 if FF underway*/);
            }
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">            if (type.hasAbility(Ability.EXPORT)) {</span>
<span class="nc" id="L702">                double factor = 1.0;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">                if (&quot;trade&quot;.equals(advantage)) factor = 1.1;</span>
<span class="nc" id="L704">                prioritize(type, EXPORT_WEIGHT * factor,</span>
                    1.0/*FIXME: weigh production v transport*/);
            }

            // Skip later stage buildings for smaller settlements.
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (type.getLevel() &gt; maxLevel) continue;</span>

            // Scale docks by the improvement available to the food supply.
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">            if (type.hasAbility(Ability.PRODUCE_IN_WATER)) {</span>
<span class="nc" id="L713">                double factor = 0.0;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                if (!colony.hasAbility(Ability.PRODUCE_IN_WATER)</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                    &amp;&amp; colony.getTile().isShore()) {</span>
<span class="nc" id="L716">                    int landFood = 0, seaFood = 0;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                    for (Tile t : colony.getTile().getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                        if (t.getOwningSettlement() == colony</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                            || player.canClaimForSettlement(t)) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                            for (AbstractGoods ag : t.getSortedPotential()) {</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                                if (ag.getType().isFoodType()) {</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                                    if (t.isLand()) {</span>
<span class="nc" id="L723">                                        landFood += ag.getAmount();</span>
                                    } else {
<span class="nc" id="L725">                                        seaFood += ag.getAmount();</span>
                                    }
                                }
<span class="nc" id="L728">                            }</span>
                        }
<span class="nc" id="L730">                    }</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    factor = (seaFood + landFood == 0) ? 0.0</span>
                        : seaFood / (double)(seaFood + landFood);
                }
<span class="nc" id="L734">                prioritize(type, FISH_WEIGHT, factor);</span>
            }

<span class="fc bfc" id="L737" title="All 2 branches covered.">            if (type.hasAbility(Ability.BUILD)) {</span>
<span class="fc" id="L738">                double factor = 1.0;</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">                if (&quot;building&quot;.equals(advantage)) factor = 1.1;</span>
<span class="fc" id="L740">                double support = 1.0;</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                for (Ability a : type.getAbilities(Ability.BUILD)) {</span>
<span class="fc" id="L742">                    List&lt;Scope&gt; scopes = a.getScopes();</span>
<span class="pc bpc" id="L743" title="2 of 4 branches missed.">                    if (scopes != null &amp;&amp; !scopes.isEmpty()) support = 0.1;</span>
<span class="fc" id="L744">                }</span>
<span class="fc" id="L745">                prioritize(type, BUILDING_WEIGHT * factor,</span>
                    support/*FIXME: need for the thing now buildable*/);
            }

<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (type.hasAbility(Ability.TEACH)) {</span>
<span class="fc" id="L750">                prioritize(type, TEACH_WEIGHT,</span>
                    1.0/*FIXME: #students, #specialists here, #wanted*/);
            }

<span class="pc bpc" id="L754" title="1 of 2 branches missed.">            if (type.hasAbility(Ability.REPAIR_UNITS)) {</span>
<span class="nc" id="L755">                double factor = 1.0;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">                if (&quot;naval&quot;.equals(advantage)) factor = 1.1;</span>
<span class="nc" id="L757">                prioritize(type, REPAIR_WEIGHT * factor,</span>
                    1.0/*FIXME: #units-to-repair, has-Europe etc*/);
            }

<span class="fc" id="L761">            GoodsType output = type.getProducedGoodsType();</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (output != null) {</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">                if (!prioritizeProduction(type, output)) {</span>
                    // Allow failure if this building can not build.
<span class="fc" id="L765">                    expectFail = true;</span>
                }
            } else {
<span class="fc bfc" id="L768" title="All 2 branches covered.">                for (GoodsType g : spec().getGoodsTypeList()) {</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">                    if (type.hasModifier(g.getId())) {</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">                        if (!prioritizeProduction(type, g)) {</span>
<span class="nc" id="L771">                            expectFail = true;</span>
                        }
                    }
<span class="fc" id="L774">                }</span>
                // Hacks.  No good way to make this really generic.
<span class="fc bfc" id="L776" title="All 2 branches covered.">                if (type.hasModifier(Modifier.WAREHOUSE_STORAGE)) {</span>
<span class="fc" id="L777">                    double factor = 1.0;</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">                    if (&quot;trade&quot;.equals(advantage)) factor = 1.1;</span>
<span class="fc" id="L779">                    prioritize(type, STORAGE_WEIGHT * factor,</span>
                        1.0/*FIXME: amount of goods*/);
                }
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">                if (type.hasModifier(Modifier.BREEDING_DIVISOR)) {</span>
<span class="nc" id="L783">                    prioritize(type, BREEDING_WEIGHT,</span>
                        1.0/*FIXME: horses present?*/);
                }
            }

<span class="pc bpc" id="L788" title="1 of 4 branches missed.">            if (findBuildPlan(type) == null &amp;&amp; !expectFail) {</span>
<span class="nc" id="L789">                logger.warning(&quot;No building priority found for: &quot; + type);</span>
            }
<span class="fc" id="L791">        }</span>

<span class="fc" id="L793">        double wagonNeed = 0.0;</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">        if (!colony.isConnectedPort()) { // Inland colonies need transportation</span>
<span class="fc" id="L795">            int wagons = euaip.getNeededWagons(colony.getTile());</span>
<span class="pc bpc" id="L796" title="3 of 4 branches missed.">            wagonNeed = (wagons &lt;= 0) ? 0.0 : (wagons &gt; 3) ? 1.0</span>
                : wagons / 3.0;
        }
<span class="fc bfc" id="L799" title="All 2 branches covered.">        for (UnitType unitType : spec().getUnitTypeList()) {</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">            if (!colony.canBuild(unitType)) continue;</span>
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">            if (unitType.hasAbility(Ability.NAVAL_UNIT)) {</span>
                ; // FIXME: decide to build a ship
<span class="fc bfc" id="L803" title="All 2 branches covered.">            } else if (unitType.isDefensive()) {</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">                if (colony.isBadlyDefended()) {</span>
<span class="fc" id="L805">                    prioritize(unitType, DEFENCE_WEIGHT,</span>
                        1.0/*FIXME: how badly defended?*/);
                }
<span class="fc bfc" id="L808" title="All 2 branches covered.">            } else if (unitType.hasAbility(Ability.CARRY_GOODS)) {</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">                if (wagonNeed &gt; 0.0) {</span>
<span class="nc" id="L810">                    double factor = 1.0;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">                    if (&quot;trade&quot;.equals(advantage)) factor = 1.1;</span>
<span class="nc" id="L812">                    prioritize(unitType, TRANSPORT_WEIGHT * factor,</span>
                        wagonNeed/*FIXME: type.getSpace()*/);
                }
            }
<span class="fc" id="L816">        }</span>

        // Weight by lower required goods.
<span class="fc bfc" id="L819" title="All 2 branches covered.">        for (BuildPlan bp : buildPlans) {</span>
<span class="fc" id="L820">            double difficulty = bp.type.getRequiredGoods().stream()</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">                .filter(ag -&gt; ag.getAmount() &gt; colony.getGoodsCount(ag.getType()))</span>
<span class="fc" id="L822">                .mapToDouble(ag -&gt; {</span>
<span class="fc" id="L823">                        final GoodsType type = ag.getType();</span>
<span class="fc" id="L824">                        return (ag.getAmount() - colony.getGoodsCount(type))</span>
                            // Penalize building with type that can not be
                            // made locally.
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                            * ((produce.contains(type.getInputType())) ? 1.0</span>
                                : 5.0);
<span class="fc" id="L829">                    }).sum();</span>
<span class="fc" id="L830">            bp.difficulty = Math.max(1.0f, Math.sqrt(difficulty));</span>
<span class="fc" id="L831">        }</span>

<span class="fc" id="L833">        Collections.sort(buildPlans, buildPlanComparator);</span>
<span class="fc" id="L834">    }</span>

    /**
     * Makes a plan for each type of possible production, that is
     * those work locations that can use a unit or can auto-produce.
     * Note that this will almost certainly include clashes over work
     * locations.  That gets sorted out elsewhere as ColonyPlans do
     * not examine the units present.
     *
     * With the complete list of work plans, finish creating the list
     * of goods to produce.
     *
     * Then filter out the auto-production plans as they are not
     * going to be helpful for unit allocation.
     *
     * Finally sort by desirability.
     */
    private void updatePlans(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L852">        workPlans.clear();</span>
        for (Entry&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; entry
<span class="fc bfc" id="L854" title="All 2 branches covered.">                 : production.entrySet()) {</span>
<span class="fc" id="L855">            GoodsType g = entry.getKey();</span>
            // Do not make plans to produce into a full warehouse.
<span class="fc bfc" id="L857" title="All 2 branches covered.">            if (g.isStorable()</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">                &amp;&amp; colony.getGoodsCount(g) &gt;= colony.getWarehouseCapacity()</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">                &amp;&amp; !g.limitIgnored()) continue;</span>

<span class="fc bfc" id="L861" title="All 2 branches covered.">            for (WorkLocation wl : entry.getValue().keySet()) {</span>
<span class="pc bpc" id="L862" title="3 of 4 branches missed.">                if (wl.canBeWorked() || wl.canAutoProduce()) {</span>
<span class="fc" id="L863">                    workPlans.add(new WorkLocationPlan(getAIMain(), wl, g));</span>
                }
<span class="fc" id="L865">            }</span>
<span class="fc" id="L866">        }</span>

        // Now we have lots of plans, determine what goods to produce.
<span class="fc" id="L869">        updateProductionList(production);</span>

        // Filter out plans that can not use a unit.
<span class="fc" id="L872">        List&lt;WorkLocationPlan&gt; oldPlans = new ArrayList&lt;&gt;(workPlans);</span>
<span class="fc" id="L873">        workPlans.clear();</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (WorkLocationPlan wlp : oldPlans) {</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">            if (wlp.getWorkLocation().canBeWorked()) workPlans.add(wlp);</span>
<span class="fc" id="L876">        }</span>

        // Sort the work plans by earliest presence in the produce
        // list, and then by amount.  If the type of goods produced is
        // not on the produce list, then make sure such plans sort to
        // the end, except for food plans.
<span class="fc" id="L882">        Collections.sort(workPlans, new Comparator&lt;WorkLocationPlan&gt;() {</span>
                @Override
                public int compare(WorkLocationPlan w1, WorkLocationPlan w2) {
<span class="fc" id="L885">                    GoodsType g1 = w1.getGoodsType();</span>
<span class="fc" id="L886">                    GoodsType g2 = w2.getGoodsType();</span>
<span class="fc" id="L887">                    int i1 = produce.indexOf(g1);</span>
<span class="fc" id="L888">                    int i2 = produce.indexOf(g2);</span>
<span class="fc bfc" id="L889" title="All 4 branches covered.">                    if (i1 &lt; 0 &amp;&amp; !g1.isFoodType()) i1 = 99999;</span>
<span class="fc bfc" id="L890" title="All 4 branches covered.">                    if (i2 &lt; 0 &amp;&amp; !g2.isFoodType()) i2 = 99999;</span>
<span class="fc" id="L891">                    int cmp = i1 - i2;</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">                    if (cmp == 0) {</span>
<span class="fc" id="L893">                        cmp = w2.getWorkLocation().getGenericPotential(g2)</span>
<span class="fc" id="L894">                            - w1.getWorkLocation().getGenericPotential(g1);</span>
                    }
<span class="fc" id="L896">                    return cmp;</span>
                }
            });
<span class="fc" id="L899">    }</span>

    /**
     * Add the other goods types to the production list.  When this is
     * called the new world goods production is already present on the
     * produce list.  Ignores food which is treated separately.
     */
    private void updateProductionList(final Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L907">        final Comparator&lt;GoodsType&gt; productionComparator</span>
<span class="fc" id="L908">            = new Comparator&lt;GoodsType&gt;() {</span>
                @Override
                public int compare(GoodsType g1, GoodsType g2) {
<span class="fc" id="L911">                    int p1 = production.get(g1).values().stream()</span>
<span class="fc" id="L912">                        .mapToInt(Integer::intValue).sum();</span>
<span class="fc" id="L913">                    int p2 = production.get(g2).values().stream()</span>
<span class="fc" id="L914">                        .mapToInt(Integer::intValue).sum();</span>
<span class="fc" id="L915">                    return p2 - p1;</span>
                }
            };
<span class="fc" id="L918">        List&lt;GoodsType&gt; toAdd = new ArrayList&lt;&gt;();</span>

        // If we need liberty put it before the new world production.
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        if (colony.getSoL() &lt; 100) {</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">            for (GoodsType g : libertyGoodsTypes) {</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">                if (production.containsKey(g)) toAdd.add(g);</span>
<span class="fc" id="L924">            }</span>
<span class="fc" id="L925">            Collections.sort(toAdd, productionComparator);</span>
<span class="fc" id="L926">            produce.addAll(0, toAdd);</span>
<span class="fc" id="L927">            toAdd.clear();</span>
        }

        // Always add raw/building materials first.
<span class="fc" id="L931">        Collections.sort(rawBuildingGoodsTypes, productionComparator);</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">        for (GoodsType g : buildingGoodsTypes) {</span>
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">            if (production.containsKey(g)) {</span>
<span class="fc" id="L934">                GoodsType raw = g.getInputType();</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">                if (colony.getGoodsCount(raw) &gt;= GoodsContainer.CARGO_SIZE/2</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">                    || production.containsKey(raw)) {</span>
<span class="fc" id="L937">                    toAdd.add(g);</span>
                }
            }
<span class="fc" id="L940">        }</span>
<span class="fc" id="L941">        Collections.sort(toAdd, new Comparator&lt;GoodsType&gt;() {</span>
                @Override
                public int compare(GoodsType g1, GoodsType g2) {
<span class="fc" id="L944">                    int i1 = rawBuildingGoodsTypes.indexOf(g1.getInputType());</span>
<span class="fc" id="L945">                    int i2 = rawBuildingGoodsTypes.indexOf(g2.getInputType());</span>
<span class="fc" id="L946">                    return i1 - i2;</span>
                }
            });
<span class="fc bfc" id="L949" title="All 2 branches covered.">        for (int i = toAdd.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L950">            GoodsType make = toAdd.get(i);</span>
<span class="fc" id="L951">            GoodsType raw = make.getInputType();</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">            if (production.containsKey(raw)) {</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">                if (colony.getGoodsCount(raw) &gt;= GoodsContainer.CARGO_SIZE/2) {</span>
<span class="fc" id="L954">                    produce.add(raw); // Add at the end, enough in stock</span>
<span class="fc" id="L955">                    produce.add(0, make);</span>
                } else {
<span class="fc" id="L957">                    produce.add(0, make);</span>
<span class="fc" id="L958">                    produce.add(0, raw);</span>
                }
            } else {
<span class="fc" id="L961">                produce.add(0, make);</span>
            }
        }
<span class="fc" id="L964">        toAdd.clear();</span>

        // Military goods after lucrative production.
<span class="fc bfc" id="L967" title="All 2 branches covered.">        for (GoodsType g : militaryGoodsTypes) {</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">            if (production.containsKey(g)) toAdd.add(g);</span>
<span class="fc" id="L969">        }</span>
<span class="fc" id="L970">        Collections.sort(toAdd, productionComparator);</span>
<span class="fc" id="L971">        produce.addAll(toAdd);</span>
<span class="fc" id="L972">        toAdd.clear();</span>

        // Immigration last.
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">        if (colony.getOwner().getEurope() != null) {</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">            for (GoodsType g : immigrationGoodsTypes) {</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                if (production.containsKey(g)) toAdd.add(g);</span>
<span class="nc" id="L978">            }</span>
<span class="fc" id="L979">            Collections.sort(toAdd, productionComparator);</span>
<span class="fc" id="L980">            produce.addAll(toAdd);</span>
<span class="fc" id="L981">            toAdd.clear();</span>
        }
<span class="fc" id="L983">    }</span>

    /**
     * Tries to swap an expert unit for another doing its job.
     *
     * @param expert The expert &lt;code&gt;Unit&lt;/code&gt;.
     * @param others A list of other &lt;code&gt;Unit&lt;/code&gt;s to test against.
     * @param colony The &lt;code&gt;Colony&lt;/code&gt; the units are working in.
     * @return The unit that was replaced by the expert, or null if none.
     */
    private Unit trySwapExpert(Unit expert, List&lt;Unit&gt; others, Colony colony) {
<span class="fc" id="L994">        Role oldRole = expert.getRole();</span>
<span class="fc" id="L995">        int oldRoleCount = expert.getRoleCount();</span>
<span class="fc" id="L996">        GoodsType work = expert.getType().getExpertProduction();</span>
<span class="fc" id="L997">        GoodsType oldWork = expert.getWorkType();</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">        for (Unit other : others) {</span>
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">            if (!other.isPerson()) continue;</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">            if (other.getWorkType() == work</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                &amp;&amp; other.getType().getExpertProduction() != work) {</span>
<span class="nc" id="L1002">                Location l1 = expert.getLocation();</span>
<span class="nc" id="L1003">                Location l2 = other.getLocation();</span>
<span class="nc" id="L1004">                other.setLocation(colony.getTile());</span>
<span class="nc" id="L1005">                expert.setLocation(l2);</span>
<span class="nc" id="L1006">                expert.changeWorkType(work);</span>
<span class="nc" id="L1007">                other.setLocation(l1);</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                if (oldWork != null) other.changeWorkType(oldWork);</span>
<span class="nc" id="L1009">                Role tmpRole = other.getRole();</span>
<span class="nc" id="L1010">                int tmpRoleCount = other.getRoleCount();</span>
<span class="nc" id="L1011">                other.changeRole(oldRole, oldRoleCount);</span>
<span class="nc" id="L1012">                expert.changeRole(tmpRole, tmpRoleCount);</span>
<span class="nc" id="L1013">                return other;</span>
            }
<span class="fc" id="L1015">        }</span>
<span class="fc" id="L1016">        return null;</span>
    }

    /**
     * Finds a plan on a list that produces a given goods type.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @param plans The list of &lt;code&gt;WorkLocationPlan&lt;/code&gt;s to check.
     * @return The first plan found that produces the goods type, or null
     *     if none found.
     */
    private WorkLocationPlan findPlan(GoodsType goodsType,
                                      List&lt;WorkLocationPlan&gt; plans) {
<span class="fc bfc" id="L1029" title="All 2 branches covered.">        return find(plans, wlp -&gt; wlp.getGoodsType() == goodsType);</span>
    }

    /**
     * Gets the best worker to execute a work location plan.
     * - The most productive one wins (which will automatically pick a
     *   relevant expert).
     * - If they are all relevant experts, pick any.
     * - Pick the unit that can upgrade to the required expert with the most
     *     relevant experience or least irrelevant expertise.
     * - Pick a unit that can not upgrade at all.
     * - Pick an otherwise upgradeable unit with the most relevant experience
     *     or least irrelevant experience.
     * - Pick the least skillful unit.
     *
     * Public for the benefit of the test suite.
     *
     * @param wl The &lt;code&gt;WorkLocation&lt;/code&gt; to work at.
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to make.
     * @param workers A list of potential &lt;code&gt;Unit&lt;/code&gt;s to try.
     * @return The best worker for the job.
     */
    public static Unit getBestWorker(WorkLocation wl, GoodsType goodsType,
                                     List&lt;Unit&gt; workers) {
<span class="fc bfc" id="L1053" title="All 4 branches covered.">        if (workers == null || workers.isEmpty()) return null;</span>
<span class="fc" id="L1054">        final Colony colony = wl.getColony();</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">        final GoodsType outputType = (goodsType.isStoredAs())</span>
<span class="fc" id="L1056">            ? goodsType.getStoredAs() : goodsType;</span>

        // Avoid some nasty autodestructions by accepting singleton
        // workers that do *something*.
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        if (workers.size() == 1) {</span>
<span class="fc" id="L1061">            Unit u = workers.get(0);</span>
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">            if (!wl.canAdd(u)) return null;</span>
<span class="fc" id="L1063">            Location oldLoc = u.getLocation();</span>
<span class="fc" id="L1064">            GoodsType oldWork = u.getWorkType();</span>
<span class="fc" id="L1065">            u.setLocation(wl);</span>
<span class="fc" id="L1066">            u.changeWorkType(goodsType);</span>
<span class="fc" id="L1067">            int production = wl.getProductionOf(u, goodsType);</span>
<span class="fc" id="L1068">            u.setLocation(oldLoc);</span>
<span class="fc" id="L1069">            u.changeWorkType(oldWork);</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">            return (production &gt; 0) ? u : null;</span>
        }

        // Do not mutate the workers list!
<span class="fc" id="L1074">        List&lt;Unit&gt; todo = new ArrayList&lt;&gt;(workers);</span>
<span class="fc" id="L1075">        List&lt;Unit&gt; best = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1076">        int bestValue = colony.getAdjustedNetProductionOf(outputType);</span>
<span class="fc" id="L1077">        Unit special = null;</span>
<span class="fc" id="L1078">        best.clear();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        for (Unit u : todo) {</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">            if (!wl.canAdd(u)) continue;</span>
<span class="fc" id="L1081">            Location oldLoc = u.getLocation();</span>
<span class="fc" id="L1082">            GoodsType oldWork = u.getWorkType();</span>
<span class="fc" id="L1083">            u.setLocation(wl);</span>
<span class="fc" id="L1084">            u.changeWorkType(goodsType);</span>

<span class="fc" id="L1086">            int value = colony.getAdjustedNetProductionOf(outputType);</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">            if (value &gt; bestValue) {</span>
<span class="fc" id="L1088">                bestValue = value;</span>
<span class="fc" id="L1089">                best.clear();</span>
<span class="fc" id="L1090">                best.add(u);</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">                if (u.getType().getExpertProduction() == goodsType) {</span>
<span class="fc" id="L1092">                    special = u;</span>
                }
<span class="fc bfc" id="L1094" title="All 4 branches covered.">            } else if (value == bestValue &amp;&amp; !best.isEmpty()) {</span>
<span class="fc" id="L1095">                best.add(u);</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">                if (u.getType().getExpertProduction() == goodsType) {</span>
<span class="nc" id="L1097">                    special = u;</span>
                }
            }

<span class="fc" id="L1101">            u.setLocation(oldLoc);</span>
<span class="fc" id="L1102">            u.changeWorkType(oldWork);</span>
<span class="fc" id="L1103">        }</span>

<span class="fc bfc" id="L1105" title="All 3 branches covered.">        switch (best.size()) {</span>
<span class="fc" id="L1106">        case 0: return null; // Not good.  No unit improves production.</span>
<span class="fc" id="L1107">        case 1: return best.get(0);</span>
<span class="fc" id="L1108">        default:todo.clear(); todo.addAll(best); break;</span>
        }
        // Several winners including an expert implies they are all experts.
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">        if (special != null) return special;</span>

        // Partition units into those that can upgrade-by-experience
        // to the relevant expert (which we favour), those that can
        // upgrade-by-experience in some way but not to the expert
        // (which we avoid), and the rest.  Within the groups, favour
        // those with the most relevant experience and the least irrelevant
        // experience.
<span class="fc" id="L1119">        Specification spec = colony.getSpecification();</span>
<span class="fc" id="L1120">        UnitType expert = spec.getExpertForProducing(goodsType);</span>
<span class="fc" id="L1121">        best.clear();</span>
<span class="fc" id="L1122">        bestValue = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        for (Unit u : todo) {</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">            boolean relevant = u.getWorkType() == goodsType;</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">            int score = (relevant) ? u.getExperience() : -u.getExperience();</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">            if (expert != null</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                &amp;&amp; u.getType().canBeUpgraded(expert, ChangeType.EXPERIENCE)) {</span>
<span class="fc" id="L1128">                score += 10000;</span>
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">            } else if (expert != null</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">                &amp;&amp; u.getType().canBeUpgraded(null, ChangeType.EXPERIENCE)) {</span>
<span class="fc" id="L1131">                score -= 10000;</span>
            }
<span class="fc bfc" id="L1133" title="All 2 branches covered.">            if (score &gt; bestValue) {</span>
<span class="fc" id="L1134">                best.clear();</span>
<span class="fc" id="L1135">                best.add(u);</span>
<span class="fc" id="L1136">                bestValue = score;</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            } else if (score == bestValue) {</span>
<span class="fc" id="L1138">                best.add(u);</span>
            }
<span class="fc" id="L1140">        }</span>
<span class="pc bpc" id="L1141" title="1 of 3 branches missed.">        switch (best.size()) {</span>
<span class="nc" id="L1142">        case 0: break;</span>
<span class="fc" id="L1143">        case 1: return best.get(0);</span>
<span class="fc" id="L1144">        default:todo.clear(); todo.addAll(best); break;</span>
        }

        // Use the unit with the least skill, in the hope that
        // remaining experts will be called upon in due course.
<span class="fc" id="L1149">        int worstSkill = Integer.MAX_VALUE;</span>
<span class="fc" id="L1150">        special = null;</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        for (Unit u : todo) {</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">            if (u.getType().getSkill() &lt; worstSkill) {</span>
<span class="fc" id="L1153">                special = u;</span>
<span class="fc" id="L1154">                worstSkill = u.getType().getSkill();</span>
            }
<span class="fc" id="L1156">        }</span>
<span class="fc" id="L1157">        return special;</span>
    }

    /**
     * Equips a unit for a role, trying extra possibilities.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to equip if possible.
     * @param role The &lt;code&gt;Role&lt;/code&gt; for the unit to take.
     * @param colony The &lt;code&gt;Colony&lt;/code&gt; storing the equipment.
     * @return True if the unit was equipped.
     */
    private static boolean fullEquipUnit(Specification spec, Unit unit,
                                         Role role, Colony colony) {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (role.isOffensive()) {</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            for (Role r : unit.getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">                if (colony.equipForRole(unit, </span>
<span class="nc" id="L1173">                                        r, r.getMaximumCount())) return true;</span>
<span class="nc" id="L1174">            }</span>
<span class="nc" id="L1175">            return false;</span>
        }
<span class="nc" id="L1177">        return colony.equipForRole(unit, role, role.getMaximumCount());</span>
    }

    /**
     * Tries to apply a colony plan given a list of workers.
     *
     * @param workers A list of &lt;code&gt;Unit&lt;/code&gt;s to assign.
     * @param preferScout Prefer to make scouts rather than soldiers.
     * @param lb A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return A scratch colony with the workers in place.
     */
    public Colony assignWorkers(List&lt;Unit&gt; workers, boolean preferScout,
                                LogBuilder lb) {
<span class="fc" id="L1190">        final GoodsType foodType = spec().getPrimaryFoodType();</span>

        // Collect the work location plans.  Note that the plans are
        // pre-sorted in order of desirability.
<span class="fc" id="L1194">        final List&lt;GoodsType&gt; produce = getPreferredProduction();</span>
<span class="fc" id="L1195">        List&lt;WorkLocationPlan&gt; foodPlans = getFoodPlans();</span>
<span class="fc" id="L1196">        List&lt;WorkLocationPlan&gt; workPlans = getWorkPlans();</span>

        // Make a scratch colony to work on.
<span class="fc" id="L1199">        Colony col = colony.copyColony();</span>
<span class="fc" id="L1200">        Tile tile = col.getTile();</span>

        // Replace the given workers with those in the scratch colony.
<span class="fc" id="L1203">        List&lt;Unit&gt; otherWorkers = new ArrayList&lt;&gt;(workers);</span>
<span class="fc" id="L1204">        workers.clear();</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">        for (Unit u : otherWorkers) workers.add(col.getCorresponding(u));</span>

        // Move all workers to the tile.
        // Also remove equipment, which is safe because no missionaries
        // or active pioneers should be on the worker list.
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        for (Unit u : workers) {</span>
<span class="fc" id="L1211">            u.setLocation(tile);</span>
<span class="fc" id="L1212">            col.equipForRole(u, spec().getDefaultRole(), 0);</span>
<span class="fc" id="L1213">        }</span>

        // Move outdoor experts outside if possible.
        // Prefer scouts in early game if there are very few.
<span class="fc" id="L1217">        Role[] outdoorRoles = {</span>
<span class="fc" id="L1218">            spec().getRoleWithAbility(Ability.IMPROVE_TERRAIN, null),</span>
            null,
<span class="fc" id="L1220">            spec().getRoleWithAbility(Ability.SPEAK_WITH_CHIEF, null)</span>
        };
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">        if (preferScout) {</span>
<span class="fc" id="L1223">            Role tmp = outdoorRoles[1];</span>
<span class="fc" id="L1224">            outdoorRoles[1] = outdoorRoles[2];</span>
<span class="fc" id="L1225">            outdoorRoles[2] = tmp;</span>
        }
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        for (Role outdoorRole : outdoorRoles) {</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">            for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">                if (workers.size() &lt;= 1) break;</span>
<span class="fc" id="L1230">                Role role = outdoorRole;</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">                if (role == null) {</span>
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">                    if ((role = u.getMilitaryRole()) == null) continue;</span>
                }
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">                if (u.getType() == role.getExpertUnit()</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">                        &amp;&amp; fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1236">                    workers.remove(u);</span>
<span class="nc" id="L1237">                    lb.add(u.getId(), &quot;(&quot;, u.getType().getSuffix(),</span>
<span class="nc" id="L1238">                            &quot;) -&gt; &quot;, role.getSuffix(), &quot;\n&quot;);</span>
                }
<span class="fc" id="L1240">            }</span>
        }

        // Consider the defence situation.
        // FIXME: scan for neighbouring hostiles
        // Favour low-skill/experience units for defenders, order experts
        // in reverse order of their production on the produce-list.
<span class="fc" id="L1247">        Comparator&lt;Unit&gt; soldierComparator = new Comparator&lt;Unit&gt;() {</span>
            @Override
            public int compare(Unit u1, Unit u2) {
<span class="fc" id="L1250">                int cmp = u1.getSkillLevel() - u2.getSkillLevel();</span>
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">                if (cmp == 0) {</span>
<span class="fc" id="L1252">                    GoodsType g1 = u1.getType().getExpertProduction();</span>
<span class="fc" id="L1253">                    GoodsType g2 = u2.getType().getExpertProduction();</span>
<span class="pc bpc" id="L1254" title="2 of 4 branches missed.">                    cmp = ((g2 == null) ? 1 : 0) - ((g1 == null) ? 1 : 0);</span>
<span class="pc bpc" id="L1255" title="2 of 4 branches missed.">                    if (cmp == 0 &amp;&amp; g1 != null) {</span>
<span class="nc" id="L1256">                        int i = produce.indexOf(g2);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                        cmp = (i &lt; 0) ? produce.size() : i;</span>
<span class="nc" id="L1258">                        i = produce.indexOf(g1);</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                        cmp -= (i &lt; 0) ? produce.size() : i;</span>
                    }
                }
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">                if (cmp == 0) {</span>
<span class="fc" id="L1263">                    cmp = u1.getExperience() - u2.getExperience();</span>
                }
<span class="fc" id="L1265">                return cmp;</span>
            }
        };
<span class="fc" id="L1268">        Collections.sort(workers, soldierComparator);</span>
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">        for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            if (workers.size() &lt;= 1) break;</span>
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">            if (!col.isBadlyDefended()) break;</span>
<span class="nc" id="L1272">            Role role = u.getMilitaryRole();</span>
<span class="nc bnc" id="L1273" title="All 4 branches missed.">            if (role != null &amp;&amp; fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1274">                workers.remove(u);</span>
<span class="nc" id="L1275">                lb.add(u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) -&gt; &quot;,</span>
<span class="nc" id="L1276">                       u.getRoleSuffix(), &quot;\n&quot;);</span>
            }
<span class="nc" id="L1278">        }</span>

        // Greedy assignment of other workers to plans.
<span class="fc" id="L1281">        List&lt;AbstractGoods&gt; buildGoods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1282">        BuildableType build = col.getCurrentlyBuilding();</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">        if (build != null) buildGoods.addAll(build.getRequiredGoods());</span>
        List&lt;WorkLocationPlan&gt; wlps;
        WorkLocationPlan wlp;
<span class="fc" id="L1286">        boolean done = false;</span>
<span class="pc bpc" id="L1287" title="1 of 4 branches missed.">        while (!workers.isEmpty() &amp;&amp; !done) {</span>
            // Decide what to produce: set the work location plan to
            // try (wlp), and the list the plan came from so it can
            // be recycled if successful (wlps).
<span class="fc" id="L1291">            wlps = null;</span>
<span class="fc" id="L1292">            wlp = null;</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">            if (col.getAdjustedNetProductionOf(foodType) &gt; 0) {</span>
                // Try to produce something.
<span class="fc" id="L1295">                wlps = workPlans;</span>
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">                while (!produce.isEmpty()) {</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">                    if ((wlp = findPlan(produce.get(0), workPlans)) != null) {</span>
<span class="fc" id="L1298">                        break; // Found a plan to try.</span>
                    }
<span class="fc" id="L1300">                    produce.remove(0); // Can not produce this goods type</span>
                }
            }

            // See if a plan can be satisfied.
            Unit best;
            WorkLocation wl;
            GoodsType goodsType;
            for (;;) {
<span class="fc bfc" id="L1309" title="All 2 branches covered.">                if (wlp == null) { // Time to use a food plan.</span>
<span class="pc bpc" id="L1310" title="1 of 2 branches missed.">                    if (foodPlans.isEmpty()) {</span>
<span class="nc" id="L1311">                        lb.add(&quot;    Food plans exhausted\n&quot;);</span>
<span class="nc" id="L1312">                        done = true;</span>
<span class="nc" id="L1313">                        break;</span>
                    }
<span class="fc" id="L1315">                    wlps = foodPlans;</span>
<span class="fc" id="L1316">                    wlp = wlps.get(0);</span>
                }

<span class="fc" id="L1319">                String err = null;</span>
<span class="fc" id="L1320">                goodsType = wlp.getGoodsType();</span>
<span class="fc" id="L1321">                wl = col.getCorresponding(wlp.getWorkLocation());</span>
<span class="fc" id="L1322">                best = null;</span>
<span class="fc" id="L1323">                lb.add(&quot;    &quot;, LogBuilder.wide(2, col.getUnitCount()),</span>
<span class="fc" id="L1324">                       &quot;: &quot;, LogBuilder.wide(-15, goodsType.getSuffix()),</span>
<span class="fc" id="L1325">                       &quot;@&quot;, LogBuilder.wide(25, locationDescription(wl)),</span>
                       &quot; =&gt; &quot;);

<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">                if (!wl.canBeWorked()) {</span>
<span class="nc" id="L1329">                    err = &quot;can not be worked&quot;;</span>
<span class="fc bfc" id="L1330" title="All 2 branches covered.">                } else if (wl.isFull()) {</span>
<span class="fc" id="L1331">                    err = &quot;full&quot;;</span>
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">                } else if ((best = ColonyPlan.getBestWorker(wl, goodsType,</span>
                                                            workers)) == null) {
<span class="nc" id="L1334">                    err = &quot;no worker found&quot;;</span>
                }
<span class="fc bfc" id="L1336" title="All 2 branches covered.">                if (err != null) {</span>
<span class="fc" id="L1337">                    wlps.remove(wlp); // The plan can not be worked, dump it.</span>
<span class="fc" id="L1338">                    lb.add(err, &quot;\n&quot;);</span>
<span class="fc" id="L1339">                    break;</span>
                }

                // Found a suitable worker, place it.
<span class="fc" id="L1343">                best.setLocation(wl);</span>

                // Did the placement break the production bonus?
<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">                if (col.getProductionBonus() &lt; 0) {</span>
<span class="nc" id="L1347">                    best.setLocation(tile);</span>
<span class="nc" id="L1348">                    done = true;</span>
<span class="nc" id="L1349">                    lb.add(&quot;    broke production bonus\n&quot;);</span>
<span class="nc" id="L1350">                    break;</span>
                }

                // Is the colony going to starve because of this placement?
<span class="pc bpc" id="L1354" title="1 of 2 branches missed.">                if (col.getAdjustedNetProductionOf(foodType) &lt; 0) {</span>
<span class="nc" id="L1355">                    int net = col.getAdjustedNetProductionOf(foodType);</span>
<span class="nc" id="L1356">                    int count = col.getGoodsCount(foodType);</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                    if (count / -net &lt; PRODUCTION_TURNOVER_TURNS) {</span>
                        // Too close for comfort.  Back out the
                        // placement and try a food plan, unless this
                        // was already a food plan.
<span class="nc" id="L1361">                        best.setLocation(tile);</span>
<span class="nc" id="L1362">                        wlp = null;</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                        if (goodsType.isFoodType()) {</span>
<span class="nc" id="L1364">                            lb.add(&quot;    starvation (&quot;, count, &quot;/&quot;, net, &quot;)\n&quot;);</span>
<span class="nc" id="L1365">                            done = true;</span>
<span class="nc" id="L1366">                            break;</span>
                        }
<span class="nc" id="L1368">                        lb.add(&quot;    would starve (&quot;, count, &quot;/&quot;, net, &quot;)\n&quot;);</span>
<span class="nc" id="L1369">                        continue;</span>
                    }
                    // Otherwise tolerate the food stock running down.
                    // Rely on the warehouse-exhaustion code to fire
                    // another rearrangement before units starve.
                }

                // Check if placing the worker will soon exhaust the
                // raw material.  Do not reduce raw materials below
                // what is needed for a building--- e.g. prevent
                // musket production from hogging the tools.
<span class="fc" id="L1380">                GoodsType raw = goodsType.getInputType();</span>
<span class="fc" id="L1381">                int rawNeeded = buildGoods.stream()</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">                    .filter(ag -&gt; ag.getType() == raw)</span>
<span class="fc" id="L1383">                    .mapToInt(AbstractGoods::getAmount).sum();</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">                if (raw == null</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">                    || col.getAdjustedNetProductionOf(raw) &gt;= 0</span>
<span class="fc" id="L1386">                    || (((col.getGoodsCount(raw) - rawNeeded)</span>
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">                            / -col.getAdjustedNetProductionOf(raw))</span>
                        &gt;= PRODUCTION_TURNOVER_TURNS)) {
                    // No raw material problems, the placement
                    // succeeded.  Set the work type, move the
                    // successful goods type to the end of the produce
                    // list for later reuse, remove the worker from
                    // the workers pool, but leave the successful plan
                    // on its list.
<span class="fc" id="L1395">                    best.changeWorkType(goodsType);</span>
<span class="fc" id="L1396">                    workers.remove(best);</span>
<span class="fc" id="L1397">                    lb.add(&quot;    &quot;, best.getId(), &quot;(&quot;,</span>
<span class="fc" id="L1398">                           best.getType().getSuffix(),&quot;)\n&quot;);</span>
<span class="pc bpc" id="L1399" title="1 of 4 branches missed.">                    if (!goodsType.isFoodType() &amp;&amp; produce.remove(goodsType)) {</span>
<span class="fc" id="L1400">                        produce.add(goodsType);</span>
                    }
                    break;
                }

                // Yes, we need more of the raw material.  Pull the
                // unit out again and see if we can make more.
<span class="nc" id="L1407">                best.setLocation(tile);</span>

<span class="nc" id="L1409">                WorkLocationPlan rawWlp = findPlan(raw, workPlans);</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">                if (rawWlp != null) {</span>
                    // OK, we have an alternate plan.  Put the raw
                    // material at the start of the produce list and
                    // loop trying to satisfy the alternate plan.
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                    if (produce.remove(raw)) produce.add(0, raw);</span>
<span class="nc" id="L1415">                    wlp = rawWlp;</span>
<span class="nc" id="L1416">                    lb.add(&quot;    retry with &quot;, raw.getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1417">                    continue;</span>
                }

                // No raw material available, so we have to give up on
                // both the plan and the type of production.
                // Hopefully the raw production is positive again and
                // we will succeed next time.
<span class="nc" id="L1424">                wlps.remove(wlp);</span>
<span class="nc" id="L1425">                produce.remove(goodsType);</span>
<span class="nc" id="L1426">                lb.add(&quot;    needs more &quot;, raw.getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1427">                break;</span>
            }
<span class="fc" id="L1429">        }</span>

        // Put the rest of the workers on the tile.
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">        for (Unit u : workers) {</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">            if (u.getLocation() != tile) u.setLocation(tile);</span>
<span class="nc" id="L1434">        }</span>

        // Check for failure to assign any workers.  This happens when:
        // - there are no useful food plans
        //   - in which case look for a `harmless' place and add one worker
        // - food is low, and perhaps partly eaten by horses, and no
        //   unit can *improve* production by being added.
        //   - find a place to produce food that at least avoids
        //     starvation and add one worker.
<span class="pc bpc" id="L1443" title="1 of 2 branches missed.">        if (col.getUnitCount() == 0) {</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            if (getFoodPlans().isEmpty()) {</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">locations:      for (WorkLocation wl : col.getAvailableWorkLocations()) {</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">                    for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">                        for (GoodsType type : libertyGoodsTypes) {</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">                            if (wl.canAdd(u)</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">                                &amp;&amp; wl.getPotentialProduction(type,</span>
<span class="nc" id="L1450">                                    u.getType()) &gt; 0) {</span>
<span class="nc" id="L1451">                                u.setLocation(wl);</span>
<span class="nc" id="L1452">                                u.changeWorkType(type);</span>
<span class="nc" id="L1453">                                workers.remove(u);</span>
<span class="nc" id="L1454">                                break locations;</span>
                            }
<span class="nc" id="L1456">                        }</span>
<span class="nc" id="L1457">                    }</span>
<span class="nc" id="L1458">                }</span>
            } else {
<span class="nc bnc" id="L1460" title="All 2 branches missed.">plans:          for (WorkLocationPlan w : getFoodPlans()) {</span>
<span class="nc" id="L1461">                    GoodsType goodsType = w.getGoodsType();</span>
<span class="nc" id="L1462">                    WorkLocation wl = col.getCorresponding(w.getWorkLocation());</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">                    for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1464">                        GoodsType oldWork = u.getWorkType();</span>
<span class="nc" id="L1465">                        u.setLocation(wl);</span>
<span class="nc" id="L1466">                        u.changeWorkType(goodsType);</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                        if (col.getAdjustedNetProductionOf(foodType) &gt;= 0) {</span>
<span class="nc" id="L1468">                            lb.add(&quot;    Subsist with &quot;, u, &quot;\n&quot;);</span>
<span class="nc" id="L1469">                            workers.remove(u);</span>
<span class="nc" id="L1470">                            break plans;</span>
                        }
<span class="nc" id="L1472">                        u.setLocation(tile);</span>
<span class="nc" id="L1473">                        u.changeWorkType(oldWork);</span>
<span class="nc" id="L1474">                    }</span>
<span class="nc" id="L1475">                }</span>
            }
        }

        // The greedy algorithm works reasonably well, but will
        // misplace experts when they are more productive at the
        // immediately required task than a lesser unit, not knowing
        // that a requirement for their speciality will subsequently
        // follow.  Do a cleanup pass to sort these out.
<span class="fc" id="L1484">        List&lt;Unit&gt; experts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1485">        List&lt;Unit&gt; nonExperts = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">        for (Unit u : col.getUnitList()) {</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">            if (u.getType().getExpertProduction() != null) {</span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">                if (u.getType().getExpertProduction() != u.getWorkType()) {</span>
<span class="fc" id="L1489">                    experts.add(u);</span>
                }
            } else {
<span class="fc" id="L1492">                nonExperts.add(u);</span>
            }
<span class="fc" id="L1494">        }</span>
<span class="fc" id="L1495">        int expert = 0;</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">        while (expert &lt; experts.size()) {</span>
<span class="fc" id="L1497">            Unit u1 = experts.get(expert);</span>
            Unit other;
<span class="pc bpc" id="L1499" title="1 of 2 branches missed.">            if ((other = trySwapExpert(u1, experts, col)) != null) {</span>
<span class="nc" id="L1500">                lb.add(&quot;    Swapped &quot;, u1.getId(), &quot;(&quot;,</span>
<span class="nc" id="L1501">                    u1.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1502">                experts.remove(u1);</span>
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">            } else if ((other = trySwapExpert(u1, nonExperts, col)) != null) {</span>
<span class="nc" id="L1504">                lb.add(&quot;    Swapped &quot;, u1.getId(), &quot;(&quot;,</span>
<span class="nc" id="L1505">                    u1.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1506">                experts.remove(u1);</span>
            } else {
<span class="fc" id="L1508">                expert++;</span>
            }
<span class="fc" id="L1510">        }</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">        for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1512">            GoodsType work = u.getType().getExpertProduction();</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">            if (work != null) {</span>
<span class="nc" id="L1514">                Unit other = trySwapExpert(u, col.getUnitList(), col);</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">                if (other != null) {</span>
<span class="nc" id="L1516">                    lb.add(&quot;    Swapped &quot;, u.getId(), &quot;(&quot;,</span>
<span class="nc" id="L1517">                        u.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1518">                    workers.remove(u);</span>
<span class="nc" id="L1519">                    workers.add(other);</span>
                }
            }
<span class="nc" id="L1522">        }</span>

        // Rearm what remains as far as possible.
<span class="fc" id="L1525">        Collections.sort(workers, soldierComparator);</span>
<span class="pc bpc" id="L1526" title="1 of 2 branches missed.">        for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1527">            Role role = u.getMilitaryRole();</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">            if (role == null) continue;</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            if (fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1530">                lb.add(&quot;    &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(),</span>
<span class="nc" id="L1531">                       &quot;) -&gt; &quot;, u.getRoleSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1532">                workers.remove(u);</span>
            } else break;
<span class="nc" id="L1534">        }</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered.">        for (Unit u : col.getUnitList()) {</span>
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">            if (!u.hasDefaultRole()) {</span>
<span class="nc" id="L1537">                logger.warning(&quot;assignWorkers bogus role for &quot; + u);</span>
<span class="nc" id="L1538">                u.changeRole(spec().getDefaultRole(), 0);</span>
            }
<span class="fc" id="L1540">        }</span>

        // Log and return the scratch colony on success.
        // Otherwise abandon this rearrangement, disposing of the
        // scratch colony and returning null.
<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">        for (Unit u : workers) {</span>
<span class="nc" id="L1546">            lb.add(&quot;    &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(),</span>
                   &quot;) -&gt; UNUSED\n&quot;);
<span class="nc" id="L1548">        }</span>
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">        if (col.getUnitCount() &lt;= 0) col = null;</span>
<span class="fc" id="L1550">        return col;</span>
    }

    /**
     * Gets a concise textual description of a location associated with
     * the colony.  No i18n here, this is for debugging purposes.
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to describe.
     * @return The text description.
     */
    private String locationDescription(Location loc) {
<span class="fc" id="L1561">        String name = colony.getName() + &quot;-&quot;;</span>
<span class="fc" id="L1562">        String desc = loc.toShortString();</span>
<span class="pc bpc" id="L1563" title="1 of 2 branches missed.">        if (desc.startsWith(name)) {</span>
<span class="fc" id="L1564">            desc = desc.substring(name.length(), desc.length());</span>
        }
<span class="fc" id="L1566">        return desc;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="nc" id="L1574">        final Tile tile = colony.getTile();</span>
<span class="nc" id="L1575">        LogBuilder lb = new LogBuilder(256);</span>
<span class="nc" id="L1576">        lb.add(&quot;ColonyPlan: &quot;, colony,</span>
<span class="nc" id="L1577">            &quot; &quot;, colony.getTile(),</span>
            &quot;\nProfile: &quot;, profileType, &quot;\nPreferred production:&quot;);
<span class="nc" id="L1579">        FreeColObject.logFreeColObjects(getPreferredProduction(), lb);</span>
<span class="nc" id="L1580">        lb.add(getBuildableReport(), &quot;Food Plans:\n&quot;);</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">        for (WorkLocationPlan wlp : getFoodPlans()) {</span>
<span class="nc" id="L1582">            WorkLocation wl = wlp.getWorkLocation();</span>
<span class="nc" id="L1583">            lb.add(locationDescription(wl),</span>
<span class="nc" id="L1584">                &quot;: &quot;, wl.getGenericPotential(wlp.getGoodsType()), </span>
<span class="nc" id="L1585">                &quot; &quot;, wlp.getGoodsType().getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1586">        }</span>
<span class="nc" id="L1587">        lb.add(&quot;Work Plans:\n&quot;);</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">        for (WorkLocationPlan wlp : getWorkPlans()) {</span>
<span class="nc" id="L1589">            WorkLocation wl = wlp.getWorkLocation();</span>
<span class="nc" id="L1590">            lb.add(locationDescription(wl),</span>
<span class="nc" id="L1591">                &quot;: &quot;, wl.getGenericPotential(wlp.getGoodsType()),</span>
<span class="nc" id="L1592">                &quot; &quot;, wlp.getGoodsType().getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1593">        }</span>
<span class="nc" id="L1594">        return lb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>