<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColonyPlan.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.ai</a> &gt; <span class="el_source">ColonyPlan.java</span></div><h1>ColonyPlan.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.ai;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.AbstractGoods;
import net.sf.freecol.common.model.BuildableType;
import net.sf.freecol.common.model.BuildingType;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.FreeColObject;
import net.sf.freecol.common.model.GoodsContainer;
import net.sf.freecol.common.model.GoodsType;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.Market;
import net.sf.freecol.common.model.Modifier;
import net.sf.freecol.common.model.NationType;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Scope;
import net.sf.freecol.common.model.Specification;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.Role;
import net.sf.freecol.common.model.UnitType;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import net.sf.freecol.common.model.WorkLocation;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.LogBuilder;

/**
 * Objects of this class describes the plan the AI has for a
 * &lt;code&gt;Colony&lt;/code&gt;.
 *
 * A &lt;code&gt;ColonyPlan&lt;/code&gt; contains a list of {@link WorkLocationPlan}s which
 * suggests the food and non-food production of each {@link WorkLocation}, and a
 * list of {@link BuildableType}s to build. It takes account of the available
 * tiles and building production, but does not make decisions to claim tiles or
 * change the current buildable. It does takes account of goods present in the
 * colony, and overall colony size but not the exact composition of the units
 * involved. However there is extensive structure for making a trial assignment
 * of workers in {@link #assignWorkers}.
 *
 * {@link AIColony#rearrangeWorkers} is responsible for making the real
 * decisions.
 *
 * @see Colony
 */
public class ColonyPlan {

	/** The Constant logger. */
<span class="fc" id="L77">	private static final Logger logger = Logger.getLogger(ColonyPlan.class.getName());</span>

	/** Require production plans to always produce an amount exceeding this. */
	private static final int LOW_PRODUCTION_THRESHOLD = 1;

	/**
	 * Number of turns to require production of without exhausting the input
	 * goods.
	 */
	private static final int PRODUCTION_TURNOVER_TURNS = 5;

	/** The profile of the colony (a sort of general flavour). */
<span class="pc" id="L89">	private static enum ProfileType {</span>

		/** The outpost. */
<span class="fc" id="L92">		OUTPOST,</span>

		/** The small. */
<span class="fc" id="L95">		SMALL,</span>

		/** The medium. */
<span class="fc" id="L98">		MEDIUM,</span>

		/** The large. */
<span class="fc" id="L101">		LARGE,</span>

		/** The capital. */
<span class="fc" id="L104">		CAPITAL;</span>

		/**
		 * Chooses a suitable profile type given a size of colony.
		 *
		 * @param size
		 *            A proposed colony size.
		 * @return the profile type from size
		 */
		public static ProfileType getProfileTypeFromSize(int size) {
<span class="pc bpc" id="L114" title="2 of 8 branches missed.">			return (size &lt;= 1) ? ProfileType.OUTPOST</span>
					: (size &lt;= 2) ? ProfileType.SMALL
							: (size &lt;= 4) ? ProfileType.MEDIUM : (size &lt;= 8) ? ProfileType.LARGE : ProfileType.CAPITAL;
		}
	};

	/** The profile type. */
	private ProfileType profileType;

	/** Private copy of the AIMain. */
	private final AIMain aiMain;

	/** The colony this AIColony manages. */
	private final Colony colony;

	/** The things to build, and their priority. */
	private static class BuildPlan {

		/** The type. */
		public final BuildableType type;

		/** The weight. */
		public double weight;

		/** The support. */
		public double support;

		/** The difficulty. */
		public double difficulty;

		/**
		 * Instantiates a new builds the plan.
		 *
		 * @param type
		 *            the type
		 * @param weight
		 *            the weight
		 * @param support
		 *            the support
		 */
<span class="fc" id="L154">		public BuildPlan(BuildableType type, double weight, double support) {</span>
<span class="fc" id="L155">			this.type = type;</span>
<span class="fc" id="L156">			this.weight = weight;</span>
<span class="fc" id="L157">			this.support = support;</span>
<span class="fc" id="L158">			this.difficulty = 1.0f;</span>
<span class="fc" id="L159">		}</span>

		/**
		 * Gets the value.
		 *
		 * @return the value
		 */
		public double getValue() {
<span class="fc" id="L167">			return weight * support / difficulty;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L175">			return String.format(&quot;%s (%1.3f * %1.3f / %1.3f = %1.3f)&quot;, type.getSuffix(), weight, support, difficulty,</span>
<span class="nc" id="L176">					getValue());</span>
		}
	};

	/** The build plans. */
<span class="fc" id="L181">	private final List&lt;BuildPlan&gt; buildPlans = new ArrayList&lt;&gt;();</span>

	/**
	 * Comparator to sort buildable types on their priority in the buildPlan
	 * map.
	 */
<span class="fc" id="L187">	private static final Comparator&lt;BuildPlan&gt; buildPlanComparator = new Comparator&lt;BuildPlan&gt;() {</span>
		@Override
		public int compare(BuildPlan b1, BuildPlan b2) {
<span class="fc" id="L190">			double d = b1.getValue() - b2.getValue();</span>
<span class="pc bpc" id="L191" title="1 of 4 branches missed.">			return (d &gt; 0.0) ? -1 : (d &lt; 0.0) ? 1 : 0;</span>
		}
	};

	/** Plans for work locations available to this colony. */
<span class="fc" id="L196">	private final List&lt;WorkLocationPlan&gt; workPlans = new ArrayList&lt;&gt;();</span>

	/** The goods types to produce. */
<span class="fc" id="L199">	private final List&lt;GoodsType&gt; produce = new ArrayList&lt;&gt;();</span>

	/**
	 * Lists of goods types to be produced in this colony. Temporary variables
	 * that do not need to be serialized.
	 */
<span class="fc" id="L205">	private final List&lt;GoodsType&gt; foodGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The liberty goods types. */
<span class="fc" id="L208">	private final List&lt;GoodsType&gt; libertyGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The immigration goods types. */
<span class="fc" id="L211">	private final List&lt;GoodsType&gt; immigrationGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The military goods types. */
<span class="fc" id="L214">	private final List&lt;GoodsType&gt; militaryGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The raw building goods types. */
<span class="fc" id="L217">	private final List&lt;GoodsType&gt; rawBuildingGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The building goods types. */
<span class="fc" id="L220">	private final List&lt;GoodsType&gt; buildingGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The raw luxury goods types. */
<span class="fc" id="L223">	private final List&lt;GoodsType&gt; rawLuxuryGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The luxury goods types. */
<span class="fc" id="L226">	private final List&lt;GoodsType&gt; luxuryGoodsTypes = new ArrayList&lt;&gt;();</span>

	/** The other raw goods types. */
<span class="fc" id="L229">	private final List&lt;GoodsType&gt; otherRawGoodsTypes = new ArrayList&lt;&gt;();</span>

	/**
	 * Creates a new &lt;code&gt;ColonyPlan&lt;/code&gt;.
	 *
	 * @param aiMain
	 *            The main AI-object.
	 * @param colony
	 *            The colony to make a &lt;code&gt;ColonyPlan&lt;/code&gt; for.
	 */
<span class="fc" id="L239">	public ColonyPlan(AIMain aiMain, Colony colony) {</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">		if (aiMain == null)</span>
<span class="nc" id="L241">			throw new IllegalArgumentException(&quot;Null AIMain&quot;);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">		if (colony == null)</span>
<span class="nc" id="L243">			throw new IllegalArgumentException(&quot;Null colony&quot;);</span>

<span class="fc" id="L245">		this.aiMain = aiMain;</span>
<span class="fc" id="L246">		this.colony = colony;</span>
<span class="fc" id="L247">		this.profileType = ProfileType.getProfileTypeFromSize(colony.getUnitCount());</span>
<span class="fc" id="L248">	}</span>

	/**
	 * Gets the main AI-object.
	 *
	 * @return The main AI-object.
	 */
	private AIMain getAIMain() {
<span class="fc" id="L256">		return aiMain;</span>
	}

	/**
	 * Gets the specification.
	 *
	 * @return The specification.
	 */
	private Specification spec() {
<span class="fc" id="L265">		return aiMain.getGame().getSpecification();</span>
	}

	// Public functionality.

	/**
	 * Gets the preferred goods to produce.
	 *
	 * @return A copy of the preferred goods production list in this plan.
	 */
	public List&lt;GoodsType&gt; getPreferredProduction() {
<span class="fc" id="L276">		return new ArrayList&lt;&gt;(produce);</span>
	}

	/**
	 * Gets a copy of the current list of buildable types associated with this
	 * &lt;code&gt;ColonyPlan&lt;/code&gt;.
	 *
	 * @return A copy of the of &lt;code&gt;BuildableType&lt;/code&gt;s list.
	 */
	public List&lt;BuildableType&gt; getBuildableTypes() {
<span class="fc" id="L286">		List&lt;BuildableType&gt; build = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">		for (BuildPlan b : buildPlans)</span>
<span class="fc" id="L288">			build.add(b.type);</span>
<span class="fc" id="L289">		return build;</span>
	}

	/**
	 * Gets the best buildable type from this plan that can currently be built
	 * by the colony.
	 *
	 * @return The best current &lt;code&gt;BuildableType&lt;/code&gt;.
	 */
	public BuildableType getBestBuildableType() {
<span class="fc" id="L299">		BuildPlan bp = find(buildPlans, p -&gt; colony.canBuild(p.type));</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">		return (bp == null) ? null : bp.type;</span>
	}

	/**
	 * Get a report on the build plans.
	 *
	 * @return A build plan report.
	 */
	public String getBuildableReport() {
<span class="nc" id="L309">		LogBuilder lb = new LogBuilder(64);</span>
<span class="nc" id="L310">		lb.add(&quot;Buildables:\n&quot;);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">		for (BuildPlan b : buildPlans)</span>
<span class="nc" id="L312">			lb.add(b, &quot;\n&quot;);</span>
<span class="nc" id="L313">		return lb.toString();</span>
	}

	/**
	 * Gets the food-producing and non-autoproducing work location plans
	 * associated with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
	 *
	 * @return A list of food producing plans.
	 */
	public List&lt;WorkLocationPlan&gt; getFoodPlans() {
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">		return workPlans.stream().filter(wp -&gt; wp.isFoodPlan() &amp;&amp; !wp.getWorkLocation().canAutoProduce())</span>
<span class="fc" id="L324">				.collect(Collectors.toList());</span>
	}

	/**
	 * Gets the non-food-producing/non-autoproducing work location plans
	 * associated with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
	 *
	 * @return A list of non-food producing plans.
	 */
	public List&lt;WorkLocationPlan&gt; getWorkPlans() {
<span class="pc bpc" id="L334" title="1 of 4 branches missed.">		return workPlans.stream().filter(wp -&gt; !wp.isFoodPlan() &amp;&amp; !wp.getWorkLocation().canAutoProduce())</span>
<span class="fc" id="L335">				.collect(Collectors.toList());</span>
	}

	/**
	 * Refines this plan given the colony choice of what to build.
	 *
	 * @param build
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to be built (may be null).
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 */
	public void refine(BuildableType build, LogBuilder lb) {
<span class="fc" id="L347">		List&lt;GoodsType&gt; required = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">		for (AbstractGoods ag : colony.getFullRequiredGoods(build)) {</span>
<span class="fc" id="L349">			required.add(ag.getType());</span>
<span class="fc" id="L350">		}</span>
<span class="fc" id="L351">		Map&lt;GoodsType, List&lt;WorkLocationPlan&gt;&gt; suppressed = new HashMap&lt;&gt;();</span>

		// Examine a copy of the work plans, but operate on the
		// original list. Maintain a offset between the index in the
		// copied list and the original to aid reinsertion.
		//
		// Remove any work plans to make raw/building goods that are
		// not required to complete the current buildable, but take
		// care to put such plans back again if a plan is encountered
		// that makes goods that are made from a type that was removed
		// and there is less than CARGO_SIZE/2 of that type in stock.
		// Note though in such cases the position of the
		// building-goods plans in the work plans list will have moved
		// from their usual high priority to immediately before the
		// position of the manufactured goods.
		//
		// So, for example, we should suppress tool building when a
		// colony is building a warehouse, unless we find a plan to
		// make muskets and the tool stock is low.
		//
		// FIXME: generalize this further to make tools for pioneers.
		//
<span class="fc" id="L373">		List&lt;WorkLocationPlan&gt; plans = new ArrayList&lt;&gt;(workPlans);</span>
<span class="fc" id="L374">		int offset = 0;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">		for (int i = 0; i &lt; plans.size(); i++) {</span>
			List&lt;WorkLocationPlan&gt; wls;
<span class="fc" id="L377">			WorkLocationPlan wlp = plans.get(i);</span>
<span class="fc" id="L378">			GoodsType g = wlp.getGoodsType();</span>
<span class="fc bfc" id="L379" title="All 4 branches covered.">			if ((rawBuildingGoodsTypes.contains(g) &amp;&amp; !required.contains(g.getOutputType()))</span>
<span class="fc bfc" id="L380" title="All 4 branches covered.">					|| (buildingGoodsTypes.contains(g) &amp;&amp; !required.contains(g))) {</span>
<span class="fc" id="L381">				workPlans.remove(i - offset);</span>
<span class="fc" id="L382">				offset++;</span>
<span class="fc" id="L383">				wls = suppressed.get(g);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">				if (wls == null)</span>
<span class="fc" id="L385">					wls = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L386">				wls.add(0, wlp); // reverses list</span>
<span class="fc" id="L387">				suppressed.put(g, wls);</span>
<span class="fc" id="L388">				produce.remove(g);</span>
<span class="fc" id="L389">				lb.add(&quot;, suppress production of &quot;, g);</span>
<span class="fc bfc" id="L390" title="All 4 branches covered.">			} else if (g.isRefined() &amp;&amp; (rawBuildingGoodsTypes.contains(g.getInputType())</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">					|| buildingGoodsTypes.contains(g.getInputType()))) {</span>
<span class="fc" id="L392">				int n = 0, idx = produce.indexOf(g);</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">				for (GoodsType type = g.getInputType(); type != null; type = type.getInputType()) {</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">					if ((wls = suppressed.get(type)) == null)</span>
<span class="fc" id="L395">						break;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">					if (colony.getGoodsCount(type) &gt;= GoodsContainer.CARGO_SIZE / 2)</span>
<span class="nc" id="L397">						break;</span>
<span class="nc" id="L398">					n += wls.size();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">					while (!wls.isEmpty()) {</span>
						// reverses again when adding, cancelling reversal above
<span class="nc" id="L401">						workPlans.add(i - offset, wls.remove(0));</span>
					}
<span class="nc" id="L403">					produce.add(idx, type);</span>
<span class="nc" id="L404">					lb.add(&quot;, restore production of &quot;, type);</span>
				}
<span class="fc" id="L406">				offset -= n;</span>
			}
		}
<span class="fc" id="L409">	}</span>

	/**
	 * Recreates the buildables and work location plans for this colony.
	 */
	public void update() {
		// Update the profile type.
<span class="fc" id="L416">		profileType = ProfileType.getProfileTypeFromSize(colony.getUnitCount());</span>

		// Build the total map of all possible production with standard units.
<span class="fc" id="L419">		Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production = createProductionMap();</span>

		// Set the goods type lists, and prune production of manufactured
		// goods that are missing raw materials and other non-interesting.
<span class="fc" id="L423">		updateGoodsTypeLists(production);</span>

		// Set the preferred raw materials. Prune production and
		// goods lists further removing the non-preferred new world
		// raw and refined materials.
<span class="fc" id="L428">		updateRawMaterials(production);</span>

		// The buildables depend on the profile type, the goods type lists
		// and/or goods-to-produce list.
<span class="fc" id="L432">		updateBuildableTypes();</span>

		// Make plans for each valid &lt;goods, location&gt; production and
		// complete the list of goods to produce.
<span class="fc" id="L436">		updatePlans(production);</span>
<span class="fc" id="L437">	}</span>

	// Internals

	/**
	 * Creates a map of potential production of all goods types from all
	 * available work locations using the default unit type. Includes
	 * non-workable locations (e.g. chapel, colony-center-tile) as their
	 * production can influence the choice of goods to produce.
	 *
	 * @return The map of potential production.
	 */
	private Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; createProductionMap() {
<span class="fc" id="L450">		Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">		for (WorkLocation wl : colony.getAvailableWorkLocations()) {</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">			for (GoodsType g : spec().getGoodsTypeList()) {</span>
<span class="fc" id="L453">				int p = wl.getGenericPotential(g);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">				if (p &gt; 0) {</span>
<span class="fc" id="L455">					Map&lt;WorkLocation, Integer&gt; m = production.get(g);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">					if (m == null) {</span>
<span class="fc" id="L457">						m = new HashMap&lt;&gt;();</span>
<span class="fc" id="L458">						production.put(g, m);</span>
					}
<span class="fc" id="L460">					m.put(wl, p);</span>
				}
<span class="fc" id="L462">			}</span>
<span class="fc" id="L463">		}</span>
<span class="fc" id="L464">		return production;</span>
	}

	/**
	 * Updates the goods type lists. The categories are:
	 * &lt;UL&gt;
	 * &lt;LI&gt;food&lt;/LI&gt;
	 * &lt;LI&gt;liberty&lt;/LI&gt;
	 * &lt;LI&gt;immigration&lt;/LI&gt;
	 * &lt;LI&gt;military&lt;/LI&gt;
	 * &lt;LI&gt;raw building&lt;/LI&gt;
	 * &lt;LI&gt;building&lt;/LI&gt;
	 * &lt;LI&gt;raw luxury&lt;/LI&gt;
	 * &lt;LI&gt;luxury&lt;/LI&gt;
	 * &lt;LI&gt;raw other&lt;/LI&gt;
	 * &lt;/UL&gt;
	 *
	 * Ignore raw materials which can not be refined and refined goods that have
	 * no raw materials available. Also ignore other goods that do not fit these
	 * categories (e.g. trade goods).
	 *
	 * @param production
	 *            The production map.
	 */
	private void updateGoodsTypeLists(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L489">		foodGoodsTypes.clear();</span>
<span class="fc" id="L490">		libertyGoodsTypes.clear();</span>
<span class="fc" id="L491">		immigrationGoodsTypes.clear();</span>
<span class="fc" id="L492">		militaryGoodsTypes.clear();</span>
<span class="fc" id="L493">		rawBuildingGoodsTypes.clear();</span>
<span class="fc" id="L494">		buildingGoodsTypes.clear();</span>
<span class="fc" id="L495">		rawLuxuryGoodsTypes.clear();</span>
<span class="fc" id="L496">		luxuryGoodsTypes.clear();</span>
<span class="fc" id="L497">		otherRawGoodsTypes.clear();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">		for (GoodsType g : new ArrayList&lt;&gt;(production.keySet())) {</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">			if (g.isFoodType()) {</span>
<span class="fc" id="L500">				foodGoodsTypes.add(g);</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">			} else if (g.isLibertyType()) {</span>
<span class="fc" id="L502">				libertyGoodsTypes.add(g);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">			} else if (g.isImmigrationType()) {</span>
<span class="nc" id="L504">				immigrationGoodsTypes.add(g);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">			} else if (g.isMilitaryGoods()) {</span>
<span class="fc" id="L506">				militaryGoodsTypes.add(g);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">			} else if (g.isRawBuildingMaterial()) {</span>
<span class="fc" id="L508">				rawBuildingGoodsTypes.add(g);</span>
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">			} else if (g.isBuildingMaterial() &amp;&amp; g.getInputType().isRawBuildingMaterial()) {</span>
<span class="fc" id="L510">				buildingGoodsTypes.add(g);</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">			} else if (g.isNewWorldGoodsType()) {</span>
<span class="fc" id="L512">				rawLuxuryGoodsTypes.add(g);</span>
<span class="pc bpc" id="L513" title="1 of 4 branches missed.">			} else if (g.isRefined() &amp;&amp; g.getInputType().isNewWorldGoodsType()) {</span>
<span class="fc" id="L514">				luxuryGoodsTypes.add(g);</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">			} else if (g.isFarmed()) {</span>
<span class="fc" id="L516">				otherRawGoodsTypes.add(g);</span>
			} else { // Not interested in this goods type. Should not happen.
<span class="nc" id="L518">				logger.warning(&quot;Ignoring goods type &quot; + g + &quot; at &quot; + colony.getName());</span>
<span class="nc" id="L519">				production.remove(g);</span>
			}
<span class="fc" id="L521">		}</span>
<span class="fc" id="L522">	}</span>

	/**
	 * Chooses the two best raw materials, updating the production map and
	 * lists.
	 *
	 * FIXME: scale with colony size.
	 *
	 * @param production
	 *            The production map.
	 */
	private void updateRawMaterials(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L534">		Player player = colony.getOwner();</span>
<span class="fc" id="L535">		Market market = player.getMarket();</span>
<span class="fc" id="L536">		NationType nationType = player.getNationType();</span>
<span class="fc" id="L537">		GoodsType primaryRawMaterial = null;</span>
<span class="fc" id="L538">		GoodsType secondaryRawMaterial = null;</span>
<span class="fc" id="L539">		int primaryValue = -1;</span>
<span class="fc" id="L540">		int secondaryValue = -1;</span>

<span class="fc" id="L542">		produce.clear();</span>
<span class="fc" id="L543">		List&lt;GoodsType&gt; rawMaterials = new ArrayList&lt;&gt;(rawLuxuryGoodsTypes);</span>
<span class="fc" id="L544">		rawMaterials.addAll(otherRawGoodsTypes);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">		for (GoodsType g : rawMaterials) {</span>
<span class="fc" id="L546">			int value = production.get(g).entrySet().stream().mapToInt(e -&gt; e.getValue()).sum();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">			if (value &lt;= LOW_PRODUCTION_THRESHOLD) {</span>
<span class="fc" id="L548">				production.remove(g);</span>
<span class="fc" id="L549">				continue;</span>
			}
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">			if (market != null) {</span>
				// If the market is available, weight by sale price of
				// the material, or if it is the raw material for a
				// refined goods type, the average of the raw and
				// refined goods prices.
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">				if (g.getOutputType() == null) {</span>
<span class="nc" id="L557">					value *= market.getSalePrice(g, 1);</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">				} else if (production.containsKey(g.getOutputType())) {</span>
<span class="fc" id="L559">					value *= (market.getSalePrice(g, 1) + market.getSalePrice(g.getOutputType(), 1)) / 2;</span>
				}
			}
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">			if (nationType.hasModifier(g.getId())) {</span>
<span class="nc" id="L563">				value = (value * 12) / 10; // Bonus for national advantages</span>
			}
<span class="pc bpc" id="L565" title="2 of 4 branches missed.">			if (value &gt; secondaryValue &amp;&amp; secondaryRawMaterial != null) {</span>
<span class="nc" id="L566">				production.remove(secondaryRawMaterial);</span>
<span class="nc" id="L567">				production.remove(secondaryRawMaterial.getOutputType());</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">				if (rawLuxuryGoodsTypes.contains(secondaryRawMaterial)) {</span>
<span class="nc" id="L569">					rawLuxuryGoodsTypes.remove(secondaryRawMaterial);</span>
<span class="nc" id="L570">					luxuryGoodsTypes.remove(secondaryRawMaterial.getOutputType());</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">				} else if (otherRawGoodsTypes.contains(secondaryRawMaterial)) {</span>
<span class="nc" id="L572">					otherRawGoodsTypes.remove(secondaryRawMaterial);</span>
				}
			}
<span class="fc bfc" id="L575" title="All 2 branches covered.">			if (value &gt; primaryValue) {</span>
<span class="fc" id="L576">				secondaryRawMaterial = primaryRawMaterial;</span>
<span class="fc" id="L577">				secondaryValue = primaryValue;</span>
<span class="fc" id="L578">				primaryRawMaterial = g;</span>
<span class="fc" id="L579">				primaryValue = value;</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">			} else if (value &gt; secondaryValue) {</span>
<span class="fc" id="L581">				secondaryRawMaterial = g;</span>
<span class="fc" id="L582">				secondaryValue = value;</span>
			}
<span class="fc" id="L584">		}</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">		if (primaryRawMaterial != null) {</span>
<span class="fc" id="L586">			produce.add(primaryRawMaterial);</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">			if (primaryRawMaterial.getOutputType() != null) {</span>
<span class="fc" id="L588">				produce.add(primaryRawMaterial.getOutputType());</span>
			}
<span class="fc bfc" id="L590" title="All 2 branches covered.">			if (secondaryRawMaterial != null) {</span>
<span class="fc" id="L591">				produce.add(secondaryRawMaterial);</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">				if (secondaryRawMaterial.getOutputType() != null) {</span>
<span class="fc" id="L593">					produce.add(secondaryRawMaterial.getOutputType());</span>
				}
			}
		}
<span class="fc" id="L597">	}</span>

	// Relative weights of the various building categories.
	// FIXME: split out/parameterize into a &quot;building strategy&quot;
	//
	/** The Constant BREEDING_WEIGHT. */
	// BuildableTypes that improve breeding.
	private static final double BREEDING_WEIGHT = 0.1;

	/** The Constant BUILDING_WEIGHT. */
	// BuildableTypes that improve building production.
	private static final double BUILDING_WEIGHT = 0.9;

	/** The Constant DEFENCE_WEIGHT. */
	// BuildableTypes that produce defensive units.
	private static final double DEFENCE_WEIGHT = 0.1;

	/** The Constant EXPORT_WEIGHT. */
	// BuildableTypes that provide export ability.
	private static final double EXPORT_WEIGHT = 0.6;

	/** The Constant FISH_WEIGHT. */
	// BuildableTypes that allow water to be used.
	private static final double FISH_WEIGHT = 0.25;

	/** The Constant FORTIFY_WEIGHT. */
	// BuildableTypes that improve the colony fortifications.
	private static final double FORTIFY_WEIGHT = 0.3;

	/** The Constant IMMIGRATION_WEIGHT. */
	// BuildableTypes that improve immigration production.
	private static final double IMMIGRATION_WEIGHT = 0.05;

	/** The Constant LIBERTY_WEIGHT. */
	// BuildableTypes that improve liberty production.
	private static final double LIBERTY_WEIGHT = 0.75;

	/** The Constant MILITARY_WEIGHT. */
	// BuildableTypes that improve military goods production.
	private static final double MILITARY_WEIGHT = 0.4;

	/** The Constant PRODUCTION_WEIGHT. */
	// BuildableTypes that improve luxury goods production.
	private static final double PRODUCTION_WEIGHT = 0.25;

	/** The Constant REPAIR_WEIGHT. */
	// BuildableTypes that improve colony storage.
	private static final double REPAIR_WEIGHT = 0.1;

	/** The Constant STORAGE_WEIGHT. */
	// BuildableTypes that improve colony storage.
	private static final double STORAGE_WEIGHT = 0.85;

	/** The Constant TEACH_WEIGHT. */
	// BuildableTypes that improve education.
	private static final double TEACH_WEIGHT = 0.2;

	/** The Constant TRANSPORT_WEIGHT. */
	// BuildableTypes that improve transport.
	private static final double TRANSPORT_WEIGHT = 0.15;

	/**
	 * Finds a build plan for this type.
	 *
	 * @param type
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to search for.
	 * @return A &lt;code&gt;BuildPlan&lt;/code&gt; with this type, or null if not found.
	 */
	private BuildPlan findBuildPlan(BuildableType type) {
<span class="fc bfc" id="L666" title="All 2 branches covered.">		return find(buildPlans, bp -&gt; bp.type == type);</span>
	}

	/**
	 * Adds or improves the priority of a buildable in a list.
	 *
	 * @param type
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to use.
	 * @param weight
	 *            The relative weight of this class of buildable with respect to
	 *            other buildable classes.
	 * @param support
	 *            The support for this buildable within its class.
	 * @return True if this type was prioritized.
	 */
	private boolean prioritize(BuildableType type, double weight, double support) {
<span class="fc" id="L682">		BuildPlan bp = findBuildPlan(type);</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">		if (bp == null) {</span>
<span class="fc" id="L684">			buildPlans.add(new BuildPlan(type, weight, support));</span>
<span class="fc" id="L685">			return true;</span>
		}
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">		if (bp.weight * bp.support &lt; weight * support) {</span>
<span class="fc" id="L688">			bp.weight = weight;</span>
<span class="fc" id="L689">			bp.support = support;</span>
<span class="fc" id="L690">			return true;</span>
		}
<span class="nc" id="L692">		return false;</span>
	}

	/**
	 * Given a buildable that improves production of a goods type, prioritize
	 * it.
	 *
	 * @param type
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to consider.
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; improved by the buildable.
	 * @return True if this type was prioritized.
	 */
	private boolean prioritizeProduction(BuildableType type, GoodsType goodsType) {
<span class="fc" id="L706">		Player player = colony.getOwner();</span>
<span class="fc" id="L707">		NationType nationType = player.getNationType();</span>
<span class="fc" id="L708">		String advantage = getAIMain().getAIPlayer(player).getAIAdvantage();</span>
<span class="fc" id="L709">		boolean ret = false;</span>
<span class="fc" id="L710">		double factor = 1.0;</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">		if (nationType.hasModifier(goodsType.getId())) {</span>
			// Handles building, agriculture, furTrapping advantages
<span class="nc" id="L713">			factor *= 1.2;</span>
		}
<span class="fc bfc" id="L715" title="All 2 branches covered.">		if (goodsType.isMilitaryGoods()) {</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">			if (&quot;conquest&quot;.equals(advantage))</span>
<span class="nc" id="L717">				factor = 1.2;</span>
<span class="fc" id="L718">			ret = prioritize(type, MILITARY_WEIGHT * factor,</span>
					1.0/* FIXME: amount present wrt amount to equip */);
<span class="fc bfc" id="L720" title="All 2 branches covered.">		} else if (goodsType.isBuildingMaterial()) {</span>
<span class="fc" id="L721">			ret = prioritize(type, BUILDING_WEIGHT * factor,</span>
					1.0/* FIXME: need for this type */);
<span class="fc bfc" id="L723" title="All 2 branches covered.">		} else if (goodsType.isLibertyType()) {</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">			if (player.isREF())</span>
<span class="nc" id="L725">				return false; // no bells for REF colonies</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">			ret = prioritize(type, LIBERTY_WEIGHT, (colony.getSoL() &gt;= 100) ? 0.01 : 1.0);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">		} else if (goodsType.isImmigrationType()) {</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">			if (&quot;immigration&quot;.equals(advantage))</span>
<span class="nc" id="L729">				factor = 1.2;</span>
<span class="fc" id="L730">			ret = prioritize(type, IMMIGRATION_WEIGHT * factor,</span>
					1.0/* FIXME: Brewster? */);
<span class="fc bfc" id="L732" title="All 2 branches covered.">		} else if (produce.contains(goodsType)) {</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">			if (&quot;trade&quot;.equals(advantage))</span>
<span class="fc" id="L734">				factor = 1.2;</span>
<span class="fc" id="L735">			double f = 0.1 * colony.getTotalProductionOf(goodsType.getInputType());</span>
<span class="fc" id="L736">			ret = prioritize(type, PRODUCTION_WEIGHT, f/* FIXME: improvement? */);</span>
		}
<span class="fc" id="L738">		return ret;</span>
	}

	/**
	 * Updates the build plans for this colony.
	 */
	private void updateBuildableTypes() {
<span class="fc" id="L745">		final EuropeanAIPlayer euaip = (EuropeanAIPlayer) getAIMain().getAIPlayer(colony.getOwner());</span>
<span class="fc" id="L746">		String advantage = euaip.getAIAdvantage();</span>
<span class="fc" id="L747">		buildPlans.clear();</span>

		int maxLevel;
<span class="pc bpc" id="L750" title="2 of 5 branches missed.">		switch (profileType) {</span>
		case OUTPOST:
		case SMALL:
<span class="fc" id="L753">			maxLevel = 1;</span>
<span class="fc" id="L754">			break;</span>
		case MEDIUM:
<span class="fc" id="L756">			maxLevel = 2;</span>
<span class="fc" id="L757">			break;</span>
		case LARGE:
<span class="fc" id="L759">			maxLevel = 3;</span>
<span class="fc" id="L760">			break;</span>
		case CAPITAL:
<span class="nc" id="L762">			maxLevel = 4;</span>
<span class="nc" id="L763">			break;</span>
		default:
<span class="nc" id="L765">			throw new IllegalStateException(&quot;Bogus profile type: &quot; + profileType);</span>
		}

<span class="fc" id="L768">		Player player = colony.getOwner();</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">		for (BuildingType type : spec().getBuildingTypeList()) {</span>
<span class="fc" id="L770">			boolean expectFail = false;</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">			if (!colony.canBuild(type))</span>
<span class="fc" id="L772">				continue;</span>

			// Exempt defence and export from the level check.
<span class="fc bfc" id="L775" title="All 2 branches covered.">			if (type.hasModifier(Modifier.DEFENCE)) {</span>
<span class="fc" id="L776">				double factor = 1.0;</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">				if (&quot;conquest&quot;.equals(advantage))</span>
<span class="nc" id="L778">					factor = 1.1;</span>
<span class="fc" id="L779">				prioritize(type, FORTIFY_WEIGHT * factor,</span>
						1.0/* FIXME: 0 if FF underway */);
			}
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">			if (type.hasAbility(Ability.EXPORT)) {</span>
<span class="nc" id="L783">				double factor = 1.0;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">				if (&quot;trade&quot;.equals(advantage))</span>
<span class="nc" id="L785">					factor = 1.1;</span>
<span class="nc" id="L786">				prioritize(type, EXPORT_WEIGHT * factor,</span>
						1.0/* FIXME: weigh production v transport */);
			}

			// Skip later stage buildings for smaller settlements.
<span class="fc bfc" id="L791" title="All 2 branches covered.">			if (type.getLevel() &gt; maxLevel)</span>
<span class="fc" id="L792">				continue;</span>

			// Scale docks by the improvement available to the food supply.
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">			if (type.hasAbility(Ability.PRODUCE_IN_WATER)) {</span>
<span class="nc" id="L796">				double factor = 0.0;</span>
<span class="nc bnc" id="L797" title="All 4 branches missed.">				if (!colony.hasAbility(Ability.PRODUCE_IN_WATER) &amp;&amp; colony.getTile().isShore()) {</span>
<span class="nc" id="L798">					int landFood = 0, seaFood = 0;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">					for (Tile t : colony.getTile().getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L800" title="All 4 branches missed.">						if (t.getOwningSettlement() == colony || player.canClaimForSettlement(t)) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">							for (AbstractGoods ag : t.getSortedPotential()) {</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">								if (ag.getType().isFoodType()) {</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">									if (t.isLand()) {</span>
<span class="nc" id="L804">										landFood += ag.getAmount();</span>
									} else {
<span class="nc" id="L806">										seaFood += ag.getAmount();</span>
									}
								}
<span class="nc" id="L809">							}</span>
						}
<span class="nc" id="L811">					}</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">					factor = (seaFood + landFood == 0) ? 0.0 : seaFood / (double) (seaFood + landFood);</span>
				}
<span class="nc" id="L814">				prioritize(type, FISH_WEIGHT, factor);</span>
			}

<span class="fc bfc" id="L817" title="All 2 branches covered.">			if (type.hasAbility(Ability.BUILD)) {</span>
<span class="fc" id="L818">				double factor = 1.0;</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">				if (&quot;building&quot;.equals(advantage))</span>
<span class="nc" id="L820">					factor = 1.1;</span>
<span class="fc" id="L821">				double support = 1.0;</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">				for (Ability a : type.getAbilities(Ability.BUILD)) {</span>
<span class="fc" id="L823">					List&lt;Scope&gt; scopes = a.getScopes();</span>
<span class="pc bpc" id="L824" title="2 of 4 branches missed.">					if (scopes != null &amp;&amp; !scopes.isEmpty())</span>
<span class="fc" id="L825">						support = 0.1;</span>
<span class="fc" id="L826">				}</span>
<span class="fc" id="L827">				prioritize(type, BUILDING_WEIGHT * factor,</span>
						support/* FIXME: need for the thing now buildable */);
			}

<span class="fc bfc" id="L831" title="All 2 branches covered.">			if (type.hasAbility(Ability.TEACH)) {</span>
<span class="fc" id="L832">				prioritize(type, TEACH_WEIGHT,</span>
						1.0/* FIXME: #students, #specialists here, #wanted */);
			}

<span class="pc bpc" id="L836" title="1 of 2 branches missed.">			if (type.hasAbility(Ability.REPAIR_UNITS)) {</span>
<span class="nc" id="L837">				double factor = 1.0;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">				if (&quot;naval&quot;.equals(advantage))</span>
<span class="nc" id="L839">					factor = 1.1;</span>
<span class="nc" id="L840">				prioritize(type, REPAIR_WEIGHT * factor,</span>
						1.0/* FIXME: #units-to-repair, has-Europe etc */);
			}

<span class="fc" id="L844">			GoodsType output = type.getProducedGoodsType();</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">			if (output != null) {</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">				if (!prioritizeProduction(type, output)) {</span>
					// Allow failure if this building can not build.
<span class="fc" id="L848">					expectFail = true;</span>
				}
			} else {
<span class="fc bfc" id="L851" title="All 2 branches covered.">				for (GoodsType g : spec().getGoodsTypeList()) {</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">					if (type.hasModifier(g.getId())) {</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">						if (!prioritizeProduction(type, g)) {</span>
<span class="nc" id="L854">							expectFail = true;</span>
						}
					}
<span class="fc" id="L857">				}</span>
				// Hacks. No good way to make this really generic.
<span class="fc bfc" id="L859" title="All 2 branches covered.">				if (type.hasModifier(Modifier.WAREHOUSE_STORAGE)) {</span>
<span class="fc" id="L860">					double factor = 1.0;</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">					if (&quot;trade&quot;.equals(advantage))</span>
<span class="fc" id="L862">						factor = 1.1;</span>
<span class="fc" id="L863">					prioritize(type, STORAGE_WEIGHT * factor,</span>
							1.0/* FIXME: amount of goods */);
				}
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">				if (type.hasModifier(Modifier.BREEDING_DIVISOR)) {</span>
<span class="nc" id="L867">					prioritize(type, BREEDING_WEIGHT,</span>
							1.0/* FIXME: horses present? */);
				}
			}

<span class="pc bpc" id="L872" title="1 of 4 branches missed.">			if (findBuildPlan(type) == null &amp;&amp; !expectFail) {</span>
<span class="nc" id="L873">				logger.warning(&quot;No building priority found for: &quot; + type);</span>
			}
<span class="fc" id="L875">		}</span>

<span class="fc" id="L877">		double wagonNeed = 0.0;</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">		if (!colony.isConnectedPort()) { // Inland colonies need transportation</span>
<span class="fc" id="L879">			int wagons = euaip.getNeededWagons(colony.getTile());</span>
<span class="pc bpc" id="L880" title="3 of 4 branches missed.">			wagonNeed = (wagons &lt;= 0) ? 0.0 : (wagons &gt; 3) ? 1.0 : wagons / 3.0;</span>
		}
<span class="fc bfc" id="L882" title="All 2 branches covered.">		for (UnitType unitType : spec().getUnitTypeList()) {</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">			if (!colony.canBuild(unitType))</span>
<span class="fc" id="L884">				continue;</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">			if (unitType.hasAbility(Ability.NAVAL_UNIT)) {</span>
				; // FIXME: decide to build a ship
<span class="fc bfc" id="L887" title="All 2 branches covered.">			} else if (unitType.isDefensive()) {</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">				if (colony.isBadlyDefended()) {</span>
<span class="fc" id="L889">					prioritize(unitType, DEFENCE_WEIGHT,</span>
							1.0/* FIXME: how badly defended? */);
				}
<span class="fc bfc" id="L892" title="All 2 branches covered.">			} else if (unitType.hasAbility(Ability.CARRY_GOODS)) {</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">				if (wagonNeed &gt; 0.0) {</span>
<span class="nc" id="L894">					double factor = 1.0;</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">					if (&quot;trade&quot;.equals(advantage))</span>
<span class="nc" id="L896">						factor = 1.1;</span>
<span class="nc" id="L897">					prioritize(unitType, TRANSPORT_WEIGHT * factor,</span>
							wagonNeed/* FIXME: type.getSpace() */);
				}
			}
<span class="fc" id="L901">		}</span>

		// Weight by lower required goods.
<span class="fc bfc" id="L904" title="All 2 branches covered.">		for (BuildPlan bp : buildPlans) {</span>
<span class="fc" id="L905">			double difficulty = bp.type.getRequiredGoods().stream()</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">					.filter(ag -&gt; ag.getAmount() &gt; colony.getGoodsCount(ag.getType())).mapToDouble(ag -&gt; {</span>
<span class="fc" id="L907">						final GoodsType type = ag.getType();</span>
<span class="fc" id="L908">						return (ag.getAmount() - colony.getGoodsCount(type))</span>
								// Penalize building with type that can not be
								// made locally.
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">								* ((produce.contains(type.getInputType())) ? 1.0 : 5.0);</span>
<span class="fc" id="L912">					}).sum();</span>
<span class="fc" id="L913">			bp.difficulty = Math.max(1.0f, Math.sqrt(difficulty));</span>
<span class="fc" id="L914">		}</span>

<span class="fc" id="L916">		Collections.sort(buildPlans, buildPlanComparator);</span>
<span class="fc" id="L917">	}</span>

	/**
	 * Makes a plan for each type of possible production, that is those work
	 * locations that can use a unit or can auto-produce. Note that this will
	 * almost certainly include clashes over work locations. That gets sorted
	 * out elsewhere as ColonyPlans do not examine the units present.
	 * 
	 * With the complete list of work plans, finish creating the list of goods
	 * to produce.
	 * 
	 * Then filter out the auto-production plans as they are not going to be
	 * helpful for unit allocation.
	 * 
	 * Finally sort by desirability.
	 *
	 * @param production
	 *            the production
	 */
	private void updatePlans(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L937">		workPlans.clear();</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">		for (Entry&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; entry : production.entrySet()) {</span>
<span class="fc" id="L939">			GoodsType g = entry.getKey();</span>
			// Do not make plans to produce into a full warehouse.
<span class="pc bpc" id="L941" title="1 of 6 branches missed.">			if (g.isStorable() &amp;&amp; colony.getGoodsCount(g) &gt;= colony.getWarehouseCapacity() &amp;&amp; !g.limitIgnored())</span>
<span class="fc" id="L942">				continue;</span>

<span class="fc bfc" id="L944" title="All 2 branches covered.">			for (WorkLocation wl : entry.getValue().keySet()) {</span>
<span class="pc bpc" id="L945" title="3 of 4 branches missed.">				if (wl.canBeWorked() || wl.canAutoProduce()) {</span>
<span class="fc" id="L946">					workPlans.add(new WorkLocationPlan(getAIMain(), wl, g));</span>
				}
<span class="fc" id="L948">			}</span>
<span class="fc" id="L949">		}</span>

		// Now we have lots of plans, determine what goods to produce.
<span class="fc" id="L952">		updateProductionList(production);</span>

		// Filter out plans that can not use a unit.
<span class="fc" id="L955">		List&lt;WorkLocationPlan&gt; oldPlans = new ArrayList&lt;&gt;(workPlans);</span>
<span class="fc" id="L956">		workPlans.clear();</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">		for (WorkLocationPlan wlp : oldPlans) {</span>
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">			if (wlp.getWorkLocation().canBeWorked())</span>
<span class="fc" id="L959">				workPlans.add(wlp);</span>
<span class="fc" id="L960">		}</span>

		// Sort the work plans by earliest presence in the produce
		// list, and then by amount. If the type of goods produced is
		// not on the produce list, then make sure such plans sort to
		// the end, except for food plans.
<span class="fc" id="L966">		Collections.sort(workPlans, new Comparator&lt;WorkLocationPlan&gt;() {</span>
			@Override
			public int compare(WorkLocationPlan w1, WorkLocationPlan w2) {
<span class="fc" id="L969">				GoodsType g1 = w1.getGoodsType();</span>
<span class="fc" id="L970">				GoodsType g2 = w2.getGoodsType();</span>
<span class="fc" id="L971">				int i1 = produce.indexOf(g1);</span>
<span class="fc" id="L972">				int i2 = produce.indexOf(g2);</span>
<span class="fc bfc" id="L973" title="All 4 branches covered.">				if (i1 &lt; 0 &amp;&amp; !g1.isFoodType())</span>
<span class="fc" id="L974">					i1 = 99999;</span>
<span class="fc bfc" id="L975" title="All 4 branches covered.">				if (i2 &lt; 0 &amp;&amp; !g2.isFoodType())</span>
<span class="fc" id="L976">					i2 = 99999;</span>
<span class="fc" id="L977">				int cmp = i1 - i2;</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">				if (cmp == 0) {</span>
<span class="fc" id="L979">					cmp = w2.getWorkLocation().getGenericPotential(g2) - w1.getWorkLocation().getGenericPotential(g1);</span>
				}
<span class="fc" id="L981">				return cmp;</span>
			}
		});
<span class="fc" id="L984">	}</span>

	/**
	 * Add the other goods types to the production list. When this is called the
	 * new world goods production is already present on the produce list.
	 * Ignores food which is treated separately.
	 *
	 * @param production
	 *            the production
	 */
	private void updateProductionList(final Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L995">		final Comparator&lt;GoodsType&gt; productionComparator = new Comparator&lt;GoodsType&gt;() {</span>
			@Override
			public int compare(GoodsType g1, GoodsType g2) {
<span class="fc" id="L998">				int p1 = production.get(g1).values().stream().mapToInt(Integer::intValue).sum();</span>
<span class="fc" id="L999">				int p2 = production.get(g2).values().stream().mapToInt(Integer::intValue).sum();</span>
<span class="fc" id="L1000">				return p2 - p1;</span>
			}
		};
<span class="fc" id="L1003">		List&lt;GoodsType&gt; toAdd = new ArrayList&lt;&gt;();</span>

		// If we need liberty put it before the new world production.
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">		if (colony.getSoL() &lt; 100) {</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">			for (GoodsType g : libertyGoodsTypes) {</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">				if (production.containsKey(g))</span>
<span class="fc" id="L1009">					toAdd.add(g);</span>
<span class="fc" id="L1010">			}</span>
<span class="fc" id="L1011">			Collections.sort(toAdd, productionComparator);</span>
<span class="fc" id="L1012">			produce.addAll(0, toAdd);</span>
<span class="fc" id="L1013">			toAdd.clear();</span>
		}

		// Always add raw/building materials first.
<span class="fc" id="L1017">		Collections.sort(rawBuildingGoodsTypes, productionComparator);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">		for (GoodsType g : buildingGoodsTypes) {</span>
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">			if (production.containsKey(g)) {</span>
<span class="fc" id="L1020">				GoodsType raw = g.getInputType();</span>
<span class="fc bfc" id="L1021" title="All 4 branches covered.">				if (colony.getGoodsCount(raw) &gt;= GoodsContainer.CARGO_SIZE / 2 || production.containsKey(raw)) {</span>
<span class="fc" id="L1022">					toAdd.add(g);</span>
				}
			}
<span class="fc" id="L1025">		}</span>
<span class="fc" id="L1026">		Collections.sort(toAdd, new Comparator&lt;GoodsType&gt;() {</span>
			@Override
			public int compare(GoodsType g1, GoodsType g2) {
<span class="fc" id="L1029">				int i1 = rawBuildingGoodsTypes.indexOf(g1.getInputType());</span>
<span class="fc" id="L1030">				int i2 = rawBuildingGoodsTypes.indexOf(g2.getInputType());</span>
<span class="fc" id="L1031">				return i1 - i2;</span>
			}
		});
<span class="fc bfc" id="L1034" title="All 2 branches covered.">		for (int i = toAdd.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1035">			GoodsType make = toAdd.get(i);</span>
<span class="fc" id="L1036">			GoodsType raw = make.getInputType();</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">			if (production.containsKey(raw)) {</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">				if (colony.getGoodsCount(raw) &gt;= GoodsContainer.CARGO_SIZE / 2) {</span>
<span class="fc" id="L1039">					produce.add(raw); // Add at the end, enough in stock</span>
<span class="fc" id="L1040">					produce.add(0, make);</span>
				} else {
<span class="fc" id="L1042">					produce.add(0, make);</span>
<span class="fc" id="L1043">					produce.add(0, raw);</span>
				}
			} else {
<span class="fc" id="L1046">				produce.add(0, make);</span>
			}
		}
<span class="fc" id="L1049">		toAdd.clear();</span>

		// Military goods after lucrative production.
<span class="fc bfc" id="L1052" title="All 2 branches covered.">		for (GoodsType g : militaryGoodsTypes) {</span>
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">			if (production.containsKey(g))</span>
<span class="fc" id="L1054">				toAdd.add(g);</span>
<span class="fc" id="L1055">		}</span>
<span class="fc" id="L1056">		Collections.sort(toAdd, productionComparator);</span>
<span class="fc" id="L1057">		produce.addAll(toAdd);</span>
<span class="fc" id="L1058">		toAdd.clear();</span>

		// Immigration last.
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">		if (colony.getOwner().getEurope() != null) {</span>
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">			for (GoodsType g : immigrationGoodsTypes) {</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">				if (production.containsKey(g))</span>
<span class="nc" id="L1064">					toAdd.add(g);</span>
<span class="nc" id="L1065">			}</span>
<span class="fc" id="L1066">			Collections.sort(toAdd, productionComparator);</span>
<span class="fc" id="L1067">			produce.addAll(toAdd);</span>
<span class="fc" id="L1068">			toAdd.clear();</span>
		}
<span class="fc" id="L1070">	}</span>

	/**
	 * Tries to swap an expert unit for another doing its job.
	 *
	 * @param expert
	 *            The expert &lt;code&gt;Unit&lt;/code&gt;.
	 * @param others
	 *            A list of other &lt;code&gt;Unit&lt;/code&gt;s to test against.
	 * @param colony
	 *            The &lt;code&gt;Colony&lt;/code&gt; the units are working in.
	 * @return The unit that was replaced by the expert, or null if none.
	 */
	private Unit trySwapExpert(Unit expert, List&lt;Unit&gt; others, Colony colony) {
<span class="fc" id="L1084">		Role oldRole = expert.getRole();</span>
<span class="fc" id="L1085">		int oldRoleCount = expert.getRoleCount();</span>
<span class="fc" id="L1086">		GoodsType work = expert.getType().getExpertProduction();</span>
<span class="fc" id="L1087">		GoodsType oldWork = expert.getWorkType();</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">		for (Unit other : others) {</span>
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">			if (!other.isPerson())</span>
<span class="nc" id="L1090">				continue;</span>
<span class="pc bpc" id="L1091" title="3 of 4 branches missed.">			if (other.getWorkType() == work &amp;&amp; other.getType().getExpertProduction() != work) {</span>
<span class="nc" id="L1092">				Location l1 = expert.getLocation();</span>
<span class="nc" id="L1093">				Location l2 = other.getLocation();</span>
<span class="nc" id="L1094">				other.setLocation(colony.getTile());</span>
<span class="nc" id="L1095">				expert.setLocation(l2);</span>
<span class="nc" id="L1096">				expert.changeWorkType(work);</span>
<span class="nc" id="L1097">				other.setLocation(l1);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">				if (oldWork != null)</span>
<span class="nc" id="L1099">					other.changeWorkType(oldWork);</span>
<span class="nc" id="L1100">				Role tmpRole = other.getRole();</span>
<span class="nc" id="L1101">				int tmpRoleCount = other.getRoleCount();</span>
<span class="nc" id="L1102">				other.changeRole(oldRole, oldRoleCount);</span>
<span class="nc" id="L1103">				expert.changeRole(tmpRole, tmpRoleCount);</span>
<span class="nc" id="L1104">				return other;</span>
			}
<span class="fc" id="L1106">		}</span>
<span class="fc" id="L1107">		return null;</span>
	}

	/**
	 * Finds a plan on a list that produces a given goods type.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param plans
	 *            The list of &lt;code&gt;WorkLocationPlan&lt;/code&gt;s to check.
	 * @return The first plan found that produces the goods type, or null if
	 *         none found.
	 */
	private WorkLocationPlan findPlan(GoodsType goodsType, List&lt;WorkLocationPlan&gt; plans) {
<span class="fc bfc" id="L1121" title="All 2 branches covered.">		return find(plans, wlp -&gt; wlp.getGoodsType() == goodsType);</span>
	}

	/**
	 * Gets the best worker to execute a work location plan. - The most
	 * productive one wins (which will automatically pick a relevant expert). -
	 * If they are all relevant experts, pick any. - Pick the unit that can
	 * upgrade to the required expert with the most relevant experience or least
	 * irrelevant expertise. - Pick a unit that can not upgrade at all. - Pick
	 * an otherwise upgradeable unit with the most relevant experience or least
	 * irrelevant experience. - Pick the least skillful unit.
	 *
	 * Public for the benefit of the test suite.
	 *
	 * @param wl
	 *            The &lt;code&gt;WorkLocation&lt;/code&gt; to work at.
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to make.
	 * @param workers
	 *            A list of potential &lt;code&gt;Unit&lt;/code&gt;s to try.
	 * @return The best worker for the job.
	 */
	public static Unit getBestWorker(WorkLocation wl, GoodsType goodsType, List&lt;Unit&gt; workers) {
<span class="fc bfc" id="L1144" title="All 4 branches covered.">		if (workers == null || workers.isEmpty())</span>
<span class="fc" id="L1145">			return null;</span>
<span class="fc" id="L1146">		final Colony colony = wl.getColony();</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">		final GoodsType outputType = (goodsType.isStoredAs()) ? goodsType.getStoredAs() : goodsType;</span>

		// Avoid some nasty autodestructions by accepting singleton
		// workers that do *something*.
<span class="fc bfc" id="L1151" title="All 2 branches covered.">		if (workers.size() == 1) {</span>
<span class="fc" id="L1152">			Unit u = workers.get(0);</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">			if (!wl.canAdd(u))</span>
<span class="nc" id="L1154">				return null;</span>
<span class="fc" id="L1155">			Location oldLoc = u.getLocation();</span>
<span class="fc" id="L1156">			GoodsType oldWork = u.getWorkType();</span>
<span class="fc" id="L1157">			u.setLocation(wl);</span>
<span class="fc" id="L1158">			u.changeWorkType(goodsType);</span>
<span class="fc" id="L1159">			int production = wl.getProductionOf(u, goodsType);</span>
<span class="fc" id="L1160">			u.setLocation(oldLoc);</span>
<span class="fc" id="L1161">			u.changeWorkType(oldWork);</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">			return (production &gt; 0) ? u : null;</span>
		}

		// Do not mutate the workers list!
<span class="fc" id="L1166">		List&lt;Unit&gt; todo = new ArrayList&lt;&gt;(workers);</span>
<span class="fc" id="L1167">		List&lt;Unit&gt; best = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1168">		int bestValue = colony.getAdjustedNetProductionOf(outputType);</span>
<span class="fc" id="L1169">		Unit special = null;</span>
<span class="fc" id="L1170">		best.clear();</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">		for (Unit u : todo) {</span>
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">			if (!wl.canAdd(u))</span>
<span class="nc" id="L1173">				continue;</span>
<span class="fc" id="L1174">			Location oldLoc = u.getLocation();</span>
<span class="fc" id="L1175">			GoodsType oldWork = u.getWorkType();</span>
<span class="fc" id="L1176">			u.setLocation(wl);</span>
<span class="fc" id="L1177">			u.changeWorkType(goodsType);</span>

<span class="fc" id="L1179">			int value = colony.getAdjustedNetProductionOf(outputType);</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">			if (value &gt; bestValue) {</span>
<span class="fc" id="L1181">				bestValue = value;</span>
<span class="fc" id="L1182">				best.clear();</span>
<span class="fc" id="L1183">				best.add(u);</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">				if (u.getType().getExpertProduction() == goodsType) {</span>
<span class="fc" id="L1185">					special = u;</span>
				}
<span class="fc bfc" id="L1187" title="All 4 branches covered.">			} else if (value == bestValue &amp;&amp; !best.isEmpty()) {</span>
<span class="fc" id="L1188">				best.add(u);</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">				if (u.getType().getExpertProduction() == goodsType) {</span>
<span class="nc" id="L1190">					special = u;</span>
				}
			}

<span class="fc" id="L1194">			u.setLocation(oldLoc);</span>
<span class="fc" id="L1195">			u.changeWorkType(oldWork);</span>
<span class="fc" id="L1196">		}</span>

<span class="fc bfc" id="L1198" title="All 3 branches covered.">		switch (best.size()) {</span>
		case 0:
<span class="fc" id="L1200">			return null; // Not good. No unit improves production.</span>
		case 1:
<span class="fc" id="L1202">			return best.get(0);</span>
		default:
<span class="fc" id="L1204">			todo.clear();</span>
<span class="fc" id="L1205">			todo.addAll(best);</span>
			break;
		}
		// Several winners including an expert implies they are all experts.
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">		if (special != null)</span>
<span class="nc" id="L1210">			return special;</span>

		// Partition units into those that can upgrade-by-experience
		// to the relevant expert (which we favour), those that can
		// upgrade-by-experience in some way but not to the expert
		// (which we avoid), and the rest. Within the groups, favour
		// those with the most relevant experience and the least irrelevant
		// experience.
<span class="fc" id="L1218">		Specification spec = colony.getSpecification();</span>
<span class="fc" id="L1219">		UnitType expert = spec.getExpertForProducing(goodsType);</span>
<span class="fc" id="L1220">		best.clear();</span>
<span class="fc" id="L1221">		bestValue = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">		for (Unit u : todo) {</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">			boolean relevant = u.getWorkType() == goodsType;</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">			int score = (relevant) ? u.getExperience() : -u.getExperience();</span>
<span class="pc bpc" id="L1225" title="1 of 4 branches missed.">			if (expert != null &amp;&amp; u.getType().canBeUpgraded(expert, ChangeType.EXPERIENCE)) {</span>
<span class="fc" id="L1226">				score += 10000;</span>
<span class="pc bpc" id="L1227" title="1 of 4 branches missed.">			} else if (expert != null &amp;&amp; u.getType().canBeUpgraded(null, ChangeType.EXPERIENCE)) {</span>
<span class="fc" id="L1228">				score -= 10000;</span>
			}
<span class="fc bfc" id="L1230" title="All 2 branches covered.">			if (score &gt; bestValue) {</span>
<span class="fc" id="L1231">				best.clear();</span>
<span class="fc" id="L1232">				best.add(u);</span>
<span class="fc" id="L1233">				bestValue = score;</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">			} else if (score == bestValue) {</span>
<span class="fc" id="L1235">				best.add(u);</span>
			}
<span class="fc" id="L1237">		}</span>
<span class="pc bpc" id="L1238" title="1 of 3 branches missed.">		switch (best.size()) {</span>
		case 0:
<span class="nc" id="L1240">			break;</span>
		case 1:
<span class="fc" id="L1242">			return best.get(0);</span>
		default:
<span class="fc" id="L1244">			todo.clear();</span>
<span class="fc" id="L1245">			todo.addAll(best);</span>
			break;
		}

		// Use the unit with the least skill, in the hope that
		// remaining experts will be called upon in due course.
<span class="fc" id="L1251">		int worstSkill = Integer.MAX_VALUE;</span>
<span class="fc" id="L1252">		special = null;</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">		for (Unit u : todo) {</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">			if (u.getType().getSkill() &lt; worstSkill) {</span>
<span class="fc" id="L1255">				special = u;</span>
<span class="fc" id="L1256">				worstSkill = u.getType().getSkill();</span>
			}
<span class="fc" id="L1258">		}</span>
<span class="fc" id="L1259">		return special;</span>
	}

	/**
	 * Equips a unit for a role, trying extra possibilities.
	 *
	 * @param spec
	 *            the spec
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to equip if possible.
	 * @param role
	 *            The &lt;code&gt;Role&lt;/code&gt; for the unit to take.
	 * @param colony
	 *            The &lt;code&gt;Colony&lt;/code&gt; storing the equipment.
	 * @return True if the unit was equipped.
	 */
	private static boolean fullEquipUnit(Specification spec, Unit unit, Role role, Colony colony) {
<span class="nc bnc" id="L1276" title="All 2 branches missed.">		if (role.isOffensive()) {</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">			for (Role r : unit.getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">				if (colony.equipForRole(unit, r, r.getMaximumCount()))</span>
<span class="nc" id="L1279">					return true;</span>
<span class="nc" id="L1280">			}</span>
<span class="nc" id="L1281">			return false;</span>
		}
<span class="nc" id="L1283">		return colony.equipForRole(unit, role, role.getMaximumCount());</span>
	}

	/**
	 * Tries to apply a colony plan given a list of workers.
	 *
	 * @param workers
	 *            A list of &lt;code&gt;Unit&lt;/code&gt;s to assign.
	 * @param preferScout
	 *            Prefer to make scouts rather than soldiers.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return A scratch colony with the workers in place.
	 */
	public Colony assignWorkers(List&lt;Unit&gt; workers, boolean preferScout, LogBuilder lb) {
<span class="fc" id="L1298">		final GoodsType foodType = spec().getPrimaryFoodType();</span>

		// Collect the work location plans. Note that the plans are
		// pre-sorted in order of desirability.
<span class="fc" id="L1302">		final List&lt;GoodsType&gt; produce = getPreferredProduction();</span>
<span class="fc" id="L1303">		List&lt;WorkLocationPlan&gt; foodPlans = getFoodPlans();</span>
<span class="fc" id="L1304">		List&lt;WorkLocationPlan&gt; workPlans = getWorkPlans();</span>

		// Make a scratch colony to work on.
<span class="fc" id="L1307">		Colony col = colony.copyColony();</span>
<span class="fc" id="L1308">		Tile tile = col.getTile();</span>

		// Replace the given workers with those in the scratch colony.
<span class="fc" id="L1311">		List&lt;Unit&gt; otherWorkers = new ArrayList&lt;&gt;(workers);</span>
<span class="fc" id="L1312">		workers.clear();</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">		for (Unit u : otherWorkers)</span>
<span class="fc" id="L1314">			workers.add(col.getCorresponding(u));</span>

		// Move all workers to the tile.
		// Also remove equipment, which is safe because no missionaries
		// or active pioneers should be on the worker list.
<span class="fc bfc" id="L1319" title="All 2 branches covered.">		for (Unit u : workers) {</span>
<span class="fc" id="L1320">			u.setLocation(tile);</span>
<span class="fc" id="L1321">			col.equipForRole(u, spec().getDefaultRole(), 0);</span>
<span class="fc" id="L1322">		}</span>

		// Move outdoor experts outside if possible.
		// Prefer scouts in early game if there are very few.
<span class="fc" id="L1326">		Role[] outdoorRoles = { spec().getRoleWithAbility(Ability.IMPROVE_TERRAIN, null), null,</span>
<span class="fc" id="L1327">				spec().getRoleWithAbility(Ability.SPEAK_WITH_CHIEF, null) };</span>
<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">		if (preferScout) {</span>
<span class="fc" id="L1329">			Role tmp = outdoorRoles[1];</span>
<span class="fc" id="L1330">			outdoorRoles[1] = outdoorRoles[2];</span>
<span class="fc" id="L1331">			outdoorRoles[2] = tmp;</span>
		}
<span class="fc bfc" id="L1333" title="All 2 branches covered.">		for (Role outdoorRole : outdoorRoles) {</span>
<span class="fc bfc" id="L1334" title="All 2 branches covered.">			for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">				if (workers.size() &lt;= 1)</span>
<span class="fc" id="L1336">					break;</span>
<span class="fc" id="L1337">				Role role = outdoorRole;</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">				if (role == null) {</span>
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">					if ((role = u.getMilitaryRole()) == null)</span>
<span class="nc" id="L1340">						continue;</span>
				}
<span class="pc bpc" id="L1342" title="3 of 4 branches missed.">				if (u.getType() == role.getExpertUnit() &amp;&amp; fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1343">					workers.remove(u);</span>
<span class="nc" id="L1344">					lb.add(u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) -&gt; &quot;, role.getSuffix(), &quot;\n&quot;);</span>
				}
<span class="fc" id="L1346">			}</span>
		}

		// Consider the defence situation.
		// FIXME: scan for neighbouring hostiles
		// Favour low-skill/experience units for defenders, order experts
		// in reverse order of their production on the produce-list.
<span class="fc" id="L1353">		Comparator&lt;Unit&gt; soldierComparator = new Comparator&lt;Unit&gt;() {</span>
			@Override
			public int compare(Unit u1, Unit u2) {
<span class="fc" id="L1356">				int cmp = u1.getSkillLevel() - u2.getSkillLevel();</span>
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">				if (cmp == 0) {</span>
<span class="fc" id="L1358">					GoodsType g1 = u1.getType().getExpertProduction();</span>
<span class="fc" id="L1359">					GoodsType g2 = u2.getType().getExpertProduction();</span>
<span class="pc bpc" id="L1360" title="2 of 4 branches missed.">					cmp = ((g2 == null) ? 1 : 0) - ((g1 == null) ? 1 : 0);</span>
<span class="pc bpc" id="L1361" title="2 of 4 branches missed.">					if (cmp == 0 &amp;&amp; g1 != null) {</span>
<span class="nc" id="L1362">						int i = produce.indexOf(g2);</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">						cmp = (i &lt; 0) ? produce.size() : i;</span>
<span class="nc" id="L1364">						i = produce.indexOf(g1);</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">						cmp -= (i &lt; 0) ? produce.size() : i;</span>
					}
				}
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">				if (cmp == 0) {</span>
<span class="fc" id="L1369">					cmp = u1.getExperience() - u2.getExperience();</span>
				}
<span class="fc" id="L1371">				return cmp;</span>
			}
		};
<span class="fc" id="L1374">		Collections.sort(workers, soldierComparator);</span>
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">		for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">			if (workers.size() &lt;= 1)</span>
<span class="fc" id="L1377">				break;</span>
<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">			if (!col.isBadlyDefended())</span>
<span class="fc" id="L1379">				break;</span>
<span class="nc" id="L1380">			Role role = u.getMilitaryRole();</span>
<span class="nc bnc" id="L1381" title="All 4 branches missed.">			if (role != null &amp;&amp; fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1382">				workers.remove(u);</span>
<span class="nc" id="L1383">				lb.add(u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) -&gt; &quot;, u.getRoleSuffix(), &quot;\n&quot;);</span>
			}
<span class="nc" id="L1385">		}</span>

		// Greedy assignment of other workers to plans.
<span class="fc" id="L1388">		List&lt;AbstractGoods&gt; buildGoods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1389">		BuildableType build = col.getCurrentlyBuilding();</span>
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">		if (build != null)</span>
<span class="fc" id="L1391">			buildGoods.addAll(build.getRequiredGoods());</span>
		List&lt;WorkLocationPlan&gt; wlps;
		WorkLocationPlan wlp;
<span class="fc" id="L1394">		boolean done = false;</span>
<span class="pc bpc" id="L1395" title="1 of 4 branches missed.">		while (!workers.isEmpty() &amp;&amp; !done) {</span>
			// Decide what to produce: set the work location plan to
			// try (wlp), and the list the plan came from so it can
			// be recycled if successful (wlps).
<span class="fc" id="L1399">			wlps = null;</span>
<span class="fc" id="L1400">			wlp = null;</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">			if (col.getAdjustedNetProductionOf(foodType) &gt; 0) {</span>
				// Try to produce something.
<span class="fc" id="L1403">				wlps = workPlans;</span>
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">				while (!produce.isEmpty()) {</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">					if ((wlp = findPlan(produce.get(0), workPlans)) != null) {</span>
<span class="fc" id="L1406">						break; // Found a plan to try.</span>
					}
<span class="fc" id="L1408">					produce.remove(0); // Can not produce this goods type</span>
				}
			}

			// See if a plan can be satisfied.
			Unit best;
			WorkLocation wl;
			GoodsType goodsType;
			for (;;) {
<span class="fc bfc" id="L1417" title="All 2 branches covered.">				if (wlp == null) { // Time to use a food plan.</span>
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">					if (foodPlans.isEmpty()) {</span>
<span class="nc" id="L1419">						lb.add(&quot;    Food plans exhausted\n&quot;);</span>
<span class="nc" id="L1420">						done = true;</span>
<span class="nc" id="L1421">						break;</span>
					}
<span class="fc" id="L1423">					wlps = foodPlans;</span>
<span class="fc" id="L1424">					wlp = wlps.get(0);</span>
				}

<span class="fc" id="L1427">				String err = null;</span>
<span class="fc" id="L1428">				goodsType = wlp.getGoodsType();</span>
<span class="fc" id="L1429">				wl = col.getCorresponding(wlp.getWorkLocation());</span>
<span class="fc" id="L1430">				best = null;</span>
<span class="fc" id="L1431">				lb.add(&quot;    &quot;, LogBuilder.wide(2, col.getUnitCount()), &quot;: &quot;,</span>
<span class="fc" id="L1432">						LogBuilder.wide(-15, goodsType.getSuffix()), &quot;@&quot;, LogBuilder.wide(25, locationDescription(wl)),</span>
						&quot; =&gt; &quot;);

<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">				if (!wl.canBeWorked()) {</span>
<span class="nc" id="L1436">					err = &quot;can not be worked&quot;;</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">				} else if (wl.isFull()) {</span>
<span class="fc" id="L1438">					err = &quot;full&quot;;</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">				} else if ((best = ColonyPlan.getBestWorker(wl, goodsType, workers)) == null) {</span>
<span class="nc" id="L1440">					err = &quot;no worker found&quot;;</span>
				}
<span class="fc bfc" id="L1442" title="All 2 branches covered.">				if (err != null) {</span>
<span class="fc" id="L1443">					wlps.remove(wlp); // The plan can not be worked, dump it.</span>
<span class="fc" id="L1444">					lb.add(err, &quot;\n&quot;);</span>
<span class="fc" id="L1445">					break;</span>
				}

				// Found a suitable worker, place it.
<span class="fc" id="L1449">				best.setLocation(wl);</span>

				// Did the placement break the production bonus?
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">				if (col.getProductionBonus() &lt; 0) {</span>
<span class="nc" id="L1453">					best.setLocation(tile);</span>
<span class="nc" id="L1454">					done = true;</span>
<span class="nc" id="L1455">					lb.add(&quot;    broke production bonus\n&quot;);</span>
<span class="nc" id="L1456">					break;</span>
				}

				// Is the colony going to starve because of this placement?
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">				if (col.getAdjustedNetProductionOf(foodType) &lt; 0) {</span>
<span class="nc" id="L1461">					int net = col.getAdjustedNetProductionOf(foodType);</span>
<span class="nc" id="L1462">					int count = col.getGoodsCount(foodType);</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">					if (count / -net &lt; PRODUCTION_TURNOVER_TURNS) {</span>
						// Too close for comfort. Back out the
						// placement and try a food plan, unless this
						// was already a food plan.
<span class="nc" id="L1467">						best.setLocation(tile);</span>
<span class="nc" id="L1468">						wlp = null;</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">						if (goodsType.isFoodType()) {</span>
<span class="nc" id="L1470">							lb.add(&quot;    starvation (&quot;, count, &quot;/&quot;, net, &quot;)\n&quot;);</span>
<span class="nc" id="L1471">							done = true;</span>
<span class="nc" id="L1472">							break;</span>
						}
<span class="nc" id="L1474">						lb.add(&quot;    would starve (&quot;, count, &quot;/&quot;, net, &quot;)\n&quot;);</span>
<span class="nc" id="L1475">						continue;</span>
					}
					// Otherwise tolerate the food stock running down.
					// Rely on the warehouse-exhaustion code to fire
					// another rearrangement before units starve.
				}

				// Check if placing the worker will soon exhaust the
				// raw material. Do not reduce raw materials below
				// what is needed for a building--- e.g. prevent
				// musket production from hogging the tools.
<span class="fc" id="L1486">				GoodsType raw = goodsType.getInputType();</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">				int rawNeeded = buildGoods.stream().filter(ag -&gt; ag.getType() == raw).mapToInt(AbstractGoods::getAmount)</span>
<span class="fc" id="L1488">						.sum();</span>
<span class="fc bfc" id="L1489" title="All 4 branches covered.">				if (raw == null || col.getAdjustedNetProductionOf(raw) &gt;= 0 || (((col.getGoodsCount(raw) - rawNeeded)</span>
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">						/ -col.getAdjustedNetProductionOf(raw)) &gt;= PRODUCTION_TURNOVER_TURNS)) {</span>
					// No raw material problems, the placement
					// succeeded. Set the work type, move the
					// successful goods type to the end of the produce
					// list for later reuse, remove the worker from
					// the workers pool, but leave the successful plan
					// on its list.
<span class="fc" id="L1497">					best.changeWorkType(goodsType);</span>
<span class="fc" id="L1498">					workers.remove(best);</span>
<span class="fc" id="L1499">					lb.add(&quot;    &quot;, best.getId(), &quot;(&quot;, best.getType().getSuffix(), &quot;)\n&quot;);</span>
<span class="pc bpc" id="L1500" title="1 of 4 branches missed.">					if (!goodsType.isFoodType() &amp;&amp; produce.remove(goodsType)) {</span>
<span class="fc" id="L1501">						produce.add(goodsType);</span>
					}
					break;
				}

				// Yes, we need more of the raw material. Pull the
				// unit out again and see if we can make more.
<span class="nc" id="L1508">				best.setLocation(tile);</span>

<span class="nc" id="L1510">				WorkLocationPlan rawWlp = findPlan(raw, workPlans);</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">				if (rawWlp != null) {</span>
					// OK, we have an alternate plan. Put the raw
					// material at the start of the produce list and
					// loop trying to satisfy the alternate plan.
<span class="nc bnc" id="L1515" title="All 2 branches missed.">					if (produce.remove(raw))</span>
<span class="nc" id="L1516">						produce.add(0, raw);</span>
<span class="nc" id="L1517">					wlp = rawWlp;</span>
<span class="nc" id="L1518">					lb.add(&quot;    retry with &quot;, raw.getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1519">					continue;</span>
				}

				// No raw material available, so we have to give up on
				// both the plan and the type of production.
				// Hopefully the raw production is positive again and
				// we will succeed next time.
<span class="nc" id="L1526">				wlps.remove(wlp);</span>
<span class="nc" id="L1527">				produce.remove(goodsType);</span>
<span class="nc" id="L1528">				lb.add(&quot;    needs more &quot;, raw.getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1529">				break;</span>
			}
<span class="fc" id="L1531">		}</span>

		// Put the rest of the workers on the tile.
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">		for (Unit u : workers) {</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">			if (u.getLocation() != tile)</span>
<span class="nc" id="L1536">				u.setLocation(tile);</span>
<span class="nc" id="L1537">		}</span>

		// Check for failure to assign any workers. This happens when:
		// - there are no useful food plans
		// - in which case look for a `harmless' place and add one worker
		// - food is low, and perhaps partly eaten by horses, and no
		// unit can *improve* production by being added.
		// - find a place to produce food that at least avoids
		// starvation and add one worker.
<span class="pc bpc" id="L1546" title="1 of 2 branches missed.">		if (col.getUnitCount() == 0) {</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">			if (getFoodPlans().isEmpty()) {</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">				locations: for (WorkLocation wl : col.getAvailableWorkLocations()) {</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">					for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">						for (GoodsType type : libertyGoodsTypes) {</span>
<span class="nc bnc" id="L1551" title="All 4 branches missed.">							if (wl.canAdd(u) &amp;&amp; wl.getPotentialProduction(type, u.getType()) &gt; 0) {</span>
<span class="nc" id="L1552">								u.setLocation(wl);</span>
<span class="nc" id="L1553">								u.changeWorkType(type);</span>
<span class="nc" id="L1554">								workers.remove(u);</span>
<span class="nc" id="L1555">								break locations;</span>
							}
<span class="nc" id="L1557">						}</span>
<span class="nc" id="L1558">					}</span>
<span class="nc" id="L1559">				}</span>
			} else {
<span class="nc bnc" id="L1561" title="All 2 branches missed.">				plans: for (WorkLocationPlan w : getFoodPlans()) {</span>
<span class="nc" id="L1562">					GoodsType goodsType = w.getGoodsType();</span>
<span class="nc" id="L1563">					WorkLocation wl = col.getCorresponding(w.getWorkLocation());</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">					for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1565">						GoodsType oldWork = u.getWorkType();</span>
<span class="nc" id="L1566">						u.setLocation(wl);</span>
<span class="nc" id="L1567">						u.changeWorkType(goodsType);</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">						if (col.getAdjustedNetProductionOf(foodType) &gt;= 0) {</span>
<span class="nc" id="L1569">							lb.add(&quot;    Subsist with &quot;, u, &quot;\n&quot;);</span>
<span class="nc" id="L1570">							workers.remove(u);</span>
<span class="nc" id="L1571">							break plans;</span>
						}
<span class="nc" id="L1573">						u.setLocation(tile);</span>
<span class="nc" id="L1574">						u.changeWorkType(oldWork);</span>
<span class="nc" id="L1575">					}</span>
<span class="nc" id="L1576">				}</span>
			}
		}

		// The greedy algorithm works reasonably well, but will
		// misplace experts when they are more productive at the
		// immediately required task than a lesser unit, not knowing
		// that a requirement for their speciality will subsequently
		// follow. Do a cleanup pass to sort these out.
<span class="fc" id="L1585">		List&lt;Unit&gt; experts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1586">		List&lt;Unit&gt; nonExperts = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">		for (Unit u : col.getUnitList()) {</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">			if (u.getType().getExpertProduction() != null) {</span>
<span class="fc bfc" id="L1589" title="All 2 branches covered.">				if (u.getType().getExpertProduction() != u.getWorkType()) {</span>
<span class="fc" id="L1590">					experts.add(u);</span>
				}
			} else {
<span class="fc" id="L1593">				nonExperts.add(u);</span>
			}
<span class="fc" id="L1595">		}</span>
<span class="fc" id="L1596">		int expert = 0;</span>
<span class="fc bfc" id="L1597" title="All 2 branches covered.">		while (expert &lt; experts.size()) {</span>
<span class="fc" id="L1598">			Unit u1 = experts.get(expert);</span>
			Unit other;
<span class="pc bpc" id="L1600" title="1 of 2 branches missed.">			if ((other = trySwapExpert(u1, experts, col)) != null) {</span>
<span class="nc" id="L1601">				lb.add(&quot;    Swapped &quot;, u1.getId(), &quot;(&quot;, u1.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1602">				experts.remove(u1);</span>
<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">			} else if ((other = trySwapExpert(u1, nonExperts, col)) != null) {</span>
<span class="nc" id="L1604">				lb.add(&quot;    Swapped &quot;, u1.getId(), &quot;(&quot;, u1.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1605">				experts.remove(u1);</span>
			} else {
<span class="fc" id="L1607">				expert++;</span>
			}
<span class="fc" id="L1609">		}</span>
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">		for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1611">			GoodsType work = u.getType().getExpertProduction();</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">			if (work != null) {</span>
<span class="nc" id="L1613">				Unit other = trySwapExpert(u, col.getUnitList(), col);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">				if (other != null) {</span>
<span class="nc" id="L1615">					lb.add(&quot;    Swapped &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1616">					workers.remove(u);</span>
<span class="nc" id="L1617">					workers.add(other);</span>
				}
			}
<span class="nc" id="L1620">		}</span>

		// Rearm what remains as far as possible.
<span class="fc" id="L1623">		Collections.sort(workers, soldierComparator);</span>
<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">		for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1625">			Role role = u.getMilitaryRole();</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">			if (role == null)</span>
<span class="nc" id="L1627">				continue;</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">			if (fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1629">				lb.add(&quot;    &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) -&gt; &quot;, u.getRoleSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1630">				workers.remove(u);</span>
			} else
				break;
<span class="nc" id="L1633">		}</span>
<span class="fc bfc" id="L1634" title="All 2 branches covered.">		for (Unit u : col.getUnitList()) {</span>
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">			if (!u.hasDefaultRole()) {</span>
<span class="nc" id="L1636">				logger.warning(&quot;assignWorkers bogus role for &quot; + u);</span>
<span class="nc" id="L1637">				u.changeRole(spec().getDefaultRole(), 0);</span>
			}
<span class="fc" id="L1639">		}</span>

		// Log and return the scratch colony on success.
		// Otherwise abandon this rearrangement, disposing of the
		// scratch colony and returning null.
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">		for (Unit u : workers) {</span>
<span class="nc" id="L1645">			lb.add(&quot;    &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) -&gt; UNUSED\n&quot;);</span>
<span class="nc" id="L1646">		}</span>
<span class="pc bpc" id="L1647" title="1 of 2 branches missed.">		if (col.getUnitCount() &lt;= 0)</span>
<span class="nc" id="L1648">			col = null;</span>
<span class="fc" id="L1649">		return col;</span>
	}

	/**
	 * Gets a concise textual description of a location associated with the
	 * colony. No i18n here, this is for debugging purposes.
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; to describe.
	 * @return The text description.
	 */
	private String locationDescription(Location loc) {
<span class="fc" id="L1661">		String name = colony.getName() + &quot;-&quot;;</span>
<span class="fc" id="L1662">		String desc = loc.toShortString();</span>
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">		if (desc.startsWith(name)) {</span>
<span class="fc" id="L1664">			desc = desc.substring(name.length(), desc.length());</span>
		}
<span class="fc" id="L1666">		return desc;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="nc" id="L1674">		final Tile tile = colony.getTile();</span>
<span class="nc" id="L1675">		LogBuilder lb = new LogBuilder(256);</span>
<span class="nc" id="L1676">		lb.add(&quot;ColonyPlan: &quot;, colony, &quot; &quot;, colony.getTile(), &quot;\nProfile: &quot;, profileType, &quot;\nPreferred production:&quot;);</span>
<span class="nc" id="L1677">		FreeColObject.logFreeColObjects(getPreferredProduction(), lb);</span>
<span class="nc" id="L1678">		lb.add(getBuildableReport(), &quot;Food Plans:\n&quot;);</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">		for (WorkLocationPlan wlp : getFoodPlans()) {</span>
<span class="nc" id="L1680">			WorkLocation wl = wlp.getWorkLocation();</span>
<span class="nc" id="L1681">			lb.add(locationDescription(wl), &quot;: &quot;, wl.getGenericPotential(wlp.getGoodsType()), &quot; &quot;,</span>
<span class="nc" id="L1682">					wlp.getGoodsType().getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1683">		}</span>
<span class="nc" id="L1684">		lb.add(&quot;Work Plans:\n&quot;);</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">		for (WorkLocationPlan wlp : getWorkPlans()) {</span>
<span class="nc" id="L1686">			WorkLocation wl = wlp.getWorkLocation();</span>
<span class="nc" id="L1687">			lb.add(locationDescription(wl), &quot;: &quot;, wl.getGenericPotential(wlp.getGoodsType()), &quot; &quot;,</span>
<span class="nc" id="L1688">					wlp.getGoodsType().getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1689">		}</span>
<span class="nc" id="L1690">		return lb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>