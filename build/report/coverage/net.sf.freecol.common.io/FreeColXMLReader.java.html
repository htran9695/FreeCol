<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FreeColXMLReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.io</a> &gt; <span class="el_source">FreeColXMLReader.java</span></div><h1>FreeColXMLReader.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.io;

import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.util.StreamReaderDelegate;

import net.sf.freecol.common.model.FreeColObject;
import net.sf.freecol.common.model.FreeColGameObject;
import net.sf.freecol.common.model.FreeColGameObjectType;
import net.sf.freecol.common.model.Game;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.Role;
import net.sf.freecol.common.model.Specification;
import net.sf.freecol.server.ai.AIObject;
import net.sf.freecol.server.ai.AIMain;

/**
 * A wrapper for &lt;code&gt;XMLStreamReader&lt;/code&gt; and potentially an underlying
 * stream. Adds on many useful utilities for reading XML and FreeCol values.
 */
public class FreeColXMLReader extends StreamReaderDelegate implements Closeable {

	/** The Constant logger. */
<span class="fc" id="L59">	private static final Logger logger = Logger.getLogger(FreeColXMLReader.class.getName());</span>

	/**
	 * The Enum ReadScope.
	 */
<span class="pc" id="L64">	public static enum ReadScope {</span>

		/** The server. */
<span class="fc" id="L67">		SERVER,</span>
		/** The normal. */
		// Loading the game in the server
<span class="fc" id="L70">		NORMAL,</span>
		/** The nointern. */
		// Normal interning read
<span class="fc" id="L73">		NOINTERN, // Do not intern any object that are read</span>
	}

	/** The stream to read from. */
<span class="fc" id="L77">	private InputStream inputStream = null;</span>

	/** The read scope to apply. */
	private ReadScope readScope;

	/** A cache of uninterned objects. */
<span class="fc" id="L83">	private Map&lt;String, FreeColObject&gt; uninterned = null;</span>

	/**
	 * Creates a new &lt;code&gt;FreeColXMLReader&lt;/code&gt;.
	 *
	 * @param inputStream
	 *            The &lt;code&gt;InputStream&lt;/code&gt; to create an
	 *            &lt;code&gt;FreeColXMLReader&lt;/code&gt; for.
	 * @exception IOException
	 *                if thrown while creating the &lt;code&gt;XMLStreamReader&lt;/code&gt;.
	 */
	public FreeColXMLReader(InputStream inputStream) throws IOException {
<span class="fc" id="L95">		super();</span>

		try {
<span class="fc" id="L98">			XMLInputFactory xif = XMLInputFactory.newInstance();</span>
<span class="fc" id="L99">			setParent(xif.createXMLStreamReader(inputStream, &quot;UTF-8&quot;));</span>
<span class="nc" id="L100">		} catch (XMLStreamException e) {</span>
<span class="nc" id="L101">			throw new IOException(e);</span>
<span class="fc" id="L102">		}</span>
<span class="fc" id="L103">		this.inputStream = inputStream;</span>
<span class="fc" id="L104">		this.readScope = ReadScope.NORMAL;</span>
<span class="fc" id="L105">	}</span>

	/**
	 * Creates a new &lt;code&gt;FreeColXMLReader&lt;/code&gt;.
	 *
	 * @param reader
	 *            A &lt;code&gt;Reader&lt;/code&gt; to create an
	 *            &lt;code&gt;FreeColXMLReader&lt;/code&gt; for.
	 * @exception IOException
	 *                if thrown while creating the
	 *                &lt;code&gt;FreeColXMLReader&lt;/code&gt;.
	 */
	public FreeColXMLReader(Reader reader) throws IOException {
<span class="fc" id="L118">		super();</span>

		try {
<span class="fc" id="L121">			XMLInputFactory xif = XMLInputFactory.newInstance();</span>
<span class="fc" id="L122">			setParent(xif.createXMLStreamReader(reader));</span>
<span class="nc" id="L123">		} catch (XMLStreamException e) {</span>
<span class="nc" id="L124">			throw new IOException(e);</span>
<span class="fc" id="L125">		}</span>
<span class="fc" id="L126">		this.inputStream = null;</span>
<span class="fc" id="L127">		this.readScope = ReadScope.NORMAL;</span>
<span class="fc" id="L128">	}</span>

	/**
	 * Should reads from this stream intern their objects into the enclosing
	 * game?.
	 *
	 * @return True if this is an interning stream.
	 */
	public boolean shouldIntern() {
<span class="fc bfc" id="L137" title="All 2 branches covered.">		return this.readScope != ReadScope.NOINTERN;</span>
	}

	/**
	 * Get the read scope.
	 *
	 * @return The &lt;code&gt;ReadScope&lt;/code&gt;.
	 */
	public ReadScope getReadScope() {
<span class="fc" id="L146">		return this.readScope;</span>
	}

	/**
	 * Set the read scope.
	 *
	 * @param readScope
	 *            The new &lt;code&gt;ReadScope&lt;/code&gt;.
	 */
	public void setReadScope(ReadScope readScope) {
<span class="fc" id="L156">		this.readScope = readScope;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">		this.uninterned = (shouldIntern()) ? null : new HashMap&lt;String, FreeColObject&gt;();</span>
<span class="fc" id="L158">	}</span>

	/**
	 * Look up an identifier in an enclosing game. If not interning prefer an
	 * non-interned result.
	 *
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to consult.
	 * @param id
	 *            The object identifier.
	 * @return The &lt;code&gt;FreeColObject&lt;/code&gt; found, or null if none.
	 */
	private FreeColObject lookup(Game game, String id) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">		FreeColObject fco = (shouldIntern()) ? null : uninterned.get(id);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">		return (fco != null) ? fco : game.getFreeColGameObject(id);</span>
	}

	/**
	 * Closes both the &lt;code&gt;XMLStreamReader&lt;/code&gt; and the underlying stream if
	 * any.
	 *
	 * Implements interface Closeable.
	 */
	@Override
	public void close() {
		try {
<span class="fc" id="L184">			super.close();</span>
<span class="nc" id="L185">		} catch (XMLStreamException xse) {</span>
<span class="nc" id="L186">			logger.log(Level.WARNING, &quot;Error closing stream.&quot;, xse);</span>
<span class="fc" id="L187">		}</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (inputStream != null) {</span>
			try {
<span class="fc" id="L191">				inputStream.close();</span>
<span class="nc" id="L192">			} catch (IOException ioe) {</span>
<span class="nc" id="L193">				logger.log(Level.WARNING, &quot;Error closing stream.&quot;, ioe);</span>
<span class="fc" id="L194">			}</span>
<span class="fc" id="L195">			inputStream = null;</span>
		}
<span class="fc" id="L197">	}</span>

	// @compat 0.10.x
	/**
	 * Reads the identifier attribute.
	 *
	 * Normally a simple getAttribute() would be sufficient, but while we are
	 * allowing both the obsolete ID_ATTRIBUTE and the correct ID_ATTRIBUTE_TAG,
	 * this routine is useful.
	 *
	 * When 0.10.x is obsolete, remove this routine and replace its uses with
	 * just getAttribute(in, ID_ATTRIBUTE_TAG, (String)null) or equivalent.
	 *
	 * @return The identifier found, or null if none present.
	 */
	public String readId() {
<span class="fc" id="L213">		String id = getAttribute(FreeColObject.ID_ATTRIBUTE_TAG, (String) null);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">		if (id == null) {</span>
<span class="fc" id="L215">			id = getAttribute(FreeColObject.ID_ATTRIBUTE, (String) null);</span>
		}
<span class="fc" id="L217">		return id;</span>
	}
	// end @compat 0.10.x

	/**
	 * Is the stream at the given tag?.
	 *
	 * @param tag
	 *            The tag to test.
	 * @return True if at the given tag.
	 */
	public boolean atTag(String tag) {
<span class="nc" id="L229">		return getLocalName().equals(tag);</span>
	}

	/**
	 * Expect a particular tag.
	 *
	 * @param tag
	 *            The expected tag name.
	 * @exception XMLStreamException
	 *                if the expected tag is not found.
	 */
	public void expectTag(String tag) throws XMLStreamException {
<span class="fc" id="L241">		final String endTag = getLocalName();</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">		if (!endTag.equals(tag)) {</span>
<span class="nc" id="L243">			throw new XMLStreamException(&quot;Parse error, &quot; + tag + &quot; expected, not: &quot; + endTag);</span>
		}
<span class="fc" id="L245">	}</span>

	/**
	 * Close the current tag, checking that it did indeed close correctly.
	 *
	 * @param tag
	 *            The expected tag name.
	 * @exception XMLStreamException
	 *                if a closing tag is not found.
	 */
	public void closeTag(String tag) throws XMLStreamException {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">		if (nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="nc" id="L257">			throw new XMLStreamException(&quot;Parse error, END_ELEMENT expected,&quot; + &quot; not: &quot; + getLocalName());</span>
		}
<span class="fc" id="L259">		expectTag(tag);</span>
<span class="fc" id="L260">	}</span>

	/**
	 * Extract the current tag and its attributes from an input stream. Useful
	 * for error messages.
	 *
	 * @return A simple display of the stream state.
	 */
	public String currentTag() {
<span class="nc" id="L269">		StringBuilder sb = new StringBuilder(getLocalName());</span>
<span class="nc" id="L270">		sb.append(&quot;, attributes:&quot;);</span>
<span class="nc" id="L271">		int n = getAttributeCount();</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L273">			sb.append(&quot; &quot;).append(getAttributeLocalName(i)).append(&quot;=\&quot;&quot;).append(getAttributeValue(i)).append(&quot;\&quot;&quot;);</span>
		}
<span class="nc" id="L275">		return sb.toString();</span>
	}

	/**
	 * Is there an attribute present in the stream?.
	 *
	 * @param attributeName
	 *            An attribute name
	 * @return True if the attribute is present.
	 */
	public boolean hasAttribute(String attributeName) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">		return getParent().getAttributeValue(null, attributeName) != null;</span>
	}

	/**
	 * Gets a boolean from an attribute in a stream.
	 *
	 * @param attributeName
	 *            The attribute name.
	 * @param defaultValue
	 *            The default value.
	 * @return The boolean attribute value, or the default value if none found.
	 */
	public boolean getAttribute(String attributeName, boolean defaultValue) {
<span class="fc" id="L299">		final String attrib = getParent().getAttributeValue(null, attributeName);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">		return (attrib == null) ? defaultValue : Boolean.parseBoolean(attrib);</span>
	}

	/**
	 * Gets a float from an attribute in a stream.
	 *
	 * @param attributeName
	 *            The attribute name.
	 * @param defaultValue
	 *            The default value.
	 * @return The float attribute value, or the default value if none found.
	 */
	public float getAttribute(String attributeName, float defaultValue) {
<span class="fc" id="L313">		final String attrib = getParent().getAttributeValue(null, attributeName);</span>
<span class="fc" id="L314">		float result = defaultValue;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (attrib != null) {</span>
			try {
<span class="fc" id="L317">				result = Float.parseFloat(attrib);</span>
<span class="nc" id="L318">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L319">				logger.warning(attributeName + &quot; is not a float: &quot; + attrib);</span>
<span class="fc" id="L320">			}</span>
		}
<span class="fc" id="L322">		return result;</span>
	}

	/**
	 * Gets an int from an attribute in a stream.
	 *
	 * @param attributeName
	 *            The attribute name.
	 * @param defaultValue
	 *            The default value.
	 * @return The int attribute value, or the default value if none found.
	 */
	public int getAttribute(String attributeName, int defaultValue) {
<span class="fc" id="L335">		final String attrib = getParent().getAttributeValue(null, attributeName);</span>
<span class="fc" id="L336">		int result = defaultValue;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">		if (attrib != null) {</span>
			try {
<span class="fc" id="L339">				result = Integer.decode(attrib);</span>
<span class="nc" id="L340">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L341">				logger.warning(attributeName + &quot; is not an integer: &quot; + attrib);</span>
<span class="fc" id="L342">			}</span>
		}
<span class="fc" id="L344">		return result;</span>
	}

	/**
	 * Gets a long from an attribute in a stream.
	 *
	 * @param attributeName
	 *            The attribute name.
	 * @param defaultValue
	 *            The default value.
	 * @return The long attribute value, or the default value if none found.
	 */
	public long getAttribute(String attributeName, long defaultValue) {
<span class="nc" id="L357">		final String attrib = getParent().getAttributeValue(null, attributeName);</span>
<span class="nc" id="L358">		long result = defaultValue;</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">		if (attrib != null) {</span>
			try {
<span class="nc" id="L361">				result = Long.decode(attrib);</span>
<span class="nc" id="L362">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L363">				logger.warning(attributeName + &quot; is not a long: &quot; + attrib);</span>
<span class="nc" id="L364">			}</span>
		}
<span class="nc" id="L366">		return result;</span>
	}

	/**
	 * Gets a string from an attribute in a stream.
	 *
	 * @param attributeName
	 *            The attribute name.
	 * @param defaultValue
	 *            The default value.
	 * @return The string attribute value, or the default value if none found.
	 */
	public String getAttribute(String attributeName, String defaultValue) {
<span class="fc" id="L379">		final String attrib = getParent().getAttributeValue(null, attributeName);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">		return (attrib == null) ? defaultValue : attrib;</span>
	}

	/**
	 * Gets an enum from an attribute in a stream.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param attributeName
	 *            The attribute name.
	 * @param returnClass
	 *            The class of the return value.
	 * @param defaultValue
	 *            The default value.
	 * @return The enum attribute value, or the default value if none found.
	 */
	public &lt;T extends Enum&lt;T&gt;&gt; T getAttribute(String attributeName, Class&lt;T&gt; returnClass, T defaultValue) {
<span class="fc" id="L397">		final String attrib = getParent().getAttributeValue(null, attributeName);</span>
<span class="fc" id="L398">		T result = defaultValue;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">		if (attrib != null) {</span>
			try {
<span class="fc" id="L401">				result = Enum.valueOf(returnClass, attrib.toUpperCase(Locale.US));</span>
<span class="nc" id="L402">			} catch (Exception e) {</span>
<span class="nc" id="L403">				logger.warning(attributeName + &quot; is not a &quot; + defaultValue.getClass().getName() + &quot;: &quot; + attrib);</span>
<span class="fc" id="L404">			}</span>
		}
<span class="fc" id="L406">		return result;</span>
	}

	/**
	 * Gets a FreeCol object from an attribute in a stream.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param attributeName
	 *            The attribute name.
	 * @param returnClass
	 *            The &lt;code&gt;FreeColObject&lt;/code&gt; type to expect.
	 * @param defaultValue
	 *            The default value.
	 * @return The &lt;code&gt;FreeColObject&lt;/code&gt; found, or the default value if
	 *         not.
	 * @exception XMLStreamException
	 *                if the wrong class was passed.
	 */
	public &lt;T extends FreeColObject&gt; T getAttribute(Game game, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue) throws XMLStreamException {

<span class="fc" id="L430">		final String attrib =</span>
				// @compat 0.10.7
<span class="fc bfc" id="L432" title="All 2 branches covered.">				(FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId() :</span>
				// end @compat
<span class="fc" id="L434">						getAttribute(attributeName, (String) null);</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">		if (attrib == null)</span>
<span class="fc" id="L437">			return defaultValue;</span>
<span class="fc" id="L438">		FreeColObject fco = lookup(game, attrib);</span>
		try {
<span class="fc" id="L440">			return returnClass.cast(fco);</span>
<span class="nc" id="L441">		} catch (ClassCastException cce) {</span>
<span class="nc" id="L442">			throw new XMLStreamException(cce);</span>
		}
	}

	/**
	 * Get a FreeCol AI object from an attribute in a stream.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param aiMain
	 *            The &lt;code&gt;AIMain&lt;/code&gt; that contains the object.
	 * @param attributeName
	 *            The attribute name.
	 * @param returnClass
	 *            The &lt;code&gt;AIObject&lt;/code&gt; type to expect.
	 * @param defaultValue
	 *            The default value.
	 * @return The &lt;code&gt;AIObject&lt;/code&gt; found, or the default value if not.
	 */
	public &lt;T extends AIObject&gt; T getAttribute(AIMain aiMain, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue) {
<span class="nc" id="L463">		final String attrib =</span>
				// @compat 0.10.7
<span class="nc bnc" id="L465" title="All 2 branches missed.">				(FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId() :</span>
				// end @compat
<span class="nc" id="L467">						getAttribute(attributeName, (String) null);</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">		return (attrib == null) ? defaultValue : aiMain.getAIObject(attrib, returnClass);</span>
	}

	/**
	 * Find a new location from a stream attribute. This is necessary because
	 * &lt;code&gt;Location&lt;/code&gt; is an interface.
	 *
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param attributeName
	 *            The attribute to check.
	 * @param make
	 *            If true, try to make the location if it is not found.
	 * @return The &lt;code&gt;Location&lt;/code&gt; found.
	 * @throws XMLStreamException
	 *             the XML stream exception
	 */
	public Location getLocationAttribute(Game game, String attributeName, boolean make) throws XMLStreamException {

<span class="pc bpc" id="L488" title="1 of 2 branches missed.">		if (attributeName == null)</span>
<span class="nc" id="L489">			return null;</span>

<span class="fc" id="L491">		final String attrib =</span>
				// @compat 0.10.7
<span class="fc bfc" id="L493" title="All 2 branches covered.">				(FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId() :</span>
				// end @compat
<span class="fc" id="L495">						getAttribute(attributeName, (String) null);</span>

<span class="fc bfc" id="L497" title="All 2 branches covered.">		if (attrib != null) {</span>
<span class="fc" id="L498">			FreeColObject fco = lookup(game, attrib);</span>
<span class="pc bpc" id="L499" title="1 of 4 branches missed.">			if (fco == null &amp;&amp; make) {</span>
<span class="fc" id="L500">				Class&lt;? extends FreeColGameObject&gt; c = game.getLocationClass(attrib);</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">				if (c != null) {</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">					fco = makeFreeColGameObject(game, attributeName, c, getReadScope() == ReadScope.SERVER);</span>
				}
			}
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">			if (fco instanceof Location)</span>
<span class="fc" id="L506">				return (Location) fco;</span>
<span class="nc" id="L507">			logger.warning(&quot;Not a location: &quot; + attrib);</span>
		}
<span class="fc" id="L509">		return null;</span>
	}

	/**
	 * Reads an XML-representation of a list of some general type.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param tag
	 *            The tag for the list &lt;code&gt;Element&lt;/code&gt;.
	 * @param type
	 *            The type of the items to be added. This type needs to have a
	 *            constructor accepting a single &lt;code&gt;String&lt;/code&gt;.
	 * @return The list.
	 * @exception XMLStreamException
	 *                if a problem was encountered during parsing.
	 */
	public &lt;T&gt; List&lt;T&gt; readList(String tag, Class&lt;T&gt; type) throws XMLStreamException {

<span class="nc" id="L528">		expectTag(tag);</span>

<span class="nc" id="L530">		final int length = getAttribute(FreeColObject.ARRAY_SIZE_TAG, -1);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">		if (length &lt; 0)</span>
<span class="nc" id="L532">			return Collections.&lt;T&gt;emptyList();</span>

<span class="nc" id="L534">		List&lt;T&gt; list = new ArrayList&lt;&gt;(length);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">		for (int x = 0; x &lt; length; x++) {</span>
			try {
<span class="nc" id="L537">				final String value = getAttribute(&quot;x&quot; + x, (String) null);</span>
<span class="nc" id="L538">				T object = null;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">				if (value != null) {</span>
<span class="nc" id="L540">					Constructor&lt;T&gt; c = type.getConstructor(type);</span>
<span class="nc" id="L541">					object = c.newInstance(new Object[] { value });</span>
				}
<span class="nc" id="L543">				list.add(object);</span>
<span class="nc" id="L544">			} catch (IllegalAccessException | InstantiationException | InvocationTargetException</span>
					| NoSuchMethodException e) {
<span class="nc" id="L546">				throw new RuntimeException(e);</span>
<span class="nc" id="L547">			}</span>
		}

<span class="nc" id="L550">		closeTag(tag);</span>
<span class="nc" id="L551">		return list;</span>
	}

	/**
	 * Reads an XML-representation of a list of
	 * &lt;code&gt;FreeColGameObjectType&lt;/code&gt;s.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param spec
	 *            The &lt;code&gt;Specification&lt;/code&gt; to find items in.
	 * @param tag
	 *            The tag for the list &lt;code&gt;Element&lt;/code&gt;.
	 * @param type
	 *            The type of the items to be added. The type must exist in the
	 *            supplied specification.
	 * @return The list.
	 * @exception XMLStreamException
	 *                if a problem was encountered during parsing.
	 */
	public &lt;T extends FreeColGameObjectType&gt; List&lt;T&gt; readList(Specification spec, String tag, Class&lt;T&gt; type)
			throws XMLStreamException {

<span class="fc" id="L574">		expectTag(tag);</span>

<span class="fc" id="L576">		final int length = getAttribute(FreeColObject.ARRAY_SIZE_TAG, -1);</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">		if (length &lt; 0)</span>
<span class="nc" id="L578">			return Collections.&lt;T&gt;emptyList();</span>

<span class="fc" id="L580">		List&lt;T&gt; list = new ArrayList&lt;&gt;(length);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">		for (int x = 0; x &lt; length; x++) {</span>
<span class="nc" id="L582">			T value = getType(spec, &quot;x&quot; + x, type, (T) null);</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">			if (value == null)</span>
<span class="nc" id="L584">				logger.warning(&quot;Null list value(&quot; + x + &quot;)&quot;);</span>
<span class="nc" id="L585">			list.add(value);</span>
		}

<span class="fc" id="L588">		closeTag(tag);</span>
<span class="fc" id="L589">		return list;</span>
	}

	/**
	 * Find a &lt;code&gt;FreeColGameObject&lt;/code&gt; of a given class from a stream
	 * attribute.
	 * 
	 * Use this routine when the object is optionally already be present in the
	 * game.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;code&gt; to look in.
	 * &amp;#64;param attributeName The attribute name.
	 * &amp;#64;param returnClass The class to expect.
	 * &amp;#64;param defaultValue A default value to return if not found.
	 * &amp;#64;param required If true a null result should throw an exception.
	 * @return The &lt;code&gt;FreeColGameObject&lt;/code&gt; found, or the default value if
	 *         not found.
	 * @exception XMLStreamException
	 *                if the attribute is missing.
	 */
	public &lt;T extends FreeColGameObject&gt; T findFreeColGameObject(Game game, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue, boolean required) throws XMLStreamException {

<span class="fc" id="L615">		T ret = getAttribute(game, attributeName, returnClass, (T) null);</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">		if (ret == (T) null) {</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">			if (required) {</span>
<span class="nc" id="L618">				throw new XMLStreamException(</span>
<span class="nc" id="L619">						&quot;Missing &quot; + attributeName + &quot; for &quot; + returnClass.getName() + &quot;: &quot; + currentTag());</span>
			} else {
<span class="fc" id="L621">				ret = defaultValue;</span>
			}
		}
<span class="fc" id="L624">		return ret;</span>
	}

	/**
	 * Either get an existing &lt;code&gt;FreeColGameObject&lt;/code&gt; from a stream
	 * attribute or create it if it does not exist.
	 * 
	 * Use this routine when the object may not necessarily already be present
	 * in the game, but is expected to be defined eventually.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param attributeName
	 *            The required attribute name.
	 * @param returnClass
	 *            The class of object.
	 * @param required
	 *            If true a null result should throw an exception.
	 * @return The &lt;code&gt;FreeColGameObject&lt;/code&gt; found or made, or null if the
	 *         attribute was not present.
	 * @throws XMLStreamException
	 *             the XML stream exception
	 */
	public &lt;T extends FreeColGameObject&gt; T makeFreeColGameObject(Game game, String attributeName, Class&lt;T&gt; returnClass,
			boolean required) throws XMLStreamException {
<span class="fc" id="L651">		final String id =</span>
				// @compat 0.10.7
<span class="fc bfc" id="L653" title="All 2 branches covered.">				(FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId() :</span>
				// end @compat
<span class="fc" id="L655">						getAttribute(attributeName, (String) null);</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">		if (id == null) {</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">			if (required) {</span>
<span class="nc" id="L659">				throw new XMLStreamException(</span>
<span class="nc" id="L660">						&quot;Missing &quot; + attributeName + &quot; for &quot; + returnClass.getName() + &quot;: &quot; + currentTag());</span>
			}
		} else {
<span class="fc" id="L663">			FreeColObject fco = lookup(game, id);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">			if (fco == null) {</span>
				try {
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">					T ret = game.newInstance(returnClass, getReadScope() == ReadScope.SERVER);</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">					if (shouldIntern()) {</span>
<span class="fc" id="L668">						ret.internId(id);</span>
					} else {
<span class="nc" id="L670">						uninterned.put(id, ret);</span>
					}
<span class="fc" id="L672">					return ret;</span>
<span class="nc" id="L673">				} catch (IOException e) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">					if (required) {</span>
<span class="nc" id="L675">						throw new XMLStreamException(e);</span>
					} else {
<span class="nc" id="L677">						logger.log(Level.WARNING, &quot;Failed to create FCGO: &quot; + id, e);</span>
					}
<span class="nc" id="L679">				}</span>
			} else {
				try {
<span class="fc" id="L682">					return returnClass.cast(fco);</span>
<span class="nc" id="L683">				} catch (ClassCastException cce) {</span>
<span class="nc" id="L684">					throw new XMLStreamException(cce);</span>
				}
			}
		}
<span class="fc" id="L688">		return null;</span>
	}

	/**
	 * Do a normal interning read of a &lt;code&gt;FreeColGameObject&lt;/code&gt;.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param returnClass
	 *            The class to expect.
	 * @return The &lt;code&gt;FreeColGameObject&lt;/code&gt; found, or null there was no
	 *         ID_ATTRIBUTE_TAG present.
	 * @exception XMLStreamException
	 *                if there is problem reading the stream.
	 */
	private &lt;T extends FreeColGameObject&gt; T internedRead(Game game, Class&lt;T&gt; returnClass) throws XMLStreamException {

<span class="fc" id="L707">		T ret = makeFreeColGameObject(game, FreeColObject.ID_ATTRIBUTE_TAG, returnClass, false);</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">		if (ret != null)</span>
<span class="fc" id="L709">			ret.readFromXML(this);</span>
<span class="fc" id="L710">		return ret;</span>
	}

	/**
	 * Do a special non-interning read of a &lt;code&gt;FreeColObject&lt;/code&gt;.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param returnClass
	 *            The class to expect.
	 * @return The &lt;code&gt;FreeColObject&lt;/code&gt; found, or null there was no
	 *         ID_ATTRIBUTE_TAG present.
	 * @exception XMLStreamException
	 *                if there is problem reading the stream.
	 */
	private &lt;T extends FreeColObject&gt; T uninternedRead(Game game, Class&lt;T&gt; returnClass) throws XMLStreamException {

		T ret;
		try {
<span class="fc" id="L731">			ret = game.newInstance(returnClass, false);</span>
<span class="nc" id="L732">		} catch (IOException e) {</span>
<span class="nc" id="L733">			throw new XMLStreamException(e);</span>
<span class="fc" id="L734">		}</span>
<span class="fc" id="L735">		String id = readId();</span>
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">		if (id == null) {</span>
<span class="nc" id="L737">			throw new XMLStreamException(&quot;Object identifier not found.&quot;);</span>
		}
<span class="fc" id="L739">		uninterned.put(id, ret);</span>
<span class="fc" id="L740">		ret.readFromXML(this);</span>
<span class="fc" id="L741">		return ret;</span>
	}

	/**
	 * Reads a &lt;code&gt;FreeColGameObject&lt;/code&gt; from a stream. Expects the object
	 * to be identified by the standard ID_ATTRIBUTE_TAG.
	 * 
	 * Use this routine when the object may or may not have been referenced and
	 * created-by-id in this game, but this is the point where it is
	 * authoritatively defined.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param returnClass
	 *            The class to expect.
	 * @return The &lt;code&gt;FreeColGameObject&lt;/code&gt; found, or null there was no
	 *         ID_ATTRIBUTE_TAG present.
	 * @exception XMLStreamException
	 *                if there is problem reading the stream.
	 */
	public &lt;T extends FreeColGameObject&gt; T readFreeColGameObject(Game game, Class&lt;T&gt; returnClass)
			throws XMLStreamException {
<span class="fc bfc" id="L765" title="All 2 branches covered.">		return (shouldIntern()) ? internedRead(game, returnClass) : uninternedRead(game, returnClass);</span>
	}

	/**
	 * Find a FreeCol AI object from an attribute in a stream.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param aiMain
	 *            The &lt;code&gt;AIMain&lt;/code&gt; that contains the object.
	 * @param attributeName
	 *            The attribute name.
	 * @param returnClass
	 *            The &lt;code&gt;AIObject&lt;/code&gt; type to expect.
	 * @param defaultValue
	 *            The default value.
	 * @param required
	 *            If true a null result should throw an exception.
	 * @return The &lt;code&gt;AIObject&lt;/code&gt; found, or the default value if not.
	 * @exception XMLStreamException
	 *                if there is problem reading the stream.
	 */
	public &lt;T extends AIObject&gt; T findAIObject(AIMain aiMain, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue, boolean required) throws XMLStreamException {

<span class="nc" id="L790">		T ret = getAttribute(aiMain, attributeName, returnClass, (T) null);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">		if (ret == (T) null) {</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">			if (required) {</span>
<span class="nc" id="L793">				throw new XMLStreamException(</span>
<span class="nc" id="L794">						&quot;Missing &quot; + attributeName + &quot; for &quot; + returnClass.getName() + &quot;: &quot; + currentTag());</span>
			} else {
<span class="nc" id="L796">				ret = defaultValue;</span>
			}
		}
<span class="nc" id="L799">		return ret;</span>
	}

	/**
	 * Either get an existing &lt;code&gt;AIObject&lt;/code&gt; from a stream attribute or
	 * create it if it does not exist.
	 * 
	 * Use this routine when the object may not necessarily already be present
	 * in the game, but is expected to be defined eventually.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param aiMain
	 *            The &lt;code&gt;AIMain&lt;/code&gt; that contains the object.
	 * @param attributeName
	 *            The attribute name.
	 * @param returnClass
	 *            The &lt;code&gt;AIObject&lt;/code&gt; type to expect.
	 * @param defaultValue
	 *            The default value.
	 * @param required
	 *            the required
	 * @return The &lt;code&gt;AIObject&lt;/code&gt; found, or the default value if not.
	 * @exception XMLStreamException
	 *                if there is problem reading the stream.
	 */
	public &lt;T extends AIObject&gt; T makeAIObject(AIMain aiMain, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue, boolean required) throws XMLStreamException {

<span class="nc" id="L828">		final String id =</span>
				// @compat 0.10.7
<span class="nc bnc" id="L830" title="All 2 branches missed.">				(FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId() :</span>
				// end @compat
<span class="nc" id="L832">						getAttribute(attributeName, (String) null);</span>

<span class="nc" id="L834">		T ret = null;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">		if (id == null) {</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">			if (required) {</span>
<span class="nc" id="L837">				throw new XMLStreamException(</span>
<span class="nc" id="L838">						&quot;Missing &quot; + attributeName + &quot; for &quot; + returnClass.getName() + &quot;: &quot; + currentTag());</span>
			}
		} else {
<span class="nc" id="L841">			ret = aiMain.getAIObject(id, returnClass);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">			if (ret == null) {</span>
				try {
<span class="nc" id="L844">					Constructor&lt;T&gt; c = returnClass.getConstructor(AIMain.class, String.class);</span>
<span class="nc" id="L845">					ret = returnClass.cast(c.newInstance(aiMain, id));</span>
<span class="nc bnc" id="L846" title="All 4 branches missed.">					if (required &amp;&amp; ret == null) {</span>
<span class="nc" id="L847">						throw new XMLStreamException(</span>
<span class="nc" id="L848">								&quot;Constructed null &quot; + returnClass.getName() + &quot; for &quot; + id + &quot;: &quot; + currentTag());</span>
					}
<span class="nc" id="L850">				} catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException</span>
						| IllegalArgumentException | InvocationTargetException | XMLStreamException e) {
<span class="nc bnc" id="L852" title="All 2 branches missed.">					if (required) {</span>
<span class="nc" id="L853">						throw new XMLStreamException(e);</span>
					} else {
<span class="nc" id="L855">						logger.log(Level.WARNING, &quot;Failed to create AIObject: &quot; + id, e);</span>
					}
<span class="nc" id="L857">				}</span>
			}
		}
<span class="nc" id="L860">		return ret;</span>
	}

	/**
	 * Should the game object type being read clear its containers before
	 * reading the child elements?
	 *
	 * Usually true, but not if the type is extending another one.
	 *
	 * @return True if the containers should be cleared.
	 */
	public boolean shouldClearContainers() {
<span class="fc bfc" id="L872" title="All 4 branches covered.">		return !hasAttribute(FreeColGameObjectType.EXTENDS_TAG) &amp;&amp; !hasAttribute(FreeColGameObjectType.PRESERVE_TAG);</span>
	}

	/**
	 * Get a FreeColGameObjectType by identifier from a stream from a
	 * specification.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param spec
	 *            The &lt;code&gt;Specification&lt;/code&gt; to look in.
	 * @param attributeName
	 *            the name of the attribute identifying the
	 *            &lt;code&gt;FreeColGameObjectType&lt;/code&gt;.
	 * @param returnClass
	 *            The expected class of the return value.
	 * @param defaultValue
	 *            A default value to return if the attributeName attribute is
	 *            not present.
	 * @return The &lt;code&gt;FreeColGameObjectType&lt;/code&gt; found, or the
	 *         &lt;code&gt;defaultValue&lt;/code&gt;.
	 */
	public &lt;T extends FreeColGameObjectType&gt; T getType(Specification spec, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue) {

<span class="fc" id="L897">		final String attrib =</span>
				// @compat 0.10.7
<span class="fc bfc" id="L899" title="All 2 branches covered.">				(FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId() :</span>
				// end @compat
<span class="fc" id="L901">						getAttribute(attributeName, (String) null);</span>

<span class="fc bfc" id="L903" title="All 2 branches covered.">		return (attrib == null) ? defaultValue : spec.getType(attrib, returnClass);</span>
	}

	/**
	 * Gets the role.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param spec
	 *            the spec
	 * @param attributeName
	 *            the attribute name
	 * @param returnClass
	 *            the return class
	 * @param defaultValue
	 *            the default value
	 * @return the role
	 */
	// @compat 0.10.7
	public &lt;T extends FreeColGameObjectType&gt; T getRole(Specification spec, String attributeName, Class&lt;T&gt; returnClass,
			T defaultValue) {

<span class="pc bpc" id="L925" title="1 of 2 branches missed.">		String attrib = (FreeColObject.ID_ATTRIBUTE_TAG.equals(attributeName)) ? readId()</span>
<span class="fc" id="L926">				: getAttribute(attributeName, (String) null);</span>

<span class="pc bpc" id="L928" title="1 of 2 branches missed.">		if (attrib == null) {</span>
<span class="nc" id="L929">			return defaultValue;</span>
		}
<span class="fc" id="L931">		attrib = Role.fixRoleId(attrib);</span>
<span class="fc" id="L932">		return spec.getType(attrib, returnClass);</span>
	}
	// end @compat

	/**
	 * Copy a FreeColObject by serializing it and reading back the result with a
	 * non-interning stream.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to look in.
	 * @param returnClass
	 *            The class to expect.
	 * @return The copied &lt;code&gt;FreeColObject&lt;/code&gt; found, or null there was no
	 *         ID_ATTRIBUTE_TAG present.
	 * @exception XMLStreamException
	 *                if there is problem reading the stream.
	 */
	public &lt;T extends FreeColObject&gt; T copy(Game game, Class&lt;T&gt; returnClass) throws XMLStreamException {

<span class="fc" id="L953">		setReadScope(ReadScope.NOINTERN);</span>
<span class="fc" id="L954">		nextTag();</span>
<span class="fc" id="L955">		return uninternedRead(game, returnClass);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>