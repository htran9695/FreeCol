<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Tile.java</span></div><h1>Tile.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.Direction;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.RandomChoice;
import static net.sf.freecol.common.util.RandomUtils.*;

/**
 * Represents a single tile on the &lt;code&gt;Map&lt;/code&gt;.
 *
 * @see Map
 */
public final class Tile extends UnitLocation implements Named, Ownable {

	/** The Constant logger. */
<span class="fc" id="L53">	private static final Logger logger = Logger.getLogger(Tile.class.getName());</span>

	/** Comparator to sort tiles by increasing distance from the edge. */
<span class="fc" id="L56">	public static final Comparator&lt;Tile&gt; edgeDistanceComparator = Comparator.comparingInt(Tile::getEdgeDistance);</span>

	/**
	 * Information that is internal to the native settlements, and only updated
	 * on close contact.
	 */
<span class="fc" id="L62">	private static class IndianSettlementInternals {</span>

		/** The skill taught at the settlement. */
<span class="fc" id="L65">		public UnitType skill = null;</span>

		/** The goods the settlement is interested in. */
<span class="fc" id="L68">		public GoodsType[] wantedGoods = null;</span>

		/**
		 * Update the internal information from a native settlement.
		 *
		 * @param indianSettlement
		 *            The &lt;code&gt;IndianSettlement&lt;/code&gt; to update.
		 */
		public void update(IndianSettlement indianSettlement) {
<span class="fc" id="L77">			setValues(indianSettlement.getLearnableSkill(), indianSettlement.getWantedGoods());</span>
<span class="fc" id="L78">		}</span>

		/**
		 * Set the internal values.
		 *
		 * @param skill
		 *            The skill taught.
		 * @param wanted
		 *            The wanted goods.
		 */
		public void setValues(UnitType skill, GoodsType[] wanted) {
<span class="fc" id="L89">			this.skill = skill;</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">			if (wanted == null) {</span>
<span class="nc" id="L91">				this.wantedGoods = null;</span>
			} else {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">				if (this.wantedGoods == null) {</span>
<span class="fc" id="L94">					this.wantedGoods = new GoodsType[IndianSettlement.WANTED_GOODS_COUNT];</span>
				}
<span class="fc" id="L96">				System.arraycopy(wanted, 0, this.wantedGoods, 0, Math.min(wanted.length, this.wantedGoods.length));</span>
			}
<span class="fc" id="L98">		}</span>
	}

	/**
	 * This must be distinct from ColonyTile/Building.UNIT_CHANGE or the colony
	 * panel can get confused.
	 */
	public static final String UNIT_CHANGE = &quot;TILE_UNIT_CHANGE&quot;;

	/**
	 * Flag to assign to the high seas count to flag that the high seas
	 * connectivity needs recalculation after reading in the map.
	 */
	public static final int FLAG_RECALCULATE = Integer.MAX_VALUE;

	/**
	 * Warn about colonies that can not produce this amount of a building
	 * material.
	 */
	private static final int LOW_PRODUCTION_WARNING_VALUE = 4;

	/**
	 * The maximum distance that will still be considered &quot;near&quot; when
	 * determining the location name.
	 *
	 * @see #getLocationLabel
	 */
	public static final int NEAR_RADIUS = 8;

	/** The Constant OVERLAY_ZINDEX. */
	public static final int OVERLAY_ZINDEX = 100;

	/** The Constant FOREST_ZINDEX. */
	public static final int FOREST_ZINDEX = 200;

	/** The Constant RESOURCE_ZINDEX. */
	public static final int RESOURCE_ZINDEX = 400;

	/** The Constant RUMOUR_ZINDEX. */
	public static final int RUMOUR_ZINDEX = 500;

	/**
	 * The type of the tile. Beware: this may appear to be null in the client
	 * when the tile is unexplored.
	 */
	private TileType type;

	/** The tile coordinates in the enclosing map. */
	private int x, y;

	/** The player that consider this tile to be their land. */
	private Player owner;

	/**
	 * A pointer to the settlement located on this tile or null if there is no
	 * settlement on this tile.
	 */
	private Settlement settlement;

	/**
	 * Indicates which settlement owns this tile (null indicates no owner). A
	 * colony owns the tile it is located on, and every tile it has claimed by
	 * successfully moving a worker on to it. Note that while units and
	 * settlements are owned by a player, a tile is owned by a settlement.
	 */
	private Settlement owningSettlement;

	/** Stores all Improvements and Resources (if any). */
	private TileItemContainer tileItemContainer;

	/** The region this tile is in. */
	private Region region;

	/** The number of tiles to traverse to get to the high seas. */
<span class="fc" id="L172">	private int highSeasCount = -1;</span>

	/**
	 * Does this tile have an explicit moveToEurope state. If null, just use the
	 * defaults (usually not, unless water and on map edge), otherwise use the
	 * explicit value provided here.
	 */
	private Boolean moveToEurope;

	/** The style of this Tile, as determined by adjacent tiles. */
	private int style;

	/**
	 * An artificial contiguous-region number to identify connected parts of the
	 * map. That is, all land tiles with the same contiguity number can be
	 * reached by a land unit on any of those tiles in the absence of
	 * extra-geographic blockages like settlements and other units. Similarly
	 * for water tiles/naval units.
	 *
	 * This is used to quickly scope out the sort of paths available to a unit
	 * attempting to reach some destination. It only needs serialization from
	 * server to client, as it is set by the TerrainGenerator on map import or
	 * creation.
	 */
<span class="fc" id="L196">	private int contiguity = -1;</span>

	/** A map of cached tiles for each European player, null in clients. */
	private final java.util.Map&lt;Player, Tile&gt; cachedTiles;

	/**
	 * A map of native settlement internals for each European player, null in
	 * clients.
	 */
	private final java.util.Map&lt;Player, IndianSettlementInternals&gt; playerIndianSettlements;

	/** A comparator to sort for best defence value. */
<span class="fc" id="L208">	private final Comparator&lt;Tile&gt; defenceValueComparator = new Comparator&lt;Tile&gt;() {</span>
		public int compare(Tile t1, Tile t2) {
<span class="fc" id="L210">			double f = t2.getDefenceValue() - t1.getDefenceValue();</span>
<span class="fc bfc" id="L211" title="All 4 branches covered.">			return (f &lt; 0.0) ? -1 : (f &gt; 0.0) ? 1 : 0;</span>
		}
	};

	/**
	 * The main tile constructor.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param type
	 *            The &lt;code&gt;TileType&lt;/code&gt;.
	 * @param locX
	 *            The x-position of this tile on the map.
	 * @param locY
	 *            The y-position of this tile on the map.
	 */
	public Tile(Game game, TileType type, int locX, int locY) {
<span class="fc" id="L228">		super(game);</span>

<span class="fc" id="L230">		this.type = type;</span>
<span class="fc" id="L231">		this.x = locX;</span>
<span class="fc" id="L232">		this.y = locY;</span>
<span class="fc" id="L233">		this.owningSettlement = null;</span>
<span class="fc" id="L234">		this.settlement = null;</span>

<span class="pc bpc" id="L236" title="1 of 2 branches missed.">		if (game.isInServer()) {</span>
<span class="fc" id="L237">			this.cachedTiles = new HashMap&lt;&gt;();</span>
<span class="fc" id="L238">			this.playerIndianSettlements = new HashMap&lt;&gt;();</span>
		} else {
<span class="nc" id="L240">			this.cachedTiles = null;</span>
<span class="nc" id="L241">			this.playerIndianSettlements = null;</span>
		}
<span class="fc" id="L243">	}</span>

	/**
	 * Create a new &lt;code&gt;Tile&lt;/code&gt; with the given identifier. The object
	 * should later be initialized by calling either
	 * {@link #readFromXML(FreeColXMLReader)}.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param id
	 *            The object identifier.
	 */
	public Tile(Game game, String id) {
<span class="fc" id="L256">		super(game, id);</span>

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">		if (game.isInServer()) {</span>
<span class="fc" id="L259">			this.cachedTiles = new HashMap&lt;&gt;();</span>
<span class="fc" id="L260">			this.playerIndianSettlements = new HashMap&lt;&gt;();</span>
		} else {
<span class="nc" id="L262">			this.cachedTiles = null;</span>
<span class="nc" id="L263">			this.playerIndianSettlements = null;</span>
		}
<span class="fc" id="L265">	}</span>

	//
	// Basic accessors and mutators
	//

	/**
	 * Gets the type of this Tile.
	 *
	 * @return The &lt;code&gt;TileType&lt;/code&gt;.
	 */
	public TileType getType() {
<span class="fc" id="L277">		return type;</span>
	}

	/**
	 * Sets the type for this Tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param t
	 *            The new &lt;code&gt;TileType&lt;/code&gt; for this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public void setType(TileType t) {
<span class="fc" id="L289">		type = t;</span>
<span class="fc" id="L290">	}</span>

	/**
	 * Check if the tile has been explored.
	 *
	 * @return True if this is an explored &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean isExplored() {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">		return type != null;</span>
	}

	/**
	 * Is this a land tile?.
	 *
	 * @return True if this a land &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean isLand() {
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">		return type != null &amp;&amp; !type.isWater();</span>
	}

	/**
	 * Is this a forested tile?.
	 *
	 * @return True if this is a forested &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean isForested() {
<span class="nc bnc" id="L316" title="All 4 branches missed.">		return type != null &amp;&amp; type.isForested();</span>
	}

	/**
	 * Gets the x-coordinate of this tile.
	 *
	 * @return The x-coordinate of this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public int getX() {
<span class="fc" id="L325">		return x;</span>
	}

	/**
	 * Gets the y-coordinate of this tile.
	 *
	 * @return The y-coordinate of this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public int getY() {
<span class="fc" id="L334">		return y;</span>
	}

	/**
	 * Get the map in which this tile belongs.
	 *
	 * @return The enclosing &lt;code&gt;Map&lt;/code&gt;.
	 */
	public Map getMap() {
<span class="fc" id="L343">		return getGame().getMap();</span>
	}

	/**
	 * Gets the settlement on this tile.
	 *
	 * @return The &lt;code&gt;Settlement&lt;/code&gt; that is located on this
	 *         &lt;code&gt;Tile&lt;/code&gt;, or null if none is present.
	 * @see #setSettlement
	 */
	@Override
	public Settlement getSettlement() {
<span class="fc" id="L355">		return settlement;</span>
	}

	/**
	 * Put a settlement onto this tile. A tile can only have one settlement
	 * located on it. The settlement will also become the owner of this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param settlement
	 *            A &lt;code&gt;Settlement&lt;/code&gt; to put on this &lt;code&gt;Tile&lt;/code&gt;.
	 * @see #getSettlement
	 */
	public void setSettlement(Settlement settlement) {
<span class="fc" id="L369">		this.settlement = settlement;</span>
<span class="fc" id="L370">	}</span>

	/**
	 * Does this tile have a settlement.
	 *
	 * @return True if there is a settlement present.
	 */
	public boolean hasSettlement() {
<span class="fc bfc" id="L378" title="All 2 branches covered.">		return settlement != null;</span>
	}

	/**
	 * Gets the owning settlement for this tile.
	 *
	 * @return The &lt;code&gt;Settlement&lt;/code&gt; that owns this &lt;code&gt;Tile&lt;/code&gt;.
	 * @see #setOwner
	 */
	public Settlement getOwningSettlement() {
<span class="fc" id="L388">		return owningSettlement;</span>
	}

	/**
	 * Sets the settlement that owns this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param owner
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to own this &lt;code&gt;Tile&lt;/code&gt;.
	 * @see #getOwner
	 */
	public void setOwningSettlement(Settlement owner) {
<span class="fc" id="L401">		this.owningSettlement = owner;</span>
<span class="fc" id="L402">	}</span>

	/**
	 * Gets this tiles &lt;code&gt;TileItemContainer&lt;/code&gt;.
	 *
	 * @return The &lt;code&gt;TileItemContainer&lt;/code&gt;.
	 */
	public TileItemContainer getTileItemContainer() {
<span class="fc" id="L410">		return tileItemContainer;</span>
	}

	/**
	 * Sets the &lt;code&gt;TileItemContainer&lt;/code&gt;.
	 *
	 * @param newTileItemContainer
	 *            The new &lt;code&gt;TileItemContainer&lt;/code&gt; value.
	 */
	public void setTileItemContainer(TileItemContainer newTileItemContainer) {
<span class="fc" id="L420">		tileItemContainer = newTileItemContainer;</span>
<span class="fc" id="L421">	}</span>

	/**
	 * Get the tile region.
	 *
	 * @return The tile &lt;code&gt;Region&lt;/code&gt;.
	 */
	public Region getRegion() {
<span class="fc" id="L429">		return region;</span>
	}

	/**
	 * Set the tile region.
	 *
	 * -til: Changes appearance.
	 *
	 * @param newRegion
	 *            The new &lt;code&gt;Region&lt;/code&gt; value.
	 */
	public void setRegion(final Region newRegion) {
<span class="fc" id="L441">		this.region = newRegion;</span>
<span class="fc" id="L442">	}</span>

	/**
	 * Get the discoverable region of this tile.
	 *
	 * @return Any discoverable &lt;code&gt;Region&lt;/code&gt;.
	 */
	public Region getDiscoverableRegion() {
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">		return (region == null) ? null : region.getDiscoverableRegion();</span>
	}

	/**
	 * Gets whether this tile is connected to the high seas.
	 *
	 * @return True if this &lt;code&gt;Tile&lt;/code&gt; is connected to the high seas.
	 */
	public boolean isHighSeasConnected() {
<span class="fc bfc" id="L459" title="All 2 branches covered.">		return highSeasCount &gt;= 0;</span>
	}

	/**
	 * Gets the high seas count.
	 *
	 * @return The high seas count value.
	 */
	public int getHighSeasCount() {
<span class="fc" id="L468">		return this.highSeasCount;</span>
	}

	/**
	 * Set the high seas count.
	 *
	 * @param count
	 *            The new high seas count value.
	 */
	public void setHighSeasCount(final int count) {
<span class="fc" id="L478">		this.highSeasCount = count;</span>
<span class="fc" id="L479">	}</span>

	/**
	 * Is this a land tile on the sea coast (lakes do not count).
	 *
	 * @return True if this is a coastland tile.
	 */
	public boolean isCoastland() {
<span class="nc bnc" id="L487" title="All 4 branches missed.">		return isLand() &amp;&amp; getHighSeasCount() &gt; 0;</span>
	}

	/**
	 * Get the move-to-Europe state of the tile.
	 *
	 * @return The move-to-Europe state of the &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Boolean getMoveToEurope() {
<span class="fc" id="L496">		return moveToEurope;</span>
	}

	/**
	 * Set the move-to-Europe state of the tile.
	 *
	 * @param moveToEurope
	 *            The new move-to-Europe state for the &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public void setMoveToEurope(Boolean moveToEurope) {
<span class="fc" id="L506">		this.moveToEurope = moveToEurope;</span>
<span class="fc" id="L507">	}</span>

	/**
	 * Can a unit move to the high seas from this tile?.
	 *
	 * @return True if a unit can move to high seas from this tile.
	 */
	public boolean isDirectlyHighSeasConnected() {
<span class="pc bpc" id="L515" title="1 of 4 branches missed.">		return (moveToEurope != null) ? moveToEurope : (type == null) ? false : type.isDirectlyHighSeasConnected();</span>
	}

	/**
	 * Is this tile on a river corner?.
	 *
	 * @return True if this is a river corner.
	 */
	public boolean isRiverCorner() {
<span class="nc" id="L524">		List&lt;Tile&gt; tiles = getSurroundingTiles(0, 1).stream().filter(Tile::isOnRiver).collect(Collectors.toList());</span>
<span class="nc bnc" id="L525" title="All 4 branches missed.">		switch (tiles.size()) {</span>
		case 0:
		case 1:
<span class="nc" id="L528">			return false;</span>
		case 2:
<span class="nc" id="L530">			return tiles.get(0).isAdjacent(tiles.get(1));</span>
		case 3:
<span class="nc bnc" id="L532" title="All 4 branches missed.">			return tiles.get(0).isAdjacent(tiles.get(1)) || tiles.get(1).isAdjacent(tiles.get(2))</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">					|| tiles.get(2).isAdjacent(tiles.get(0));</span>
		default:
			break;
		}
<span class="nc" id="L537">		return true;</span>
	}

	/**
	 * Get the minimum distance in tiles from this tile to the map edge.
	 *
	 * @return The distance to the edge.
	 */
	private int getEdgeDistance() {
<span class="fc" id="L546">		final Map map = getMap();</span>
<span class="fc" id="L547">		final int x = getX(), y = getY();</span>
<span class="fc" id="L548">		return Math.min(Math.min(x, map.getWidth() - x), Math.min(y, map.getHeight() - y));</span>
	}

	/**
	 * Get the style value.
	 *
	 * @return The &lt;code&gt;Tile&lt;/code&gt; style.
	 */
	public int getStyle() {
<span class="nc" id="L557">		return style;</span>
	}

	/**
	 * Set the tile style.
	 *
	 * -til: Changes appearance.
	 *
	 * @param newStyle
	 *            The new style value.
	 */
	public void setStyle(final int newStyle) {
<span class="fc" id="L569">		this.style = newStyle;</span>
<span class="fc" id="L570">	}</span>

	/**
	 * Get the contiguity identifier for this tile.
	 *
	 * @return A contiguity number.
	 */
	public int getContiguity() {
<span class="fc" id="L578">		return contiguity;</span>
	}

	/**
	 * Sets the contiguity identifier for this tile.
	 *
	 * @param contiguity
	 *            A contiguity number.
	 */
	public void setContiguity(int contiguity) {
<span class="fc" id="L588">		this.contiguity = contiguity;</span>
<span class="fc" id="L589">	}</span>

	/**
	 * Is this tile connected to another across the same contiguous piece of
	 * land or water?.
	 *
	 * @param other
	 *            The other &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if the &lt;code&gt;Tile&lt;/code&gt;s are connected.
	 */
	public boolean isConnectedTo(Tile other) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">		return getContiguity() == other.getContiguity();</span>
	}

	/**
	 * Get the adjacent tiles that have a given contiguity.
	 *
	 * @param contiguity
	 *            The contiguity to search for.
	 * @return A set of &lt;code&gt;Tile&lt;/code&gt;s with the required contiguity.
	 */
	public Set&lt;Tile&gt; getContiguityAdjacent(int contiguity) {
<span class="fc" id="L611">		Set&lt;Tile&gt; ret = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">		for (Tile t : getSurroundingTiles(1)) {</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">			if (t.getContiguity() == contiguity)</span>
<span class="nc" id="L614">				ret.add(t);</span>
<span class="fc" id="L615">		}</span>
<span class="fc" id="L616">		return ret;</span>
	}

	/**
	 * Is this tile on or adjacent to a navigable river but not the ocean.
	 *
	 * @return True if on a navigable river.
	 */
	public boolean isOnRiver() {
<span class="fc" id="L625">		final TileType greatRiver = getSpecification().getTileType(&quot;model.tile.greatRiver&quot;);</span>
<span class="fc" id="L626">		final TileType ocean = getSpecification().getTileType(&quot;model.tile.ocean&quot;);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">		boolean ret = getType() == greatRiver;</span>
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">		for (Tile t : getSurroundingTiles(1)) {</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">			if (t.getType() == ocean)</span>
<span class="fc" id="L630">				return false;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">			ret |= t.getType() == greatRiver;</span>
<span class="nc" id="L632">		}</span>
<span class="nc" id="L633">		return ret;</span>
	}

	/**
	 * Quick test whether this tile is trivially blocked to moves from a unit.
	 * This is a simplification, use getMoveType().isProgress() for the full
	 * details.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to test.
	 * @return True if the unit can not move to this tile.
	 */
	public boolean isBlocked(Unit unit) {
<span class="nc" id="L646">		Player owner = unit.getOwner();</span>

<span class="nc" id="L648">		Unit u = getFirstUnit();</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">		if (u != null &amp;&amp; !owner.owns(u))</span>
<span class="nc" id="L650">			return true; // Blocked by unit</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">		if (isLand()) {</span>
<span class="nc" id="L653">			Settlement s = getSettlement();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">			if (unit.isNaval()) {</span>
<span class="nc bnc" id="L655" title="All 4 branches missed.">				return s == null || !owner.owns(s); // Land, not our settlement</span>
			} else {
<span class="nc bnc" id="L657" title="All 4 branches missed.">				return s != null &amp;&amp; !owner.owns(s); // Not our settlement</span>
			}
		} else {
<span class="nc bnc" id="L660" title="All 2 branches missed.">			return !unit.isNaval(); // Can not swim</span>
		}
	}

	/**
	 * Gets the &lt;code&gt;IndianSettlementInternals&lt;/code&gt; for the given player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to query.
	 * @return The &lt;code&gt;IndianSettlementInternals&lt;/code&gt; for the given player,
	 *         or null if none present.
	 */
	private IndianSettlementInternals getPlayerIndianSettlement(Player player) {
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">		return (playerIndianSettlements == null) ? null : playerIndianSettlements.get(player);</span>
	}

	//
	// Tile Item (LCR, Resource, TileImprovement) handling
	//

	/**
	 * Gets a list of &lt;code&gt;TileImprovements&lt;/code&gt;.
	 *
	 * @return A list of all the &lt;code&gt;TileImprovements&lt;/code&gt;.
	 */
	public List&lt;TileImprovement&gt; getTileImprovements() {
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">		return (tileItemContainer == null) ? Collections.&lt;TileImprovement&gt;emptyList()</span>
<span class="nc" id="L687">				: tileItemContainer.getImprovements();</span>
	}

	/**
	 * Gets a list of completed &lt;code&gt;TileImprovements&lt;/code&gt;.
	 *
	 * @return A list of all completed &lt;code&gt;TileImprovements&lt;/code&gt;.
	 */
	public List&lt;TileImprovement&gt; getCompletedTileImprovements() {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">		return (tileItemContainer == null) ? Collections.&lt;TileImprovement&gt;emptyList()</span>
<span class="fc" id="L697">				: tileItemContainer.getCompletedImprovements();</span>
	}

	/**
	 * Does this tile contain a completed improvement of the given type?.
	 *
	 * @param type
	 *            The &lt;code&gt;TileImprovementType&lt;/code&gt; to look for.
	 * @return True if there is a completed improvement present.
	 */
	public boolean hasTileImprovement(TileImprovementType type) {
<span class="pc bpc" id="L708" title="1 of 4 branches missed.">		return (type.isChangeType()) ? type.changeContainsTarget(getType())</span>
<span class="fc" id="L709">				: (tileItemContainer == null) ? false : tileItemContainer.hasImprovement(type);</span>
	}

	/**
	 * Gets the TileImprovement of a given type, or null if there is no match.
	 *
	 * @param type
	 *            The &lt;code&gt;TileImprovementType&lt;/code&gt; to look for.
	 * @return The &lt;code&gt;TileImprovement&lt;/code&gt; of the requested type found, or
	 *         null if none.
	 */
	public TileImprovement getTileImprovement(TileImprovementType type) {
<span class="fc bfc" id="L721" title="All 2 branches covered.">		return (tileItemContainer == null) ? null : tileItemContainer.getImprovement(type);</span>
	}

	/**
	 * Does this tile have a LCR?.
	 *
	 * @return True if this &lt;code&gt;Tile&lt;/code&gt; has a &lt;code&gt;LostCityRumour&lt;/code&gt;
	 *         on it.
	 */
	public boolean hasLostCityRumour() {
<span class="fc bfc" id="L731" title="All 4 branches covered.">		return tileItemContainer != null &amp;&amp; tileItemContainer.getLostCityRumour() != null;</span>
	}

	/**
	 * Gets a lost city rumour on this tile.
	 *
	 * @return The &lt;code&gt;LostCityRumour&lt;/code&gt; on this &lt;code&gt;Tile&lt;/code&gt;, or
	 *         null if none found.
	 */
	public LostCityRumour getLostCityRumour() {
<span class="nc bnc" id="L741" title="All 2 branches missed.">		return (tileItemContainer == null) ? null : tileItemContainer.getLostCityRumour();</span>
	}

	/**
	 * Does this tile have a resource?.
	 *
	 * @return True if this is a resource &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean hasResource() {
<span class="fc bfc" id="L750" title="All 4 branches covered.">		return tileItemContainer != null &amp;&amp; tileItemContainer.getResource() != null;</span>
	}

	/**
	 * Does this tile have a river?.
	 *
	 * @return True if this is a river &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean hasRiver() {
<span class="fc bfc" id="L759" title="All 4 branches covered.">		return tileItemContainer != null &amp;&amp; tileItemContainer.getRiver() != null;</span>
	}

	/**
	 * Gets the river on this tile.
	 *
	 * @return A river &lt;code&gt;TileImprovement&lt;/code&gt;, or null if none present.
	 */
	public TileImprovement getRiver() {
<span class="fc bfc" id="L768" title="All 2 branches covered.">		return (tileItemContainer == null) ? null : tileItemContainer.getRiver();</span>
	}

	/**
	 * Gets the style of a river improvement on this tile.
	 *
	 * @return The river &lt;code&gt;TileImprovementStyle&lt;/code&gt;.
	 */
	public TileImprovementStyle getRiverStyle() {
		TileImprovement river;
<span class="nc bnc" id="L778" title="All 2 branches missed.">		return (tileItemContainer == null) ? null</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">				: ((river = tileItemContainer.getRiver()) == null) ? null : river.getStyle();</span>
	}

	/**
	 * Does this tile have a road?.
	 *
	 * @return True if this &lt;code&gt;Tile&lt;/code&gt; has a road.
	 */
	public boolean hasRoad() {
<span class="fc bfc" id="L788" title="All 4 branches covered.">		return tileItemContainer != null &amp;&amp; tileItemContainer.getRoad() != null;</span>
	}

	/**
	 * Gets the road on this tile.
	 *
	 * @return A road &lt;code&gt;TileImprovement&lt;/code&gt;, or null if none present.
	 */
	public TileImprovement getRoad() {
<span class="fc bfc" id="L797" title="All 2 branches covered.">		return (tileItemContainer == null) ? null : tileItemContainer.getRoad();</span>
	}

	/**
	 * Adds a tile item to this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param item
	 *            The &lt;code&gt;TileItem&lt;/code&gt; to add.
	 * @return True if the item was added.
	 */
	private boolean addTileItem(TileItem item) {
<span class="fc bfc" id="L810" title="All 2 branches covered.">		if (item == null)</span>
<span class="fc" id="L811">			return false;</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">		if (tileItemContainer == null) {</span>
<span class="fc" id="L813">			tileItemContainer = new TileItemContainer(getGame(), this);</span>
		}
<span class="fc" id="L815">		TileItem added = tileItemContainer.addTileItem(item);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">		return added == item;</span>
	}

	/**
	 * Removes a tile item from this tile.
	 * 
	 * -til: Changes appearance.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param item
	 *            The &lt;code&gt;TileItem&lt;/code&gt; to remove.
	 * @return The item removed, or null on failure.
	 */
	private &lt;T extends TileItem&gt; T removeTileItem(T item) {
<span class="pc bpc" id="L831" title="2 of 4 branches missed.">		if (item == null || tileItemContainer == null)</span>
<span class="nc" id="L832">			return null;</span>
<span class="fc" id="L833">		return tileItemContainer.removeTileItem(item);</span>
	}

	/**
	 * Adds a lost city rumour to this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param rumour
	 *            The &lt;code&gt;LostCityRumour&lt;/code&gt; to add.
	 */
	public void addLostCityRumour(LostCityRumour rumour) {
<span class="fc" id="L845">		addTileItem(rumour);</span>
<span class="fc" id="L846">	}</span>

	/**
	 * Removes the lost city rumour from this &lt;code&gt;Tile&lt;/code&gt; if there is one.
	 *
	 * -til: Changes appearance.
	 *
	 * @return The removed &lt;code&gt;LostCityRumour&lt;/code&gt;.
	 */
	public LostCityRumour removeLostCityRumour() {
<span class="nc" id="L856">		return removeTileItem(getLostCityRumour());</span>
	}

	/**
	 * Adds a new river to this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param magnitude
	 *            The magnitude of the river to be created
	 * @param conns
	 *            The encoded river size/connections.
	 * @return The new river added, or null on failure.
	 */
	public TileImprovement addRiver(int magnitude, String conns) {
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">		if (magnitude == TileImprovement.NO_RIVER)</span>
<span class="nc" id="L872">			return null;</span>
<span class="fc" id="L873">		TileImprovementType riverType = getSpecification().getTileImprovementType(&quot;model.improvement.river&quot;);</span>
<span class="fc" id="L874">		TileImprovement river = new TileImprovement(getGame(), this, riverType);</span>
<span class="fc" id="L875">		river.setTurnsToComplete(0);</span>
<span class="fc" id="L876">		river.setMagnitude(magnitude);</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">		if (!addTileItem(river))</span>
<span class="fc" id="L878">			return null;</span>
<span class="fc" id="L879">		river.updateRiverConnections(conns);</span>
<span class="fc" id="L880">		return river;</span>
	}

	/**
	 * Removes a river from this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @return The removed river.
	 */
	public TileImprovement removeRiver() {
<span class="nc" id="L891">		TileImprovement river = getRiver();</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">		if (river == null)</span>
<span class="nc" id="L893">			return null;</span>
<span class="nc" id="L894">		TileImprovement result = removeTileItem(river);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">		if (result == river)</span>
<span class="nc" id="L896">			river.updateRiverConnections(null);</span>
<span class="nc" id="L897">		return result;</span>
	}

	/**
	 * Adds a road to this tile. It is not complete.
	 *
	 * -til: Changes appearance.
	 *
	 * @return The new road added, or the existing one.
	 */
	public TileImprovement addRoad() {
<span class="fc" id="L908">		TileImprovementType roadType = getSpecification().getTileImprovementType(&quot;model.improvement.road&quot;);</span>
<span class="fc" id="L909">		TileImprovement road = new TileImprovement(getGame(), this, roadType);</span>
<span class="fc" id="L910">		road.setMagnitude(1);</span>
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">		return (addTileItem(road)) ? road : null;</span>
	}

	/**
	 * Removes a road from this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @return The removed road.
	 */
	public TileImprovement removeRoad() {
<span class="fc" id="L922">		TileImprovement road = getRoad();</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">		if (road == null)</span>
<span class="nc" id="L924">			return null;</span>
<span class="fc" id="L925">		road.updateRoadConnections(false);</span>
<span class="fc" id="L926">		return removeTileItem(road);</span>
	}

	/**
	 * Gets the resource on this tile.
	 *
	 * @return A &lt;code&gt;Resource&lt;/code&gt;, or null if none present.
	 */
	public Resource getResource() {
<span class="nc bnc" id="L935" title="All 2 branches missed.">		return (tileItemContainer == null) ? null : tileItemContainer.getResource();</span>
	}

	/**
	 * Adds a resource to this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param resource
	 *            The &lt;code&gt;Resource&lt;/code&gt; to add.
	 */
	public void addResource(Resource resource) {
<span class="fc" id="L947">		addTileItem(resource);</span>
<span class="fc" id="L948">	}</span>

	/**
	 * Removes a resource from this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @return The removed &lt;code&gt;Resource&lt;/code&gt;.
	 */
	public Resource removeResource() {
<span class="nc" id="L958">		Resource resource = getResource();</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">		if (resource == null)</span>
<span class="nc" id="L960">			return null;</span>
<span class="nc" id="L961">		return removeTileItem(resource);</span>
	}

	/**
	 * Get the number of turns it takes for a non-expert pioneer to build the
	 * given &lt;code&gt;TileImprovementType&lt;/code&gt;. It will check if it is valid for
	 * this &lt;code&gt;TileType&lt;/code&gt;.
	 *
	 * @param workType
	 *            The &lt;code&gt;TileImprovementType&lt;/code&gt; to check.
	 * @return The number of turns it should take a non-expert pioneer to finish
	 *         the work.
	 */
	public int getWorkAmount(TileImprovementType workType) {
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">		return (workType == null) ? -1</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">				: (getTileImprovement(workType) != null) ? -1</span>
						// Return the basic work turns + additional work turns
<span class="fc" id="L978">						: getType().getBasicWorkTurns() + workType.getAddWorkTurns();</span>
	}

	/**
	 * Check if a given improvement type is valid for this tile.
	 *
	 * @param type
	 *            The &lt;code&gt;TileImprovementType&lt;/code&gt; to check.
	 * @return True if this tile can be improved with the improvement type.
	 */
	public boolean isImprovementTypeAllowed(TileImprovementType type) {
		TileImprovement ti;
<span class="pc bpc" id="L990" title="1 of 4 branches missed.">		return type != null &amp;&amp; type.isTileTypeAllowed(getType())</span>
<span class="pc bpc" id="L991" title="3 of 4 branches missed.">				&amp;&amp; ((ti = getTileImprovement(type)) == null || !ti.isComplete());</span>
	}

	/**
	 * Check if a given improvement is valid for this tile.
	 *
	 * @param tip
	 *            The &lt;code&gt;TileImprovement&lt;/code&gt; to check.
	 * @return True if this tile can be improved with the improvement.
	 */
	public boolean isImprovementAllowed(TileImprovement tip) {
<span class="nc" id="L1002">		final TileImprovementType type = tip.getType();</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">		if (!isImprovementTypeAllowed(type))</span>
<span class="nc" id="L1004">			return false;</span>
<span class="nc" id="L1005">		TileImprovementType req = type.getRequiredImprovementType();</span>
<span class="nc bnc" id="L1006" title="All 4 branches missed.">		if (req != null &amp;&amp; getTileImprovement(req) == null)</span>
<span class="nc" id="L1007">			return false;</span>
<span class="nc" id="L1008">		TileImprovement ti = getTileImprovement(type);</span>
<span class="nc bnc" id="L1009" title="All 4 branches missed.">		return ti == null || !ti.isComplete();</span>
	}

	/**
	 * Gets a weighted list of natural disasters than can strike this tile. This
	 * list comprises all natural disasters that can strike a tile of this type
	 * or a completed tile improvement present.
	 *
	 * @return A weighted list of &lt;code&gt;Disaster&lt;/code&gt;s.
	 */
	public List&lt;RandomChoice&lt;Disaster&gt;&gt; getDisasters() {
<span class="nc" id="L1020">		List&lt;RandomChoice&lt;Disaster&gt;&gt; disasters = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1021">		disasters.addAll(type.getDisasters());</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">		for (TileImprovement ti : getCompletedTileImprovements()) {</span>
<span class="nc" id="L1023">			disasters.addAll(ti.getType().getDisasters());</span>
<span class="nc" id="L1024">		}</span>
<span class="nc" id="L1025">		return disasters;</span>
	}

	//
	// Naming
	//

	/**
	 * Gets a description of the &lt;code&gt;Tile&lt;/code&gt;, with the name of the tile
	 * and any improvements on it (road/plow/etc) from
	 * &lt;code&gt;TileItemContainer&lt;/code&gt;.
	 *
	 * @return The description label for this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public StringTemplate getLabel() {
<span class="nc" id="L1040">		StringTemplate label = StringTemplate.key(type);</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">		if (tileItemContainer != null) {</span>
<span class="nc" id="L1042">			List&lt;Named&gt; keys = tileItemContainer.getTileItems().stream().filter(TileItem::isComplete)</span>
<span class="nc" id="L1043">					.collect(Collectors.toList());</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">			if (!keys.isEmpty()) {</span>
<span class="nc" id="L1045">				label = StringTemplate.label(&quot;/&quot;).addNamed(type);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">				for (Named key : keys)</span>
<span class="nc" id="L1047">					label.addNamed(key);</span>
			}
		}
<span class="nc" id="L1050">		return label;</span>
	}

	/**
	 * Get a simple label for this tile, with just its coordinates.
	 *
	 * @return A simple &lt;code&gt;StringTemplate&lt;/code&gt; label.
	 */
	public StringTemplate getSimpleLabel() {
<span class="fc" id="L1059">		return StringTemplate.template(&quot;model.tile.simpleLabel&quot;).addAmount(&quot;%x%&quot;, getX()).addAmount(&quot;%y%&quot;, getY());</span>
	}

	/**
	 * Get a detailed label for this tile.
	 *
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
	 */
	public StringTemplate getDetailedLocationLabel() {
<span class="nc" id="L1068">		Settlement nearSettlement = null;</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">		for (Tile tile : getSurroundingTiles(NEAR_RADIUS)) {</span>
<span class="nc" id="L1070">			nearSettlement = tile.getSettlement();</span>
<span class="nc bnc" id="L1071" title="All 4 branches missed.">			if (nearSettlement != null &amp;&amp; nearSettlement.getName() != null) {</span>
<span class="nc" id="L1072">				Direction d = Map.getRoughDirection(tile, this);</span>
<span class="nc" id="L1073">				StringTemplate t = StringTemplate.template(&quot;model.tile.nameLocation&quot;);</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">				if (d == null) {</span>
<span class="nc" id="L1075">					t.addName(&quot;%location%&quot;, nearSettlement.getName());</span>
				} else {
<span class="nc" id="L1077">					t.addStringTemplate(&quot;%location%&quot;, getNearLocationLabel(d, nearSettlement.getLocationLabel()));</span>
				}
<span class="nc bnc" id="L1079" title="All 2 branches missed.">				if (type == null) {</span>
<span class="nc" id="L1080">					t.add(&quot;%name%&quot;, &quot;unexplored&quot;);</span>
				} else {
<span class="nc" id="L1082">					t.addNamed(&quot;%name%&quot;, type);</span>
				}
<span class="nc" id="L1084">				return t;</span>
			}
<span class="nc" id="L1086">		}</span>
<span class="nc bnc" id="L1087" title="All 4 branches missed.">		return (region != null &amp;&amp; region.getName() != null) ? StringTemplate.template(&quot;model.tile.nameLocation&quot;)</span>
<span class="nc" id="L1088">				.addNamed(&quot;%name%&quot;, type).addNamed(&quot;%location%&quot;, region) : getSimpleLabel();</span>
	}

	/**
	 * Get a detailed label for this tile for a given player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to produce a label for.
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
	 */
	public StringTemplate getDetailedLocationLabelFor(Player player) {
<span class="fc" id="L1099">		Settlement nearSettlement = null;</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">		for (Tile tile : getSurroundingTiles(NEAR_RADIUS)) {</span>
<span class="fc" id="L1101">			nearSettlement = tile.getSettlement();</span>
<span class="fc bfc" id="L1102" title="All 4 branches covered.">			if (nearSettlement != null &amp;&amp; nearSettlement.hasContacted(player)) {</span>
<span class="fc" id="L1103">				Direction d = Map.getRoughDirection(tile, this);</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">				StringTemplate t = StringTemplate.template(&quot;model.tile.nameLocation&quot;).addStringTemplate(&quot;%location%&quot;,</span>
<span class="pc" id="L1105">						(d == null) ? nearSettlement.getLocationLabelFor(player)</span>
<span class="fc" id="L1106">								: getNearLocationLabel(d, nearSettlement.getLocationLabelFor(player)));</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">				if (type == null) {</span>
<span class="nc" id="L1108">					t.add(&quot;%name%&quot;, &quot;unexplored&quot;);</span>
				} else {
<span class="fc" id="L1110">					t.addNamed(&quot;%name%&quot;, type);</span>
				}
<span class="fc" id="L1112">				return t;</span>
			}
<span class="fc" id="L1114">		}</span>
<span class="pc bpc" id="L1115" title="2 of 4 branches missed.">		return (region != null &amp;&amp; region.getName() != null) ? StringTemplate.template(&quot;model.tile.nameLocation&quot;)</span>
<span class="pc" id="L1116">				.addNamed(&quot;%name%&quot;, type).addStringTemplate(&quot;%location%&quot;, region.getLabel()) : getSimpleLabel();</span>
	}

	/**
	 * Get a label for this tile assuming it is a colony tile of a given colony.
	 *
	 * @param colony
	 *            The &lt;code&gt;Colony&lt;/code&gt; assumed to own this tile.
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;, or null if this tile is
	 *         not close enough to the colony to be a colony tile.
	 */
	public StringTemplate getColonyTileLocationLabel(Colony colony) {
<span class="fc" id="L1128">		Tile ct = colony.getTile();</span>
<span class="fc" id="L1129">		StringTemplate t = StringTemplate.template(&quot;model.tile.nameLocation&quot;);</span>
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">		if (ct == this) {</span>
<span class="nc" id="L1131">			t.addStringTemplate(&quot;%location%&quot;, StringTemplate.key(&quot;colonyCenter&quot;));</span>
		} else {
<span class="fc" id="L1133">			Direction d = getMap().getDirection(ct, this);</span>
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">			if (d == null)</span>
<span class="nc" id="L1135">				return null;</span>
<span class="fc" id="L1136">			t.addNamed(&quot;%location%&quot;, d);</span>
		}
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">		if (type == null) {</span>
<span class="nc" id="L1139">			t.add(&quot;%name%&quot;, &quot;unexplored&quot;);</span>
		} else {
<span class="fc" id="L1141">			t.addNamed(&quot;%name%&quot;, type);</span>
		}
<span class="fc" id="L1143">		return t;</span>
	}

	//
	// Map / geographic routines
	//

	/**
	 * Gets the distance in tiles between this tile and the specified one.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check the distance to.
	 * @return The distance.
	 */
	public int getDistanceTo(Tile tile) {
<span class="fc" id="L1158">		return getMap().getDistance(this, tile);</span>
	}

	/**
	 * Gets the direction to a neighbouring tile from this one.
	 *
	 * @param tile
	 *            The other &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The direction to the other &lt;code&gt;Tile&lt;/code&gt;, or null if the
	 *         other tile is not a neighbour.
	 */
	public Direction getDirection(Tile tile) {
<span class="fc" id="L1170">		return getMap().getDirection(this, tile);</span>
	}

	/**
	 * Get the neighbouring tile in the given direction.
	 *
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; to check in.
	 * @return The neighbouring &lt;code&gt;Tile&lt;/code&gt; in the given
	 *         &lt;code&gt;Direction&lt;/code&gt;, or null if none present.
	 */
	public Tile getNeighbourOrNull(Direction direction) {
<span class="fc" id="L1182">		return getMap().getAdjacentTile(x, y, direction);</span>
	}

	/**
	 * Determines whether this tile is adjacent to the specified tile.
	 *
	 * @param tile
	 *            A potentially adjacent &lt;code&gt;Tile&lt;/code&gt;.
	 * @return True if the &lt;code&gt;Tile&lt;/code&gt; is adjacent to this
	 *         &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean isAdjacent(Tile tile) {
<span class="pc bpc" id="L1194" title="1 of 4 branches missed.">		return (tile == null) ? false : any(getSurroundingTiles(1, 1), t -&gt; t == tile);</span>
	}

	/**
	 * Is this tile in the polar regions?.
	 *
	 * @return True if the &lt;code&gt;Tile&lt;/code&gt; is polar.
	 */
	public boolean isPolar() {
<span class="fc" id="L1203">		return getMap().isPolar(this);</span>
	}

	/**
	 * Is this tile land locked?.
	 *
	 * @return True if land locked.
	 */
	public boolean isLandLocked() {
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">		return (!isLand()) ? false : all(getSurroundingTiles(1, 1), Tile::isLand);</span>
	}

	/**
	 * Is this a shoreline tile?
	 *
	 * The tile can be water or land, and the water can be ocean, river or an
	 * inland lake. If this is true for a land tile with a colony, the colony
	 * can build docks.
	 *
	 * @return True if this &lt;code&gt;Tile&lt;/code&gt; is on the shore.
	 */
	public boolean isShore() {
<span class="fc bfc" id="L1225" title="All 2 branches covered.">		return any(getSurroundingTiles(1, 1), t -&gt; t.isLand() != this.isLand());</span>
	}

	/**
	 * Gets all the tiles surrounding a tile within the given range. The center
	 * tile is not included.
	 *
	 * @param range
	 *            How far away do we need to go starting from this.
	 * @return The tiles surrounding this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Iterable&lt;Tile&gt; getSurroundingTiles(int range) {
<span class="fc" id="L1237">		return getMap().getCircleTiles(this, true, range);</span>
	}

	/**
	 * Gets all the tiles surrounding this tile within the given inclusive upper
	 * and lower bounds.
	 *
	 * getSurroundingTiles(r) is equivalent to getSurroundingTiles(1, r), thus
	 * this tile is included if rangeMin is zero.
	 *
	 * @param rangeMin
	 *            The inclusive minimum distance from this &lt;code&gt;Tile&lt;/code&gt;.
	 * @param rangeMax
	 *            The inclusive maximum distance from this &lt;code&gt;Tile&lt;/code&gt;.
	 * @return A list of the tiles surrounding this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public List&lt;Tile&gt; getSurroundingTiles(int rangeMin, int rangeMax) {
<span class="fc" id="L1254">		List&lt;Tile&gt; result = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1255" title="2 of 4 branches missed.">		if (rangeMin &gt; rangeMax || rangeMin &lt; 0)</span>
<span class="nc" id="L1256">			return result;</span>

<span class="fc bfc" id="L1258" title="All 2 branches covered.">		if (rangeMin == 0)</span>
<span class="fc" id="L1259">			result.add(this);</span>

<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">		if (rangeMax &gt; 0) {</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">			for (Tile t : getSurroundingTiles(rangeMax)) {</span>
				// add all tiles up to rangeMax
<span class="fc" id="L1264">				result.add(t);</span>
<span class="fc" id="L1265">			}</span>
		}
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">		if (rangeMin &gt; 1) {</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">			for (Tile t : getSurroundingTiles(rangeMin - 1)) {</span>
				// remove the tiles closer than rangeMin
<span class="nc" id="L1270">				result.remove(t);</span>
<span class="nc" id="L1271">			}</span>
		}
<span class="fc" id="L1273">		return result;</span>
	}

	/**
	 * Determine whether this tile has adjacent tiles that are unexplored.
	 *
	 * @return True if at least one neighbouring &lt;code&gt;Tile&lt;/code&gt;s is
	 *         unexplored.
	 */
	public boolean hasUnexploredAdjacent() {
<span class="nc bnc" id="L1283" title="All 2 branches missed.">		return any(getSurroundingTiles(1, 1), t -&gt; !t.isExplored());</span>
	}

	/**
	 * Get the number of tiles adjacent to this one that are of the same
	 * land/water type such as to be nominally accessible to a unit.
	 *
	 * @return The number of adjacent available tiles.
	 */
	public int getAvailableAdjacentCount() {
<span class="nc" id="L1293">		int n = 0;</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">		for (Tile t : getSurroundingTiles(1))</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">			if (t.isLand() == isLand())</span>
<span class="nc" id="L1296">				n++;</span>
<span class="nc" id="L1297">		return n;</span>
	}

	/**
	 * Get the adjacent colonies.
	 *
	 * @return A list of adjacent &lt;code&gt;Colony&lt;/code&gt;s.
	 */
	public List&lt;Colony&gt; getAdjacentColonies() {
<span class="fc" id="L1306">		List&lt;Colony&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1307" title="All 2 branches covered.">		for (Tile t : getSurroundingTiles(1)) {</span>
<span class="fc" id="L1308">			Colony c = t.getColony();</span>
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">			if (c != null)</span>
<span class="nc" id="L1310">				result.add(c);</span>
<span class="fc" id="L1311">		}</span>
<span class="fc" id="L1312">		return result;</span>
	}

	/**
	 * Finds the nearest settlement to this tile.
	 *
	 * @param owner
	 *            If non-null, the settlement should be owned by this player.
	 * @param radius
	 *            The maximum radius of the search.
	 * @param same
	 *            If true, require the settlement to be on the same land mass.
	 * @return The nearest settlement, or null if none.
	 */
	public Settlement getNearestSettlement(Player owner, int radius, boolean same) {
<span class="nc bnc" id="L1327" title="All 2 branches missed.">		if (radius &lt;= 0)</span>
<span class="nc" id="L1328">			radius = INFINITY;</span>
<span class="nc" id="L1329">		Map map = getGame().getMap();</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">		for (Tile t : map.getCircleTiles(this, true, radius)) {</span>
<span class="nc bnc" id="L1331" title="All 6 branches missed.">			if (t == this || (same &amp;&amp; !isConnectedTo(t)))</span>
<span class="nc" id="L1332">				continue;</span>
<span class="nc" id="L1333">			Settlement settlement = t.getSettlement();</span>
<span class="nc bnc" id="L1334" title="All 6 branches missed.">			if (settlement != null &amp;&amp; (owner == null || owner.owns(settlement))) {</span>
<span class="nc" id="L1335">				return settlement;</span>
			}
<span class="nc" id="L1337">		}</span>
<span class="nc" id="L1338">		return null;</span>
	}

	/**
	 * Finds a safe tile to put a unit on, near to this one. Useful on return
	 * from Europe.
	 *
	 * @param player
	 *            The owner of the unit to place (may be null).
	 * @param random
	 *            An optional pseudo-random number source.
	 * @return A vacant &lt;code&gt;Tile&lt;/code&gt; near this one.
	 */
	public Tile getSafeTile(Player player, Random random) {
<span class="nc bnc" id="L1352" title="All 4 branches missed.">		if ((getFirstUnit() == null || getFirstUnit().getOwner() == player)</span>
<span class="nc bnc" id="L1353" title="All 4 branches missed.">				&amp;&amp; (!hasSettlement() || getSettlement().getOwner() == player)) {</span>
<span class="nc" id="L1354">			return this;</span>
		}

<span class="nc" id="L1357">		for (int r = 1; true; r++) {</span>
<span class="nc" id="L1358">			List&lt;Tile&gt; tiles = getSurroundingTiles(r, r);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">			if (tiles.isEmpty())</span>
<span class="nc" id="L1360">				return null;</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">			if (random != null) {</span>
<span class="nc" id="L1362">				randomShuffle(logger, &quot;Safe tile&quot;, tiles, random);</span>
			}
<span class="nc bnc" id="L1364" title="All 2 branches missed.">			for (Tile t : tiles) {</span>
<span class="nc bnc" id="L1365" title="All 4 branches missed.">				if ((t.getFirstUnit() == null || t.getFirstUnit().getOwner() == player)</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">						&amp;&amp; (t.getSettlement() == null || t.getSettlement().getOwner() == player)) {</span>
<span class="nc" id="L1367">					return t;</span>
				}
<span class="nc" id="L1369">			}</span>
		}
	}

	/**
	 * Get the defence value for this tile type.
	 *
	 * @return The defence value.
	 */
	public double getDefenceValue() {
<span class="fc" id="L1379">		final TileType type = getType();</span>
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">		return (type == null) ? 0.0 : applyModifiers(1.0f, null, type.getDefenceModifiers());</span>
	}

	/**
	 * Get the defence bonus as a percent.
	 *
	 * @return The percentage defence bonus.
	 */
	public int getDefenceBonusPercentage() {
<span class="nc" id="L1389">		return (int) getType().applyModifiers(100f, getGame().getTurn(), Modifier.DEFENCE) - 100;</span>
	}

	/**
	 * Get a list of surrounding land tiles, sorted with the most defensible
	 * first. Useful when planning an attack.
	 *
	 * @param player
	 *            A &lt;code&gt;Player&lt;/code&gt; to use to check for tile access.
	 * @return A list of land &lt;code&gt;Tile&lt;/code&gt;s.
	 */
	public List&lt;Tile&gt; getSafestSurroundingLandTiles(Player player) {
<span class="fc" id="L1401">		return getSurroundingTiles(0, 1).stream()</span>
<span class="pc bpc" id="L1402" title="1 of 6 branches missed.">				.filter(t -&gt; t.isLand() &amp;&amp; (!t.hasSettlement() || player.owns(t.getSettlement())))</span>
<span class="fc" id="L1403">				.sorted(defenceValueComparator).collect(Collectors.toList());</span>
	}

	/**
	 * Get the adjacent land tile with the best defence bonus. Useful for
	 * incoming attackers as a disembark site.
	 *
	 * @param player
	 *            A &lt;code&gt;Player&lt;/code&gt; to use to check for tile access.
	 * @return The most defensible adjacent land &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Tile getBestDisembarkTile(Player player) {
<span class="fc" id="L1415">		return find(getSafestSurroundingLandTiles(player), Tile::isHighSeasConnected);</span>
	}

	/**
	 * Is this tile dangerous for a naval unit to enter? That is, is there an
	 * adjacent settlement that is likely to bombard it.
	 *
	 * @param ship
	 *            The naval &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @return True if moving the ship to this tile exposes it to attack.
	 */
	public boolean isDangerousToShip(Unit ship) {
<span class="fc" id="L1427">		final Player player = ship.getOwner();</span>
<span class="fc" id="L1428">		return any(getSurroundingTiles(0, 1).stream().filter(Tile::hasSettlement), t -&gt; {</span>
<span class="fc" id="L1429">			Settlement settlement = t.getSettlement();</span>
<span class="pc bpc" id="L1430" title="3 of 4 branches missed.">			return !player.owns(settlement) &amp;&amp; settlement.canBombardEnemyShip()</span>
<span class="pc bnc" id="L1431" title="All 4 branches missed.">					&amp;&amp; (player.atWarWith(settlement.getOwner()) || ship.hasAbility(Ability.PIRACY));</span>
		});
	}

	/**
	 * Get any safe sites for a naval transport unit to stop at to disembark a
	 * unit to this tile. To be safe, the tile must be adjacent to this one but
	 * not adjacent to a dangerous settlement.
	 *
	 * @param unit
	 *            The transport &lt;code&gt;Unit&lt;/code&gt; that needs a anchoring site.
	 * @return A list of suitable &lt;code&gt;Tile&lt;/code&gt;s.
	 */
	public List&lt;Tile&gt; getSafeAnchoringTiles(Unit unit) {
<span class="nc" id="L1445">		return getSurroundingTiles(0, 1).stream()</span>
<span class="nc bnc" id="L1446" title="All 6 branches missed.">				.filter(t -&gt; !t.isLand() &amp;&amp; t.isHighSeasConnected() &amp;&amp; !t.isDangerousToShip(unit))</span>
<span class="nc" id="L1447">				.collect(Collectors.toList());</span>
	}

	//
	// Type and Ownership
	//

	/**
	 * Changes the type of this tile. The map generator et al should just use
	 * setType(), whereas this routine should be called for the special case of
	 * a change of an existing tile type (e.g. pioneer clearing forest).
	 *
	 * -til: Changes appearance.
	 *
	 * @param type
	 *            The new &lt;code&gt;TileType&lt;/code&gt;.
	 */
	public void changeType(TileType type) {
<span class="fc" id="L1465">		setType(type);</span>

<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">		if (tileItemContainer != null) {</span>
<span class="fc" id="L1468">			tileItemContainer.removeIncompatibleImprovements();</span>
		}
<span class="fc bfc" id="L1470" title="All 2 branches covered.">		if (!isLand())</span>
<span class="fc" id="L1471">			settlement = null;</span>

<span class="fc" id="L1473">		updateColonyTiles();</span>
<span class="fc" id="L1474">	}</span>

	/**
	 * Is this tile under active use?.
	 *
	 * @return True if a &lt;code&gt;Colony&lt;/code&gt; is using this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean isInUse() {
<span class="fc bfc" id="L1482" title="All 4 branches covered.">		return getOwningSettlement() instanceof Colony &amp;&amp; ((Colony) getOwningSettlement()).isTileInUse(this);</span>
	}

	/**
	 * Changes the owning settlement for this tile.
	 *
	 * -til: Changes appearance.
	 *
	 * @param settlement
	 *            The new owning &lt;code&gt;Settlement&lt;/code&gt; for this
	 *            &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public void changeOwningSettlement(Settlement settlement) {
<span class="fc bfc" id="L1495" title="All 2 branches covered.">		if (owningSettlement != null) {</span>
<span class="fc" id="L1496">			owningSettlement.removeTile(this);</span>
		}
<span class="fc" id="L1498">		setOwningSettlement(settlement);// -til</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">		if (settlement != null) {</span>
<span class="fc" id="L1500">			settlement.addTile(this);</span>
		}
<span class="fc" id="L1502">	}</span>

	/**
	 * Change the tile ownership. Also change the owning settlement as the two
	 * are commonly related.
	 *
	 * -til: Changes appearance.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to own the tile.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to own the &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public void changeOwnership(Player player, Settlement settlement) {
<span class="fc" id="L1516">		setOwner(player);// -til</span>
<span class="fc" id="L1517">		changeOwningSettlement(settlement);// -til</span>
<span class="fc" id="L1518">	}</span>

	/**
	 * A colony is proposed to be built on this tile. Collect warnings if this
	 * has disadvantages.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; which is to build the colony.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; containing the warnings, or null if
	 *         none.
	 */
	public StringTemplate getBuildColonyWarnings(Unit unit) {
<span class="nc" id="L1530">		final Specification spec = getSpecification();</span>
<span class="nc" id="L1531">		final Player owner = unit.getOwner();</span>
<span class="nc" id="L1532">		boolean landLocked = true;</span>
<span class="nc" id="L1533">		boolean ownedByEuropeans = false;</span>
<span class="nc" id="L1534">		boolean ownedBySelf = false;</span>
<span class="nc" id="L1535">		boolean ownedByIndians = false;</span>

<span class="nc" id="L1537">		java.util.Map&lt;GoodsType, Integer&gt; goodsMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">		for (GoodsType goodsType : spec.getGoodsTypeList()) {</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">			if (goodsType.isBuildingMaterial()) {</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">				while (goodsType.isRefined()) {</span>
<span class="nc" id="L1541">					goodsType = goodsType.getInputType();</span>
				}
<span class="nc bnc" id="L1543" title="All 2 branches missed.">			} else if (!goodsType.isFoodType()) {</span>
<span class="nc" id="L1544">				continue;</span>
			}
<span class="nc bnc" id="L1546" title="All 2 branches missed.">			for (ProductionType productionType : getType().getAvailableProductionTypes(false)) {</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">				int potential = (productionType.getOutput(goodsType) == null) ? 0</span>
<span class="nc" id="L1548">						: getPotentialProduction(goodsType, null);</span>
<span class="nc" id="L1549">				Integer oldPotential = goodsMap.get(goodsType);</span>
<span class="nc bnc" id="L1550" title="All 4 branches missed.">				if (oldPotential == null || potential &gt; oldPotential) {</span>
<span class="nc" id="L1551">					goodsMap.put(goodsType, potential);</span>
				}
<span class="nc" id="L1553">			}</span>
<span class="nc" id="L1554">		}</span>

<span class="nc bnc" id="L1556" title="All 2 branches missed.">		for (Tile t : getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">			if (!t.isLand())</span>
<span class="nc" id="L1558">				landLocked = false;</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">			for (Entry&lt;GoodsType, Integer&gt; entry : goodsMap.entrySet()) {</span>
<span class="nc" id="L1560">				entry.setValue(</span>
<span class="nc" id="L1561">						entry.getValue() + t.getPotentialProduction(entry.getKey(), spec.getDefaultUnitType(owner)));</span>
<span class="nc" id="L1562">			}</span>
<span class="nc" id="L1563">			Player tileOwner = t.getOwner();</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">			if (owner == tileOwner) {</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">				if (t.getOwningSettlement() != null) {</span>
					// we are using newTile
<span class="nc" id="L1567">					ownedBySelf = true;</span>
				} else {
<span class="nc bnc" id="L1569" title="All 2 branches missed.">					for (Tile ownTile : t.getSurroundingTiles(1)) {</span>
<span class="nc" id="L1570">						Colony colony = ownTile.getColony();</span>
<span class="nc bnc" id="L1571" title="All 4 branches missed.">						if (colony != null &amp;&amp; colony.getOwner() == owner) {</span>
							// newTile can be used from an own colony
<span class="nc" id="L1573">							ownedBySelf = true;</span>
<span class="nc" id="L1574">							break;</span>
						}
<span class="nc" id="L1576">					}</span>
				}
<span class="nc bnc" id="L1578" title="All 4 branches missed.">			} else if (tileOwner != null &amp;&amp; tileOwner.isEuropean()) {</span>
<span class="nc" id="L1579">				ownedByEuropeans = true;</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">			} else if (tileOwner != null) {</span>
<span class="nc" id="L1581">				ownedByIndians = true;</span>
			}
<span class="nc" id="L1583">		}</span>

<span class="nc" id="L1585">		StringTemplate ret = StringTemplate.label(&quot;\n&quot;);</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">		if (landLocked) {</span>
<span class="nc" id="L1587">			ret.add(&quot;warning.landLocked&quot;);</span>
		}
<span class="nc" id="L1589">		int food = goodsMap.entrySet().stream().filter(e -&gt; e.getKey().isFoodType()).mapToInt(e -&gt; e.getValue()).sum();</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">		if (food &lt; 8) {</span>
<span class="nc" id="L1591">			ret.add(&quot;warning.noFood&quot;);</span>
		}
<span class="nc bnc" id="L1593" title="All 2 branches missed.">		for (Entry&lt;GoodsType, Integer&gt; entry : goodsMap.entrySet()) {</span>
<span class="nc bnc" id="L1594" title="All 4 branches missed.">			if (!entry.getKey().isFoodType() &amp;&amp; entry.getValue() &lt; LOW_PRODUCTION_WARNING_VALUE) {</span>
<span class="nc" id="L1595">				ret.addStringTemplate(</span>
<span class="nc" id="L1596">						StringTemplate.template(&quot;warning.noBuildingMaterials&quot;).addNamed(&quot;%goods%&quot;, entry.getKey()));</span>
			}
<span class="nc" id="L1598">		}</span>

<span class="nc bnc" id="L1600" title="All 2 branches missed.">		if (ownedBySelf) {</span>
<span class="nc" id="L1601">			ret.add(&quot;warning.ownLand&quot;);</span>
		}
<span class="nc bnc" id="L1603" title="All 2 branches missed.">		if (ownedByEuropeans) {</span>
<span class="nc" id="L1604">			ret.add(&quot;warning.europeanLand&quot;);</span>
		}
<span class="nc bnc" id="L1606" title="All 2 branches missed.">		if (ownedByIndians) {</span>
<span class="nc" id="L1607">			ret.add(&quot;warning.nativeLand&quot;);</span>
		}

<span class="nc" id="L1610">		return ret;</span>
	}

	//
	// Production
	//

	/**
	 * Can this tile produce a given goods type? To produce goods either the
	 * tile type must have a suitable production type, or the tile item
	 * container contains suitable resource.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt; to use.
	 * @return True if the tile can produce the goods.
	 */
	public boolean canProduce(GoodsType goodsType, UnitType unitType) {
<span class="pc bpc" id="L1629" title="1 of 6 branches missed.">		return (type != null &amp;&amp; type.canProduce(goodsType, unitType))</span>
<span class="fc bfc" id="L1630" title="All 2 branches covered.">				|| (tileItemContainer != null &amp;&amp; tileItemContainer.canProduce(goodsType, unitType));</span>
	}

	/**
	 * Get the base production exclusive of any bonuses.
	 *
	 * @param productionType
	 *            An optional &lt;code&gt;ProductionType&lt;/code&gt; to use, if null the
	 *            best available one is used.
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt; to use.
	 * @return The base production due to tile type and resources.
	 */
	public int getBaseProduction(ProductionType productionType, GoodsType goodsType, UnitType unitType) {
<span class="pc bpc" id="L1646" title="3 of 6 branches missed.">		if (type == null || goodsType == null || !goodsType.isFarmed())</span>
<span class="nc" id="L1647">			return 0;</span>
<span class="fc" id="L1648">		int amount = type.getBaseProduction(productionType, goodsType, unitType);</span>
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">		return (amount &lt; 0) ? 0 : amount;</span>
	}

	/**
	 * Get the potential production of this tile for a given goods type and
	 * optional worker type.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check the potential for.
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt; to do the work.
	 * @return The potential production of this &lt;code&gt;Tile&lt;/code&gt; to produce the
	 *         given &lt;code&gt;GoodsType&lt;/code&gt;.
	 */
	public int getPotentialProduction(GoodsType goodsType, UnitType unitType) {
<span class="fc bfc" id="L1664" title="All 2 branches covered.">		if (!canProduce(goodsType, unitType))</span>
<span class="fc" id="L1665">			return 0;</span>

<span class="fc" id="L1667">		int amount = getBaseProduction(null, goodsType, unitType);</span>
<span class="fc" id="L1668">		amount = (int) applyModifiers(amount, getGame().getTurn(), getProductionModifiers(goodsType, unitType));</span>
<span class="pc bpc" id="L1669" title="1 of 2 branches missed.">		return (amount &lt; 0) ? 0 : amount;</span>
	}

	/**
	 * Get the production modifiers for this tile.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt; to do the work.
	 * @return A list of production &lt;code&gt;Modifier&lt;/code&gt;s.
	 */
	public List&lt;Modifier&gt; getProductionModifiers(GoodsType goodsType, UnitType unitType) {
<span class="fc bfc" id="L1682" title="All 2 branches covered.">		if (!canProduce(goodsType, unitType)) {</span>
<span class="fc" id="L1683">			return Collections.&lt;Modifier&gt;emptyList();</span>
		}

<span class="fc" id="L1686">		List&lt;Modifier&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">		if (tileItemContainer != null) {</span>
<span class="fc" id="L1688">			result.addAll(tileItemContainer.getProductionModifiers(goodsType, unitType));</span>
		}
<span class="fc" id="L1690">		return result;</span>
	}

	/**
	 * Gets the maximum potential for producing the given type of goods. The
	 * maximum potential is the potential of a tile after the tile has been
	 * plowed/built road on.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @param unitType
	 *            A &lt;code&gt;UnitType&lt;/code&gt; to do the work.
	 * @return The maximum potential.
	 */
	public int getMaximumPotential(GoodsType goodsType, UnitType unitType) {
		// If we consider maximum potential to the effect of having
		// all possible improvements done, iterate through the
		// improvements and get the bonuses of all related ones. If
		// there are options to change TileType using an improvement,
		// consider that too.
<span class="fc" id="L1710">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1711">		List&lt;TileType&gt; tileTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1712">		tileTypes.add(type);</span>

		// Add to the list the various possible tile type changes
<span class="fc bfc" id="L1715" title="All 2 branches covered.">		for (TileImprovementType impType : spec.getTileImprovementTypeList()) {</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">			if (impType.getChange(type) != null) {</span>
				// There is an option to change TileType
<span class="fc" id="L1718">				tileTypes.add(impType.getChange(type));</span>
			}
<span class="fc" id="L1720">		}</span>

<span class="fc" id="L1722">		int maxProduction = 0;</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">		for (TileType tileType : tileTypes) {</span>
<span class="fc" id="L1724">			float potential = tileType.getPotentialProduction(goodsType, unitType);</span>
<span class="fc bfc" id="L1725" title="All 4 branches covered.">			if (tileType == type &amp;&amp; hasResource()) {</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">				for (TileItem item : tileItemContainer.getTileItems()) {</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">					if (item instanceof Resource) {</span>
<span class="fc" id="L1728">						potential = item.applyBonus(goodsType, unitType, (int) potential);</span>
					}
<span class="fc" id="L1730">				}</span>
			}
<span class="fc bfc" id="L1732" title="All 2 branches covered.">			for (TileImprovementType ti : spec.getTileImprovementTypeList()) {</span>
<span class="fc bfc" id="L1733" title="All 4 branches covered.">				if (ti.isNatural() || !ti.isTileTypeAllowed(tileType))</span>
<span class="fc" id="L1734">					continue;</span>
<span class="fc bfc" id="L1735" title="All 2 branches covered.">				if (ti.getBonus(goodsType) &gt; 0) {</span>
<span class="fc" id="L1736">					potential = ti.getProductionModifier(goodsType).applyTo(potential);</span>
				}
<span class="fc" id="L1738">			}</span>
<span class="fc" id="L1739">			maxProduction = Math.max((int) potential, maxProduction);</span>
<span class="fc" id="L1740">		}</span>
<span class="fc" id="L1741">		return maxProduction;</span>
	}

	/**
	 * Sort possible goods types according to potential.
	 *
	 * @return A list of goods, highest potential production first.
	 */
	public List&lt;AbstractGoods&gt; getSortedPotential() {
<span class="fc" id="L1750">		return getSortedPotential(null, null);</span>
	}

	/**
	 * Sort possible goods types according to potential.
	 *
	 * @param unit
	 *            the &lt;code&gt;Unit&lt;/code&gt; to work on this &lt;code&gt;Tile&lt;/code&gt;
	 * @return A list of goods, highest potential production first.
	 */
	public List&lt;AbstractGoods&gt; getSortedPotential(Unit unit) {
<span class="nc" id="L1761">		return getSortedPotential(unit.getType(), unit.getOwner());</span>
	}

	/**
	 * Sort possible goods types according to potential.
	 *
	 * @param unitType
	 *            The &lt;code&gt;UnitType&lt;/code&gt; to do the work.
	 * @param owner
	 *            the &lt;code&gt;Player&lt;/code&gt; owning the unit.
	 * @return A list of goods, highest potential production first.
	 */
	public List&lt;AbstractGoods&gt; getSortedPotential(UnitType unitType, Player owner) {
<span class="fc" id="L1774">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1775">		List&lt;AbstractGoods&gt; goodsTypeList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1776" title="1 of 2 branches missed.">		if (getType() != null) {</span>
			// It is necessary to consider all farmed goods, since the
			// tile might have a resource that produces goods not
			// produced by the tile type.
<span class="fc bfc" id="L1780" title="All 2 branches covered.">			for (GoodsType goodsType : spec.getFarmedGoodsTypeList()) {</span>
<span class="fc" id="L1781">				int potential = getPotentialProduction(goodsType, unitType);</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">				if (potential &gt; 0) {</span>
<span class="fc" id="L1783">					goodsTypeList.add(new AbstractGoods(goodsType, potential));</span>
				}
<span class="fc" id="L1785">			}</span>
<span class="pc bpc" id="L1786" title="3 of 4 branches missed.">			Collections.sort(goodsTypeList, (owner == null || owner.getMarket() == null)</span>
<span class="nc" id="L1787">					? AbstractGoods.abstractGoodsComparator : owner.getMarket().getSalePriceComparator());</span>
		}
<span class="fc" id="L1789">		return goodsTypeList;</span>
	}

	//
	// Colony and cached Tile maintenance
	//

	/**
	 * Update player explored tiles after a change to this tile.
	 */
	private void updateColonyTiles() {
<span class="fc bfc" id="L1800" title="All 2 branches covered.">		for (Player player : getGame().getLiveEuropeanPlayers(null)) {</span>
<span class="fc bfc" id="L1801" title="All 2 branches covered.">			for (Colony colony : player.getColonies()) {</span>
<span class="fc bfc" id="L1802" title="All 2 branches covered.">				for (ColonyTile colonyTile : colony.getColonyTiles()) {</span>
<span class="fc bfc" id="L1803" title="All 2 branches covered.">					if (colonyTile.getWorkTile() == this) {</span>
<span class="fc" id="L1804">						colonyTile.updateProductionType();</span>
					}
<span class="fc" id="L1806">				}</span>
<span class="fc" id="L1807">			}</span>
<span class="fc" id="L1808">		}</span>
<span class="fc" id="L1809">	}</span>

	/**
	 * Get a players view of this tile.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; who owns the view.
	 * @return The view of this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Tile getCachedTile(Player player) {
<span class="pc bpc" id="L1819" title="1 of 4 branches missed.">		return (cachedTiles == null) ? null : (player.isEuropean()) ? cachedTiles.get(player) : this;</span>
	}

	/**
	 * Set a players view of this tile.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; who owns the view.
	 * @param tile
	 *            The view of the &lt;code&gt;Tile&lt;/code&gt; (either this tile, or an
	 *            uninterned copy of it).
	 */
	public void setCachedTile(Player player, Tile tile) {
<span class="pc bpc" id="L1832" title="1 of 4 branches missed.">		if (cachedTiles == null || !player.isEuropean())</span>
<span class="fc" id="L1833">			return;</span>
<span class="fc" id="L1834">		cachedTiles.put(player, tile);</span>
<span class="fc" id="L1835">	}</span>

	/**
	 * Set the players view of this tile to the tile itself if the player can
	 * see it. Useful when the cache needs to be cleared forcibly such as when a
	 * native settlement is removed.
	 */
	public void seeTile() {
<span class="nc bnc" id="L1843" title="All 2 branches missed.">		for (Player p : getGame().getLiveEuropeanPlayers(null)) {</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">			if (p.canSee(this))</span>
<span class="nc" id="L1845">				seeTile(p);</span>
<span class="nc" id="L1846">		}</span>
<span class="nc" id="L1847">	}</span>

	/**
	 * Set a players view of this tile to the tile itself.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; who owns the view.
	 */
	public void seeTile(Player player) {
<span class="fc" id="L1856">		setCachedTile(player, this);</span>
<span class="fc" id="L1857">	}</span>

	/**
	 * A change is about to occur on this tile. Cache it if unseen.
	 */
	public void cacheUnseen() {
<span class="fc" id="L1863">		cacheUnseen(null, null);</span>
<span class="fc" id="L1864">	}</span>

	/**
	 * Get a copy of this tile suitable for caching (lacking units).
	 *
	 * @return An uninterned copy of this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Tile getTileToCache() {
<span class="fc" id="L1872">		Tile tile = this.copy(getGame(), Tile.class);</span>
<span class="fc" id="L1873">		tile.clearUnitList();</span>
		// Set the unit count for a copied colony
<span class="fc" id="L1875">		Colony colony = getColony();</span>
<span class="fc bfc" id="L1876" title="All 2 branches covered.">		if (colony != null) {</span>
<span class="fc" id="L1877">			tile.getColony().setDisplayUnitCount(colony.getUnitCount());</span>
		}
<span class="fc" id="L1879">		return tile;</span>
	}

	/**
	 * A change is about to occur on this tile. Cache it if unseen.
	 *
	 * @param player
	 *            A &lt;code&gt;Player&lt;/code&gt; that currently may not be able to see
	 *            the tile, but will as a result of the change, and so should
	 *            not cache it.
	 */
	public void cacheUnseen(Player player) {
<span class="fc" id="L1891">		cacheUnseen(player, null);</span>
<span class="fc" id="L1892">	}</span>

	/**
	 * A change may have occured on this tile. Establish caches where needed.
	 * Use the copied tile if supplied (which should have been created
	 * previously with {@link #getTileToCache},
	 *
	 * @param copied
	 *            An optional &lt;code&gt;Tile&lt;/code&gt; to cache.
	 */
	public void cacheUnseen(Tile copied) {
<span class="fc" id="L1903">		cacheUnseen(null, copied);</span>
<span class="fc" id="L1904">	}</span>

	/**
	 * A change may have occured on this tile. Establish caches where needed.
	 * Use the copied tile if supplied (which should have been created
	 * previously with {@link #getTileToCache},
	 *
	 * @param player
	 *            A &lt;code&gt;Player&lt;/code&gt; that currently may not be able to see
	 *            the tile, but will as a result of the change, and so should
	 *            not cache it.
	 * @param copied
	 *            An optional &lt;code&gt;Tile&lt;/code&gt; to cache.
	 */
	public void cacheUnseen(Player player, Tile copied) {
<span class="pc bpc" id="L1919" title="1 of 2 branches missed.">		if (cachedTiles == null)</span>
<span class="nc" id="L1920">			return;</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">		for (Player p : getGame().getLiveEuropeanPlayers(player)) {</span>
<span class="fc bfc" id="L1922" title="All 4 branches covered.">			if (!p.canSee(this) &amp;&amp; getCachedTile(p) == this) {</span>
<span class="pc bpc" id="L1923" title="1 of 2 branches missed.">				if (copied == null)</span>
<span class="fc" id="L1924">					copied = getTileToCache();</span>
<span class="fc" id="L1925">				setCachedTile(p, copied);</span>
			}
<span class="fc" id="L1927">		}</span>
<span class="fc" id="L1928">	}</span>

	/**
	 * Updates the information about the native settlement on this
	 * &lt;code&gt;Tile&lt;/code&gt; for the given &lt;code&gt;Player&lt;/code&gt;.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt;.
	 */
	public void updateIndianSettlement(Player player) {
<span class="pc bpc" id="L1938" title="2 of 4 branches missed.">		if (playerIndianSettlements == null || !player.isEuropean())</span>
<span class="nc" id="L1939">			return;</span>
<span class="fc" id="L1940">		IndianSettlementInternals isi = getPlayerIndianSettlement(player);</span>
<span class="fc" id="L1941">		IndianSettlement is = getIndianSettlement();</span>
<span class="pc bpc" id="L1942" title="1 of 2 branches missed.">		if (is == null) {</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">			if (isi != null)</span>
<span class="nc" id="L1944">				removeIndianSettlementInternals(player);</span>
		} else {
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">			if (isi == null) {</span>
<span class="fc" id="L1947">				isi = new IndianSettlementInternals();</span>
<span class="fc" id="L1948">				playerIndianSettlements.put(player, isi);</span>
			}
<span class="fc" id="L1950">			isi.update(is);</span>
		}
<span class="fc" id="L1952">	}</span>

	/**
	 * Removes the indian settlement internals.
	 *
	 * @param player
	 *            the player
	 */
	public void removeIndianSettlementInternals(Player player) {
<span class="nc bnc" id="L1961" title="All 2 branches missed.">		if (playerIndianSettlements == null)</span>
<span class="nc" id="L1962">			return;</span>
<span class="nc" id="L1963">		playerIndianSettlements.remove(player);</span>
<span class="nc" id="L1964">	}</span>

	/**
	 * Gets the learnable skill.
	 *
	 * @param player
	 *            the player
	 * @return the learnable skill
	 */
	public UnitType getLearnableSkill(Player player) {
<span class="nc" id="L1974">		IndianSettlementInternals isi = getPlayerIndianSettlement(player);</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">		return (isi == null) ? null : isi.skill;</span>
	}

	/**
	 * Gets the wanted goods.
	 *
	 * @param player
	 *            the player
	 * @return the wanted goods
	 */
	public GoodsType[] getWantedGoods(Player player) {
<span class="nc" id="L1986">		IndianSettlementInternals isi = getPlayerIndianSettlement(player);</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">		return (isi == null) ? null : isi.wantedGoods;</span>
	}

	/**
	 * Set native settlement information. Do not check the current map state as
	 * we might leak destruction information.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to pet belonged to.
	 * @param skill
	 *            The skill taught by the settlement.
	 * @param wanted
	 *            The goods wanted by the settlement.
	 */
	public void setIndianSettlementInternals(Player player, UnitType skill, GoodsType[] wanted) {
<span class="nc" id="L2002">		IndianSettlementInternals isi = getPlayerIndianSettlement(player);</span>
<span class="nc bnc" id="L2003" title="All 2 branches missed.">		if (isi == null) {</span>
<span class="nc" id="L2004">			isi = new IndianSettlementInternals();</span>
<span class="nc" id="L2005">			playerIndianSettlements.put(player, isi);</span>
		}
<span class="nc" id="L2007">		isi.setValues(skill, wanted);</span>
<span class="nc" id="L2008">	}</span>

	/**
	 * Checks if this &lt;code&gt;Tile&lt;/code&gt; has been explored by the given
	 * &lt;code&gt;Player&lt;/code&gt;.
	 *
	 * If we are in the server, then the presence of a cached tile determines
	 * whether exploration has happened. In the client there are no cached
	 * tiles, but if the tile is explored the server will have updated the
	 * client with the tile type (checked by isExplored()).
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt;.
	 * @return True if this &lt;code&gt;Tile&lt;/code&gt; has been explored by the given
	 *         &lt;code&gt;Player&lt;/code&gt;.
	 */
	public boolean isExploredBy(Player player) {
<span class="fc bfc" id="L2025" title="All 2 branches covered.">		return (!player.isEuropean()) ? true</span>
<span class="pc bpc" id="L2026" title="2 of 6 branches missed.">				: (!isExplored()) ? false : (cachedTiles == null) ? true : getCachedTile(player) != null;</span>
	}

	/**
	 * Explore/unexplore a tile for a player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; that is exploring.
	 * @param reveal
	 *            The exploration state.
	 */
	public void setExplored(Player player, boolean reveal) {
<span class="pc bpc" id="L2038" title="2 of 4 branches missed.">		if (cachedTiles == null || !player.isEuropean())</span>
<span class="nc" id="L2039">			return;</span>
<span class="pc bpc" id="L2040" title="1 of 2 branches missed.">		if (reveal) {</span>
<span class="fc" id="L2041">			seeTile(player);</span>
		} else {
<span class="nc" id="L2043">			cachedTiles.remove(player);</span>
		}
<span class="fc" id="L2045">	}</span>

	//
	// Unit manipulation
	//

	/**
	 * Gets the unit that is currently defending this tile.
	 * &lt;p&gt;
	 * If this tile has a settlement, the units inside the settlement are also
	 * considered as potential defenders.
	 * &lt;p&gt;
	 * As this method is quite expensive, it should not be used to test for the
	 * presence of enemy units.
	 *
	 * @param attacker
	 *            The &lt;code&gt;Unit&lt;/code&gt; that would be attacking this
	 *            &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The &lt;code&gt;Unit&lt;/code&gt; that has been chosen to defend this
	 *         &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Unit getDefendingUnit(Unit attacker) {
<span class="fc" id="L2067">		CombatModel cm = getGame().getCombatModel();</span>
<span class="fc" id="L2068">		Unit defender = null;</span>
<span class="fc" id="L2069">		double defenderPower = -1.0, power;</span>

		// Check the units on the tile...
<span class="fc bfc" id="L2072" title="All 2 branches covered.">		for (Unit u : getUnitList()) {</span>
<span class="pc bpc" id="L2073" title="1 of 2 branches missed.">			if (isLand() != u.isNaval()) {</span>
				// On land, ships are normally docked in port and
				// cannot defend. Except if beached (see below).
				// On ocean tiles, land units behave as ship cargo and
				// can not defend.
<span class="fc" id="L2078">				power = cm.getDefencePower(attacker, u);</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">				if (Unit.betterDefender(defender, defenderPower, u, power)) {</span>
<span class="fc" id="L2080">					defender = u;</span>
<span class="fc" id="L2081">					defenderPower = power;</span>
				}
			}
<span class="fc" id="L2084">		}</span>

		// ...then a settlement defender if any...
<span class="pc bpc" id="L2087" title="1 of 6 branches missed.">		if ((defender == null || !defender.isDefensiveUnit()) &amp;&amp; hasSettlement()) {</span>
<span class="fc" id="L2088">			Unit u = null;</span>
			try {
				// HACK: The AI is prone to removing all units in a
				// settlement which causes Colony.getDefendingUnit()
				// to throw.
<span class="fc" id="L2093">				u = settlement.getDefendingUnit(attacker);</span>
<span class="nc" id="L2094">			} catch (IllegalStateException e) {</span>
<span class="nc" id="L2095">				logger.log(Level.WARNING, &quot;Empty settlement: &quot; + settlement.getName(), e);</span>
<span class="fc" id="L2096">			}</span>
			// This routine can be called on the client for the pre-combat
			// popup where enemy settlement defenders are not visible,
			// thus u == null is valid.
<span class="pc bpc" id="L2100" title="1 of 2 branches missed.">			if (u != null) {</span>
<span class="fc" id="L2101">				power = cm.getDefencePower(attacker, u);</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">				if (Unit.betterDefender(defender, defenderPower, u, power)) {</span>
<span class="fc" id="L2103">					defender = u;</span>
					// defenderPower = power;
				}
			}
		}

		// ...finally, if we have failed to find a valid defender
		// for a land tile, allow a beached naval unit to defend (and
		// lose) as a last resort.
<span class="pc bpc" id="L2112" title="3 of 4 branches missed.">		if (defender == null &amp;&amp; isLand())</span>
<span class="nc" id="L2113">			defender = getFirstUnit();</span>

<span class="fc" id="L2115">		return defender;</span>
	}

	/**
	 * Gets the unit that is occupying the tile.
	 *
	 * @return The &lt;code&gt;Unit&lt;/code&gt; that is occupying this &lt;code&gt;Tile&lt;/code&gt;.
	 * @see #isOccupied()
	 */
	public Unit getOccupyingUnit() {
<span class="fc" id="L2125">		Unit unit = getFirstUnit();</span>
<span class="fc" id="L2126">		Player owner = null;</span>
<span class="fc bfc" id="L2127" title="All 2 branches covered.">		if (getOwningSettlement() != null) {</span>
<span class="fc" id="L2128">			owner = getOwningSettlement().getOwner();</span>
		}
<span class="pc bpc" id="L2130" title="5 of 8 branches missed.">		return (owner != null &amp;&amp; unit != null &amp;&amp; unit.getOwner() != owner &amp;&amp; unit.getOwner().atWarWith(owner))</span>
<span class="pc" id="L2131">				? find(getUnitList(), Unit::isOffensiveUnit) : null;</span>
	}

	/**
	 * Checks whether there is an enemy unit occupying this tile. Units can not
	 * produce in occupied tiles.
	 *
	 * @return True if an enemy unit is occupying this &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean isOccupied() {
<span class="pc bpc" id="L2141" title="1 of 2 branches missed.">		return getOccupyingUnit() != null;</span>
	}

	// Interface Location
	// getSettlement and getColony are simple accessors of Tile
	// Inherits
	// FreeColObject.getId
	// UnitLocation.getUnitCount
	// UnitLocation.getUnitList
	// UnitLocation.getGoodsContainer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Tile getTile() {
<span class="fc" id="L2157">		return this;</span>
	}

	/**
	 * Get a label for a nearby location.
	 *
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; from this tile to the nearby
	 *            location.
	 * @param location
	 *            A &lt;code&gt;StringTemplate&lt;/code&gt; describing the location.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; stating that the location is
	 *         nearby.
	 */
	public StringTemplate getNearLocationLabel(Direction direction, StringTemplate location) {
<span class="fc" id="L2172">		return StringTemplate.template(&quot;model.tile.nearLocation&quot;).addNamed(&quot;%direction%&quot;, direction)</span>
<span class="fc" id="L2173">				.addStringTemplate(&quot;%location%&quot;, location);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabel() {
<span class="nc bnc" id="L2181" title="All 2 branches missed.">		return (settlement != null) ? settlement.getLocationLabel() : getDetailedLocationLabel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabelFor(Player player) {
<span class="fc bfc" id="L2189" title="All 2 branches covered.">		return (settlement != null) ? settlement.getLocationLabelFor(player) : getDetailedLocationLabelFor(player);</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * -til: Changes appearance with TileItems.
	 */
	@Override
	public boolean add(Locatable locatable) {
<span class="fc bfc" id="L2199" title="All 2 branches covered.">		if (locatable instanceof TileItem) {</span>
<span class="fc" id="L2200">			return addTileItem((TileItem) locatable);// -til</span>

<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">		} else if (locatable instanceof Unit) {</span>
<span class="pc bpc" id="L2203" title="1 of 2 branches missed.">			if (super.add(locatable)) {</span>
<span class="fc" id="L2204">				((Unit) locatable).setState(Unit.UnitState.ACTIVE);</span>
<span class="fc" id="L2205">				return true;</span>
			}
<span class="nc" id="L2207">			return false;</span>

		} else {
<span class="nc" id="L2210">			return super.add(locatable);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 *
	 * -til: Changes appearance with TileItems.
	 */
	@Override
	public boolean remove(Locatable locatable) {
<span class="pc bpc" id="L2221" title="1 of 2 branches missed.">		if (locatable instanceof TileItem) {</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">			return removeTileItem((TileItem) locatable) == locatable;// -til</span>

		} else {
<span class="fc" id="L2225">			return super.remove(locatable);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean contains(Locatable locatable) {
<span class="pc bpc" id="L2234" title="1 of 2 branches missed.">		if (locatable instanceof TileItem) {</span>
<span class="nc bnc" id="L2235" title="All 4 branches missed.">			return tileItemContainer != null &amp;&amp; tileItemContainer.contains((TileItem) locatable);</span>
		} else {
<span class="fc" id="L2237">			return super.contains(locatable);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean canAdd(Locatable locatable) {
<span class="pc bpc" id="L2246" title="1 of 2 branches missed.">		if (locatable instanceof Unit) {</span>
<span class="fc" id="L2247">			return ((Unit) locatable).isTileAccessible(this);</span>
<span class="nc bnc" id="L2248" title="All 2 branches missed.">		} else if (locatable instanceof TileImprovement) {</span>
<span class="nc" id="L2249">			return ((TileImprovement) locatable).getType().isTileTypeAllowed(getType());</span>
		} else {
<span class="nc" id="L2251">			return false;</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location up() {
<span class="fc bfc" id="L2260" title="All 2 branches covered.">		return (hasSettlement()) ? getSettlement() : this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getRank() {
<span class="nc" id="L2268">		return getX() + getY() * getMap().getWidth();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toShortString() {
<span class="fc" id="L2276">		StringBuilder sb = new StringBuilder(16);</span>
<span class="fc" id="L2277">		TileType type = getType();</span>
<span class="pc bpc" id="L2278" title="1 of 2 branches missed.">		sb.append(getX()).append(&quot;,&quot;).append(getY()).append(&quot;-&quot;).append((type == null) ? &quot;?&quot; : type.getSuffix());</span>
<span class="fc" id="L2279">		return sb.toString();</span>
	}

	// Interface Named

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getNameKey() {
<span class="nc bnc" id="L2289" title="All 2 branches missed.">		if (getGame().isInClient()) {</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">			return (isExplored()) ? getType().getNameKey() : &quot;unexplored&quot;;</span>
		} else {
<span class="nc" id="L2292">			Player player = getGame().getCurrentPlayer();</span>
<span class="nc bnc" id="L2293" title="All 2 branches missed.">			if (player != null) {</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">				return (getCachedTile(player) == null) ? &quot;unexplored&quot; : getType().getNameKey();</span>
			} else {
<span class="nc" id="L2296">				logger.warning(&quot;player == null&quot;);</span>
<span class="nc" id="L2297">				return &quot;&quot;;</span>
			}
		}
	}

	// Interface Ownable

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Player getOwner() {
<span class="fc" id="L2309">		return owner;</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * -til: Changes appearance.
	 */
	@Override
	public void setOwner(Player owner) {
<span class="fc" id="L2319">		this.owner = owner;</span>
<span class="fc" id="L2320">	}</span>

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void disposeResources() {
<span class="nc bnc" id="L2329" title="All 2 branches missed.">		if (settlement != null) {</span>
<span class="nc" id="L2330">			settlement.disposeResources();</span>
<span class="nc" id="L2331">			settlement = null;</span>
		}
<span class="nc bnc" id="L2333" title="All 2 branches missed.">		if (tileItemContainer != null) {</span>
<span class="nc" id="L2334">			tileItemContainer.disposeResources();</span>
<span class="nc" id="L2335">			tileItemContainer = null;</span>
		}
<span class="nc" id="L2337">		super.disposeResources();</span>
<span class="nc" id="L2338">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public FreeColGameObject getLinkTarget(Player player) {
<span class="nc" id="L2345">		return this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int checkIntegrity(boolean fix) {
<span class="fc" id="L2353">		int result = super.checkIntegrity(fix);</span>
<span class="fc" id="L2354">		Settlement settlement = getSettlement();</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">		if (settlement != null) {</span>
<span class="fc" id="L2356">			result = Math.min(result, settlement.checkIntegrity(fix));</span>
		}
<span class="fc bfc" id="L2358" title="All 2 branches covered.">		if (tileItemContainer != null) {</span>
<span class="fc" id="L2359">			result = Math.min(result, tileItemContainer.checkIntegrity(fix));</span>
		}
<span class="fc" id="L2361">		return result;</span>
	}

	// Override FreeColObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Set&lt;Ability&gt; getAbilities(String id, FreeColGameObjectType fcgot, Turn turn) {
		// Delegate to type
<span class="fc" id="L2372">		return getType().getAbilities(id, fcgot, turn);</span>
	}

	// Serialization

	/** The Constant CACHED_TILE_TAG. */
	private static final String CACHED_TILE_TAG = &quot;cachedTile&quot;;

	/** The Constant CONNECTED_TAG. */
	private static final String CONNECTED_TAG = &quot;connected&quot;;

	/** The Constant CONTIGUITY_TAG. */
	private static final String CONTIGUITY_TAG = &quot;contiguity&quot;;

	/** The Constant COPIED_TAG. */
	private static final String COPIED_TAG = &quot;copied&quot;;

	/** The Constant MOVE_TO_EUROPE_TAG. */
	private static final String MOVE_TO_EUROPE_TAG = &quot;moveToEurope&quot;;

	/** The Constant OWNER_TAG. */
	private static final String OWNER_TAG = &quot;owner&quot;;

	/** The Constant OWNING_SETTLEMENT_TAG. */
	private static final String OWNING_SETTLEMENT_TAG = &quot;owningSettlement&quot;;

	/** The Constant PLAYER_TAG. */
	private static final String PLAYER_TAG = &quot;player&quot;;

	/** The Constant REGION_TAG. */
	private static final String REGION_TAG = &quot;region&quot;;

	/** The Constant STYLE_TAG. */
	private static final String STYLE_TAG = &quot;style&quot;;

	/** The Constant TYPE_TAG. */
	private static final String TYPE_TAG = &quot;type&quot;;

	/** The Constant X_TAG. */
	private static final String X_TAG = &quot;x&quot;;

	/** The Constant Y_TAG. */
	private static final String Y_TAG = &quot;y&quot;;

	/** The Constant OLD_UNITS_TAG. */
	// @compat 0.10.1
	public static final String OLD_UNITS_TAG = &quot;units&quot;;
	// end @compat
	/** The Constant OLD_TILE_ITEM_CONTAINER_TAG. */
	// @compat 0.11.3
	public static final String OLD_TILE_ITEM_CONTAINER_TAG = &quot;tileitemcontainer&quot;;
	// end @compat 0.11.3

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void toXML(FreeColXMLWriter xw, String tag) throws XMLStreamException {
		// Special override of tile output serialization that handles
		// the tile caching.
		// 1. If not writing to a player, just write this tile.
		// 2. If there is no cached tile then it is unexplored, so
		// write the minimal tile (id, x, y).
		// 3. Otherwise write the cached tile, which will either be a
		// copy or &lt;code&gt;this&lt;/code&gt;.
<span class="fc" id="L2437">		Player player = xw.getClientPlayer();</span>
<span class="fc bfc" id="L2438" title="All 2 branches covered.">		Tile tile = (player == null) ? this : getCachedTile(player);</span>

<span class="fc bfc" id="L2440" title="All 2 branches covered.">		if (tile == null) {</span>
<span class="fc" id="L2441">			xw.writeStartElement(tag);</span>

<span class="fc" id="L2443">			xw.writeAttribute(ID_ATTRIBUTE_TAG, getId());</span>

<span class="fc" id="L2445">			xw.writeAttribute(X_TAG, this.x);</span>

<span class="fc" id="L2447">			xw.writeAttribute(Y_TAG, this.y);</span>

<span class="fc" id="L2449">			xw.writeEndElement();</span>
		} else {
<span class="fc" id="L2451">			tile.internalToXML(xw, tag);</span>
		}
<span class="fc" id="L2453">	}</span>

	/**
	 * Fundamental (post-cache) version of toXML.
	 *
	 * @param xw
	 *            The &lt;code&gt;FreeColXMLWriter&lt;/code&gt; to write to.
	 * @param tag
	 *            The tag to use.
	 * @exception XMLStreamException
	 *                if there are any problems writing to the stream.
	 */
	public void internalToXML(FreeColXMLWriter xw, String tag) throws XMLStreamException {
<span class="fc" id="L2466">		xw.writeStartElement(tag);</span>

<span class="fc" id="L2468">		writeAttributes(xw);</span>

<span class="fc" id="L2470">		writeChildren(xw);</span>

<span class="fc" id="L2472">		xw.writeEndElement();</span>
<span class="fc" id="L2473">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2480">		super.writeAttributes(xw);</span>

<span class="fc" id="L2482">		xw.writeAttribute(X_TAG, this.x);</span>

<span class="fc" id="L2484">		xw.writeAttribute(Y_TAG, this.y);</span>

<span class="fc" id="L2486">		xw.writeAttribute(TYPE_TAG, type);</span>

<span class="fc bfc" id="L2488" title="All 2 branches covered.">		if (owner != null) {</span>
<span class="fc" id="L2489">			xw.writeAttribute(OWNER_TAG, owner);</span>
		}

<span class="fc bfc" id="L2492" title="All 2 branches covered.">		if (owningSettlement != null) {</span>
<span class="pc bpc" id="L2493" title="2 of 4 branches missed.">			if (owningSettlement.isDisposed() || owningSettlement.getId() == null) {</span>
				// Owning settlement is a special case because it is a
				// reference to something outside this tile. If the
				// tile being written here is a cached copy, and the
				// owning settlement referred to therein has really
				// been destroyed, then we risk corrupting or at least
				// confusing the client by referring to the disposed
				// settlement. So clear out such cases. This is an
				// information leak, but a better option than the
				// crashes caused by the alternative.
<span class="nc" id="L2503">				this.owningSettlement = null;</span>
			} else {
<span class="fc" id="L2505">				xw.writeAttribute(OWNING_SETTLEMENT_TAG, owningSettlement);</span>
			}
		}

<span class="fc" id="L2509">		xw.writeAttribute(STYLE_TAG, style);</span>

<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">		if (region != null) {</span>
<span class="fc" id="L2512">			xw.writeAttribute(REGION_TAG, region);</span>
		}

<span class="fc bfc" id="L2515" title="All 2 branches covered.">		if (moveToEurope != null) {</span>
<span class="fc" id="L2516">			xw.writeAttribute(MOVE_TO_EUROPE_TAG, moveToEurope.booleanValue());</span>
		}

<span class="fc bfc" id="L2519" title="All 2 branches covered.">		if (highSeasCount &gt;= 0) {</span>
<span class="fc" id="L2520">			xw.writeAttribute(CONNECTED_TAG, highSeasCount);</span>
		}

<span class="pc bpc" id="L2523" title="1 of 2 branches missed.">		if (contiguity &gt;= 0) {</span>
<span class="fc" id="L2524">			xw.writeAttribute(CONTIGUITY_TAG, contiguity);</span>
		}
<span class="fc" id="L2526">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
		// Show tile contents (e.g. enemy units) if not scoped to a
		// player that can not see the tile, and there is no blocking
		// enemy settlement.
<span class="fc" id="L2536">		Player player = xw.getClientPlayer();</span>
<span class="fc bfc" id="L2537" title="All 8 branches covered.">		if ((player == null || player.canSee(this)) &amp;&amp; (settlement == null || xw.validFor(settlement.getOwner()))) {</span>
<span class="fc" id="L2538">			super.writeChildren(xw);</span>
		}

<span class="fc bfc" id="L2541" title="All 2 branches covered.">		if (settlement != null)</span>
<span class="fc" id="L2542">			settlement.toXML(xw);</span>

<span class="fc bfc" id="L2544" title="All 2 branches covered.">		if (tileItemContainer != null)</span>
<span class="fc" id="L2545">			tileItemContainer.toXML(xw);</span>

		// Save the cached tiles to saved games.
<span class="pc bpc" id="L2548" title="1 of 4 branches missed.">		if (xw.validForSave() &amp;&amp; cachedTiles != null) {</span>
<span class="fc bfc" id="L2549" title="All 2 branches covered.">			for (Player p : getGame().getLiveEuropeanPlayers(null)) {</span>
<span class="fc" id="L2550">				Tile t = getCachedTile(p);</span>
<span class="fc bfc" id="L2551" title="All 2 branches covered.">				if (t == null)</span>
<span class="fc" id="L2552">					continue;</span>

<span class="pc bpc" id="L2554" title="2 of 4 branches missed.">				if (t == this &amp;&amp; getIndianSettlement() != null) {</span>
					// Always save client view of native settlements
					// because of the hidden information.
<span class="nc" id="L2557">					t = getTileToCache();</span>
<span class="nc" id="L2558">					t.setIndianSettlementInternals(p, getLearnableSkill(p), getWantedGoods(p));</span>
				}

<span class="fc" id="L2561">				xw.writeStartElement(CACHED_TILE_TAG);</span>

<span class="fc" id="L2563">				xw.writeAttribute(PLAYER_TAG, p);</span>

<span class="pc bpc" id="L2565" title="1 of 2 branches missed.">				xw.writeAttribute(COPIED_TAG, t != this);</span>

<span class="pc bpc" id="L2567" title="1 of 2 branches missed.">				if (t != this) {</span>
					// Only write copied tiles, with limited scope.
<span class="nc" id="L2569">					FreeColXMLWriter.WriteScope scope = xw.getWriteScope();</span>
<span class="nc" id="L2570">					xw.setWriteScope(FreeColXMLWriter.WriteScope.toClient(p));</span>
					// Do not call toXML! It will look for a cached tile,
					// inside t which is already a cached copy!
					try {
<span class="nc" id="L2574">						t.internalToXML(xw, getXMLElementTagName());</span>
					} finally {
<span class="nc" id="L2576">						xw.setWriteScope(scope);</span>
<span class="nc" id="L2577">					}</span>
				}

<span class="fc" id="L2580">				xw.writeEndElement();</span>
<span class="fc" id="L2581">			}</span>
		}
<span class="fc" id="L2583">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L2590">		super.readAttributes(xr);</span>

<span class="fc" id="L2592">		final Specification spec = getSpecification();</span>
<span class="fc" id="L2593">		final Game game = getGame();</span>

<span class="fc" id="L2595">		x = xr.getAttribute(X_TAG, 0);</span>

<span class="fc" id="L2597">		y = xr.getAttribute(Y_TAG, 0);</span>

<span class="fc" id="L2599">		type = xr.getType(spec, TYPE_TAG, TileType.class, (TileType) null);</span>
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">		if (type == null) { // Unexplored tile.</span>
<span class="nc" id="L2601">			style = 0;</span>
<span class="nc" id="L2602">			highSeasCount = -1;</span>
<span class="nc" id="L2603">			owner = null;</span>
<span class="nc" id="L2604">			region = null;</span>
<span class="nc" id="L2605">			moveToEurope = null;</span>
<span class="nc" id="L2606">			contiguity = -1;</span>
<span class="nc" id="L2607">			return;</span>
		}

<span class="fc" id="L2610">		style = xr.getAttribute(STYLE_TAG, 0);</span>

<span class="fc" id="L2612">		String str = xr.getAttribute(CONNECTED_TAG, (String) null);</span>
<span class="pc bpc" id="L2613" title="1 of 4 branches missed.">		if (str == null || str.isEmpty()) {</span>
<span class="fc" id="L2614">			highSeasCount = -1;</span>
			// @compat 0.10.5
			// High seas should have connected==0. If it does not, this
			// is probably an old save file, so flag a recalculation.
<span class="fc" id="L2618">			String typeStr = xr.getAttribute(TYPE_TAG, (String) null);</span>
<span class="fc bfc" id="L2619" title="All 2 branches covered.">			if (&quot;model.tile.highSeas&quot;.equals(typeStr)) {</span>
<span class="fc" id="L2620">				highSeasCount = Tile.FLAG_RECALCULATE;</span>
			}
			// @end compatibility code
<span class="fc" id="L2623">		} else {</span>
			try {
<span class="fc" id="L2625">				highSeasCount = Integer.parseInt(str);</span>
<span class="nc" id="L2626">			} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L2627">				highSeasCount = -1;</span>
				// @compat 0.10.5
				// &lt; 0.10.6 used to have a simple boolean connected
				// attribute, but it is now highSeasCount, the number of
				// tiles to get to a tile where a unit can move
				// directly to the high seas.
<span class="nc" id="L2633">				highSeasCount = Tile.FLAG_RECALCULATE;</span>
				// @end compatibility code
<span class="fc" id="L2635">			}</span>
		}

<span class="fc" id="L2638">		owner = xr.findFreeColGameObject(game, OWNER_TAG, Player.class, (Player) null, false);</span>

<span class="fc" id="L2640">		region = xr.findFreeColGameObject(game, REGION_TAG, Region.class, (Region) null, false);</span>

<span class="fc bfc" id="L2642" title="All 2 branches covered.">		moveToEurope = (xr.hasAttribute(MOVE_TO_EUROPE_TAG)) ? xr.getAttribute(MOVE_TO_EUROPE_TAG, false) : null;</span>

<span class="fc" id="L2644">		contiguity = xr.getAttribute(CONTIGUITY_TAG, -1);</span>

		// Tiles are added to the settlement owned tiles list in Map.
		// Doing it here can cause cache weirdness.
<span class="fc" id="L2648">		Location loc = xr.getLocationAttribute(game, OWNING_SETTLEMENT_TAG, true);</span>
<span class="fc bfc" id="L2649" title="All 2 branches covered.">		owningSettlement = (loc instanceof Settlement) ? (Settlement) loc : null;</span>
<span class="fc" id="L2650">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// Clear containers.
<span class="fc" id="L2658">		settlement = null;</span>

<span class="fc" id="L2660">		super.readChildren(xr);</span>

		// @compat 0.10.1
		// Old settlements were prone to not owning their tiles.
<span class="fc bfc" id="L2664" title="All 2 branches covered.">		if (getSettlement() != null) {</span>
<span class="fc" id="L2665">			Settlement settlement = getSettlement();</span>
<span class="fc" id="L2666">			Player owner = settlement.getOwner();</span>
<span class="pc bpc" id="L2667" title="2 of 4 branches missed.">			if (owner != null &amp;&amp; getOwner() != owner) {</span>
<span class="nc" id="L2668">				this.owner = owner;</span>
			}
<span class="fc bfc" id="L2670" title="All 2 branches covered.">			if (this.owningSettlement != settlement) {</span>
<span class="fc" id="L2671">				this.owningSettlement = settlement;</span>
			}
		}
		// end @compat 0.10.1
<span class="fc" id="L2675">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L2682">		final Specification spec = getSpecification();</span>
<span class="fc" id="L2683">		final Game game = getGame();</span>
<span class="fc" id="L2684">		final String tag = xr.getLocalName();</span>

<span class="pc bpc" id="L2686" title="1 of 4 branches missed.">		if (cachedTiles != null &amp;&amp; CACHED_TILE_TAG.equals(tag)) {</span>
<span class="fc" id="L2687">			Player player = xr.findFreeColGameObject(game, PLAYER_TAG, Player.class, (Player) null, true);</span>

<span class="fc" id="L2689">			boolean copied = xr.getAttribute(COPIED_TAG, false);</span>
<span class="pc bpc" id="L2690" title="1 of 2 branches missed.">			if (copied) {</span>
<span class="nc" id="L2691">				FreeColXMLReader.ReadScope scope = xr.getReadScope();</span>
<span class="nc" id="L2692">				xr.setReadScope(FreeColXMLReader.ReadScope.NOINTERN);</span>
<span class="nc" id="L2693">				xr.nextTag();</span>
<span class="nc" id="L2694">				xr.expectTag(Tile.getXMLElementTagName());</span>
<span class="nc" id="L2695">				Tile tile = xr.readFreeColGameObject(game, Tile.class);</span>

				// Temporary workaround for BR#2618 on input
<span class="nc" id="L2698">				Colony colony = tile.getColony();</span>
<span class="nc bnc" id="L2699" title="All 4 branches missed.">				if (colony != null &amp;&amp; colony.getDisplayUnitCount() &lt;= 0) {</span>
<span class="nc" id="L2700">					logger.warning(&quot;Copied colony &quot; + colony.getId() + &quot; display unit count set to 1 from corrupt: &quot;</span>
<span class="nc" id="L2701">							+ colony.getDisplayUnitCount());</span>
<span class="nc" id="L2702">					colony.setDisplayUnitCount(1);</span>
				}
				// end workaround

<span class="nc" id="L2706">				setCachedTile(player, tile);</span>
<span class="nc" id="L2707">				xr.setReadScope(scope);</span>

<span class="nc" id="L2709">				IndianSettlement is = tile.getIndianSettlement();</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">				if (is == null) {</span>
<span class="nc" id="L2711">					removeIndianSettlementInternals(player);</span>
				} else {
<span class="nc" id="L2713">					setIndianSettlementInternals(player, is.getLearnableSkill(), is.getWantedGoods());</span>
				}

<span class="nc" id="L2716">			} else {</span>
<span class="fc" id="L2717">				setCachedTile(player, this);</span>
			}
<span class="fc" id="L2719">			xr.closeTag(CACHED_TILE_TAG);</span>

			// @compat 0.10.1
<span class="fc bfc" id="L2722" title="All 2 branches covered.">		} else if (OLD_UNITS_TAG.equals(tag)) {</span>
<span class="fc bfc" id="L2723" title="All 2 branches covered.">			while (xr.nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="fc" id="L2724">				super.readChild(xr);</span>
			}
			// end @compat

<span class="fc bfc" id="L2728" title="All 2 branches covered.">		} else if (Colony.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L2729">			settlement = xr.readFreeColGameObject(game, Colony.class);</span>

<span class="fc bfc" id="L2731" title="All 2 branches covered.">		} else if (IndianSettlement.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L2732">			settlement = xr.readFreeColGameObject(game, IndianSettlement.class);</span>

			// @compat 0.10.7
<span class="pc bpc" id="L2735" title="1 of 2 branches missed.">		} else if (PlayerExploredTile.getXMLElementTagName().equals(tag)) {</span>
			// Only from a saved game.
<span class="nc" id="L2737">			Player player = xr.findFreeColGameObject(game, PLAYER_TAG, Player.class, (Player) null, true);</span>

<span class="nc bnc" id="L2739" title="All 2 branches missed.">			if (xr.hasAttribute(IndianSettlement.LEARNABLE_SKILL_TAG)</span>
<span class="nc bnc" id="L2740" title="All 2 branches missed.">					|| xr.hasAttribute(IndianSettlement.WANTED_GOODS_TAG + &quot;0&quot;)) {</span>
<span class="nc" id="L2741">				UnitType skill = xr.getType(spec, IndianSettlement.LEARNABLE_SKILL_TAG, UnitType.class,</span>
						(UnitType) null);
<span class="nc" id="L2743">				GoodsType[] wanted = new GoodsType[IndianSettlement.WANTED_GOODS_COUNT];</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">				for (int i = 0; i &lt; wanted.length; i++) {</span>
<span class="nc" id="L2745">					wanted[i] = xr.getType(spec, IndianSettlement.WANTED_GOODS_TAG + i, GoodsType.class,</span>
							(GoodsType) null);
				}
<span class="nc" id="L2748">				setIndianSettlementInternals(player, skill, wanted);</span>
			}

<span class="nc" id="L2751">			PlayerExploredTile pet = xr.readFreeColGameObject(game, PlayerExploredTile.class);</span>
<span class="nc" id="L2752">			pet.fixCache();</span>
			// end @compat 0.10.7

<span class="pc bfc" id="L2755" title="All 2 branches covered.">		} else if (TileItemContainer.getXMLElementTagName().equals(tag)</span>
				// @compat 0.11.3
<span class="fc bfc" id="L2757" title="All 2 branches covered.">				|| OLD_TILE_ITEM_CONTAINER_TAG.equals(tag)</span>
		// end @compat 0.11.3
		) {
<span class="fc" id="L2760">			tileItemContainer = xr.readFreeColGameObject(game, TileItemContainer.class);</span>

		} else {
<span class="fc" id="L2763">			super.readChild(xr);</span>
		}

		// @compat 0.10.x
		// Fix bug where missionary locations get cleared.
		// FIXME: Remove this when PETs have been revised to not store
		// the actual unit.
<span class="fc bfc" id="L2770" title="All 2 branches covered.">		if (settlement instanceof IndianSettlement) {</span>
<span class="fc" id="L2771">			Unit missionary = ((IndianSettlement) settlement).getMissionary();</span>
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">			if (missionary != null)</span>
<span class="nc" id="L2773">				missionary.setLocationNoUpdate(settlement);</span>
		}
		// end @compat 0.10.x
<span class="fc" id="L2776">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="fc" id="L2783">		StringBuilder sb = new StringBuilder(64);</span>
<span class="pc bpc" id="L2784" title="1 of 2 branches missed.">		sb.append(&quot;[&quot;).append(getId()).append(&quot; &quot;).append((type == null) ? &quot;unknown&quot; : type.getSuffix()).append(&quot; &quot;)</span>
<span class="fc bfc" id="L2785" title="All 2 branches covered.">				.append(x).append(&quot;,&quot;).append(y).append((!hasSettlement()) ? &quot;&quot; : &quot; &quot; + getSettlement().getName())</span>
<span class="fc" id="L2786">				.append(&quot;]&quot;);</span>
<span class="fc" id="L2787">		return sb.toString();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="fc" id="L2795">		return getXMLElementTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;tile&quot;.
	 */
	public static String getXMLElementTagName() {
<span class="fc" id="L2804">		return &quot;tile&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>