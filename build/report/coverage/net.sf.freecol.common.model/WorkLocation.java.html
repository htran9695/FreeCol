<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WorkLocation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">WorkLocation.java</span></div><h1>WorkLocation.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.LogBuilder;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.Utils;

/**
 * The &lt;code&gt;WorkLocation&lt;/code&gt; is a place in a {@link Colony} where
 * &lt;code&gt;Units&lt;/code&gt; can work. The unit capacity of a WorkLocation is likely to
 * be limited. ColonyTiles can only hold a single worker, and Buildings can hold
 * no more than three workers, for example. WorkLocations do not store any
 * Goods. They take any Goods they consume from the Colony, and put all Goods
 * they produce there, too. Although the WorkLocation implements
 * {@link Ownable}, its owner can not be changed directly, as it is always owned
 * by the owner of the Colony.
 */
public abstract class WorkLocation extends UnitLocation implements Ownable {

	/** The Constant logger. */
<span class="fc" id="L52">	private static final Logger logger = Logger.getLogger(WorkLocation.class.getName());</span>

	/** The Constant EMPTY_LIST. */
<span class="fc" id="L55">	public static final List&lt;AbstractGoods&gt; EMPTY_LIST = Collections.&lt;AbstractGoods&gt;emptyList();</span>

	/** Container class to suggest a better use of a unit. */
	public static class Suggestion {

		/** The Constant descendingAmountComparator. */
<span class="nc" id="L61">		public static final Comparator&lt;Suggestion&gt; descendingAmountComparator = new Comparator&lt;Suggestion&gt;() {</span>
			@Override
			public int compare(Suggestion s1, Suggestion s2) {
<span class="nc" id="L64">				int cmp = s2.amount - s1.amount;</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">				if (cmp == 0) {</span>
<span class="nc" id="L66">					cmp = GoodsType.goodsTypeComparator.compare(s1.goodsType, s2.goodsType);</span>
				}
<span class="nc bnc" id="L68" title="All 2 branches missed.">				if (cmp == 0) {</span>
<span class="nc" id="L69">					cmp = s2.newType.getId().compareTo(s1.newType.getId());</span>
				}
<span class="nc" id="L71">				return cmp;</span>
			}
		};

		/** The work location. */
		public final WorkLocation workLocation;

		/** The old type. */
		public final UnitType oldType;

		/** The new type. */
		public final UnitType newType;

		/** The goods type. */
		public final GoodsType goodsType;

		/** The amount. */
		public final int amount;

		/**
		 * Suggest that work done by (optional) &lt;code&gt;oldType&lt;/code&gt; would be
		 * better done by &lt;code&gt;newType&lt;/code&gt; because it could produce
		 * &lt;code&gt;amount&lt;/code&gt; more &lt;code&gt;goodsType&lt;/code&gt;.
		 *
		 * @param workLocation
		 *            The &lt;code&gt;WorkLocation&lt;/code&gt; to add a unit to.
		 * @param oldType
		 *            The optional &lt;code&gt;UnitType&lt;/code&gt; currently doing the
		 *            work.
		 * @param newType
		 *            A new &lt;code&gt;UnitType&lt;/code&gt; to do the work.
		 * @param goodsType
		 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
		 * @param amount
		 *            The extra goods that would be produced if the suggestion
		 *            is taken.
		 */
		public Suggestion(WorkLocation workLocation, UnitType oldType, UnitType newType, GoodsType goodsType,
<span class="nc" id="L109">				int amount) {</span>
<span class="nc" id="L110">			this.workLocation = workLocation;</span>
<span class="nc" id="L111">			this.oldType = oldType;</span>
<span class="nc" id="L112">			this.newType = newType;</span>
<span class="nc" id="L113">			this.goodsType = goodsType;</span>
<span class="nc" id="L114">			this.amount = amount;</span>
<span class="nc" id="L115">		}</span>
	};

	/** The colony that contains this work location. */
	protected Colony colony;

	/** The production type of this WorkLocation. */
	private ProductionType productionType;

	/**
	 * Constructor for ServerWorkLocation.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 */
	protected WorkLocation(Game game) {
<span class="fc" id="L131">		super(game);</span>
<span class="fc" id="L132">	}</span>

	/**
	 * Creates a new &lt;code&gt;WorkLocation&lt;/code&gt; with the given identifier. The
	 * object should later be initialized by calling either
	 * {@link #readFromXML(FreeColXMLReader)} or
	 * {@link #readFromXMLElement(Element)}.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param id
	 *            The object identifier.
	 */
	public WorkLocation(Game game, String id) {
<span class="fc" id="L146">		super(game, id);</span>
<span class="fc" id="L147">	}</span>

	/**
	 * Gets the owning settlement for this work location.
	 *
	 * @return The owning settlement for this work location.
	 */
	public Settlement getOwningSettlement() {
<span class="nc" id="L155">		return colony;</span>
	}

	/**
	 * Get the production type.
	 *
	 * @return The &lt;code&gt;ProductionType&lt;/code&gt; for this work location.
	 */
	public final ProductionType getProductionType() {
<span class="fc" id="L164">		return productionType;</span>
	}

	/**
	 * Set the prodution type.
	 *
	 * @param newProductionType
	 *            The new &lt;code&gt;ProductionType&lt;/code&gt; value.
	 */
	public final void setProductionType(final ProductionType newProductionType) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">		if (!Utils.equals(newProductionType, productionType)) {</span>
<span class="fc" id="L175">			productionType = newProductionType;</span>
<span class="fc" id="L176">			colony.invalidateCache();</span>
<span class="fc" id="L177">			logger.fine(&quot;Production type at &quot; + this + &quot; is now: &quot; + newProductionType);</span>
		}
<span class="fc" id="L179">	}</span>

	/**
	 * Get the current work type of any unit present.
	 *
	 * This assumes that all units in a work location are doing the same work,
	 * which is true for now.
	 *
	 * @return The current &lt;code&gt;GoodsType&lt;/code&gt; being produced, or null if
	 *         none.
	 */
	public GoodsType getCurrentWorkType() {
<span class="fc" id="L191">		Unit unit = getFirstUnit();</span>
<span class="pc bpc" id="L192" title="1 of 4 branches missed.">		return (unit != null &amp;&amp; unit.getType() != null) ? unit.getWorkType() : null;</span>
	}

	/**
	 * Update production type on the basis of the current work location type
	 * (which might change due to an upgrade) and the work type of units
	 * present.
	 */
	public void updateProductionType() {
<span class="fc" id="L201">		setProductionType(getBestProductionType(isEmpty(), getCurrentWorkType()));</span>
<span class="fc" id="L202">	}</span>

	/**
	 * Get the best available production type at this work location.
	 *
	 * @param unattended
	 *            Whether to require unattended production.
	 * @param workType
	 *            An optional work type to require.
	 * @return The best available &lt;code&gt;ProductionType&lt;/code&gt; given the argument
	 *         constraints.
	 */
	public ProductionType getBestProductionType(boolean unattended, GoodsType workType) {
<span class="fc" id="L215">		ProductionType best = null;</span>
<span class="fc" id="L216">		int amount = -1;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">		for (ProductionType pt : getAvailableProductionTypes(unattended)) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">			for (AbstractGoods output : pt.getOutputs()) {</span>
<span class="fc bfc" id="L219" title="All 4 branches covered.">				if (workType != null &amp;&amp; workType != output.getType())</span>
<span class="fc" id="L220">					continue;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">				if (amount &lt; output.getAmount()) {</span>
<span class="fc" id="L222">					amount = output.getAmount();</span>
<span class="fc" id="L223">					best = pt;</span>
				}
<span class="fc" id="L225">			}</span>
<span class="fc" id="L226">		}</span>
<span class="fc" id="L227">		return best;</span>
	}

	/**
	 * Gets the best occupation for a given unit at this work location.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find an &lt;code&gt;Occupation&lt;/code&gt; for.
	 * @param userMode
	 *            If a user requested this, favour the current work type, if not
	 *            favour goods that the unit requires.
	 * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null if none
	 *         found.
	 */
	public Occupation getOccupation(Unit unit, boolean userMode) {
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">		LogBuilder lb = new LogBuilder((colony.getOccupationTrace()) ? 64 : 0);</span>
<span class="fc" id="L243">		lb.add(colony.getName(), &quot;/&quot;, this, &quot;.getOccupation(&quot;, unit, &quot;)&quot;);</span>

<span class="fc" id="L245">		Occupation best = new Occupation(null, null, null);</span>
<span class="fc" id="L246">		int bestAmount = 0;</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">		for (Collection&lt;GoodsType&gt; types : colony.getWorkTypeChoices(unit, userMode)) {</span>
<span class="fc" id="L248">			lb.add(&quot;\n  &quot;);</span>
<span class="fc" id="L249">			logFreeColObjects(types, lb);</span>
<span class="fc" id="L250">			bestAmount = best.improve(unit, this, bestAmount, types, lb);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">			if (best.workType != null) {</span>
<span class="fc" id="L252">				lb.add(&quot;\n  =&gt; &quot;, best);</span>
<span class="fc" id="L253">				break;</span>
			}
<span class="fc" id="L255">		}</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">		if (best.workType == null)</span>
<span class="fc" id="L257">			lb.add(&quot;\n  FAILED&quot;);</span>
<span class="fc" id="L258">		lb.log(logger, Level.WARNING);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">		return (best.workType == null) ? null : best;</span>
	}

	/**
	 * Gets the best occupation for a given unit type at this work location.
	 *
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt; to find an
	 *            &lt;code&gt;Occupation&lt;/code&gt; for. If null, use the default unit
	 *            type.
	 * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null if none
	 *         found.
	 */
	public Occupation getOccupation(UnitType unitType) {
<span class="nc" id="L273">		final Specification spec = getSpecification();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">		if (unitType == null) {</span>
<span class="nc" id="L275">			unitType = spec.getDefaultUnitType(getOwner().getNationType());</span>
		}

<span class="nc bnc" id="L278" title="All 2 branches missed.">		LogBuilder lb = new LogBuilder((colony.getOccupationTrace()) ? 64 : 0);</span>
<span class="nc" id="L279">		lb.add(colony.getName(), &quot;/&quot;, this, &quot;.getOccupation(&quot;, unitType.getSuffix(), &quot;)&quot;);</span>

<span class="nc" id="L281">		Collection&lt;GoodsType&gt; types = spec.getGoodsTypeList();</span>
<span class="nc" id="L282">		Occupation best = new Occupation(null, null, null);</span>
<span class="nc" id="L283">		lb.add(&quot;\n  &quot;);</span>
<span class="nc" id="L284">		logFreeColObjects(types, lb);</span>
<span class="nc" id="L285">		int bestAmount = best.improve(unitType, this, 0, types, lb);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">		if (best.workType != null) {</span>
<span class="nc" id="L287">			lb.add(&quot;\n  =&gt; &quot;, best);</span>
		} else {
<span class="nc" id="L289">			lb.add(&quot;\n  FAILED&quot;);</span>
		}
<span class="nc" id="L291">		lb.log(logger, Level.WARNING);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">		return (best.workType == null) ? null : best;</span>
	}

	/**
	 * Get the best work type for a unit at this work location, favouring the
	 * existing work.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find a work type for.
	 * @return The best work &lt;code&gt;GoodsType&lt;/code&gt; for the unit, or null if
	 *         none found.
	 */
	public GoodsType getWorkFor(Unit unit) {
<span class="nc" id="L305">		Occupation occupation = getOccupation(unit, true);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">		return (occupation == null) ? null : occupation.workType;</span>
	}

	/**
	 * Install a unit at the best occupation for it at this work location.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to install.
	 * @return True if the installation succeeds.
	 */
	public boolean setWorkFor(Unit unit) {
<span class="fc" id="L317">		Occupation occupation = getOccupation(unit, false);</span>
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">		return occupation != null &amp;&amp; occupation.install(unit);</span>
	}

	/**
	 * Is it a good idea to produce a goods type at this work location using a
	 * better unit type?.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is doing the job at present, which
	 *            may be null if none is at work.
	 * @param productionType
	 *            The &lt;code&gt;ProductionType&lt;/code&gt; to use.
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @return A &lt;code&gt;Suggestion&lt;/code&gt; for a better worker, or null if
	 *         improvement is not worthwhile.
	 */
	private Suggestion getSuggestion(Unit unit, ProductionType productionType, GoodsType goodsType) {
		// Check first if there is space.
<span class="nc bnc" id="L337" title="All 10 branches missed.">		if (((unit == null || !contains(unit)) &amp;&amp; isFull()) || productionType == null || goodsType == null)</span>
<span class="nc" id="L338">			return null;</span>

<span class="nc" id="L340">		final Specification spec = getSpecification();</span>
<span class="nc" id="L341">		final Player owner = getOwner();</span>
<span class="nc" id="L342">		final UnitType expert = spec.getExpertForProducing(goodsType);</span>

		// Require there be a better unit to do this work, and that it
		// would actually improve production.
<span class="nc bnc" id="L346" title="All 2 branches missed.">		final UnitType better = (expert != null) ? expert : spec.getDefaultUnitType(owner);</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">		if (unit != null &amp;&amp; better == unit.getType())</span>
<span class="nc" id="L348">			return null;</span>
<span class="nc" id="L349">		int delta = getPotentialProduction(goodsType, better);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		if (unit != null) {</span>
<span class="nc" id="L351">			delta -= getPotentialProduction(goodsType, unit.getType());</span>
		}
		// Do we have a chance of satisfying the inputs?
<span class="nc bnc" id="L354" title="All 2 branches missed.">		for (AbstractGoods in : productionType.getInputs()) {</span>
			// TODO: should really consider in.getAmount
<span class="nc" id="L356">			delta = Math.min(delta, colony.getNetProductionOf(in.getType()));</span>
<span class="nc" id="L357">		}</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (delta &lt;= 0)</span>
<span class="nc" id="L359">			return null;</span>

		// Is the production actually a good idea? Not if we are independent
		// and have maximized liberty, or for immigration.
<span class="nc bnc" id="L363" title="All 2 branches missed.">		if (owner.getPlayerType() == Player.PlayerType.INDEPENDENT</span>
<span class="nc bnc" id="L364" title="All 6 branches missed.">				&amp;&amp; ((goodsType.isLibertyType() &amp;&amp; colony.getSoL() &gt;= 100) || goodsType.isImmigrationType()))</span>
<span class="nc" id="L365">			return null;</span>

		// FIXME: OO
<span class="nc" id="L368">		boolean ok = false;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">		if (this instanceof ColonyTile) {</span>
			// Assume the work is worth doing for owned or trivially
			// claimable colony tiles.
<span class="nc" id="L372">			Tile tile = ((ColonyTile) this).getWorkTile();</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">			ok = owner.owns(tile) || owner.canClaimForSettlement(tile);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		} else if (this instanceof Building) {</span>
<span class="nc" id="L375">			Building bu = (Building) this;</span>
			// Make sure the type can be added.
<span class="nc bnc" id="L377" title="All 2 branches missed.">			if (bu.canAddType(better)) {</span>
<span class="nc" id="L378">				Colony colony = getColony();</span>
				BuildableType bt;
				// Assume work is worth doing if a unit is already
				// there, or if the building has been upgraded, or if
				// the goods are required for the current building job.
<span class="nc bnc" id="L383" title="All 4 branches missed.">				if (bu.getLevel() &gt; 1 || unit != null) {</span>
<span class="nc" id="L384">					ok = true;</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">				} else if (colony.getTotalProductionOf(goodsType) == 0 &amp;&amp; (bt = colony.getCurrentlyBuilding()) != null</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">						&amp;&amp; AbstractGoods.containsType(goodsType, bt.getRequiredGoods())) {</span>
<span class="nc" id="L387">					ok = true;</span>
				}
			}
		}
<span class="nc bnc" id="L391" title="All 4 branches missed.">		return (!ok) ? null : new Suggestion(this, (unit == null) ? null : unit.getType(), better, goodsType, delta);</span>
	}

	/**
	 * Get a map of suggestions for better or additional units.
	 *
	 * @return A mapping of either existing units or null (denoting adding a
	 *         unit) to a &lt;code&gt;Suggestion&lt;/code&gt;.
	 */
	public java.util.Map&lt;Unit, Suggestion&gt; getSuggestions() {
<span class="nc" id="L401">		java.util.Map&lt;Unit, Suggestion&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L402" title="All 4 branches missed.">		if (!canBeWorked() || canTeach())</span>
<span class="nc" id="L403">			return result;</span>

<span class="nc" id="L405">		Occupation occ = getOccupation(null);</span>
		GoodsType work;
		Suggestion sug;
		// Check if the existing units can be improved.
<span class="nc bnc" id="L409" title="All 2 branches missed.">		for (Unit u : getUnitList()) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">			if (u.getTeacher() != null)</span>
<span class="nc" id="L411">				continue; // Students assumed temporary</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">			if ((work = u.getWorkType()) == null &amp;&amp; occ != null) {</span>
<span class="nc" id="L413">				work = occ.workType;</span>
			}
<span class="nc bnc" id="L415" title="All 2 branches missed.">			if ((sug = getSuggestion(u, getProductionType(), work)) != null) {</span>
<span class="nc" id="L416">				result.put(u, sug);</span>
			}
			// Check for a suggestion for an extra worker if there is space.
<span class="nc bnc" id="L419" title="All 6 branches missed.">			if (!isFull() &amp;&amp; occ != null &amp;&amp; (work = occ.workType) != null</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">					&amp;&amp; (sug = getSuggestion(null, occ.productionType, work)) != null) {</span>
<span class="nc" id="L421">				result.put(null, sug);</span>
			}
<span class="nc" id="L423">		}</span>
<span class="nc" id="L424">		return result;</span>
	}

	/**
	 * Get the &lt;code&gt;AbstractGoods&lt;/code&gt; consumed by this work location.
	 *
	 * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; consumed.
	 */
	public List&lt;AbstractGoods&gt; getInputs() {
<span class="fc bfc" id="L433" title="All 2 branches covered.">		return (productionType == null) ? EMPTY_LIST : productionType.getInputs();</span>
	}

	/**
	 * Get the &lt;code&gt;AbstractGoods&lt;/code&gt; produced by this work location.
	 *
	 * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; produced.
	 */
	public List&lt;AbstractGoods&gt; getOutputs() {
<span class="fc bfc" id="L442" title="All 2 branches covered.">		return (productionType == null) ? EMPTY_LIST : productionType.getOutputs();</span>
	}

	/**
	 * Does this work location produce a given type of goods?.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return True if this &lt;code&gt;WorkLocation&lt;/code&gt; produces the given
	 *         &lt;code&gt;GoodsType&lt;/code&gt;.
	 */
	public boolean produces(GoodsType goodsType) {
<span class="fc" id="L454">		return AbstractGoods.containsType(goodsType, getOutputs());</span>
	}

	/**
	 * Does this work location have any inputs.
	 *
	 * @return True if there are any inputs.
	 */
	public boolean hasInputs() {
<span class="nc bnc" id="L463" title="All 4 branches missed.">		return productionType != null &amp;&amp; !productionType.getInputs().isEmpty();</span>
	}

	/**
	 * Does this work location have any outputs.
	 *
	 * @return True if there are any outputs.
	 */
	public boolean hasOutputs() {
<span class="pc bpc" id="L472" title="1 of 4 branches missed.">		return productionType != null &amp;&amp; !productionType.getOutputs().isEmpty();</span>
	}

	/**
	 * Checks if this work location can actually be worked.
	 *
	 * @return True if the work location can be worked.
	 */
	public boolean canBeWorked() {
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">		return getNoWorkReason() == NoAddReason.NONE;</span>
	}

	/**
	 * Does this work location have teaching capability?.
	 *
	 * @return True if this is a teaching location.
	 * @see Ability#TEACH
	 */
	public boolean canTeach() {
<span class="fc" id="L491">		return hasAbility(Ability.TEACH);</span>
	}

	/**
	 * Gets the ProductionInfo for this WorkLocation from the Colony's cache.
	 *
	 * @return The work location &lt;code&gt;ProductionInfo&lt;/code&gt;.
	 */
	public ProductionInfo getProductionInfo() {
<span class="fc" id="L500">		return getColony().getProductionInfo(this);</span>
	}

	/**
	 * Gets the production at this work location.
	 *
	 * @return The work location production.
	 */
	public List&lt;AbstractGoods&gt; getProduction() {
<span class="fc" id="L509">		ProductionInfo info = getProductionInfo();</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">		return (info == null) ? EMPTY_LIST : info.getProduction();</span>
	}

	/**
	 * Gets the total production of a specified goods type at this work
	 * location.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return The amount of production.
	 */
	public int getTotalProductionOf(GoodsType goodsType) {
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">		if (goodsType == null) {</span>
<span class="nc" id="L523">			throw new IllegalArgumentException(&quot;Null GoodsType.&quot;);</span>
		}
<span class="fc" id="L525">		return AbstractGoods.getCount(goodsType, getProduction());</span>
	}

	/**
	 * Gets the maximum production of this work location for a given goods type,
	 * assuming the current workers and input goods.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return The maximum production of the goods at this work location.
	 */
	public int getMaximumProductionOf(GoodsType goodsType) {
<span class="fc" id="L537">		ProductionInfo info = getProductionInfo();</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">		if (info == null)</span>
<span class="nc" id="L539">			return 0;</span>
<span class="fc" id="L540">		List&lt;AbstractGoods&gt; production = info.getMaximumProduction();</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">		if (production != null) {</span>
<span class="fc" id="L542">			AbstractGoods ag = AbstractGoods.findByType(goodsType, production);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">			if (ag != null)</span>
<span class="fc" id="L544">				return ag.getAmount();</span>
		}
<span class="fc" id="L546">		return getTotalProductionOf(goodsType);</span>
	}

	/**
	 * Gets the unit type that is the expert for this work location using its
	 * first output for which an expert type can be found.
	 *
	 * @return The expert &lt;code&gt;UnitType&lt;/code&gt;.
	 */
	public UnitType getExpertUnitType() {
<span class="fc" id="L556">		final Specification spec = getSpecification();</span>
<span class="fc" id="L557">		ProductionType pt = getBestProductionType(false, null);</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">		return (pt == null) ? null</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">				: find(map(pt.getOutputs(), ag -&gt; spec.getExpertForProducing(ag.getType())), ut -&gt; ut != null, null);</span>
	}

	/**
	 * Get the potential production of a given goods type using the default
	 * unit. This is useful for planning.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return The potential production.
	 */
	public int getGenericPotential(GoodsType goodsType) {
<span class="fc" id="L571">		return getPotentialProduction(goodsType, getSpecification().getDefaultUnitType(getOwner()));</span>
	}

	/**
	 * Gets the productivity of a unit working in this work location,
	 * considering *only* the contribution of the unit, exclusive of that of the
	 * work location.
	 * 
	 * Used below, only public for the test suite.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @param goodsType
	 *            the goods type
	 * @return The maximum return from this unit.
	 */
	public int getUnitProduction(Unit unit, GoodsType goodsType) {
<span class="pc bpc" id="L588" title="1 of 4 branches missed.">		if (unit == null || unit.getWorkType() != goodsType)</span>
<span class="fc" id="L589">			return 0;</span>
<span class="fc" id="L590">		final UnitType unitType = unit.getType();</span>
<span class="fc" id="L591">		final Turn turn = getGame().getTurn();</span>
<span class="fc" id="L592">		int bestAmount = 0;</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">		for (AbstractGoods output : getOutputs()) {</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">			if (output.getType() != goodsType)</span>
<span class="nc" id="L595">				continue;</span>
<span class="fc" id="L596">			int amount = (int) applyModifiers(getBaseProduction(getProductionType(), goodsType, unitType), turn,</span>
<span class="fc" id="L597">					getProductionModifiers(goodsType, unitType));</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">			if (bestAmount &lt; amount)</span>
<span class="fc" id="L599">				bestAmount = amount;</span>
<span class="fc" id="L600">		}</span>
<span class="fc" id="L601">		return bestAmount;</span>
	}

	/**
	 * Gets the production of a unit of the given type of goods.
	 *
	 * @param unit
	 *            The unit to do the work.
	 * @param goodsType
	 *            The type of goods to get the production of.
	 * @return The production of the given type of goods.
	 */
	public int getProductionOf(Unit unit, GoodsType goodsType) {
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">		if (unit == null)</span>
<span class="nc" id="L615">			throw new IllegalArgumentException(&quot;Null unit.&quot;);</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">		return (!produces(goodsType)) ? 0 : Math.max(0, getPotentialProduction(goodsType, unit.getType()));</span>
	}

	/**
	 * Get the potential production of a given goods type at this location. An
	 * optional unit type to do the production may be specified, however if null
	 * the unattended production will be calculated.
	 *
	 * Usually if a unit type is specified and a unit can not be added to the
	 * work location, zero production is returned. However, this routine is
	 * intended to be used for planning purposes, so some exceptions are allowed
	 * --- the calculation proceeds:
	 *
	 * - for unclaimed tiles - when the location is currently full of units
	 *
	 * which are conditions that an AI might plausibly be able and willing to
	 * change (a case could be made for including the OCCUPIED_BY_ENEMY
	 * condition).
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            The optional &lt;code&gt;UnitType&lt;/code&gt; to do the work.
	 * @return The potential production with the given goods type and unit type.
	 */
	public int getPotentialProduction(GoodsType goodsType, UnitType unitType) {
<span class="fc bfc" id="L642" title="All 2 branches covered.">		if (!canProduce(goodsType, unitType))</span>
<span class="fc" id="L643">			return 0;</span>

<span class="fc bfc" id="L645" title="All 2 branches covered.">		if (unitType != null) {</span>
<span class="pc bpc" id="L646" title="1 of 3 branches missed.">			switch (getNoWorkReason()) {</span>
			case NONE:
			case ALREADY_PRESENT:
			case CLAIM_REQUIRED:
<span class="fc" id="L650">				break;</span>
			case CAPACITY_EXCEEDED:
<span class="nc bnc" id="L652" title="All 2 branches missed.">				if (getUnitCapacity() &gt; 0)</span>
<span class="nc" id="L653">					break; // Could work after reorg!</span>
				// Fall through
			case WRONG_TYPE:
			case OWNED_BY_ENEMY:
			case ANOTHER_COLONY:
			case COLONY_CENTER:
			case MISSING_ABILITY:
			case MISSING_SKILL:
			case MINIMUM_SKILL:
			case MAXIMUM_SKILL:
			case OCCUPIED_BY_ENEMY: // Arguable!
			default:
				// Non-transient or inapplicable conditions. Production
				// is impossible.
<span class="fc" id="L667">				return 0;</span>
			}
		}

<span class="fc" id="L671">		int amount = getBaseProduction(null, goodsType, unitType);</span>
<span class="fc" id="L672">		amount = (int) applyModifiers(amount, getGame().getTurn(), getProductionModifiers(goodsType, unitType));</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">		return (amount &lt; 0) ? 0 : amount;</span>
	}

	// Interface Location
	// Inherits:
	// FreeColObject.getId
	// UnitLocation.getLocationLabel
	// UnitLocation.contains
	// UnitLocation.canAdd
	// UnitLocation.getUnitCount
	// final UnitLocation.getUnitIterator
	// UnitLocation.getGoodsContainer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabelFor(Player player) {
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">		return (getOwner() == player) ? getLocationLabel() : getColony().getLocationLabelFor(player);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public final Tile getTile() {
<span class="fc" id="L699">		return colony.getTile();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean add(final Locatable locatable) {
<span class="fc" id="L707">		NoAddReason reason = getNoAddReason(locatable);</span>
<span class="pc bpc" id="L708" title="2 of 3 branches missed.">		switch (reason) {</span>
		case NONE:
<span class="fc" id="L710">			break;</span>
		case ALREADY_PRESENT:
<span class="nc" id="L712">			return true;</span>
		default:
<span class="nc" id="L714">			throw new IllegalStateException(&quot;Can not add &quot; + locatable + &quot; to &quot; + this + &quot; because &quot; + reason);</span>
		}
<span class="fc" id="L716">		Unit unit = (Unit) locatable;</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">		if (!super.add(unit))</span>
<span class="nc" id="L718">			return false;</span>

<span class="fc" id="L720">		unit.setState(Unit.UnitState.IN_COLONY);</span>
<span class="fc" id="L721">		unit.setMovesLeft(0);</span>

		// Choose a sensible work type, which should update production type.
<span class="fc" id="L724">		setWorkFor(unit);</span>

<span class="fc" id="L726">		getColony().invalidateCache();</span>
<span class="fc" id="L727">		return true;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean remove(final Locatable locatable) {
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">		if (!(locatable instanceof Unit)) {</span>
<span class="nc" id="L736">			throw new IllegalStateException(&quot;Not a unit: &quot; + locatable);</span>
		}
<span class="fc" id="L738">		Unit unit = (Unit) locatable;</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">		if (!contains(unit))</span>
<span class="nc" id="L740">			return true;</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">		if (!super.remove(unit))</span>
<span class="nc" id="L742">			return false;</span>

<span class="fc" id="L744">		unit.setState(Unit.UnitState.ACTIVE);</span>
<span class="fc" id="L745">		unit.setMovesLeft(0);</span>

		// Switch to unattended production if possible.
<span class="fc bfc" id="L748" title="All 2 branches covered.">		if (isEmpty())</span>
<span class="fc" id="L749">			updateProductionType();</span>

<span class="fc" id="L751">		getColony().invalidateCache();</span>
<span class="fc" id="L752">		return true;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public final Settlement getSettlement() {
<span class="fc" id="L760">		return colony;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public final int getRank() {
<span class="nc" id="L768">		return Location.getRank(getTile());</span>
	}

	// Interface UnitLocation
	// Inherits:
	// UnitLocation.getSpaceTaken
	// UnitLocation.moveToFront
	// UnitLocation.clearUnitList
	// UnitLocation.getUnitCapacity
	// UnitLocation.equipForRole

	/**
	 * {@inheritDoc}
	 */
	@Override
	public NoAddReason getNoAddReason(Locatable locatable) {
<span class="pc bpc" id="L784" title="2 of 4 branches missed.">		return (locatable instanceof Unit &amp;&amp; ((Unit) locatable).isPerson()) ? super.getNoAddReason(locatable)</span>
				: NoAddReason.WRONG_TYPE;
	}

	// Abstract and overrideable routines to be implemented by
	// WorkLocation subclasses.

	/**
	 * Get a description of the work location, with any expected extra detail.
	 *
	 * @return A label &lt;code&gt;StringTemplate&lt;/code&gt; for this work location.
	 */
	public abstract StringTemplate getLabel();

	/**
	 * Is this work location available?.
	 *
	 * @return True if the work location is either current or can be claimed.
	 */
	public abstract boolean isAvailable();

	/**
	 * Is this a current work location of this colony?.
	 *
	 * @return True if the work location is current.
	 */
	public abstract boolean isCurrent();

	/**
	 * Checks if this work location is available to the colony to be worked.
	 *
	 * @return The reason why/not the work location can be worked.
	 */
	public abstract NoAddReason getNoWorkReason();

	/**
	 * Can this work location can produce goods without workers?.
	 *
	 * @return True if this work location can produce goods without workers.
	 */
	public abstract boolean canAutoProduce();

	/**
	 * Can this work location produce a given goods type with an optional unit.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt;, if null the unattended
	 *            production is considered.
	 * @return True if this location can produce the goods.
	 */
	public abstract boolean canProduce(GoodsType goodsType, UnitType unitType);

	/**
	 * Gets the base production of a given goods type optionally using a unit of
	 * a given type in this work location. That is, the production exclusive of
	 * any modifiers. If no unit type is specified, the unattended production is
	 * calculated.
	 *
	 * @param productionType
	 *            An optional &lt;code&gt;ProductionType&lt;/code&gt; to use, if null the
	 *            best available one is used.
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            An optional &lt;code&gt;UnitType&lt;/code&gt; to produce the goods.
	 * @return The amount of goods potentially produced.
	 */
	public abstract int getBaseProduction(ProductionType productionType, GoodsType goodsType, UnitType unitType);

	/**
	 * Gets the production modifiers for the given type of goods and unit type.
	 * If no unit is specified the unattended production is calculated.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @param unitType
	 *            The optional &lt;code&gt;UnitType&lt;/code&gt; to produce them.
	 * @return A list of the applicable modifiers.
	 */
	public abstract List&lt;Modifier&gt; getProductionModifiers(GoodsType goodsType, UnitType unitType);

	/**
	 * Get the production types available for this work location.
	 *
	 * @param unattended
	 *            If true, get unattended production types.
	 * @return A list of suitable &lt;code&gt;ProductionType&lt;/code&gt;s.
	 */
	public abstract List&lt;ProductionType&gt; getAvailableProductionTypes(boolean unattended);

	/**
	 * Evaluate this work location for a given player. To be overridden by
	 * subclasses.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
	 * @return A value for the player.
	 */
	public int evaluateFor(Player player) {
<span class="nc" id="L885">		return getUnitList().stream().mapToInt(u -&gt; u.evaluateFor(player)).sum();</span>
	}

	/**
	 * Gets a template describing whether this work location can/needs-to be
	 * claimed. To be overridden by classes where this is meaningful.
	 *
	 * This is a default null implementation.
	 *
	 * @return A suitable template.
	 */
	public StringTemplate getClaimTemplate() {
<span class="nc" id="L897">		return StringTemplate.name(&quot;&quot;);</span>
	}

	// Interface Ownable

	/**
	 * Gets the owner of this &lt;code&gt;Ownable&lt;/code&gt;.
	 *
	 * @return The &lt;code&gt;Player&lt;/code&gt; controlling this {@link Ownable}.
	 */
	@Override
	public Player getOwner() {
<span class="fc" id="L909">		return colony.getOwner();</span>
	}

	/**
	 * Sets the owner of this &lt;code&gt;Ownable&lt;/code&gt;. Do not call this method,
	 * ever. The owner of this WorkLocation is the owner of the Colony, you must
	 * set the owner of the Colony instead.
	 *
	 * @param p
	 *            The &lt;code&gt;Player&lt;/code&gt; that should take ownership of this
	 *            {@link Ownable}.
	 * @exception UnsupportedOperationException
	 *                is always thrown by this method.
	 */
	@Override
	public void setOwner(Player p) {
<span class="nc" id="L925">		throw new UnsupportedOperationException();</span>
	}

	// Serialization

	/** The Constant COLONY_TAG. */
	private static final String COLONY_TAG = &quot;colony&quot;;

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L938">		super.writeAttributes(xw);</span>

<span class="fc" id="L940">		xw.writeAttribute(COLONY_TAG, colony);</span>
<span class="fc" id="L941">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L948">		super.writeChildren(xw);</span>

<span class="fc bfc" id="L950" title="All 2 branches covered.">		if (productionType != null)</span>
<span class="fc" id="L951">			productionType.toXML(xw);</span>
<span class="fc" id="L952">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L959">		super.readAttributes(xr);</span>

<span class="fc" id="L961">		colony = xr.findFreeColGameObject(getGame(), COLONY_TAG, Colony.class, (Colony) null, true);</span>
<span class="fc" id="L962">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void readChildren(FreeColXMLReader xr) throws XMLStreamException {

<span class="fc" id="L970">		super.readChildren(xr);</span>

<span class="fc" id="L972">		updateProductionType();</span>
<span class="fc" id="L973">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L980">		final Specification spec = getSpecification();</span>
<span class="fc" id="L981">		final String tag = xr.getLocalName();</span>

<span class="fc bfc" id="L983" title="All 2 branches covered.">		if (ProductionType.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L984">			productionType = new ProductionType(xr, spec);</span>

		} else {
<span class="fc" id="L987">			super.readChild(xr);</span>
		}
<span class="fc" id="L989">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>