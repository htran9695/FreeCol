<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Player.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Player.java</span></div><h1>Player.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.awt.Color;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Locale;
import java.util.Random;
import java.util.Set;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.i18n.NameCache;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.NationOptions.NationState;
import net.sf.freecol.common.option.OptionGroup;

import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;

import net.sf.freecol.common.util.Utils;

import org.w3c.dom.Element;

/**
 * Represents a player. The player can be either a human player or an AI-player,
 * which is further subdivided by PlayerType.
 *
 * In addition to storing the name, nation etc of the player, it also stores
 * various defaults for the player. One example of this is the
 * {@link #getEntryLocation entry location}.
 */
public class Player extends FreeColGameObject implements Nameable {

	/** The Constant logger. */
<span class="fc" id="L65">	private static final Logger logger = Logger.getLogger(Player.class.getName());</span>
	//
	// Types
	//

	/** Types of players. */
<span class="pc" id="L71">	public static enum PlayerType {</span>

		/** The native. */
<span class="fc" id="L74">		NATIVE,</span>
		/** The colonial. */
<span class="fc" id="L76">		COLONIAL,</span>
		/** The rebel. */
<span class="fc" id="L78">		REBEL,</span>
		/** The independent. */
<span class="fc" id="L80">		INDEPENDENT,</span>
		/** The royal. */
<span class="fc" id="L82">		ROYAL,</span>
		/** The undead. */
<span class="fc" id="L84">		UNDEAD,</span>
		/** The retired. */
<span class="fc" id="L86">		RETIRED</span>
	}

	/** Colony value categories. */
<span class="nc" id="L90">	public static enum ColonyValueCategory {</span>

		/** The a override. */
<span class="nc" id="L93">		A_OVERRIDE,</span>
		/** The a prod. */
		// override slot containing showstopper NoValueType values
<span class="nc" id="L96">		A_PROD,</span>
		/** The a tile. */
		// general production level
<span class="nc" id="L99">		A_TILE,</span>
		/** The a europe. */
		// strangeness with the tile
<span class="nc" id="L102">		A_EUROPE,</span>
		/** The a resource. */
		// proximity to Europe
<span class="nc" id="L105">		A_RESOURCE,</span>
		/** The a adjacent. */
		// penalize building on top of a resource
<span class="nc" id="L108">		A_ADJACENT,</span>
		/** The a food. */
		// penalize adjacent units and settlement-owned-tiles
<span class="nc" id="L111">		A_FOOD,</span>
		/** The a level. */
		// penalize food shortage
<span class="nc" id="L114">		A_LEVEL,</span>
		/** The a nearby. */
		// reward high production potential
<span class="nc" id="L117">		A_NEARBY,</span>
		/** The a goods. */
		// penalize nearby units and settlements
<span class="nc" id="L120">		A_GOODS; // check sufficient critical goods available (e.g. lumber)</span>
		// A_GOODS must be last, the spec is entitled to require checks on
		// as many goods types as it likes

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Enum#toString()
		 */
		@Override
		public String toString() {
<span class="nc" id="L131">			return super.toString().substring(2);</span>
		}
	}

	/** Special return values for showstopper getColonyValue fail. */
<span class="nc" id="L136">	public static enum NoValueType {</span>

		/** The bogus. */
<span class="nc" id="L139">		BOGUS(-1),</span>
		/** The terrain. */
<span class="nc" id="L141">		TERRAIN(-2),</span>
		/** The rumour. */
<span class="nc" id="L143">		RUMOUR(-3),</span>
		/** The settled. */
<span class="nc" id="L145">		SETTLED(-4),</span>
		/** The food. */
<span class="nc" id="L147">		FOOD(-5),</span>
		/** The inland. */
<span class="nc" id="L149">		INLAND(-6),</span>
		/** The polar. */
<span class="nc" id="L151">		POLAR(-7);</span>

		/** The Constant MAX. */
<span class="nc" id="L154">		private static final int MAX = values().length;</span>

		/** The value. */
		private final int value;

		/**
		 * Instantiates a new no value type.
		 *
		 * @param value
		 *            the value
		 */
<span class="nc" id="L165">		NoValueType(int value) {</span>
<span class="nc" id="L166">			this.value = value;</span>
<span class="nc" id="L167">		}</span>

		/**
		 * Gets the value.
		 *
		 * @return the value
		 */
		public int getValue() {
<span class="nc" id="L175">			return value;</span>
		}

		/**
		 * Gets the double.
		 *
		 * @return the double
		 */
		public double getDouble() {
<span class="nc" id="L184">			return (double) value;</span>
		}

		/**
		 * From value.
		 *
		 * @param i
		 *            the i
		 * @return the no value type
		 */
		public static NoValueType fromValue(int i) {
<span class="nc" id="L195">			int n = -i - 1;</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">			return (n &gt;= 0 &amp;&amp; n &lt; MAX) ? NoValueType.values()[n] : BOGUS;</span>
		}
	}

	/**
	 * A predicate that can be applied to a unit.
	 */
<span class="fc" id="L203">	public abstract class UnitPredicate {</span>

		/**
		 * Obtains.
		 *
		 * @param unit
		 *            the unit
		 * @return true, if successful
		 */
		public abstract boolean obtains(Unit unit);
	}

	/**
	 * A predicate for determining active units.
	 */
<span class="fc" id="L218">	public class ActivePredicate extends UnitPredicate {</span>

		/**
		 * Is the unit active and going nowhere, and thus available to be moved
		 * by the player?.
		 *
		 * @param unit
		 *            the unit
		 * @return True if the unit can be moved.
		 */
		@Override
		public boolean obtains(Unit unit) {
<span class="nc bnc" id="L230" title="All 4 branches missed.">			return unit.couldMove() &amp;&amp; unit.getState() != Unit.UnitState.SKIPPED;</span>
		}
	}

	/**
	 * A predicate for determining units going somewhere.
	 */
	public class GoingToPredicate extends UnitPredicate {

		/** The player. */
		private final Player player;

		/** The trade route. */
		private final boolean tradeRoute;

		/**
		 * Creates a new going-to predicate.
		 *
		 * @param player
		 *            The owning &lt;code&gt;Player&lt;/code&gt;.
		 * @param tradeRoute
		 *            Whether this should be a unit following a trade route.
		 */
<span class="fc" id="L253">		public GoingToPredicate(Player player, boolean tradeRoute) {</span>
<span class="fc" id="L254">			this.player = player;</span>
<span class="fc" id="L255">			this.tradeRoute = tradeRoute;</span>
<span class="fc" id="L256">		}</span>

		/**
		 * Does this unit have orders to go somewhere?.
		 *
		 * @param unit
		 *            the unit
		 * @return True if the unit has orders to go somewhere.
		 */
		@Override
		public boolean obtains(Unit unit) {
<span class="nc bnc" id="L267" title="All 6 branches missed.">			return !unit.isDisposed() &amp;&amp; unit.getOwner() == player &amp;&amp; unit.getState() != Unit.UnitState.FORTIFYING</span>
<span class="nc bnc" id="L268" title="All 6 branches missed.">					&amp;&amp; unit.getState() != Unit.UnitState.SKIPPED &amp;&amp; unit.getMovesLeft() &gt; 0 &amp;&amp; !unit.isDamaged()</span>
<span class="nc bnc" id="L269" title="All 8 branches missed.">					&amp;&amp; !unit.isAtSea() &amp;&amp; !unit.isOnCarrier() &amp;&amp; !unit.isInColony()</span>
<span class="nc bnc" id="L270" title="All 6 branches missed.">					&amp;&amp; ((!tradeRoute &amp;&amp; unit.getDestination() != null) || (tradeRoute &amp;&amp; unit.getTradeRoute() != null));</span>
		}
	}

	/**
	 * An &lt;code&gt;Iterator&lt;/code&gt; of {@link Unit}s that can be made active.
	 */
	public static class UnitIterator implements Iterator&lt;Unit&gt; {

		/** The owner. */
		private final Player owner;

		/** The predicate. */
		private final UnitPredicate predicate;

		/** The units. */
<span class="fc" id="L286">		private final List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>

		/**
		 * Creates a new &lt;code&gt;UnitIterator&lt;/code&gt;.
		 *
		 * @param owner
		 *            The &lt;code&gt;Player&lt;/code&gt; that needs an iterator of it's
		 *            units.
		 * @param predicate
		 *            An object for deciding whether a &lt;code&gt;Unit&lt;/code&gt; should
		 *            be included in the &lt;code&gt;Iterator&lt;/code&gt; or not.
		 */
<span class="fc" id="L298">		public UnitIterator(Player owner, UnitPredicate predicate) {</span>
<span class="fc" id="L299">			this.owner = owner;</span>
<span class="fc" id="L300">			this.predicate = predicate;</span>
<span class="fc" id="L301">			update();</span>
<span class="fc" id="L302">		}</span>

		/**
		 * Update the internal units list with units that satisfy the predicate.
		 */
		private final void update() {
<span class="fc" id="L308">			units.clear();</span>
<span class="pc" id="L309">			units.addAll(owner.getUnits().stream().filter(u -&gt; predicate.obtains(u)).sorted(Unit.locComparator)</span>
<span class="fc" id="L310">					.collect(Collectors.toList()));</span>
<span class="fc" id="L311">		}</span>

		/**
		 * Set the next valid unit.
		 *
		 * @param unit
		 *            The &lt;code&gt;Unit&lt;/code&gt; to put at the front of the list.
		 * @return True if the operation succeeds.
		 */
		public boolean setNext(Unit unit) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">			if (predicate.obtains(unit)) { // Of course, it has to be valid...</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">				Unit first = (units.isEmpty()) ? null : units.get(0);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">				while (!units.isEmpty()) {</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">					if (units.get(0) == unit) {</span>
<span class="nc" id="L325">						return true;</span>
					}
<span class="nc" id="L327">					units.remove(0);</span>
				}
<span class="nc" id="L329">				update();</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">				while (!units.isEmpty() &amp;&amp; units.get(0) != first) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">					if (units.get(0) == unit) {</span>
<span class="nc" id="L332">						return true;</span>
					}
<span class="nc" id="L334">					units.remove(0);</span>
				}
			}
<span class="nc" id="L337">			return false;</span>
		}

		/**
		 * Removes a specific unit from this unit iterator.
		 *
		 * @param u
		 *            The &lt;code&gt;Unit&lt;/code&gt; to remove.
		 * @return True if the unit was removed.
		 */
		public boolean remove(Unit u) {
<span class="fc" id="L348">			return units.remove(u);</span>
		}

		/**
		 * Reset the iterator.
		 */
		public void reset() {
<span class="nc" id="L355">			update();</span>
<span class="nc" id="L356">		}</span>

		// Implement Iterator

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasNext() {
			// Try to find a unit that still satisfies the predicate.
<span class="nc bnc" id="L366" title="All 2 branches missed.">			while (!units.isEmpty()) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">				if (predicate.obtains(units.get(0))) {</span>
<span class="nc" id="L368">					return true; // Still valid</span>
				}
<span class="nc" id="L370">				units.remove(0);</span>
			}
			// Nothing left, so refill the units list. If it is still
			// empty then there is definitely nothing left.
<span class="nc" id="L374">			update();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">			return !units.isEmpty();</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Unit next() {
<span class="nc bnc" id="L383" title="All 2 branches missed.">			return (hasNext()) ? units.remove(0) : null;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void remove() {
<span class="nc" id="L391">			next(); // Ignore value</span>
<span class="nc" id="L392">		}</span>
	}

	//
	// Constants
	//

	/** A comparator for ordering players. */
<span class="fc" id="L400">	public static final Comparator&lt;Player&gt; playerComparator = new Comparator&lt;Player&gt;() {</span>
		@Override
		public int compare(Player player1, Player player2) {
<span class="fc" id="L403">			int counter1 = 0;</span>
<span class="fc" id="L404">			int counter2 = 0;</span>

<span class="pc bpc" id="L406" title="1 of 2 branches missed.">			if (player1.isAdmin()) {</span>
<span class="nc" id="L407">				counter1 += 8;</span>
			}
<span class="fc bfc" id="L409" title="All 2 branches covered.">			if (!player1.isAI()) {</span>
<span class="fc" id="L410">				counter1 += 4;</span>
			}
<span class="fc bfc" id="L412" title="All 2 branches covered.">			if (player1.isEuropean()) {</span>
<span class="fc" id="L413">				counter1 += 2;</span>
			}
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">			if (player2.isAdmin()) {</span>
<span class="nc" id="L416">				counter2 += 8;</span>
			}
<span class="fc bfc" id="L418" title="All 2 branches covered.">			if (!player2.isAI()) {</span>
<span class="fc" id="L419">				counter2 += 4;</span>
			}
<span class="fc bfc" id="L421" title="All 2 branches covered.">			if (player2.isEuropean()) {</span>
<span class="fc" id="L422">				counter2 += 2;</span>
			}

<span class="fc" id="L425">			return counter2 - counter1;</span>
		}
	};

	/** A magic constant to denote that a players gold is not tracked. */
	public static final int GOLD_NOT_ACCOUNTED = Integer.MIN_VALUE;

	/**
	 * A token to use for the settlement name in requests to the server to ask
	 * the server to choose a settlement name.
	 */
	public static final String ASSIGN_SETTLEMENT_NAME = &quot;&quot;;

	//
	// Class variables
	//

	/**
	 * The name of this player. This defaults to the user name in case of a
	 * human player and the rulerName of the NationType in case of an AI player.
	 */
	protected String name;

	/** The name of this player as an independent nation. */
	protected String independentNationName;

	/** The type of player. */
	protected PlayerType playerType;

	/** The player nation type. */
	protected NationType nationType;

	/** The nation identifier of this player, e.g. &quot;model.nation.dutch&quot;. */
	protected String nationId;

	/** The name this player uses for the New World. */
<span class="pc" id="L461">	protected String newLandName = null;</span>

	/** Is this player an admin?. */
	protected boolean admin;

	/** Is this player an AI?. */
	protected boolean ai;

	/** Is this player ready to start?. */
	protected boolean ready;

	/** Is this player dead?. */
<span class="pc" id="L473">	protected boolean dead = false;</span>

	/** True if player has been attacked by privateers. */
<span class="pc" id="L476">	protected boolean attackedByPrivateers = false;</span>

	/**
	 * Whether the player is bankrupt, i.e. unable to pay for the maintenance of
	 * all buildings.
	 */
	private boolean bankrupt;

	/** The current score of this player. */
	protected int score;

	/** The amount of gold this player owns. */
	protected int gold;

	/**
	 * The number of immigration points. Immigration points are an abstract game
	 * concept. They are generated by but are not identical to crosses.
	 */
	protected int immigration;

	/**
	 * The amount of immigration needed until the next unit decides to migrate.
	 */
	protected int immigrationRequired;

	/**
	 * The number of liberty points. Liberty points are an abstract game
	 * concept. They are generated by but are not identical to bells.
	 */
	protected int liberty;

	/** SoL from last turn. */
<span class="pc" id="L508">	protected int oldSoL = 0;</span>

	/** The number of liberty bells produced towards the intervention force. */
	protected int interventionBells;

	/** The current tax rate for this player. */
<span class="pc" id="L514">	protected int tax = 0;</span>

	/** The player starting location on the map. */
	protected Location entryLocation;

	/** The market for Europe. */
	protected Market market;

	/** The European port/location for this player. */
	protected Europe europe;

	/** The monarch for this player. */
	protected Monarch monarch;

	/** The founding fathers in this Player's congress. */
<span class="pc" id="L529">	protected final Set&lt;FoundingFather&gt; foundingFathers = new HashSet&lt;&gt;();</span>
	/** Current founding father being recruited. */
	protected FoundingFather currentFather;
	/** The offered founding fathers. */
<span class="pc" id="L533">	protected final List&lt;FoundingFather&gt; offeredFathers = new ArrayList&lt;&gt;();</span>

	/**
	 * The tension levels, 0-1000, with 1000 being maximum hostility.
	 *
	 * Only used by AI, but resist the temptation to move it to AIPlayer, the
	 * complexity is not worth it.
	 */
<span class="pc" id="L541">	protected final java.util.Map&lt;Player, Tension&gt; tension = new HashMap&lt;&gt;();</span>

	/** A list of players who can not establish missions to this player. */
<span class="pc" id="L544">	protected Set&lt;Player&gt; bannedMissions = null;</span>

	/**
	 * Stores the stance towards the other players. One of: WAR, CEASE_FIRE,
	 * PEACE and ALLIANCE.
	 */
<span class="pc" id="L550">	protected final java.util.Map&lt;String, Stance&gt; stance = new HashMap&lt;&gt;();</span>

	/** The trade routes defined by this player. */
<span class="pc" id="L553">	protected final List&lt;TradeRoute&gt; tradeRoutes = new ArrayList&lt;&gt;();</span>

	/** The current model messages for this player. */
<span class="pc" id="L556">	protected final List&lt;ModelMessage&gt; modelMessages = new ArrayList&lt;&gt;();</span>

	/** The history events occuring with this player. */
<span class="pc" id="L559">	protected final List&lt;HistoryEvent&gt; history = new ArrayList&lt;&gt;();</span>

	/** The last-sale data. */
<span class="pc" id="L562">	protected HashMap&lt;String, LastSale&gt; lastSales = null;</span>

	// Temporary/transient variables, do not serialize.

	/** The units this player owns. */
<span class="pc" id="L567">	private final List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>

	/** The settlements this player owns. */
<span class="pc" id="L570">	protected final List&lt;Settlement&gt; settlements = new ArrayList&lt;&gt;();</span>

	/** The tiles the player can see. */
<span class="pc" id="L573">	private boolean[][] canSeeTiles = null;</span>

	/** Are the canSeeTiles valid or do they need to be recalculated?. */
<span class="pc" id="L576">	private boolean canSeeValid = false;</span>
	/** Do not access canSeeTiles without taking canSeeLock. */
<span class="pc" id="L578">	private final Object canSeeLock = new Object();</span>

	/** A container for the abilities and modifiers of this type. */
<span class="pc" id="L581">	protected final FeatureContainer featureContainer = new FeatureContainer();</span>

	/** The maximum food consumption of unit types available to this player. */
<span class="pc" id="L584">	private int maximumFoodConsumption = -1;</span>

	/** An iterator for the player units that are still active this turn. */
<span class="pc" id="L587">	private final UnitIterator nextActiveUnitIterator = new UnitIterator(this, new ActivePredicate());</span>

	/** An iterator for the player units that have a destination to go to. */
<span class="pc" id="L590">	private final UnitIterator nextGoingToUnitIterator = new UnitIterator(this, new GoingToPredicate(this, false));</span>

	/** An iterator for the player units that have a trade route to follow. */
<span class="pc" id="L593">	private final UnitIterator nextTradeRouteUnitIterator = new UnitIterator(this, new GoingToPredicate(this, true));</span>

	/**
	 * The HighSeas is a Location that enables Units to travel between the New
	 * World and one or several European Ports.
	 */
<span class="pc" id="L599">	protected HighSeas highSeas = null;</span>

	/** A cached map of the current nation summary for all live nations. */
<span class="pc" id="L602">	private final java.util.Map&lt;Player, NationSummary&gt; nationCache = new HashMap&lt;&gt;();</span>

	//
	// Constructors
	//

	/**
	 * Constructor for ServerPlayer.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 */
	protected Player(Game game) {
<span class="fc" id="L615">		super(game);</span>
<span class="fc" id="L616">	}</span>

	/**
	 * Initiates a new &lt;code&gt;Player&lt;/code&gt; from an &lt;code&gt;Element&lt;/code&gt; and
	 * registers this &lt;code&gt;Player&lt;/code&gt; at the specified game.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param e
	 *            An XML-element that will be used to initialize this object.
	 *
	 */
	public Player(Game game, Element e) {
<span class="nc" id="L629">		super(game, null);</span>

<span class="nc" id="L631">		readFromXMLElement(e);</span>
<span class="nc" id="L632">	}</span>

	/**
	 * Creates a new &lt;code&gt;Player&lt;/code&gt; with the given id. The object should
	 * later be initialized by calling either
	 * {@link #readFromXML(FreeColXMLReader)} or
	 * {@link #readFromXMLElement(Element)}.
	 *
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; this object belongs to.
	 * @param id
	 *            The object identifier.
	 */
	public Player(Game game, String id) {
<span class="fc" id="L646">		super(game, id);</span>
<span class="fc" id="L647">	}</span>

	//
	// Names and naming
	//

	/**
	 * Gets the name of this player.
	 *
	 * @return The name of this player.
	 */
	@Override
	public String getName() {
<span class="fc" id="L660">		return name;</span>
	}

	/**
	 * Set the player name.
	 *
	 * @param newName
	 *            The new name value.
	 */
	@Override
	public void setName(String newName) {
<span class="fc" id="L671">		this.name = newName;</span>
<span class="fc" id="L672">	}</span>

	/**
	 * Get a label for this player.
	 *
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
	 */
	public StringTemplate getLabel() {
<span class="nc" id="L680">		return StringTemplate.label(&quot;&quot;).add(getRulerNameKey()).addName(&quot; (&quot;).addStringTemplate(getNationLabel())</span>
<span class="nc" id="L681">				.addName(&quot;)&quot;);</span>
	}

	/**
	 * Is this player the unknown enemy?.
	 *
	 * @return True if this player is the unknown enemy.
	 */
	public boolean isUnknownEnemy() {
<span class="fc" id="L690">		return Nation.UNKNOWN_NATION_ID.equals(nationId);</span>
	}

	/**
	 * Get the new post-declaration player name.
	 *
	 * @return The post-declaration player name.
	 */
	public final String getIndependentNationName() {
<span class="nc" id="L699">		return independentNationName;</span>
	}

	/**
	 * Set the post-declaration player name.
	 *
	 * @param newIndependentNationName
	 *            The new player name.
	 */
	public final void setIndependentNationName(final String newIndependentNationName) {
<span class="fc" id="L709">		this.independentNationName = newIndependentNationName;</span>
<span class="fc" id="L710">	}</span>

	/**
	 * Gets the name this player has chosen for the new world.
	 *
	 * @return The name of the new world as chosen by the &lt;code&gt;Player&lt;/code&gt;,
	 *         or null if none chosen yet.
	 */
	public String getNewLandName() {
<span class="fc" id="L719">		return newLandName;</span>
	}

	/**
	 * Has the player already selected a name for the new world?.
	 *
	 * @return True if the new world has been named by this player.
	 */
	public boolean isNewLandNamed() {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">		return newLandName != null;</span>
	}

	/**
	 * Sets the name this player uses for the new world.
	 *
	 * @param newLandName
	 *            This &lt;code&gt;Player&lt;/code&gt;'s name for the new world.
	 */
	public void setNewLandName(String newLandName) {
<span class="fc" id="L738">		this.newLandName = newLandName;</span>
<span class="fc" id="L739">	}</span>

	/**
	 * Get a name for the new land.
	 *
	 * @return A suitable name.
	 */
	public String getNameForNewLand() {
<span class="fc" id="L747">		return NameCache.getNewLandName(this);</span>
	}

	/**
	 * Get a name key for the player Europe.
	 *
	 * @return A name key, or null if Europe is null.
	 */
	public String getEuropeNameKey() {
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">		return (europe == null) ? null : nationId + &quot;.europe&quot;;</span>
	}

	/**
	 * Gets a resource key for the nation name.
	 *
	 * @return A nation resource key.
	 */
	public String getNationResourceKey() {
<span class="nc" id="L765">		return lastPart(nationId, &quot;.&quot;).toUpperCase(Locale.US);</span>
	}

	/**
	 * Get a template for this players nation name.
	 *
	 * @return A template for this nation name.
	 */
	public StringTemplate getNationLabel() {
<span class="pc bpc" id="L774" title="1 of 4 branches missed.">		return (playerType == PlayerType.REBEL || playerType == PlayerType.INDEPENDENT)</span>
<span class="fc" id="L775">				? StringTemplate.name(independentNationName) : StringTemplate.key(Messages.nameKey(nationId));</span>
	}

	/**
	 * Get a template for this players country.
	 *
	 * @return A template for this country.
	 */
	public StringTemplate getCountryLabel() {
<span class="nc bnc" id="L784" title="All 4 branches missed.">		return (playerType == PlayerType.REBEL || playerType == PlayerType.INDEPENDENT)</span>
<span class="nc" id="L785">				? StringTemplate.name(independentNationName)</span>
<span class="nc" id="L786">				: StringTemplate.template(&quot;countryName&quot;).addStringTemplate(&quot;%nation%&quot;, getNationLabel());</span>
	}

	/**
	 * Get a label indicating for the national forces.
	 *
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
	 */
	public StringTemplate getForcesLabel() {
<span class="nc" id="L795">		return StringTemplate.template(&quot;model.player.forces&quot;).addStringTemplate(&quot;%nation%&quot;, getNationLabel());</span>
	}

	/**
	 * Get a label indicating that we are waiting for this player.
	 *
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
	 */
	public StringTemplate getWaitingLabel() {
<span class="nc" id="L804">		return StringTemplate.template(&quot;model.player.waitingFor&quot;).addStringTemplate(&quot;%nation%&quot;, getNationLabel());</span>
	}

	/**
	 * Get a short debug-suitable name for this player.
	 *
	 * @return A short name for this player.
	 */
	public String getDebugName() {
<span class="fc" id="L813">		return getNation().getSuffix();</span>
	}

	/**
	 * Get a name key for the player nation ruler.
	 *
	 * @return The ruler name key.
	 */
	public final String getRulerNameKey() {
<span class="nc" id="L822">		return Messages.rulerKey(nationId);</span>
	}

	/**
	 * Get a resource key for the player monarch image.
	 *
	 * @return The monarch image key.
	 */
	public String getMonarchKey() {
<span class="nc" id="L831">		return &quot;image.flavor.monarch.&quot; + nationId;</span>
	}

	/**
	 * What is the name of the player's market? Following a declaration of
	 * independence we are assumed to trade broadly with any European market
	 * rather than a specific port.
	 *
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the player market.
	 */
	public StringTemplate getMarketName() {
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">		return (getEurope() == null) ? StringTemplate.key(&quot;model.player.independentMarket&quot;)</span>
<span class="fc" id="L843">				: StringTemplate.key(getEuropeNameKey());</span>
	}

	/**
	 * Gets the name of this players capital. Only meaningful to natives.
	 *
	 * @param random
	 *            An optional pseudo-random number source.
	 * @return The name of this players capital.
	 */
	public String getCapitalName(Random random) {
<span class="fc" id="L854">		return NameCache.getCapitalName(this, random);</span>
	}

	/**
	 * Gets a settlement name suitable for this player.
	 *
	 * @param random
	 *            An optional pseudo-random number source.
	 * @return A new settlement name.
	 */
	public String getSettlementName(Random random) {
<span class="fc" id="L865">		return NameCache.getSettlementName(this, random);</span>
	}

	/**
	 * Puts a suggested settlement name back into the pool.
	 *
	 * @param name
	 *            A formerly suggested settlement name.
	 */
	public void putSettlementName(String name) {
<span class="nc" id="L875">		NameCache.putSettlementName(this, name);</span>
<span class="nc" id="L876">	}</span>

	/**
	 * Get a name for a region.
	 *
	 * @param region
	 *            The &lt;code&gt;Region&lt;/code&gt; to name.
	 * @return A suitable name.
	 */
	public String getNameForRegion(Region region) {
<span class="nc" id="L886">		return NameCache.getRegionName(this, region);</span>
	}

	/**
	 * Gets a new name for a unit.
	 *
	 * @param type
	 *            The &lt;code&gt;UnitType&lt;/code&gt; to choose a name for.
	 * @param random
	 *            A pseudo-random number source.
	 * @return A name for the unit, or null if not available.
	 */
	public String getNameForUnit(UnitType type, Random random) {
<span class="fc" id="L899">		return NameCache.getUnitName(this, type, random);</span>
	}

	//
	// Player / nation types and the implications thereof
	//

	/**
	 * Get the type of this player.
	 *
	 * @return The player type.
	 */
	public PlayerType getPlayerType() {
<span class="fc" id="L912">		return playerType;</span>
	}

	/**
	 * Sets the player type.
	 *
	 * @param type
	 *            The new player type.
	 * @see #getPlayerType
	 */
	private void setPlayerType(PlayerType type) {
<span class="fc" id="L923">		playerType = type;</span>
<span class="fc" id="L924">	}</span>

	/**
	 * Change the player type.
	 *
	 * Handle special abilities that are added following declaration of
	 * independence. Do not bother removing them ATM, only cases are when going
	 * undead and retiring where they are moot.
	 *
	 * @param type
	 *            The new player type.
	 */
	public void changePlayerType(PlayerType type) {
<span class="pc bpc" id="L937" title="2 of 4 branches missed.">		if (playerType != PlayerType.REBEL &amp;&amp; playerType != PlayerType.INDEPENDENT) {</span>
<span class="pc bfc" id="L938" title="All 2 branches covered.">			switch (type) {</span>
			case REBEL:
			case INDEPENDENT:
<span class="fc" id="L941">				addAbility(new Ability(Ability.INDEPENDENCE_DECLARED, true));</span>
<span class="fc" id="L942">				addAbility(new Ability(Ability.INDEPENDENT_NATION, true));</span>
<span class="fc" id="L943">				break;</span>
			default:
				break;
			}
		}

<span class="fc" id="L949">		setPlayerType(type);</span>
<span class="fc" id="L950">	}</span>

	/**
	 * Checks if this player is colonial, and thus can recruit units by
	 * producing immigration.
	 *
	 * @return True if this player is colonial.
	 */
	public boolean isColonial() {
<span class="fc bfc" id="L959" title="All 2 branches covered.">		return playerType == PlayerType.COLONIAL;</span>
	}

	/**
	 * Checks if this player is European, with does include the REF.
	 *
	 * @return True if this player is European.
	 */
	public boolean isEuropean() {
<span class="pc bpc" id="L968" title="1 of 8 branches missed.">		return playerType == PlayerType.COLONIAL || playerType == PlayerType.REBEL</span>
				|| playerType == PlayerType.INDEPENDENT || playerType == PlayerType.ROYAL;
	}

	/**
	 * Is this a native player?.
	 *
	 * @return True if this player is a native player.
	 */
	public boolean isIndian() {
<span class="fc bfc" id="L978" title="All 2 branches covered.">		return playerType == PlayerType.NATIVE;</span>
	}

	/**
	 * Is this a colonial rebel player?.
	 *
	 * @return True if this player is a rebel player.
	 */
	public boolean isRebel() {
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">		return playerType == PlayerType.REBEL;</span>
	}

	/**
	 * Is this an undead player?.
	 *
	 * @return True if this player is undead.
	 */
	public boolean isUndead() {
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">		return playerType == PlayerType.UNDEAD;</span>
	}

	/**
	 * Is this a REF player?.
	 *
	 * @return True if this is a REF player.
	 */
	public boolean isREF() {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">		return playerType == PlayerType.ROYAL;</span>
	}

	/**
	 * Is this player currently on good terms with a given player, and thus a
	 * suitable candidate for a random monarch war declaration?.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to possibly declare war on.
	 * @return True if this player is a potential enemy.
	 */
	public boolean isPotentialEnemy(Player player) {
<span class="pc bpc" id="L1017" title="1 of 4 branches missed.">		if (!hasAbility(Ability.IGNORE_EUROPEAN_WARS) &amp;&amp; player.getREFPlayer() != this) {</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">			switch (getStance(player)) {</span>
			case PEACE:
			case CEASE_FIRE:
<span class="nc" id="L1021">				return true;</span>
			default:
				break;
			}
		}
<span class="fc" id="L1026">		return false;</span>
	}

	/**
	 * Is this player currently on bad terms with a given player, and thus a
	 * suitable candidate for a random monarch peace declaration?.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to possibly declare peace with.
	 * @return True if this player is a potential friend.
	 */
	public boolean isPotentialFriend(Player player) {
<span class="fc bfc" id="L1038" title="All 2 branches covered.">		if (player.getREFPlayer() != this) {</span>
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">			switch (getStance(player)) {</span>
			case WAR:
			case CEASE_FIRE:
<span class="nc" id="L1042">				return true;</span>
			default:
				break;
			}
		}
<span class="fc" id="L1047">		return false;</span>
	}

	/**
	 * Get the nation type of this player.
	 *
	 * @return The &lt;code&gt;NationType&lt;/code&gt; of this player.
	 */
	public NationType getNationType() {
<span class="fc" id="L1056">		return nationType;</span>
	}

	/**
	 * Sets the nation type of this player.
	 *
	 * @param newNationType
	 *            The new &lt;code&gt;NationType&lt;/code&gt;.
	 */
	public void setNationType(NationType newNationType) {
<span class="fc" id="L1066">		nationType = newNationType;</span>
<span class="fc" id="L1067">	}</span>

	/**
	 * Changes the nation type of this player, handling the features.
	 *
	 * @param newNationType
	 *            The new &lt;code&gt;NationType&lt;/code&gt;.
	 */
	public void changeNationType(NationType newNationType) {
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">		if (nationType != null) {</span>
<span class="fc" id="L1077">			removeFeatures(nationType);</span>
		}
<span class="fc" id="L1079">		setNationType(newNationType);</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">		if (newNationType != null) {</span>
<span class="fc" id="L1081">			addFeatures(newNationType);</span>
		}
<span class="fc" id="L1083">	}</span>

	/**
	 * Can this player build colonies?.
	 *
	 * @return True if this player can found colonies.
	 */
	public boolean canBuildColonies() {
<span class="fc" id="L1091">		return nationType.hasAbility(Ability.FOUNDS_COLONIES);</span>
	}

	/**
	 * Can this player recruit founding fathers?.
	 *
	 * @return True if this player can recruit founding fathers.
	 */
	public boolean canHaveFoundingFathers() {
<span class="fc" id="L1100">		return nationType.hasAbility(Ability.ELECT_FOUNDING_FATHER);</span>
	}

	/**
	 * Get the identifier for this Player's nation.
	 *
	 * @return The nation identifier.
	 */
	public String getNationId() {
<span class="fc" id="L1109">		return nationId;</span>
	}

	/**
	 * Gets this Player's nation.
	 *
	 * @return The player &lt;code&gt;Nation&lt;/code&gt;.
	 */
	public Nation getNation() {
<span class="fc" id="L1118">		return getSpecification().getNation(nationId);</span>
	}

	/**
	 * Sets the nation for this player.
	 *
	 * @param newNation
	 *            The new &lt;code&gt;Nation&lt;/code&gt;.
	 */
	public void setNation(Nation newNation) {
<span class="nc" id="L1128">		Nation oldNation = getNation();</span>
<span class="nc" id="L1129">		nationId = newNation.getId();</span>
<span class="nc" id="L1130">		java.util.Map&lt;Nation, NationState&gt; nations = getGame().getNationOptions().getNations();</span>
<span class="nc" id="L1131">		nations.put(oldNation, NationState.AVAILABLE);</span>
<span class="nc" id="L1132">		nations.put(newNation, NationState.NOT_AVAILABLE);</span>
<span class="nc" id="L1133">	}</span>

	/**
	 * Is this player an admin.
	 *
	 * @return True if the player is an admin.
	 */
	public boolean isAdmin() {
<span class="fc" id="L1141">		return admin;</span>
	}

	/**
	 * Is this an AI player?.
	 *
	 * @return True if this is an AI player.
	 */
	public boolean isAI() {
<span class="fc" id="L1150">		return ai;</span>
	}

	/**
	 * Sets whether this player is an AI player.
	 *
	 * @param ai
	 *            The AI player value.
	 */
	public void setAI(boolean ai) {
<span class="fc" id="L1160">		this.ai = ai;</span>
<span class="fc" id="L1161">	}</span>

	/**
	 * Is this player ready to start the game?.
	 *
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; is ready to start the game.
	 */
	public boolean isReady() {
<span class="nc" id="L1169">		return ready;</span>
	}

	/**
	 * Sets this players readiness state.
	 *
	 * @param ready
	 *            The new readiness state.
	 */
	public void setReady(boolean ready) {
<span class="nc" id="L1179">		this.ready = ready;</span>
<span class="nc" id="L1180">	}</span>

	/**
	 * Checks if this player is dead. A &lt;code&gt;Player&lt;/code&gt; dies when it loses
	 * the game.
	 *
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; is dead.
	 */
	public boolean isDead() {
<span class="fc" id="L1189">		return dead;</span>
	}

	/**
	 * Get the player death state. This is indeed identical to isDead(), but is
	 * needed for partial updates to complement the setDead() function.
	 *
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; is dead.
	 */
	public boolean getDead() {
<span class="nc" id="L1199">		return dead;</span>
	}

	/**
	 * Sets this player to be dead or not.
	 *
	 * @param dead
	 *            The new death state.
	 * @see #getDead
	 */
	public void setDead(boolean dead) {
<span class="nc" id="L1210">		this.dead = dead;</span>
<span class="nc" id="L1211">	}</span>

	/**
	 * Has player has been attacked by privateers?.
	 *
	 * @return True if this player has been attacked by privateers.
	 */
	public boolean getAttackedByPrivateers() {
<span class="fc" id="L1219">		return attackedByPrivateers;</span>
	}

	/**
	 * Sets whether this player has been attacked by privateers.
	 *
	 * @param attacked
	 *            True if the player has been attacked by privateers.
	 */
	public void setAttackedByPrivateers(boolean attacked) {
<span class="fc" id="L1229">		attackedByPrivateers = attacked;</span>
<span class="fc" id="L1230">	}</span>

	/**
	 * Checks if this player has work to do if it is a REF-player.
	 *
	 * @return True if any of our units are located in the new world or a nation
	 *         is in rebellion against us.
	 */
	public boolean isWorkForREF() {
<span class="nc bnc" id="L1239" title="All 2 branches missed.">		return (any(getUnits(), Unit::hasTile)) ? true // Work to do still if</span>
														// there exists a unit
														// in the new world
<span class="nc bnc" id="L1242" title="All 2 branches missed.">				: !getRebels().isEmpty();</span>
	}

	/**
	 * Gets a list of the players in rebellion against this (REF) player.
	 *
	 * @return A list of nations in rebellion against us.
	 */
	public List&lt;Player&gt; getRebels() {
<span class="nc" id="L1251">		return getGame().getLiveEuropeanPlayers(this).stream()</span>
<span class="nc bnc" id="L1252" title="All 6 branches missed.">				.filter(p -&gt; p.getREFPlayer() == this &amp;&amp; (p.isRebel() || p.isUndead())).collect(Collectors.toList());</span>
	}

	/**
	 * Gets the &lt;code&gt;Player&lt;/code&gt; controlling the &quot;Royal Expeditionary Force&quot;
	 * for this player.
	 *
	 * @return The player, or &lt;code&gt;null&lt;/code&gt; if this player does not have a
	 *         royal expeditionary force.
	 */
	public Player getREFPlayer() {
<span class="fc" id="L1263">		Nation ref = getNation().getREFNation();</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">		return (ref == null) ? null : getGame().getPlayerByNation(ref);</span>
	}

	/**
	 * Gets the player nation color.
	 *
	 * @return The &lt;code&gt;Color&lt;/code&gt;.
	 */
	public Color getNationColor() {
<span class="nc" id="L1273">		final Nation nation = getNation();</span>
<span class="nc" id="L1274">		Color color = nation.getColor();</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">		return (color != null) ? color : nation.forceDefaultColor();</span>
	}

	//
	// Scoring and finance
	//

	/**
	 * Gets the current score of the player.
	 *
	 * @return The score.
	 */
	public int getScore() {
<span class="fc" id="L1288">		return score;</span>
	}

	/**
	 * Set the current score of the player.
	 *
	 * @param score
	 *            The new score.
	 */
	public void setScore(int score) {
<span class="nc" id="L1298">		this.score = score;</span>
<span class="nc" id="L1299">	}</span>

	/**
	 * Gets the score by which we decide the weakest and strongest AI players
	 * for the Spanish Succession event.
	 *
	 * @return A strength score.
	 */
	public int getSpanishSuccessionScore() {
<span class="nc" id="L1308">		return getScore();</span>
	}

	/**
	 * Get the amount of gold that this player has.
	 *
	 * Some players do not account their gold. These players return
	 * GOLD_NOT_ACCOUNTED.
	 *
	 * @return The amount of gold that this player has.
	 */
	public int getGold() {
<span class="fc" id="L1320">		return gold;</span>
	}

	/**
	 * Set the amount of gold that this player has.
	 *
	 * @param newGold
	 *            The new player gold value.
	 */
	public void setGold(int newGold) {
<span class="fc" id="L1330">		gold = newGold;</span>
<span class="fc" id="L1331">	}</span>

	/**
	 * Checks if the player has enough gold to make a purchase. Use this rather
	 * than comparing with getGold(), as this handles players that do not
	 * account for gold.
	 *
	 * @param amount
	 *            The purchase price to check.
	 * @return True if the player can afford the purchase.
	 */
	public boolean checkGold(int amount) {
<span class="fc bfc" id="L1343" title="All 4 branches covered.">		return this.gold == GOLD_NOT_ACCOUNTED || this.gold &gt;= amount;</span>
	}

	/**
	 * Modifies the amount of gold that this player has. The argument can be
	 * both positive and negative.
	 *
	 * @param amount
	 *            The amount of gold to be added to this player.
	 * @return The amount of gold post-modification.
	 */
	public int modifyGold(int amount) {
<span class="fc bfc" id="L1355" title="All 2 branches covered.">		if (this.gold != Player.GOLD_NOT_ACCOUNTED) {</span>
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">			if ((gold + amount) &gt;= 0) {</span>
<span class="fc" id="L1357">				gold += amount;</span>
			} else {
				// This can happen if the server and the client get
				// out of sync. Perhaps it can also happen if the
				// client tries to adjust gold for another player,
				// where the balance is unknown. Just keep going and
				// do the best thing possible, we don't want to crash
				// the game here.
<span class="nc" id="L1365">				logger.warning(&quot;Cannot add &quot; + amount + &quot; gold for &quot; + this + &quot;: would be negative!&quot;);</span>
<span class="nc" id="L1366">				gold = 0;</span>
			}
		}
<span class="fc" id="L1369">		return gold;</span>
	}

	/**
	 * Get the bankruptcy state.
	 *
	 * isBankrupt would be nicer, but the introspector expects getBankrupt.
	 *
	 * @return True if this player is bankrupt.
	 */
	public final boolean getBankrupt() {
<span class="nc" id="L1380">		return bankrupt;</span>
	}

	/**
	 * Set the bankruptcy state.
	 *
	 * @param newBankrupt
	 *            The new bankruptcy value.
	 */
	public final void setBankrupt(final boolean newBankrupt) {
<span class="nc" id="L1390">		this.bankrupt = newBankrupt;</span>
<span class="nc" id="L1391">	}</span>

	//
	// Migration
	//

	/**
	 * Gets the amount of immigration this player possess.
	 *
	 * @return The immigration value.
	 * @see #reduceImmigration
	 */
	public int getImmigration() {
<span class="fc bfc" id="L1404" title="All 2 branches covered.">		return (isColonial()) ? immigration : 0;</span>
	}

	/**
	 * Sets the amount of immigration this player possess.
	 *
	 * @param immigration
	 *            The immigration value for this player.
	 */
	public void setImmigration(int immigration) {
<span class="nc bnc" id="L1414" title="All 2 branches missed.">		if (!isColonial()) {</span>
<span class="nc" id="L1415">			return;</span>
		}
<span class="nc" id="L1417">		this.immigration = immigration;</span>
<span class="nc" id="L1418">	}</span>

	/**
	 * Sets the number of immigration this player possess.
	 */
	public void reduceImmigration() {
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">		if (!isColonial()) {</span>
<span class="nc" id="L1425">			return;</span>
		}

<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">		int cost = getSpecification().getBoolean(GameOptions.SAVE_PRODUCTION_OVERFLOW) ? immigrationRequired</span>
				: immigration;
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">		if (cost &gt; immigration) {</span>
<span class="nc" id="L1431">			immigration = 0;</span>
		} else {
<span class="fc" id="L1433">			immigration -= cost;</span>
		}
<span class="fc" id="L1435">	}</span>

	/**
	 * Modify the player immigration.
	 *
	 * @param amount
	 *            The amount to modify the immigration by.
	 */
	public void modifyImmigration(int amount) {
<span class="fc" id="L1444">		immigration = Math.max(0, immigration + amount);</span>
<span class="fc" id="L1445">	}</span>

	/**
	 * Gets the amount of immigration required to cause a new colonist to
	 * emigrate.
	 *
	 * @return The immigration points required to trigger emigration.
	 */
	public int getImmigrationRequired() {
<span class="fc" id="L1454">		return immigrationRequired;</span>
	}

	/**
	 * Sets the number of immigration required to cause a new colonist to
	 * emigrate.
	 *
	 * @param immigrationRequired
	 *            The new number of immigration points.
	 */
	public void setImmigrationRequired(int immigrationRequired) {
<span class="nc" id="L1465">		this.immigrationRequired = immigrationRequired;</span>
<span class="nc" id="L1466">	}</span>

	/**
	 * Updates the amount of immigration needed to emigrate a &lt;code&gt;Unit&lt;/code&gt;
	 * from &lt;code&gt;Europe&lt;/code&gt;.
	 */
	public void updateImmigrationRequired() {
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">		if (!isColonial()) {</span>
<span class="nc" id="L1474">			return;</span>
		}

<span class="fc" id="L1477">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1478">		final Turn turn = getGame().getTurn();</span>
<span class="fc" id="L1479">		final int current = immigrationRequired;</span>
<span class="fc" id="L1480">		int base = spec.getInteger(GameOptions.CROSSES_INCREMENT);</span>
		// If the religious unrest bonus is present, immigrationRequired
		// has already been reduced. We want to apply the bonus to the
		// sum of the *unreduced* immigration target and the increment.
<span class="fc" id="L1484">		int unreduced = Math.round(current / applyModifiers(1f, turn, Modifier.RELIGIOUS_UNREST_BONUS));</span>
<span class="fc" id="L1485">		immigrationRequired = (int) applyModifiers(unreduced + base, turn, Modifier.RELIGIOUS_UNREST_BONUS);</span>
		;
<span class="fc" id="L1487">		logger.finest(&quot;Immigration for &quot; + getId() + &quot; updated &quot; + current + &quot; -&gt; &quot; + immigrationRequired);</span>
<span class="fc" id="L1488">	}</span>

	/**
	 * Should a new colonist emigrate?.
	 *
	 * @return Whether a new colonist should emigrate.
	 */
	public boolean checkEmigrate() {
<span class="pc bpc" id="L1496" title="1 of 4 branches missed.">		return (isColonial()) ? getImmigrationRequired() &lt;= immigration : false;</span>
	}

	/**
	 * Get the total immigration production for this player.
	 *
	 * @return The total immigration production.
	 */
	public int getTotalImmigrationProduction() {
<span class="nc bnc" id="L1505" title="All 2 branches missed.">		if (!isColonial()) {</span>
<span class="nc" id="L1506">			return 0;</span>
		}

<span class="nc" id="L1509">		final List&lt;GoodsType&gt; immigrationGoodsTypes = getSpecification().getImmigrationGoodsTypeList();</span>
<span class="nc" id="L1510">		int production = getColonies().stream()</span>
<span class="nc" id="L1511">				.mapToInt(c -&gt; immigrationGoodsTypes.stream().mapToInt(gt -&gt; c.getTotalProductionOf(gt)).sum()).sum();</span>
<span class="nc" id="L1512">		final Europe europe = getEurope();</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">		if (europe != null) {</span>
<span class="nc" id="L1514">			production += europe.getImmigration(production);</span>
		}
<span class="nc" id="L1516">		return production;</span>
	}

	/**
	 * Get a message for a newly migrating unit.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is migrating.
	 * @return A suitable &lt;code&gt;ModelMessage&lt;/code&gt;.
	 */
	public ModelMessage getEmigrationMessage(Unit unit) {
<span class="fc" id="L1527">		return new ModelMessage(ModelMessage.MessageType.UNIT_ADDED, &quot;model.player.emigrate&quot;, this, unit)</span>
<span class="fc" id="L1528">				.addNamed(&quot;%europe%&quot;, getEurope()).addStringTemplate(&quot;%unit%&quot;, unit.getLabel());</span>
	}

	//
	// Liberty and founding fathers
	//

	/**
	 * Gets the current amount of liberty points this player has. Liberty is
	 * regularly reduced to pay for a founding father.
	 *
	 * @return The amount of liberty points.
	 */
	public int getLiberty() {
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">		return (canHaveFoundingFathers()) ? liberty : 0;</span>
	}

	/**
	 * Sets the current amount of liberty this player has.
	 *
	 * @param liberty
	 *            The new amount of liberty.
	 */
	public void setLiberty(int liberty) {
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">		if (!canHaveFoundingFathers()) {</span>
<span class="nc" id="L1553">			return;</span>
		}
<span class="fc" id="L1555">		this.liberty = liberty;</span>
<span class="fc" id="L1556">	}</span>

	/**
	 * Modifies the current amount of liberty this player has.
	 *
	 * @param amount
	 *            The amount of liberty to add.
	 */
	public void modifyLiberty(int amount) {
<span class="fc" id="L1565">		setLiberty(Math.max(0, liberty + amount));</span>
<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">		if (isRebel()) {</span>
<span class="nc" id="L1567">			interventionBells += amount;</span>
		}
<span class="fc" id="L1569">	}</span>

	/**
	 * Recalculate bells bonus when tax changes.
	 *
	 * @return True if a bells bonus was set.
	 */
	protected boolean recalculateBellsBonus() {
<span class="fc" id="L1577">		Set&lt;Modifier&gt; libertyBonus = getModifiers(&quot;model.goods.bells&quot;);</span>
<span class="fc" id="L1578">		boolean ret = false;</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">		for (Ability ability : getAbilities(Ability.ADD_TAX_TO_BELLS)) {</span>
<span class="fc" id="L1580">			FreeColObject source = ability.getSource();</span>
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">			if (source != null) {</span>
<span class="fc bfc" id="L1582" title="All 2 branches covered.">				for (Modifier modifier : libertyBonus) {</span>
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">					if (source.equals(modifier.getSource())) {</span>
<span class="fc" id="L1584">						modifier.setValue(tax);</span>
<span class="fc" id="L1585">						ret = true;</span>
					}
<span class="fc" id="L1587">				}</span>
			}
<span class="fc" id="L1589">		}</span>
<span class="fc" id="L1590">		return ret;</span>
	}

	/**
	 * Gets how much liberty will be produced next turn if no colonies are lost
	 * and nothing unexpected happens.
	 *
	 * @return The total amount of liberty this &lt;code&gt;Player&lt;/code&gt;'s
	 *         &lt;code&gt;Colony&lt;/code&gt;s will make next turn.
	 */
	public int getLibertyProductionNextTurn() {
<span class="nc" id="L1601">		final Specification spec = getSpecification();</span>
<span class="nc" id="L1602">		int nextTurn = getColonies().stream()</span>
<span class="nc" id="L1603">				.mapToInt(c -&gt; spec.getLibertyGoodsTypeList().stream().mapToInt(gt -&gt; c.getTotalProductionOf(gt)).sum())</span>
<span class="nc" id="L1604">				.sum();</span>
<span class="nc" id="L1605">		return (int) applyModifiers((float) nextTurn, getGame().getTurn(), Modifier.LIBERTY);</span>
	}

	/**
	 * Gets the total percentage of rebels in all this player's colonies.
	 *
	 * @return The total percentage of rebels in all this player's colonies.
	 */
	public int getSoL() {
<span class="fc" id="L1614">		final List&lt;Colony&gt; colonies = getColonies();</span>
<span class="pc bpc" id="L1615" title="1 of 2 branches missed.">		return (colonies.isEmpty()) ? 0 : colonies.stream().mapToInt(c -&gt; c.getSoL()).sum() / colonies.size();</span>
	}

	/**
	 * Gets the founding fathers in this player's congress.
	 *
	 * @return A set of &lt;code&gt;FoundingFather&lt;/code&gt;s in congress.
	 */
	public Set&lt;FoundingFather&gt; getFathers() {
<span class="fc" id="L1624">		return foundingFathers;</span>
	}

	/**
	 * Does this player have a certain Founding father.
	 *
	 * @param someFather
	 *            The &lt;code&gt;FoundingFather&lt;/code&gt; to check.
	 * @return Whether this player has this Founding father
	 * @see FoundingFather
	 */
	public boolean hasFather(FoundingFather someFather) {
<span class="nc" id="L1636">		return foundingFathers.contains(someFather);</span>
	}

	/**
	 * Gets the number of founding fathers in this players congress. Used to
	 * calculate number of liberty needed to recruit new fathers.
	 *
	 * @return The number of founding fathers in this players congress
	 */
	public int getFatherCount() {
<span class="fc" id="L1646">		return foundingFathers.size();</span>
	}

	/**
	 * Add a founding father to the congress.
	 *
	 * @param father
	 *            The &lt;code&gt;FoundingFather&lt;/code&gt; to add.
	 */
	public void addFather(FoundingFather father) {
<span class="fc" id="L1656">		foundingFathers.add(father);</span>
<span class="fc" id="L1657">		addFeatures(father);</span>
<span class="fc bfc" id="L1658" title="All 2 branches covered.">		for (Colony colony : getColonies()) {</span>
<span class="fc" id="L1659">			colony.invalidateCache();</span>
<span class="fc" id="L1660">		}</span>
<span class="fc" id="L1661">	}</span>

	/**
	 * Gets the {@link FoundingFather founding father} this player is working
	 * towards.
	 *
	 * @return The current &lt;code&gt;FoundingFather&lt;/code&gt;, or null if there is
	 *         none.
	 * @see #setCurrentFather
	 * @see FoundingFather
	 */
	public FoundingFather getCurrentFather() {
<span class="nc" id="L1673">		return currentFather;</span>
	}

	/**
	 * Sets the current founding father to recruit.
	 *
	 * @param someFather
	 *            The &lt;code&gt;FoundingFather&lt;/code&gt; to recruit.
	 * @see FoundingFather
	 */
	public void setCurrentFather(FoundingFather someFather) {
<span class="nc" id="L1684">		currentFather = someFather;</span>
<span class="nc" id="L1685">	}</span>

	/**
	 * Gets the offered fathers for this player.
	 *
	 * @return A list of the current offered &lt;code&gt;FoundingFather&lt;/code&gt;s.
	 */
	public List&lt;FoundingFather&gt; getOfferedFathers() {
<span class="nc" id="L1693">		return offeredFathers;</span>
	}

	/**
	 * Clear the set of offered fathers.
	 */
	public void clearOfferedFathers() {
<span class="nc" id="L1700">		offeredFathers.clear();</span>
<span class="nc" id="L1701">	}</span>

	/**
	 * Sets the set of offered fathers.
	 *
	 * @param fathers
	 *            A list of &lt;code&gt;FoundingFather&lt;/code&gt;s to offer.
	 */
	public void setOfferedFathers(List&lt;FoundingFather&gt; fathers) {
<span class="nc" id="L1710">		clearOfferedFathers();</span>
<span class="nc" id="L1711">		offeredFathers.addAll(fathers);</span>
<span class="nc" id="L1712">	}</span>

	/**
	 * Gets the number of liberty points needed to recruit the next founding
	 * father.
	 *
	 * @return How many more liberty points the &lt;code&gt;Player&lt;/code&gt; needs in
	 *         order to recruit the next &lt;code&gt;FoundingFather&lt;/code&gt;.
	 */
	public int getRemainingFoundingFatherCost() {
<span class="nc" id="L1722">		return getTotalFoundingFatherCost() - getLiberty();</span>
	}

	/**
	 * How many liberty points in total are needed to earn the Founding Father
	 * we are trying to recruit. See https://sourceforge.net/p/freecol/bugs/2623
	 * where the Col1 numbers were checked.
	 *
	 * @return Total number of liberty points the &lt;code&gt;Player&lt;/code&gt; needs to
	 *         recruit the next &lt;code&gt;FoundingFather&lt;/code&gt;.
	 */
	public int getTotalFoundingFatherCost() {
<span class="fc" id="L1734">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1735">		int base = spec.getInteger(GameOptions.FOUNDING_FATHER_FACTOR);</span>
<span class="fc" id="L1736">		int count = getFatherCount();</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">		return (count == 0) ? base : 2 * (count + 1) * base + 1;</span>
	}

	/**
	 * Gets the &lt;code&gt;Turn&lt;/code&gt;s during which FoundingFathers were elected to
	 * the Continental Congress.
	 *
	 * @return A map of father id to &lt;code&gt;Turn&lt;/code&gt;s.
	 */
	public java.util.Map&lt;String, Turn&gt; getElectionTurns() {
<span class="nc" id="L1747">		java.util.Map&lt;String, Turn&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">		for (HistoryEvent e : getHistory()) {</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">			if (e.getEventType() == HistoryEvent.HistoryEventType.FOUNDING_FATHER) {</span>
<span class="nc" id="L1750">				result.put(e.getReplacement(&quot;%father%&quot;).getId(), e.getTurn());</span>
			}
<span class="nc" id="L1752">		}</span>
<span class="nc" id="L1753">		return result;</span>
	}

	/**
	 * Check whether this player can declare independence.
	 *
	 * @return Null if there is no barrier to declaration, otherwise a
	 *         &lt;code&gt;StringTemplate&lt;/code&gt; explaining the problem.
	 */
	public StringTemplate checkDeclareIndependence() {
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">		if (getPlayerType() != PlayerType.COLONIAL) {</span>
<span class="nc" id="L1764">			return StringTemplate.template(&quot;model.player.colonialIndependence&quot;);</span>
		}
<span class="fc" id="L1766">		final Event event = getSpecification().getEvent(&quot;model.event.declareIndependence&quot;);</span>
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">		Limit limit = find(event.getLimits(), l -&gt; !l.evaluate(this));</span>
<span class="pc bpc" id="L1768" title="1 of 2 branches missed.">		return (limit == null) ? null</span>
<span class="fc" id="L1769">				: StringTemplate.template(limit.getDescriptionKey()).addAmount(&quot;%limit%&quot;,</span>
<span class="fc" id="L1770">						limit.getRightHandSide().getValue(getGame()));</span>
	}

	/**
	 * Generic strength calculation.
	 *
	 * @param naval
	 *            If true consider naval units, otherwise land units.
	 * @return A measure of naval or land offensive power.
	 */
	public int calculateStrength(boolean naval) {
<span class="fc" id="L1781">		final CombatModel cm = getGame().getCombatModel();</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">		return (int) getUnits().stream().filter(u -&gt; u.isNaval() == naval).mapToDouble(u -&gt; cm.getOffencePower(u, null))</span>
<span class="fc" id="L1783">				.sum();</span>
	}

	/**
	 * Get the strength ratio of this player with respect to its REF.
	 *
	 * @param naval
	 *            If true consider naval units, otherwise land units.
	 * @return A measure of the military viability of this player.
	 */
	public double getRebelStrengthRatio(boolean naval) {
<span class="pc bpc" id="L1794" title="1 of 2 branches missed.">		if (getPlayerType() != PlayerType.COLONIAL) {</span>
<span class="nc" id="L1795">			return 0.0;</span>
		}
<span class="fc" id="L1797">		return strengthRatio(calculateStrength(naval), getMonarch().getExpeditionaryForce().calculateStrength(naval));</span>
	}

	//
	// Taxation and trade
	//

	/**
	 * Get the current tax.
	 *
	 * @return The current tax.
	 */
	public int getTax() {
<span class="fc" id="L1810">		return tax;</span>
	}

	/**
	 * Sets the current tax.
	 *
	 * @param amount
	 *            The new tax amount.
	 */
	public void setTax(int amount) {
<span class="fc" id="L1820">		tax = amount;</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">		if (recalculateBellsBonus()) {</span>
<span class="fc bfc" id="L1822" title="All 2 branches covered.">			for (Colony colony : getColonies()) {</span>
<span class="fc" id="L1823">				colony.invalidateCache();</span>
<span class="fc" id="L1824">			}</span>
		}
<span class="fc" id="L1826">	}</span>

	/**
	 * Get this player's Market.
	 *
	 * @return The &lt;code&gt;Market&lt;/code&gt;.
	 */
	public Market getMarket() {
<span class="fc" id="L1834">		return market;</span>
	}

	/**
	 * Resets this player's Market.
	 */
	public void reinitialiseMarket() {
<span class="nc" id="L1841">		market = new Market(getGame(), this);</span>
<span class="nc" id="L1842">	}</span>

	/**
	 * Gets the current sales data for a location and goods type.
	 *
	 * @param where
	 *            The &lt;code&gt;Location&lt;/code&gt; of the sale.
	 * @param what
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; sold.
	 *
	 * @return An appropriate &lt;code&gt;LastSaleData&lt;/code&gt; record, or null if no
	 *         appropriate sale can be found.
	 */
	public LastSale getLastSale(Location where, GoodsType what) {
<span class="nc bnc" id="L1856" title="All 2 branches missed.">		return (lastSales == null) ? null : lastSales.get(LastSale.makeKey(where, what));</span>
	}

	/**
	 * Saves a record of a sale.
	 *
	 * @param sale
	 *            The &lt;code&gt;LastSale&lt;/code&gt; to save.
	 */
	public void addLastSale(LastSale sale) {
<span class="nc bnc" id="L1866" title="All 2 branches missed.">		if (lastSales == null)</span>
<span class="nc" id="L1867">			lastSales = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1868">		lastSales.put(sale.getId(), sale);</span>
<span class="nc" id="L1869">	}</span>

	/**
	 * Gets the last sale price for a location and goods type as a string.
	 *
	 * @param where
	 *            The &lt;code&gt;Location&lt;/code&gt; of the sale.
	 * @param what
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; sold.
	 * @return An abbreviation for the sale price, or null if none found.
	 */
	public String getLastSaleString(Location where, GoodsType what) {
<span class="nc" id="L1881">		LastSale data = getLastSale(where, what);</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">		return (data == null) ? null : String.valueOf(data.getPrice());</span>
	}

	/**
	 * Gets the arrears due for a type of goods.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return The arrears due for this type of goods.
	 */
	public int getArrears(GoodsType type) {
<span class="nc" id="L1893">		return getMarket().getArrears(type);</span>
	}

	/**
	 * Can a type of goods can be traded in Europe?.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return True if there are no arrears due for this type of goods.
	 */
	public boolean canTrade(GoodsType type) {
<span class="nc" id="L1904">		return canTrade(type, Market.Access.EUROPE);</span>
	}

	/**
	 * Can a type of goods can be traded at a specified place?.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @param access
	 *            The way the goods are traded (Europe OR Custom)
	 * @return True if type of goods can be traded.
	 */
	public boolean canTrade(GoodsType type, Market.Access access) {
<span class="fc bfc" id="L1917" title="All 4 branches covered.">		return getMarket().getArrears(type) == 0 || (access == Market.Access.CUSTOM_HOUSE</span>
<span class="pc bpc" id="L1918" title="1 of 2 branches missed.">				&amp;&amp; (getSpecification().getBoolean(GameOptions.CUSTOM_IGNORE_BOYCOTT)</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">						|| (hasAbility(Ability.CUSTOM_HOUSE_TRADES_WITH_FOREIGN_COUNTRIES)</span>
<span class="fc bfc" id="L1920" title="All 2 branches covered.">								&amp;&amp; any(getGame().getLiveEuropeanPlayers(this),</span>
<span class="pc bpc" id="L1921" title="1 of 4 branches missed.">										p -&gt; getStance(p) == Stance.PEACE || getStance(p) == Stance.ALLIANCE))));</span>
	}

	/**
	 * Get the current sales of a type of goods.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to query.
	 * @return The current sales.
	 */
	public int getSales(GoodsType goodsType) {
<span class="nc" id="L1932">		return getMarket().getSales(goodsType);</span>
	}

	/**
	 * Modifies the current sales.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
	 * @param amount
	 *            The new sales.
	 */
	public void modifySales(GoodsType goodsType, int amount) {
<span class="nc" id="L1944">		getMarket().modifySales(goodsType, amount);</span>
<span class="nc" id="L1945">	}</span>

	/**
	 * Has a type of goods been traded?.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return Whether these goods have been traded.
	 */
	public boolean hasTraded(GoodsType goodsType) {
<span class="nc" id="L1955">		return getMarket().hasBeenTraded(goodsType);</span>
	}

	/**
	 * Get the most valuable goods available in one of the player's colonies for
	 * the purposes of choosing a threat-to-boycott. The goods must not
	 * currently be boycotted, the player must have traded in it, and the amount
	 * to be discarded will not exceed GoodsContainer.CARGO_SIZE.
	 *
	 * @return A goods object, or null if nothing suitable found.
	 */
	public Goods getMostValuableGoods() {
<span class="nc bnc" id="L1967" title="All 2 branches missed.">		if (!isEuropean()) {</span>
<span class="nc" id="L1968">			return null;</span>
		}

<span class="nc" id="L1971">		Goods goods = null;</span>
<span class="nc" id="L1972">		int highValue = 0;</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">		for (Colony colony : getColonies()) {</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">			for (Goods g : colony.getCompactGoods()) {</span>
<span class="nc bnc" id="L1975" title="All 4 branches missed.">				if (getArrears(g.getType()) &lt;= 0 &amp;&amp; hasTraded(g.getType())) {</span>
<span class="nc" id="L1976">					int amount = Math.min(g.getAmount(), GoodsContainer.CARGO_SIZE);</span>
<span class="nc" id="L1977">					int value = market.getSalePrice(g.getType(), amount);</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">					if (value &gt; highValue) {</span>
<span class="nc" id="L1979">						highValue = value;</span>
<span class="nc" id="L1980">						goods = g;</span>
					}
				}
<span class="nc" id="L1983">			}</span>
<span class="nc" id="L1984">		}</span>
<span class="nc" id="L1985">		return goods;</span>
	}

	/**
	 * Get the current incomeBeforeTaxes.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to query.
	 * @return The current incomeBeforeTaxes.
	 */
	public int getIncomeBeforeTaxes(GoodsType goodsType) {
<span class="nc" id="L1996">		return getMarket().getIncomeBeforeTaxes(goodsType);</span>
	}

	/**
	 * Modifies the current incomeBeforeTaxes.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
	 * @param amount
	 *            The new incomeBeforeTaxes.
	 */
	public void modifyIncomeBeforeTaxes(GoodsType goodsType, int amount) {
<span class="nc" id="L2008">		getMarket().modifyIncomeBeforeTaxes(goodsType, amount);</span>
<span class="nc" id="L2009">	}</span>

	/**
	 * Get the current incomeAfterTaxes.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to query.
	 * @return The current incomeAfterTaxes.
	 */
	public int getIncomeAfterTaxes(GoodsType goodsType) {
<span class="nc" id="L2019">		return getMarket().getIncomeAfterTaxes(goodsType);</span>
	}

	/**
	 * Modifies the current incomeAfterTaxes.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
	 * @param amount
	 *            The new incomeAfterTaxes.
	 */
	public void modifyIncomeAfterTaxes(GoodsType goodsType, int amount) {
<span class="nc" id="L2031">		getMarket().modifyIncomeAfterTaxes(goodsType, amount);</span>
<span class="nc" id="L2032">	}</span>

	//
	// Europe
	//

	/**
	 * Gets this players Europe object.
	 *
	 * @return The Europe object, or null if the player is not European or
	 *         indpendent.
	 */
	public Europe getEurope() {
<span class="fc" id="L2045">		return europe;</span>
	}

	/**
	 * Set the Europe object for a player.
	 *
	 * @param europe
	 *            The new &lt;code&gt;Europe&lt;/code&gt; object.
	 */
	public void setEurope(Europe europe) {
<span class="nc" id="L2055">		this.europe = europe;</span>
<span class="nc" id="L2056">	}</span>

	/**
	 * Checks if this player can move units to Europe.
	 *
	 * @return True if this player has an instance of &lt;code&gt;Europe&lt;/code&gt;.
	 */
	public boolean canMoveToEurope() {
<span class="fc bfc" id="L2064" title="All 2 branches covered.">		return getEurope() != null;</span>
	}

	/**
	 * Gets the price for a recruit in Europe.
	 *
	 * @return The price of a single recruit in {@link Europe}.
	 */
	public int getRecruitPrice() {
		// return Math.max(0, (getCrossesRequired() - crosses) * 10);
<span class="nc" id="L2074">		return getEurope().getRecruitPrice();</span>
	}

	/**
	 * Gets the price to this player to purchase a unit in Europe.
	 *
	 * @param au
	 *            The proposed &lt;code&gt;AbstractUnit&lt;/code&gt;.
	 * @return The price for the unit.
	 */
	public int getPrice(AbstractUnit au) {
<span class="nc" id="L2085">		final Specification spec = getSpecification();</span>
<span class="nc" id="L2086">		final UnitType unitType = au.getType(spec);</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">		if (!unitType.hasPrice()) {</span>
<span class="nc" id="L2088">			return INFINITY;</span>
		}

<span class="nc" id="L2091">		return au.getNumber()</span>
<span class="nc" id="L2092">				* (getEurope().getUnitPrice(unitType) + au.getRole(spec).getRequiredGoodsPrice(getMarket()));</span>
	}

	/**
	 * Gets the monarch object this player has.
	 *
	 * @return The &lt;code&gt;Monarch&lt;/code&gt; object this player has, or null if there
	 *         is no monarch.
	 */
	public Monarch getMonarch() {
<span class="fc" id="L2102">		return monarch;</span>
	}

	/**
	 * Sets the monarch object this player has.
	 *
	 * @param monarch
	 *            The new &lt;code&gt;Monarch&lt;/code&gt; object.
	 */
	public void setMonarch(Monarch monarch) {
<span class="nc" id="L2112">		this.monarch = monarch;</span>
<span class="nc" id="L2113">	}</span>

	//
	// Units and trade routes
	//

	/**
	 * Does this player's units list contain the given unit?.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to test.
	 * @return True if the player has the unit.
	 */
	public boolean hasUnit(Unit unit) {
<span class="fc" id="L2127">		synchronized (units) {</span>
<span class="fc" id="L2128">			return units.contains(unit);</span>
<span class="nc" id="L2129">		}</span>
	}

	/**
	 * Get a copy of the players units.
	 *
	 * @return A list of the player &lt;code&gt;Unit&lt;/code&gt;s.
	 */
	public List&lt;Unit&gt; getUnits() {
<span class="fc" id="L2138">		synchronized (units) {</span>
<span class="fc" id="L2139">			return new ArrayList&lt;&gt;(units);</span>
<span class="nc" id="L2140">		}</span>
	}

	/**
	 * Get a player unit by name.
	 *
	 * @param name
	 *            The name of the unit.
	 * @return The unit with the given name, or null if none found.
	 */
	public Unit getUnitByName(String name) {
<span class="fc" id="L2151">		return find(units, u -&gt; name.equals(u.getName()));</span>
	}

	/**
	 * Get an iterator containing all the units this player owns.
	 *
	 * @return An &lt;code&gt;Iterator&lt;/code&gt; over the player &lt;code&gt;Unit&lt;/code&gt;s.
	 * @see Unit
	 */
	public Iterator&lt;Unit&gt; getUnitIterator() {
<span class="fc" id="L2161">		synchronized (units) {</span>
<span class="fc" id="L2162">			return units.iterator();</span>
<span class="nc" id="L2163">		}</span>
	}

	/**
	 * Add a unit to this player.
	 *
	 * @param newUnit
	 *            The new &lt;code&gt;Unit&lt;/code&gt; value.
	 * @return True if the units container changed.
	 */
	public final boolean addUnit(final Unit newUnit) {
<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">		if (newUnit == null) {</span>
<span class="nc" id="L2175">			return false;</span>
		}

		// Make sure the owner of the unit is set first, before adding
		// it to the list
<span class="fc bfc" id="L2180" title="All 2 branches covered.">		if (!this.owns(newUnit)) {</span>
<span class="fc" id="L2181">			throw new IllegalStateException(&quot;Adding another players unit:&quot; + newUnit.getId() + &quot; to &quot; + this);</span>
		}
<span class="pc bpc" id="L2183" title="1 of 2 branches missed.">		if (hasUnit(newUnit)) {</span>
<span class="nc" id="L2184">			return false;</span>
		}

<span class="fc" id="L2187">		synchronized (units) {</span>
<span class="fc" id="L2188">			return units.add(newUnit);</span>
<span class="nc" id="L2189">		}</span>
	}

	/**
	 * Remove a unit from this player.
	 *
	 * @param oldUnit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to remove.
	 * @return True if the units container changed.
	 */
	public boolean removeUnit(final Unit oldUnit) {
<span class="pc bpc" id="L2200" title="1 of 2 branches missed.">		if (oldUnit == null) {</span>
<span class="nc" id="L2201">			return false;</span>
		}

<span class="fc" id="L2204">		nextActiveUnitIterator.remove(oldUnit);</span>
<span class="fc" id="L2205">		nextGoingToUnitIterator.remove(oldUnit);</span>
<span class="fc" id="L2206">		nextTradeRouteUnitIterator.remove(oldUnit);</span>

<span class="fc" id="L2208">		synchronized (units) {</span>
<span class="fc" id="L2209">			return units.remove(oldUnit);</span>
<span class="nc" id="L2210">		}</span>
	}

	/**
	 * Gets the carrier units that can carry the supplied unit, if one exists.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to carry.
	 * @return A list of suitable carriers.
	 */
	public List&lt;Unit&gt; getCarriersForUnit(Unit unit) {
<span class="fc" id="L2221">		return getUnits().stream().filter(u -&gt; u.couldCarry(unit)).collect(Collectors.toList());</span>
	}

	/**
	 * Get the number of units a player has, either land or naval.
	 *
	 * @param naval
	 *            If true, count naval units, else count land units.
	 * @return The number of units.
	 */
	public int getUnitCount(boolean naval) {
<span class="pc bpc" id="L2232" title="1 of 2 branches missed.">		return (int) getUnits().stream().filter(u -&gt; u.isNaval() == naval).count();</span>
	}

	/**
	 * Gets the number of King's land units.
	 *
	 * @return The number of units
	 */
	public int getNumberOfKingLandUnits() {
<span class="nc bnc" id="L2241" title="All 4 branches missed.">		return (int) getUnits().stream().filter(u -&gt; u.hasAbility(Ability.REF_UNIT) &amp;&amp; !u.isNaval()).count();</span>
	}

	/**
	 * Checks if this player has at least one of a given unit type.
	 *
	 * @param typeId
	 *            The identifier for the unit type to check.
	 * @return True if this player owns at least one of the specified unit type.
	 */
	public boolean hasUnitType(String typeId) {
<span class="nc" id="L2252">		return any(getUnits(), u -&gt; typeId.equals(u.getType().getId()));</span>
	}

	/**
	 * Gets a new active unit.
	 *
	 * @return A &lt;code&gt;Unit&lt;/code&gt; that can be made active.
	 */
	public Unit getNextActiveUnit() {
<span class="nc" id="L2261">		return nextActiveUnitIterator.next();</span>
	}

	/**
	 * Sets a new active unit.
	 *
	 * @param unit
	 *            A &lt;code&gt;Unit&lt;/code&gt; to make the next one to be active.
	 * @return True if the operation succeeded.
	 */
	public boolean setNextActiveUnit(Unit unit) {
<span class="nc" id="L2272">		return nextActiveUnitIterator.setNext(unit);</span>
	}

	/**
	 * Checks if a new active unit can be made active.
	 *
	 * @return True if there is a potential active unit.
	 */
	public boolean hasNextActiveUnit() {
<span class="nc" id="L2281">		return nextActiveUnitIterator.hasNext();</span>
	}

	/**
	 * Gets a new going-to unit.
	 *
	 * @return A &lt;code&gt;Unit&lt;/code&gt; that can be made active.
	 */
	public Unit getNextGoingToUnit() {
<span class="nc" id="L2290">		return nextGoingToUnitIterator.next();</span>
	}

	/**
	 * Sets a new going-to unit.
	 *
	 * @param unit
	 *            A &lt;code&gt;Unit&lt;/code&gt; to make the next one to be active.
	 * @return True if the operation succeeded.
	 */
	public boolean setNextGoingToUnit(Unit unit) {
<span class="nc" id="L2301">		return nextGoingToUnitIterator.setNext(unit);</span>
	}

	/**
	 * Checks if there is a unit that has a destination.
	 *
	 * @return True if there is a unit with a destination.
	 */
	public boolean hasNextGoingToUnit() {
<span class="nc" id="L2310">		return nextGoingToUnitIterator.hasNext();</span>
	}

	/**
	 * Gets the next trade route unit.
	 *
	 * @return A &lt;code&gt;Unit&lt;/code&gt; that has a trade route to follow.
	 */
	public Unit getNextTradeRouteUnit() {
<span class="nc" id="L2319">		return nextTradeRouteUnitIterator.next();</span>
	}

	/**
	 * Checks if there is a unit that has a trade route.
	 *
	 * @return True if there is a unit with a trade route.
	 */
	public boolean hasNextTradeRouteUnit() {
<span class="nc" id="L2328">		return nextTradeRouteUnitIterator.hasNext();</span>
	}

	/**
	 * Reset the player iterators ready for a new turn.
	 */
	public void resetIterators() {
<span class="nc" id="L2335">		nextActiveUnitIterator.reset();</span>
<span class="nc" id="L2336">		nextGoingToUnitIterator.reset();</span>
<span class="nc" id="L2337">		nextTradeRouteUnitIterator.reset();</span>
<span class="nc" id="L2338">	}</span>

	/**
	 * Get the trade routes defined for this player.
	 *
	 * @return The list of &lt;code&gt;TradeRoute&lt;/code&gt;s for this player.
	 */
	public final List&lt;TradeRoute&gt; getTradeRoutes() {
<span class="fc" id="L2346">		return tradeRoutes;</span>
	}

	/**
	 * Get a trade route by name.
	 *
	 * @param name
	 *            The trade route name.
	 * @return the trade route by name
	 */
	public TradeRoute getTradeRouteByName(String name) {
<span class="nc" id="L2357">		return find(tradeRoutes, t -&gt; t.getName().equals(name));</span>
	}

	/**
	 * Set the players trade routes.
	 *
	 * @param newTradeRoutes
	 *            The new list of &lt;code&gt;TradeRoute&lt;/code&gt;s.
	 */
	public final void setTradeRoutes(final List&lt;TradeRoute&gt; newTradeRoutes) {
<span class="nc" id="L2367">		tradeRoutes.clear();</span>
<span class="nc" id="L2368">		tradeRoutes.addAll(newTradeRoutes);</span>
<span class="nc" id="L2369">	}</span>

	/**
	 * Get a unique name for a new trade route.
	 *
	 * @return the name for trade route
	 */
	public String getNameForTradeRoute() {
<span class="nc" id="L2377">		return NameCache.getTradeRouteName(this);</span>
	}

	/**
	 * Add an ownable to a caching container. Not all ownables are cached.
	 *
	 * @param o
	 *            The &lt;code&gt;Ownable&lt;/code&gt; to add.
	 * @return True if the container changed.
	 */
	public boolean addOwnable(Ownable o) {
<span class="pc bpc" id="L2388" title="1 of 4 branches missed.">		return (o instanceof Settlement) ? addSettlement((Settlement) o)</span>
<span class="pc" id="L2389">				: (o instanceof Unit) ? addUnit((Unit) o) : false;</span>
	}

	/**
	 * Remove an ownable from a caching container. Not all ownables are cached.
	 *
	 * @param o
	 *            The &lt;code&gt;Ownable&lt;/code&gt; to remove.
	 * @return True if the container changed.
	 */
	public boolean removeOwnable(Ownable o) {
<span class="pc bpc" id="L2400" title="3 of 4 branches missed.">		return (o instanceof Settlement) ? removeSettlement((Settlement) o)</span>
<span class="nc" id="L2401">				: (o instanceof Unit) ? removeUnit((Unit) o) : false;</span>
	}

	//
	// Settlements
	//

	/**
	 * Gets a the settlements this player owns.
	 *
	 * @return The list of &lt;code&gt;Settlements&lt;/code&gt; this player owns.
	 */
	public List&lt;Settlement&gt; getSettlements() {
<span class="fc" id="L2414">		return settlements;</span>
	}

	/**
	 * Get the number of settlements.
	 *
	 * @return The number of settlements this player has.
	 */
	public int getNumberOfSettlements() {
<span class="fc" id="L2423">		return settlements.size();</span>
	}

	/**
	 * Get the number of port settlements.
	 *
	 * @return The number of port settlements this player has.
	 */
	public int getNumberOfPorts() {
<span class="pc bpc" id="L2432" title="1 of 2 branches missed.">		if (!isEuropean()) {</span>
<span class="nc" id="L2433">			return 0;</span>
		}
<span class="fc" id="L2435">		int n = 0;</span>
<span class="pc bpc" id="L2436" title="1 of 2 branches missed.">		for (Colony colony : getColonies()) {</span>
<span class="nc bnc" id="L2437" title="All 2 branches missed.">			if (colony.isConnectedPort()) {</span>
<span class="nc" id="L2438">				n++;</span>
			}
<span class="nc" id="L2440">		}</span>
<span class="fc" id="L2441">		return n;</span>
	}

	/**
	 * Get the port settlements.
	 *
	 * @return A list of port &lt;code&gt;Colony&lt;/code&gt;s.
	 */
	public List&lt;Colony&gt; getPorts() {
<span class="nc bnc" id="L2450" title="All 2 branches missed.">		return (!isEuropean()) ? Collections.&lt;Colony&gt;emptyList()</span>
<span class="nc" id="L2451">				: getColonies().stream().filter(Colony::isConnectedPort).collect(Collectors.toList());</span>
	}

	/**
	 * Does this player own a given settlement.
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to check.
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; owns the given
	 *         &lt;code&gt;Settlement&lt;/code&gt;.
	 */
	public boolean hasSettlement(Settlement settlement) {
<span class="fc" id="L2463">		return settlements.contains(settlement);</span>
	}

	/**
	 * Adds a given settlement to this player's list of settlements.
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to add.
	 * @return True if the settlements container changed.
	 */
	public boolean addSettlement(Settlement settlement) {
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">		if (settlement == null) {</span>
<span class="nc" id="L2475">			return false;</span>
		}
<span class="pc bpc" id="L2477" title="1 of 2 branches missed.">		if (!owns(settlement)) {</span>
<span class="nc" id="L2478">			throw new IllegalStateException(&quot;Does not own: &quot; + settlement);</span>
		}
<span class="pc bpc" id="L2480" title="1 of 2 branches missed.">		if (hasSettlement(settlement)) {</span>
<span class="nc" id="L2481">			return false;</span>
		}
<span class="fc" id="L2483">		settlements.add(settlement);</span>
<span class="fc" id="L2484">		return true;</span>
	}

	/**
	 * Removes the given settlement from this player's list of settlements.
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to remove.
	 * @return True if the settlements container changed.
	 */
	public boolean removeSettlement(Settlement settlement) {
<span class="fc" id="L2495">		return settlements.remove(settlement);</span>
	}

	/**
	 * Gets the sum of units currently working in the colonies of this player.
	 *
	 * @return The sum of the units currently working in the colonies.
	 */
	public int getColoniesPopulation() {
<span class="fc" id="L2504">		return getColonies().stream().mapToInt(c -&gt; c.getUnitCount()).sum();</span>
	}

	/**
	 * Gets the &lt;code&gt;Colony&lt;/code&gt; with the given name.
	 *
	 * @param name
	 *            The name of the &lt;code&gt;Colony&lt;/code&gt;.
	 * @return The &lt;code&gt;Colony&lt;/code&gt; with the given name, or null if not
	 *         found.
	 */
	public Colony getColonyByName(String name) {
<span class="nc" id="L2516">		return find(getColonies(), c -&gt; c.getName().equals(name));</span>
	}

	/**
	 * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; with the given name.
	 *
	 * @param name
	 *            The name of the &lt;code&gt;IndianSettlement&lt;/code&gt;.
	 * @return The &lt;code&gt;IndianSettlement&lt;/code&gt; with the given name, or null if
	 *         not found.
	 */
	public IndianSettlement getIndianSettlementByName(String name) {
<span class="nc" id="L2528">		return find(getIndianSettlements(), is -&gt; is.getName().equals(name));</span>
	}

	/**
	 * Gets a fresh list of all colonies this player owns. It is an error to
	 * call this on non-European players.
	 *
	 * @return A fresh list of the &lt;code&gt;Colony&lt;/code&gt;s this player owns.
	 */
	public List&lt;Colony&gt; getColonies() {
<span class="fc" id="L2538">		List&lt;Colony&gt; colonies = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2539" title="All 2 branches covered.">		for (Settlement s : getSettlements()) {</span>
<span class="pc bpc" id="L2540" title="1 of 2 branches missed.">			if (s instanceof Colony) {</span>
<span class="fc" id="L2541">				colonies.add((Colony) s);</span>
			} else {
<span class="nc" id="L2543">				throw new RuntimeException(&quot;getColonies found: &quot; + s);</span>
			}
<span class="fc" id="L2545">		}</span>
<span class="fc" id="L2546">		return colonies;</span>
	}

	/**
	 * Get a sorted list of all colonies this player owns.
	 *
	 * @param c
	 *            A comparator to operate on the colony list.
	 * @return A fresh list of the &lt;code&gt;Colony&lt;/code&gt;s this player owns.
	 */
	public List&lt;Colony&gt; getSortedColonies(Comparator&lt;Colony&gt; c) {
<span class="nc" id="L2557">		List&lt;Colony&gt; colonies = getColonies();</span>
<span class="nc" id="L2558">		Collections.sort(colonies, c);</span>
<span class="nc" id="L2559">		return colonies;</span>
	}

	/**
	 * Gets a list of all the IndianSettlements this player owns. It is an error
	 * to call this on non-native players.
	 *
	 * @return The indian settlements this player owns.
	 */
	public List&lt;IndianSettlement&gt; getIndianSettlements() {
<span class="fc" id="L2569">		List&lt;IndianSettlement&gt; indianSettlements = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2570" title="All 2 branches covered.">		for (Settlement s : getSettlements()) {</span>
<span class="pc bpc" id="L2571" title="1 of 2 branches missed.">			if (s instanceof IndianSettlement) {</span>
<span class="fc" id="L2572">				indianSettlements.add((IndianSettlement) s);</span>
			} else {
<span class="nc" id="L2574">				throw new RuntimeException(&quot;getIndianSettlements found: &quot; + s);</span>
			}
<span class="fc" id="L2576">		}</span>
<span class="fc" id="L2577">		return indianSettlements;</span>
	}

	/**
	 * Find a &lt;code&gt;Settlement&lt;/code&gt; by name.
	 *
	 * @param name
	 *            The name of the &lt;code&gt;Settlement&lt;/code&gt;.
	 * @return The &lt;code&gt;Settlement&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if not found.
	 **/
	public Settlement getSettlementByName(String name) {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">		return (isIndian()) ? getIndianSettlementByName(name) : getColonyByName(name);</span>
	}

	/**
	 * Gets the port closest to Europe owned by this player.
	 *
	 * @return This players closest port.
	 */
	public Settlement getClosestPortForEurope() {
<span class="nc" id="L2597">		int bestValue = INFINITY;</span>
<span class="nc" id="L2598">		Settlement best = null;</span>
<span class="nc bnc" id="L2599" title="All 2 branches missed.">		for (Settlement settlement : getSettlements()) {</span>
<span class="nc" id="L2600">			int value = settlement.getHighSeasCount();</span>
<span class="nc bnc" id="L2601" title="All 2 branches missed.">			if (bestValue &gt; value) {</span>
<span class="nc" id="L2602">				bestValue = value;</span>
<span class="nc" id="L2603">				best = settlement;</span>
			}
<span class="nc" id="L2605">		}</span>
<span class="nc" id="L2606">		return best;</span>
	}

	//
	// Messages and history
	//

	/**
	 * Gets all the model messages for this player.
	 *
	 * @return A copy of the &lt;code&gt;ModelMessage&lt;/code&gt;s for this
	 *         &lt;code&gt;Player&lt;/code&gt;.
	 */
	public List&lt;ModelMessage&gt; getModelMessages() {
<span class="fc" id="L2620">		synchronized (modelMessages) {</span>
<span class="fc" id="L2621">			return new ArrayList&lt;&gt;(modelMessages);</span>
<span class="nc" id="L2622">		}</span>
	}

	/**
	 * Gets all new messages for this player.
	 *
	 * @return all The new &lt;code&gt;ModelMessage&lt;/code&gt;s for this
	 *         &lt;code&gt;Player&lt;/code&gt;.
	 */
	public List&lt;ModelMessage&gt; getNewModelMessages() {
<span class="nc" id="L2632">		synchronized (modelMessages) {</span>
<span class="nc bnc" id="L2633" title="All 2 branches missed.">			return modelMessages.stream().filter(m -&gt; !m.hasBeenDisplayed()).collect(Collectors.toList());</span>
<span class="nc" id="L2634">		}</span>
	}

	/**
	 * Adds a message for this player.
	 *
	 * @param modelMessage
	 *            The &lt;code&gt;ModelMessage&lt;/code&gt; to add.
	 */
	public void addModelMessage(ModelMessage modelMessage) {
<span class="nc" id="L2644">		synchronized (modelMessages) {</span>
<span class="nc" id="L2645">			modelMessages.add(modelMessage);</span>
<span class="nc" id="L2646">		}</span>
<span class="nc" id="L2647">	}</span>

	/**
	 * Refilters the current model messages, removing the ones that are no
	 * longer valid.
	 *
	 * @param options
	 *            The &lt;code&gt;OptionGroup&lt;/code&gt; for message display to enforce.
	 */
	public void refilterModelMessages(OptionGroup options) {
<span class="nc" id="L2657">		synchronized (modelMessages) {</span>
<span class="nc" id="L2658">			Iterator&lt;ModelMessage&gt; messageIterator = modelMessages.iterator();</span>
<span class="nc bnc" id="L2659" title="All 2 branches missed.">			while (messageIterator.hasNext()) {</span>
<span class="nc" id="L2660">				ModelMessage message = messageIterator.next();</span>
<span class="nc" id="L2661">				String id = message.getMessageType().getOptionName();</span>
<span class="nc bnc" id="L2662" title="All 2 branches missed.">				if (!options.getBoolean(id)) {</span>
<span class="nc" id="L2663">					messageIterator.remove();</span>
				}
<span class="nc" id="L2665">			}</span>
<span class="nc" id="L2666">		}</span>
<span class="nc" id="L2667">	}</span>

	/**
	 * Removes all undisplayed model messages for this player.
	 */
	public void removeDisplayedModelMessages() {
<span class="nc" id="L2673">		synchronized (modelMessages) {</span>
<span class="nc" id="L2674">			Iterator&lt;ModelMessage&gt; messageIterator = modelMessages.iterator();</span>
<span class="nc bnc" id="L2675" title="All 2 branches missed.">			while (messageIterator.hasNext()) {</span>
<span class="nc" id="L2676">				ModelMessage message = messageIterator.next();</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">				if (message.hasBeenDisplayed()) {</span>
<span class="nc" id="L2678">					messageIterator.remove();</span>
				}
<span class="nc" id="L2680">			}</span>
<span class="nc" id="L2681">		}</span>
<span class="nc" id="L2682">	}</span>

	/**
	 * Removes all the model messages for this player.
	 */
	public void clearModelMessages() {
<span class="fc" id="L2688">		synchronized (modelMessages) {</span>
<span class="fc" id="L2689">			modelMessages.clear();</span>
<span class="pc" id="L2690">		}</span>
<span class="fc" id="L2691">	}</span>

	/**
	 * Sometimes an event causes the source (and display) fields in an
	 * accumulated model message to become invalid (e.g. Europe disappears on
	 * independence). This routine is for cleaning up such cases.
	 *
	 * @param source
	 *            The source field that has become invalid.
	 * @param newSource
	 *            A new source field to replace the old with, or if null then
	 *            remove the message
	 */
	public void divertModelMessages(FreeColGameObject source, FreeColGameObject newSource) {
<span class="nc" id="L2705">		synchronized (modelMessages) {</span>
<span class="nc" id="L2706">			Iterator&lt;ModelMessage&gt; messageIterator = modelMessages.iterator();</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">			while (messageIterator.hasNext()) {</span>
<span class="nc" id="L2708">				ModelMessage message = messageIterator.next();</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">				if (Utils.equals(message.getSourceId(), source.getId())) {</span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">					if (newSource == null) {</span>
<span class="nc" id="L2711">						messageIterator.remove();</span>
					} else {
<span class="nc" id="L2713">						message.divert(newSource);</span>
					}
				}
<span class="nc" id="L2716">			}</span>
<span class="nc" id="L2717">		}</span>
<span class="nc" id="L2718">	}</span>

	/**
	 * Add the tutorial message for the start of the game.
	 */
	public void addStartGameMessage() {
<span class="nc" id="L2724">		Tile tile = getEntryLocation().getTile();</span>
<span class="nc bnc" id="L2725" title="All 4 branches missed.">		String sailTag = (tile == null) ? &quot;unknown&quot; : (tile.getX() &lt; tile.getMap().getWidth() / 2) ? &quot;east&quot; : &quot;west&quot;;</span>
<span class="nc" id="L2726">		addModelMessage(new ModelMessage(ModelMessage.MessageType.TUTORIAL, &quot;model.player.startGame&quot;, this)</span>
<span class="nc" id="L2727">				.add(&quot;%direction%&quot;, sailTag));</span>
<span class="nc" id="L2728">	}</span>

	/**
	 * Get the history events for this player.
	 *
	 * @return The list of &lt;code&gt;HistoryEvent&lt;/code&gt;s for this player.
	 */
	public final List&lt;HistoryEvent&gt; getHistory() {
<span class="nc" id="L2736">		return history;</span>
	}

	/**
	 * Add a history event to this player.
	 *
	 * @param event
	 *            The &lt;code&gt;HistoryEvent&lt;/code&gt; to add.
	 */
	public void addHistory(HistoryEvent event) {
<span class="nc" id="L2746">		history.add(event);</span>
<span class="nc" id="L2747">	}</span>

	//
	// The players view of the Map
	//

	/**
	 * Gets the default initial location where the units arriving from
	 * {@link Europe} appear on the map.
	 *
	 * @return The entry &lt;code&gt;Location&lt;/code&gt;.
	 * @see Unit#getEntryLocation
	 */
	public Location getEntryLocation() {
<span class="nc" id="L2761">		return entryLocation;</span>
	}

	/**
	 * Sets the default initial location where the units arriving from
	 * {@link Europe} appear on the map.
	 *
	 * @param entryLocation
	 *            The new entry &lt;code&gt;Location&lt;/code&gt;.
	 * @see #getEntryLocation
	 */
	public void setEntryLocation(Location entryLocation) {
<span class="fc" id="L2773">		this.entryLocation = entryLocation;</span>
<span class="fc" id="L2774">	}</span>

	/**
	 * Get a default tile to display at the start of the player turn should
	 * there not be any active units.
	 *
	 * Favour the first settlement, followed by the entry tile.
	 * 
	 * @return A suitable &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Tile getFallbackTile() {
<span class="nc" id="L2785">		List&lt;Settlement&gt; settlements = getSettlements();</span>
<span class="nc bnc" id="L2786" title="All 2 branches missed.">		return (!settlements.isEmpty()) ? settlements.get(0).getTile() : getEntryLocation().getTile();</span>
	}

	/**
	 * Get the players high seas.
	 *
	 * @return The &lt;code&gt;HighSeas&lt;/code&gt; for this player.
	 */
	public final HighSeas getHighSeas() {
<span class="fc" id="L2795">		return highSeas;</span>
	}

	/**
	 * Initialize the highSeas. Needs to be public until the backward
	 * compatibility code in FreeColServer is gone.
	 */
	public void initializeHighSeas() {
<span class="fc" id="L2803">		Game game = getGame();</span>
<span class="fc" id="L2804">		highSeas = new HighSeas(game);</span>
<span class="pc bpc" id="L2805" title="1 of 2 branches missed.">		if (europe != null) {</span>
<span class="fc" id="L2806">			highSeas.addDestination(europe);</span>
		}
<span class="fc bfc" id="L2808" title="All 2 branches covered.">		if (game.getMap() != null) {</span>
<span class="fc" id="L2809">			highSeas.addDestination(game.getMap());</span>
		}
<span class="fc" id="L2811">	}</span>

	/**
	 * Can this player see a given tile.
	 *
	 * The tile can be seen if it is in a unit or settlement's line of sight.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if this player can see the given &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public boolean canSee(Tile tile) {
<span class="fc bfc" id="L2823" title="All 2 branches covered.">		if (tile == null) {</span>
<span class="fc" id="L2824">			return false;</span>
		}

		do {
<span class="fc" id="L2828">			synchronized (canSeeLock) {</span>
<span class="fc bfc" id="L2829" title="All 2 branches covered.">				if (canSeeValid) {</span>
<span class="fc" id="L2830">					return canSeeTiles[tile.getX()][tile.getY()];</span>
				}
<span class="pc" id="L2832">			}</span>
<span class="pc bpc" id="L2833" title="1 of 2 branches missed.">		} while (resetCanSeeTiles());</span>
<span class="nc" id="L2834">		return false;</span>
	}

	/**
	 * Forces an update of the &lt;code&gt;canSeeTiles&lt;/code&gt;.
	 *
	 * This method should be used to invalidate the current
	 * &lt;code&gt;canSeeTiles&lt;/code&gt; when something significant changes. The method
	 * {@link #resetCanSeeTiles} will be called whenever it is needed.
	 *
	 * So what is &quot;significant&quot;? Looking at the makeCanSeeTiles routine suggests
	 * the following:
	 *
	 * - Unit added to map - Unit removed from map - Unit moved on map - Unit
	 * type changes (which may change its line-of-sight) - Unit ownership
	 * changes - Settlement added to map - Settlement removed from map -
	 * Settlement ownership changes - Coronado added (can now see other
	 * colonies) - Coronado removed (only in debug mode) - Mission established
	 * (if enhanced missionaries enabled) - Mission removed (if enhanced
	 * missionaries enabled) - Mission ownership changes (Spanish succession
	 * with enhanced missionaries enabled) - Map is unexplored (debug mode)
	 *
	 * Ideally then when any of these events occurs we should call
	 * invalidateCanSeeTiles(). However while iCST is quick and cheap, as soon
	 * as we then call canSee() the big expensive makeCanSeeTiles will be run.
	 * Often the situation in the server is that several routines with
	 * visibility implications will be called in succession. Usually there, the
	 * best solution is to make all the changes and issue the iCST at the end.
	 * So, to make this a bit more visible, routines that change visibility are
	 * annotated with a &quot;-vis&quot; comment at both definition and call sites.
	 * Similarly routines that fix up the mess have a &quot;+vis&quot; comment. Thus it is
	 * an error for a -vis to appear without a following +vis (unless the
	 * enclosing routine is marked -vis). By convention, we try to avoid cs*
	 * routines being -vis.
	 */
	public void invalidateCanSeeTiles() {
<span class="fc" id="L2870">		synchronized (canSeeLock) {</span>
<span class="fc" id="L2871">			canSeeValid = false;</span>
<span class="pc" id="L2872">		}</span>
<span class="fc" id="L2873">	}</span>

	/**
	 * Resets this player's &quot;can see&quot;-tiles. This is done by setting all the
	 * tiles within each {@link Unit} and {@link Settlement}s line of sight
	 * visible. The other tiles are made invisible.
	 *
	 * Use {@link #invalidateCanSeeTiles} whenever possible.
	 *
	 * @return True if successful.
	 */
	private boolean resetCanSeeTiles() {
<span class="fc" id="L2885">		Map map = getGame().getMap();</span>
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">		if (map == null) {</span>
<span class="nc" id="L2887">			return false;</span>
		}

<span class="fc" id="L2890">		boolean[][] cST = makeCanSeeTiles(map);</span>
<span class="fc" id="L2891">		synchronized (canSeeLock) {</span>
<span class="fc" id="L2892">			canSeeTiles = cST;</span>
<span class="fc" id="L2893">			canSeeValid = true;</span>
<span class="pc" id="L2894">		}</span>
<span class="fc" id="L2895">		return true;</span>
	}

	/**
	 * Checks if this player has explored the given tile.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if the &lt;code&gt;Tile&lt;/code&gt; has been explored.
	 */
	public boolean hasExplored(Tile tile) {
<span class="nc" id="L2906">		return tile.isExplored();</span>
	}

	/**
	 * Builds a canSeeTiles array.
	 *
	 * Note that tiles must be tested for null as they may be both valid tiles
	 * but yet null during a save game load.
	 *
	 * Note the use of copies of the unit and settlement lists to avoid nasty
	 * surprises due to asynchronous disappearance of members of either. FIXME:
	 * see if this can be relaxed.
	 *
	 * @param map
	 *            The &lt;code&gt;Map&lt;/code&gt; to use.
	 * @return A canSeeTiles array.
	 */
	private boolean[][] makeCanSeeTiles(Map map) {
<span class="fc" id="L2924">		final Specification spec = getSpecification();</span>
		// Simple case when there is no fog of war: a tile is
		// visible once it is explored.
<span class="pc bpc" id="L2927" title="1 of 2 branches missed.">		if (!spec.getBoolean(GameOptions.FOG_OF_WAR)) {</span>
<span class="nc bnc" id="L2928" title="All 2 branches missed.">			boolean[][] cST = (canSeeTiles != null) ? canSeeTiles : new boolean[map.getWidth()][map.getHeight()];</span>
<span class="nc bnc" id="L2929" title="All 2 branches missed.">			for (Tile t : getGame().getMap().getAllTiles()) {</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">				if (t != null) {</span>
<span class="nc" id="L2931">					cST[t.getX()][t.getY()] = hasExplored(t);</span>
				}
<span class="nc" id="L2933">			}</span>
<span class="nc" id="L2934">			return cST;</span>
		}

		// When there is fog, have to trace all locations where the
		// player has units, settlements, (optionally) missions, and
		// extra visibility.
		// Set the PET for visible tiles to the tile itself.
<span class="fc" id="L2941">		boolean[][] cST = new boolean[map.getWidth()][map.getHeight()];</span>

<span class="fc bfc" id="L2943" title="All 2 branches covered.">		for (Unit unit : getUnits()) {</span>
			// Only consider units directly on the map, not those on a
			// carrier or in Europe.
<span class="fc bfc" id="L2946" title="All 2 branches covered.">			if (!(unit.getLocation() instanceof Tile)) {</span>
<span class="fc" id="L2947">				continue;</span>
			}

			// All the units.
<span class="fc bfc" id="L2951" title="All 2 branches covered.">			for (Tile t : ((Tile) unit.getLocation()).getSurroundingTiles(0, unit.getLineOfSight())) {</span>
<span class="fc" id="L2952">				cST[t.getX()][t.getY()] = true;</span>
<span class="fc" id="L2953">				t.seeTile(this);</span>
<span class="fc" id="L2954">			}</span>
<span class="fc" id="L2955">		}</span>
		// All the settlements.
<span class="fc bfc" id="L2957" title="All 2 branches covered.">		for (Settlement settlement : getSettlements()) {</span>
<span class="fc bfc" id="L2958" title="All 2 branches covered.">			for (Tile t : settlement.getTile().getSurroundingTiles(0, settlement.getLineOfSight())) {</span>
<span class="fc" id="L2959">				cST[t.getX()][t.getY()] = true;</span>
<span class="fc" id="L2960">				t.seeTile(this);</span>
<span class="fc" id="L2961">			}</span>
<span class="fc" id="L2962">		}</span>
		// All missions if using enhanced missionaries.
<span class="pc bpc" id="L2964" title="1 of 4 branches missed.">		if (isEuropean() &amp;&amp; spec.getBoolean(GameOptions.ENHANCED_MISSIONARIES)) {</span>
<span class="fc bfc" id="L2965" title="All 2 branches covered.">			for (Player other : getGame().getLiveNativePlayers(this)) {</span>
<span class="fc bfc" id="L2966" title="All 2 branches covered.">				for (IndianSettlement is : other.getIndianSettlements()) {</span>
<span class="fc bfc" id="L2967" title="All 2 branches covered.">					if (!is.hasMissionary(this)) {</span>
<span class="fc" id="L2968">						continue;</span>
					}
<span class="fc bfc" id="L2970" title="All 2 branches covered.">					for (Tile t : is.getTile().getSurroundingTiles(0, is.getLineOfSight())) {</span>
<span class="fc" id="L2971">						cST[t.getX()][t.getY()] = true;</span>
<span class="fc" id="L2972">						t.seeTile(this);</span>
<span class="fc" id="L2973">					}</span>
<span class="fc" id="L2974">				}</span>
<span class="fc" id="L2975">			}</span>
		}
		// All other European settlements if can see all colonies.
<span class="pc bpc" id="L2978" title="1 of 4 branches missed.">		if (isEuropean() &amp;&amp; hasAbility(Ability.SEE_ALL_COLONIES)) {</span>
<span class="nc bnc" id="L2979" title="All 2 branches missed.">			for (Player other : getGame().getLiveEuropeanPlayers(this)) {</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">				for (Colony colony : other.getColonies()) {</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">					for (Tile t : colony.getTile().getSurroundingTiles(0, colony.getLineOfSight())) {</span>
<span class="nc" id="L2982">						cST[t.getX()][t.getY()] = true;</span>
<span class="nc" id="L2983">						t.seeTile(this);</span>
<span class="nc" id="L2984">					}</span>
<span class="nc" id="L2985">				}</span>
<span class="nc" id="L2986">			}</span>
		}
<span class="fc" id="L2988">		return cST;</span>
	}

	//
	// Foreign relations
	//

	/**
	 * Gets the hostility this player has against the given player.
	 *
	 * @param player
	 *            The other &lt;code&gt;Player&lt;/code&gt;.
	 * @return An object representing the tension level.
	 */
	public Tension getTension(Player player) {
<span class="pc bpc" id="L3003" title="1 of 2 branches missed.">		if (player == null) {</span>
<span class="nc" id="L3004">			throw new IllegalStateException(&quot;Null player.&quot;);</span>
		}
<span class="fc" id="L3006">		Tension newTension = tension.get(player);</span>
<span class="fc bfc" id="L3007" title="All 2 branches covered.">		if (newTension == null) {</span>
<span class="fc" id="L3008">			newTension = new Tension(Tension.TENSION_MIN);</span>
<span class="fc" id="L3009">			tension.put(player, newTension);</span>
		}
<span class="fc" id="L3011">		return newTension;</span>
	}

	/**
	 * Sets the tension with respect to a given player.
	 *
	 * @param player
	 *            The other &lt;code&gt;Player&lt;/code&gt;.
	 * @param newTension
	 *            The new &lt;code&gt;Tension&lt;/code&gt;.
	 */
	public void setTension(Player player, Tension newTension) {
<span class="pc bpc" id="L3023" title="2 of 4 branches missed.">		if (player == this || player == null) {</span>
<span class="nc" id="L3024">			return;</span>
		}
<span class="fc" id="L3026">		tension.put(player, newTension);</span>
<span class="fc" id="L3027">	}</span>

	/**
	 * Removes all tension with respect to a given player. Used when a player
	 * leaves the game.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to remove tension for.
	 */
	public void removeTension(Player player) {
<span class="nc bnc" id="L3037" title="All 2 branches missed.">		if (player != null) {</span>
<span class="nc" id="L3038">			tension.remove(player);</span>
		}
<span class="nc" id="L3040">	}</span>

	/**
	 * Does this player ban missions from another player?.
	 *
	 * @param player
	 *            The other &lt;code&gt;Player&lt;/code&gt; to test.
	 * @return True if the given player is banned.
	 */
	public boolean missionsBanned(Player player) {
<span class="pc bpc" id="L3050" title="3 of 4 branches missed.">		return bannedMissions != null &amp;&amp; bannedMissions.contains(player);</span>
	}

	/**
	 * Ban a player from establishing missions to this player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to ban.
	 */
	public void addMissionBan(Player player) {
<span class="nc bnc" id="L3060" title="All 2 branches missed.">		if (bannedMissions == null) {</span>
<span class="nc" id="L3061">			bannedMissions = new HashSet&lt;&gt;();</span>
		}
<span class="nc" id="L3063">		bannedMissions.add(player);</span>
<span class="nc" id="L3064">	}</span>

	/**
	 * Remove a mission ban from a player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to clear the ban for.
	 */
	public void removeMissionBan(Player player) {
<span class="nc bnc" id="L3073" title="All 2 branches missed.">		if (bannedMissions != null) {</span>
<span class="nc" id="L3074">			bannedMissions.remove(player);</span>
		}
<span class="nc" id="L3076">	}</span>

	/**
	 * Gets the stance towards a given player.
	 *
	 * @param player
	 *            The other &lt;code&gt;Player&lt;/code&gt; to check.
	 * @return The stance.
	 */
	public Stance getStance(Player player) {
<span class="pc bpc" id="L3086" title="1 of 4 branches missed.">		return (player == null || stance.get(player.getId()) == null) ? Stance.UNCONTACTED : stance.get(player.getId());</span>
	}

	/**
	 * Sets the stance towards a given player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to set the &lt;code&gt;Stance&lt;/code&gt; for.
	 * @param newStance
	 *            The new &lt;code&gt;Stance&lt;/code&gt;.
	 * @return True if the stance change was valid.
	 * @throws IllegalArgumentException
	 *             if player is null or this.
	 */
	public boolean setStance(Player player, Stance newStance) {
<span class="pc bpc" id="L3101" title="1 of 2 branches missed.">		if (player == null) {</span>
<span class="nc" id="L3102">			throw new IllegalArgumentException(&quot;Player must not be 'null'.&quot;);</span>
		}
<span class="pc bpc" id="L3104" title="1 of 2 branches missed.">		if (player == this) {</span>
<span class="nc" id="L3105">			throw new IllegalArgumentException(&quot;Cannot set the stance towards ourselves.&quot;);</span>
		}
<span class="pc bpc" id="L3107" title="1 of 2 branches missed.">		if (newStance == null) {</span>
<span class="nc" id="L3108">			stance.remove(player.getId());</span>
<span class="nc" id="L3109">			return true;</span>
		}
<span class="fc" id="L3111">		Stance oldStance = stance.get(player.getId());</span>
<span class="fc bfc" id="L3112" title="All 2 branches covered.">		if (newStance == oldStance) {</span>
<span class="fc" id="L3113">			return true;</span>
		}

<span class="fc" id="L3116">		boolean valid = true;</span>
		;
<span class="pc bpc" id="L3118" title="2 of 6 branches missed.">		if ((newStance == Stance.CEASE_FIRE &amp;&amp; oldStance != Stance.WAR) || newStance == Stance.UNCONTACTED) {</span>
<span class="nc" id="L3119">			valid = false;</span>
		}
<span class="fc" id="L3121">		stance.put(player.getId(), newStance);</span>
<span class="fc" id="L3122">		return valid;</span>
	}

	/**
	 * Is this player at war with the specified one.
	 *
	 * @param player
	 *            The other &lt;code&gt;Player&lt;/code&gt; to check.
	 * @return True if the players are at war.
	 */
	public boolean atWarWith(Player player) {
<span class="fc bfc" id="L3133" title="All 2 branches covered.">		return getStance(player) == Stance.WAR;</span>
	}

	/**
	 * Checks whether this player is at war with any other player.
	 *
	 * @return True if this player is at war with any other.
	 */
	public boolean isAtWar() {
<span class="fc" id="L3142">		return any(getGame().getLivePlayers(null), p -&gt; atWarWith(p));</span>
	}

	/**
	 * Has this player met contacted the given one?.
	 *
	 * @param player
	 *            The other &lt;code&gt;Player&lt;/code&gt; to check.
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; has contacted the other.
	 */
	public boolean hasContacted(Player player) {
<span class="fc bfc" id="L3153" title="All 2 branches covered.">		return getStance(player) != Stance.UNCONTACTED;</span>
	}

	/**
	 * Has this player has met with any Europeans at all?.
	 *
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; has contacted any Europeans.
	 */
	public boolean hasContactedEuropeans() {
<span class="nc" id="L3162">		return any(getGame().getLiveEuropeanPlayers(this), p -&gt; hasContacted(p));</span>
	}

	/**
	 * Has this player met any natives at all?.
	 *
	 * @return True if this &lt;code&gt;Player&lt;/code&gt; has contacted any natives.
	 */
	public boolean hasContactedIndians() {
<span class="nc" id="L3171">		return any(getGame().getLiveNativePlayers(this), p -&gt; hasContacted(p));</span>
	}

	/**
	 * Set this player as having made initial contact with another player.
	 * Always start with PEACE, which can go downhill fast.
	 *
	 * @param player1
	 *            One &lt;code&gt;Player&lt;/code&gt; to check.
	 * @param player2
	 *            The other &lt;code&gt;Player&lt;/code&gt; to check.
	 */
	public static void makeContact(Player player1, Player player2) {
<span class="fc" id="L3184">		player1.stance.put(player2.getId(), Stance.PEACE);</span>
<span class="fc" id="L3185">		player2.stance.put(player1.getId(), Stance.PEACE);</span>
<span class="fc" id="L3186">		player1.setTension(player2, new Tension(Tension.TENSION_MIN));</span>
<span class="fc" id="L3187">		player2.setTension(player1, new Tension(Tension.TENSION_MIN));</span>
<span class="fc" id="L3188">	}</span>

	/**
	 * Gets the price of the given land.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to get the price for.
	 * @return The price of the land if it is for sale, zero if it is already
	 *         ours, unclaimed or unwanted, negative if it is not for sale.
	 */
	public int getLandPrice(Tile tile) {
<span class="fc" id="L3199">		final Specification spec = getSpecification();</span>
<span class="fc" id="L3200">		Player nationOwner = tile.getOwner();</span>

<span class="pc bpc" id="L3202" title="2 of 4 branches missed.">		if (nationOwner == null || nationOwner == this) {</span>
<span class="nc" id="L3203">			return 0; // Freely available</span>
<span class="pc bpc" id="L3204" title="1 of 2 branches missed.">		} else if (tile.hasSettlement()) {</span>
<span class="nc" id="L3205">			return -1; // Not for sale</span>
<span class="fc bfc" id="L3206" title="All 2 branches covered.">		} else if (nationOwner.isEuropean()) {</span>
<span class="pc bpc" id="L3207" title="2 of 4 branches missed.">			if (tile.getOwningSettlement() != null &amp;&amp; tile.getOwningSettlement().getOwner() == nationOwner) {</span>
<span class="fc" id="L3208">				return -1; // Nailed down by a European colony</span>
			} else {
<span class="nc" id="L3210">				return 0; // Claim abandoned or only by tile improvement</span>
			}
		} // Else, native ownership
<span class="fc" id="L3213">		int price = spec.getInteger(GameOptions.LAND_PRICE_FACTOR) * spec.getGoodsTypeList().stream()</span>
				// Only consider specific food types, not the aggregation.
<span class="fc bfc" id="L3215" title="All 2 branches covered.">				.filter(gt -&gt; gt != spec.getPrimaryFoodType()).mapToInt(gt -&gt; tile.getPotentialProduction(gt, null))</span>
<span class="fc" id="L3216">				.sum() + 100;</span>
<span class="fc" id="L3217">		return (int) applyModifiers(price, getGame().getTurn(), Modifier.LAND_PAYMENT_MODIFIER);</span>
	}

	/**
	 * Access the nation cache.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to get the summary for.
	 * @return The current &lt;code&gt;NationSummary&lt;/code&gt; for a player.
	 */
	public NationSummary getNationSummary(Player player) {
<span class="fc" id="L3228">		return nationCache.get(player);</span>
	}

	/**
	 * Update the nation cache.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to get the summary for.
	 * @param ns
	 *            The new &lt;code&gt;NationSummary&lt;/code&gt; for the player.
	 */
	public void putNationSummary(Player player, NationSummary ns) {
<span class="fc" id="L3240">		nationCache.put(player, ns);</span>
<span class="fc" id="L3241">	}</span>

	/**
	 * Clear the nation cache.
	 */
	public void clearNationCache() {
<span class="fc" id="L3247">		nationCache.clear();</span>
<span class="fc" id="L3248">	}</span>

	/**
	 * Get the strength ratio of this player with respect to another.
	 *
	 * This relies on an up-to-date nation cache value for the target player.
	 *
	 * @param other
	 *            The other &lt;code&gt;Player&lt;/code&gt;.
	 * @param naval
	 *            If true, get the naval strength, else the land strength.
	 * @return The strength ratio (strength/sum(strengths)), or negative on
	 *         error.
	 */
	public double getStrengthRatio(Player other, boolean naval) {
<span class="nc" id="L3263">		NationSummary ns = getNationSummary(other);</span>
<span class="nc bnc" id="L3264" title="All 2 branches missed.">		if (ns == null) {</span>
<span class="nc" id="L3265">			return -1.0;</span>
		}
<span class="nc" id="L3267">		int strength = calculateStrength(naval);</span>
<span class="nc" id="L3268">		return strengthRatio((double) strength, ns.getMilitaryStrength());</span>
	}

	/**
	 * Abstraction of the strength ratio calculation.
	 *
	 * @param ours
	 *            The player strength.
	 * @param theirs
	 *            The enemy strength.
	 * @return The resulting strength ratio.
	 */
	public static double strengthRatio(double ours, double theirs) {
<span class="pc bpc" id="L3281" title="1 of 2 branches missed.">		return (ours == 0.0) ? 0.0 : ours / (ours + theirs);</span>
	}

	//
	// Claiming of tiles
	//

	/**
	 * A variety of reasons why a tile can not be claimed, either to found a
	 * settlement or just to be used by one, including the double negative NONE
	 * == &quot;no reason&quot; case.
	 */
<span class="pc" id="L3293">	public static enum NoClaimReason implements Named {</span>

		/** The none. */
<span class="fc" id="L3296">		NONE,</span>
		/** The terrain. */
		// Actually, tile can be claimed
<span class="fc" id="L3299">		TERRAIN,</span>
		/** The rumour. */
		// Not on settleable terrain
<span class="fc" id="L3302">		RUMOUR,</span>
		/** The water. */
		// Europeans can not claim tiles with LCR
<span class="fc" id="L3305">		WATER,</span>
		/** The occupied. */
		// Natives do not claim water
<span class="fc" id="L3308">		OCCUPIED,</span>
		/** The settlement. */
		// Hostile unit present.
<span class="fc" id="L3311">		SETTLEMENT,</span>
		/** The worked. */
		// Settlement present
<span class="fc" id="L3314">		WORKED,</span>
		/** The europeans. */
		// One of our settlements is working this tile
<span class="fc" id="L3317">		EUROPEANS,</span>
		/** The natives. */
		// Owned by Europeans and not for sale
<span class="fc" id="L3320">		NATIVES; // Owned by natives and they want payment for it</span>

		/**
		 * Get a message key describing this reason.
		 *
		 * @return A message key.
		 */
		private String getKey() {
<span class="nc" id="L3328">			return &quot;noClaimReason.&quot; + getEnumKey(this);</span>
		}

		/**
		 * Gets the description key.
		 *
		 * @return the description key
		 */
		public String getDescriptionKey() {
<span class="nc" id="L3337">			return Messages.descriptionKey(&quot;model.&quot; + getKey());</span>
		}

		// Implement Named

		/**
		 * {@inheritDoc}
		 */
		public String getNameKey() {
<span class="nc" id="L3346">			return Messages.nameKey(&quot;model.&quot; + getKey());</span>
		}
	};

	/**
	 * Can a tile be owned by this player?.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to consider.
	 * @return True if the tile can be owned by this player.
	 */
	public boolean canOwnTile(Tile tile) {
<span class="fc bfc" id="L3358" title="All 2 branches covered.">		return canOwnTileReason(tile) == NoClaimReason.NONE;</span>
	}

	/**
	 * Can a tile be owned by this player? This is a test of basic practicality
	 * and does not consider the full complexity of tile ownership issues.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to consider.
	 * @return The reason why/not the tile can be owned by this player.
	 */
	private NoClaimReason canOwnTileReason(Tile tile) {
<span class="fc bfc" id="L3370" title="All 6 branches covered.">		return (any(tile.getUnitList(), u -&gt; u.getOwner() != this &amp;&amp; u.isOffensiveUnit())) ? NoClaimReason.OCCUPIED // The</span>
																													// tile
																													// is
																													// held
																													// against
																													// us
<span class="fc bfc" id="L3376" title="All 4 branches covered.">				: (isEuropean()) ? ((tile.hasLostCityRumour()) ? NoClaimReason.RUMOUR : NoClaimReason.NONE)</span>
<span class="fc bfc" id="L3377" title="All 2 branches covered.">						: ((tile.isLand()) ? NoClaimReason.NONE : NoClaimReason.WATER);</span>
	}

	/**
	 * Checks if a tile can be claimed for use by a settlement.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
	 * @return True if the tile can be claimed to found a settlement.
	 */
	public boolean canClaimForSettlement(Tile tile) {
<span class="fc bfc" id="L3388" title="All 2 branches covered.">		return canClaimForSettlementReason(tile) == NoClaimReason.NONE;</span>
	}

	/**
	 * The test for whether a tile can be freely claimed by a player settlement
	 * (freely =&gt; not by purchase or stealing). The rule for the center tile is
	 * different, see below.
	 *
	 * The tile must be ownable by this player, settlement-free, and either not
	 * currently owned, owned by this player and not by another settlement that
	 * is using the tile, or owned by someone else who does not want anything
	 * for it. Got that?
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
	 * @return The reason why/not the tile can be claimed.
	 */
	public NoClaimReason canClaimForSettlementReason(Tile tile) {
		int price;
<span class="fc" id="L3407">		NoClaimReason reason = canOwnTileReason(tile);</span>
<span class="fc bfc" id="L3408" title="All 2 branches covered.">		return (reason != NoClaimReason.NONE) ? reason</span>
<span class="fc bfc" id="L3409" title="All 2 branches covered.">				: (tile.hasSettlement()) ? NoClaimReason.SETTLEMENT</span>
<span class="fc bfc" id="L3410" title="All 2 branches covered.">						: (tile.getOwner() == null) ? NoClaimReason.NONE</span>
<span class="fc bfc" id="L3411" title="All 2 branches covered.">								: (tile.getOwner() == this)</span>
<span class="fc bfc" id="L3412" title="All 2 branches covered.">										? ((tile.isInUse()) ? NoClaimReason.WORKED : NoClaimReason.NONE)</span>
<span class="fc bfc" id="L3413" title="All 4 branches covered.">										: ((price = getLandPrice(tile)) &lt; 0) ? NoClaimReason.EUROPEANS</span>
												: (price &gt; 0) ? NoClaimReason.NATIVES : NoClaimReason.NONE;
	}

	/**
	 * Can a tile be claimed to found a settlement on?.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
	 * @return True if the tile can be claimed to found a settlement.
	 */
	public boolean canClaimToFoundSettlement(Tile tile) {
<span class="fc bfc" id="L3425" title="All 2 branches covered.">		return canClaimToFoundSettlementReason(tile) == NoClaimReason.NONE;</span>
	}

	/**
	 * Can a tile be claimed to found a settlement on? Almost the same as
	 * canClaimForSettlement but there is an extra requirement that the tile be
	 * of a settleable type, and some relaxations that allow free center tile
	 * acquisition.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
	 * @return The reason why/not the tile can be claimed.
	 */
	public NoClaimReason canClaimToFoundSettlementReason(Tile tile) {
		NoClaimReason reason;
<span class="fc bfc" id="L3440" title="All 2 branches covered.">		return (!tile.getType().canSettle()) ? NoClaimReason.TERRAIN</span>
<span class="fc bfc" id="L3441" title="All 2 branches covered.">				: ((reason = canClaimForSettlementReason(tile)) != NoClaimReason.NATIVES) ? reason</span>
<span class="pc bpc" id="L3442" title="1 of 2 branches missed.">						: (!tile.getAdjacentColonies().isEmpty()) ? NoClaimReason.SETTLEMENT</span>
<span class="pc bpc" id="L3443" title="1 of 2 branches missed.">								: (canClaimFreeCenterTile(tile)) ? NoClaimReason.NONE : NoClaimReason.NATIVES;</span>
	}

	/**
	 * Is this tile claimable for a colony center tile under the special
	 * provisions of the model.option.buildOnNativeLand option.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
	 * @return True if the tile can be claimed.
	 */
	private boolean canClaimFreeCenterTile(Tile tile) {
<span class="fc" id="L3455">		final Specification spec = getGame().getSpecification();</span>
<span class="fc" id="L3456">		String build = spec.getString(GameOptions.BUILD_ON_NATIVE_LAND);</span>
<span class="pc bpc" id="L3457" title="3 of 6 branches missed.">		return isEuropean() &amp;&amp; tile.getOwner() != null &amp;&amp; tile.getOwner().isIndian()</span>
<span class="pc bpc" id="L3458" title="1 of 2 branches missed.">				&amp;&amp; (GameOptions.BUILD_ON_NATIVE_LAND_ALWAYS.equals(build)</span>
<span class="pc bpc" id="L3459" title="3 of 4 branches missed.">						|| (GameOptions.BUILD_ON_NATIVE_LAND_FIRST.equals(build) &amp;&amp; hasZeroSettlements())</span>
<span class="pc bpc" id="L3460" title="2 of 4 branches missed.">						|| (GameOptions.BUILD_ON_NATIVE_LAND_FIRST_AND_UNCONTACTED.equals(build) &amp;&amp; hasZeroSettlements()</span>
<span class="pc bnc" id="L3461" title="All 4 branches missed.">								&amp;&amp; (tile.getOwner() == null || tile.getOwner().getStance(this) == Stance.UNCONTACTED)));</span>
	}

	/**
	 * The second and third cases of buildOnNative land need to test if the
	 * player has no settlements yet. We can not just check that the number of
	 * settlement is zero because by the time the settlement is being placed and
	 * we are collecting the tiles to claim, the settlement already exists and
	 * thus there will already be one settlement--- so we have to check if that
	 * one settlement is on the map yet.
	 *
	 * @return True if the player has no settlements (on the map) yet.
	 */
	private boolean hasZeroSettlements() {
<span class="fc" id="L3475">		List&lt;Settlement&gt; settlements = getSettlements();</span>
<span class="pc bpc" id="L3476" title="1 of 2 branches missed.">		return settlements.isEmpty()</span>
<span class="pc bpc" id="L3477" title="2 of 4 branches missed.">				|| (settlements.size() == 1 &amp;&amp; settlements.get(0).getTile().getSettlement() == null);</span>
	}

	/**
	 * Can the ownership of this tile be claimed for the purposes of making an
	 * improvement. Quick test that does not handle the curly case of tile
	 * transfer between colonies, or guarantee success (natives may want to be
	 * paid), but just that success is possible.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to consider.
	 *
	 * @return True if the tile ownership can be claimed.
	 */
	public boolean canClaimForImprovement(Tile tile) {
<span class="fc" id="L3492">		Player owner = tile.getOwner();</span>
<span class="pc bpc" id="L3493" title="4 of 6 branches missed.">		return owner == null || owner == this || getLandPrice(tile) == 0;</span>
	}

	/**
	 * Can a tile be acquired from its owners and used for an improvement?
	 * Slightly weakens canClaimForImprovement to allow for purchase and/or
	 * stealing.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to consider.
	 * @return True if the tile ownership can be claimed.
	 */
	public boolean canAcquireForImprovement(Tile tile) {
<span class="pc bpc" id="L3506" title="3 of 4 branches missed.">		return canClaimForImprovement(tile) || getLandPrice(tile) &gt; 0;</span>
	}

	/**
	 * Gets the list of tiles that might be claimable by a settlement. We can
	 * not do a simple iteration of the rings because this allows settlements to
	 * claim tiles across unclaimable gaps (e.g. Aztecs owning tiles on nearby
	 * islands). So we have to only allow tiles that are adjacent to a known
	 * connected tile.
	 *
	 * @param centerTile
	 *            The intended settlement center &lt;code&gt;Tile&lt;/code&gt;.
	 * @param radius
	 *            The radius of the settlement.
	 * @return A list of potentially claimable tiles.
	 */
	public List&lt;Tile&gt; getClaimableTiles(Tile centerTile, int radius) {
<span class="fc" id="L3523">		List&lt;Tile&gt; tiles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3524">		List&lt;Tile&gt; layer = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3525" title="All 2 branches covered.">		if (canClaimToFoundSettlement(centerTile)) {</span>
<span class="fc" id="L3526">			layer.add(centerTile);</span>
<span class="fc bfc" id="L3527" title="All 2 branches covered.">			for (int r = 1; r &lt;= radius; r++) {</span>
<span class="fc" id="L3528">				List&lt;Tile&gt; lastLayer = new ArrayList&lt;&gt;(layer);</span>
<span class="fc" id="L3529">				tiles.addAll(layer);</span>
<span class="fc" id="L3530">				layer.clear();</span>
<span class="fc bfc" id="L3531" title="All 2 branches covered.">				for (Tile have : lastLayer) {</span>
<span class="fc bfc" id="L3532" title="All 2 branches covered.">					for (Tile next : have.getSurroundingTiles(1)) {</span>
<span class="fc bfc" id="L3533" title="All 4 branches covered.">						if (!tiles.contains(next) &amp;&amp; canClaimForSettlement(next)) {</span>
<span class="fc" id="L3534">							layer.add(next);</span>
						}
<span class="fc" id="L3536">					}</span>
<span class="fc" id="L3537">				}</span>
			}
<span class="fc" id="L3539">			tiles.addAll(layer);</span>
		}
<span class="fc" id="L3541">		return tiles;</span>
	}

	//
	// AI helpers for evaluation settlement locations
	//

	/**
	 * Not currently in use. Leave here for now, it might yet be revived.
	 * 
	 * Calculates the value of an outpost-type colony at this tile. An &quot;outpost&quot;
	 * is supposed to be a colony containing one worker, exporting its whole
	 * production to europe. The value of such colony is the maximum amount of
	 * money it can make in one turn, assuming sale of its secondary goods plus
	 * farmed goods from one of the surrounding tiles.
	 *
	 * @param tile
	 *            the tile
	 * @return The value of a future colony located on this tile. This value is
	 *         used by the AI when deciding where to build a new colony. public
	 *         int getOutpostValue(Tile t) { Market market = getMarket(); if
	 *         (canClaimToFoundSettlement(t)) { boolean nearbyTileIsOcean =
	 *         false; float advantages = 1f; int value = 0; for (Tile tile :
	 *         t.getSurroundingTiles(1)) { if (tile.getColony() != null) { //
	 *         can't build next to colony return 0; } else if
	 *         (tile.hasSettlement()) { // can build next to an indian
	 *         settlement, but shouldn't SettlementType type =
	 *         tile.getSettlement().getType(); if (type.getClaimableRadius() &gt;
	 *         1) { // really shouldn't build next to cities advantages *=
	 *         0.25f; } else { advantages *= 0.5f; } } else { if
	 *         (tile.isHighSeasConnected()) { nearbyTileIsOcean = true; } if
	 *         (tile.getType()!=null) { for (AbstractGoods production :
	 *         tile.getType().getProduction()) { GoodsType type =
	 *         production.getType(); int potential = market.getSalePrice(type,
	 *         tile.getPotentialProduction(type, null)); if (tile.getOwner() !=
	 *         null &amp;&amp; !this.owns(tile)) { // tile is already owned by someone
	 *         (and not by us!) if (tile.getOwner().isEuropean()) { continue; }
	 *         else { potential /= 2; } } value = Math.max(value, potential); }
	 *         } } }
	 * 
	 *         // add good that could be produced by a colony on this tile int
	 *         bestValue = 0; for (ProductionType productionType : t.getType()
	 *         .getAvailableProductionTypes(true)) { if
	 *         (productionType.getOutputs() != null) { int newValue = 0; for
	 *         (AbstractGoods output: productionType.getOutputs()) { newValue +=
	 *         market.getSalePrice(output.getType(),
	 *         t.getPotentialProduction(output.getType(), null)); } if (newValue
	 *         &gt; bestValue) { bestValue = newValue; } } } value += bestValue; if
	 *         (nearbyTileIsOcean) { return Math.max(0, (int) (value *
	 *         advantages)); } } return 0; }
	 */

	/**
	 * Gets a list of values for building a &lt;code&gt;Colony&lt;/code&gt; on the given
	 * tile for each &lt;code&gt;ColonyValueCategory&lt;/code&gt;.
	 *
	 * FIXME: tune magic numbers and expose more to the spec.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt;
	 * @return A list of values.
	 */
	public List&lt;Double&gt; getAllColonyValues(Tile tile) {
		// Want a few settlements before taking risks
<span class="nc" id="L3605">		final int LOW_SETTLEMENT_NUMBER = 3;</span>

		// Would like a caravel to reach high seas in 3 moves
<span class="nc" id="L3608">		final int LONG_PATH_TILES = 12;</span>

		// Applied once
<span class="nc" id="L3611">		final double MOD_HAS_RESOURCE = 0.75;</span>
<span class="nc" id="L3612">		final double MOD_FOOD_LOW = 0.75;</span>
<span class="nc" id="L3613">		final double MOD_INITIAL_FOOD = 2.0;</span>
<span class="nc" id="L3614">		final double MOD_STEAL = 0.5;</span>
<span class="nc" id="L3615">		final double MOD_INLAND = 0.5;</span>

		// Applied per surrounding tile
<span class="nc" id="L3618">		final double MOD_OWNED_EUROPEAN = 0.67;</span>
<span class="nc" id="L3619">		final double MOD_OWNED_NATIVE = 0.8;</span>

		// Applied per goods production, per surrounding tile
<span class="nc" id="L3622">		final double MOD_HIGH_PRODUCTION = 1.2;</span>
<span class="nc" id="L3623">		final double MOD_GOOD_PRODUCTION = 1.1;</span>

		// Applied per occurrence (own colony only one-time), range-dependent.
<span class="nc" id="L3626">		final int DISTANCE_MAX = 5;</span>
<span class="nc" id="L3627">		final double[] MOD_OWN_COLONY = { 0.0, 0.0, 0.5, 1.50, 1.25 };</span>
<span class="nc" id="L3628">		final double[] MOD_ENEMY_COLONY = { 0.0, 0.0, 0.4, 0.50, 0.70 };</span>
<span class="nc" id="L3629">		final double[] MOD_NEUTRAL_COLONY = { 0.0, 0.0, 0.7, 0.80, 1.00 };</span>
<span class="nc" id="L3630">		final double[] MOD_ENEMY_UNIT = { 0.4, 0.5, 0.6, 0.75, 0.90 };</span>

		// Goods production in excess of this on a tile counts as good/high
<span class="nc" id="L3633">		final int GOOD_PRODUCTION = 4;</span>
<span class="nc" id="L3634">		final int HIGH_PRODUCTION = 8;</span>

		// Counting &quot;high&quot; production as 2, &quot;good&quot; production as 1
		// overall food production is considered low/very low if less than...
<span class="nc" id="L3638">		final int FOOD_LOW = 4;</span>
<span class="nc" id="L3639">		final int FOOD_VERY_LOW = 1;</span>

		// Multiplicative modifiers, to be applied to value later
<span class="nc" id="L3642">		List&lt;Double&gt; values = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3643" title="All 2 branches missed.">		for (ColonyValueCategory c : ColonyValueCategory.values()) {</span>
<span class="nc" id="L3644">			values.add(1.0);</span>
		}
		// Penalize certain problems more in the initial colonies.
<span class="nc" id="L3647">		double development = Math.min(LOW_SETTLEMENT_NUMBER, settlements.size()) / (double) LOW_SETTLEMENT_NUMBER;</span>
<span class="nc" id="L3648">		int portCount = getNumberOfPorts();</span>

<span class="nc bnc" id="L3650" title="All 4 branches missed.">		if (tile.isPolar() &amp;&amp; settlements.size() &lt; LOW_SETTLEMENT_NUMBER) {</span>
<span class="nc" id="L3651">			values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.POLAR.getDouble());</span>
<span class="nc" id="L3652">			return values;</span>
		}

<span class="pc bnc" id="L3655" title="All 7 branches missed.">		switch (canClaimToFoundSettlementReason(tile)) {</span>
		case NONE:
<span class="nc" id="L3657">			break;</span>
		case TERRAIN:
		case WATER:
<span class="nc" id="L3660">			values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.TERRAIN.getDouble());</span>
<span class="nc" id="L3661">			return values;</span>
		case RUMOUR:
<span class="nc bnc" id="L3663" title="All 2 branches missed.">			if (settlements.isEmpty()) {</span>
<span class="nc" id="L3664">				values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.RUMOUR.getDouble());</span>
<span class="nc" id="L3665">				return values;</span>
			}
<span class="nc" id="L3667">			values.set(ColonyValueCategory.A_TILE.ordinal(), development);</span>
<span class="nc" id="L3668">			break;</span>
		case OCCUPIED: // transient we hope
<span class="nc" id="L3670">			values.set(ColonyValueCategory.A_TILE.ordinal(), MOD_ENEMY_UNIT[0]);</span>
<span class="nc" id="L3671">			break;</span>
		case SETTLEMENT:
		case WORKED:
		case EUROPEANS:
<span class="nc" id="L3675">			values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3676">			return values;</span>
		case NATIVES: // If we have no ports, we are desperate enough to steal
<span class="nc bnc" id="L3678" title="All 4 branches missed.">			if (tile.getOwningSettlement() != null &amp;&amp; tile.getOwningSettlement().getTile() != null</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">					&amp;&amp; tile.getOwningSettlement().getTile().isAdjacent(tile)) {</span>
<span class="nc" id="L3680">				values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3681">				return values;</span>
			}
<span class="nc" id="L3683">			int price = getLandPrice(tile);</span>
<span class="nc bnc" id="L3684" title="All 6 branches missed.">			if (price &gt; 0 &amp;&amp; !checkGold(price) &amp;&amp; portCount &gt; 0) {</span>
<span class="nc" id="L3685">				values.set(ColonyValueCategory.A_TILE.ordinal(), MOD_STEAL);</span>
			}
			break;
		default:
<span class="nc" id="L3689">			values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.BOGUS.getDouble());</span>
<span class="nc" id="L3690">			return values;</span>
		}

		// Set up maps for all foods and building materials
<span class="nc" id="L3694">		final Specification spec = getSpecification();</span>
<span class="nc" id="L3695">		TypeCountMap&lt;GoodsType&gt; production = new TypeCountMap&lt;&gt;();</span>

		// Initialize tile value with food production.
<span class="nc" id="L3698">		int initialFood = 0;</span>
<span class="nc" id="L3699">		final GoodsType foodType = spec.getPrimaryFoodType();</span>
<span class="nc bnc" id="L3700" title="All 2 branches missed.">		for (ProductionType productionType : tile.getType().getAvailableProductionTypes(true)) {</span>
<span class="nc bnc" id="L3701" title="All 2 branches missed.">			for (AbstractGoods output : productionType.getOutputs()) {</span>
<span class="nc bnc" id="L3702" title="All 2 branches missed.">				if (!output.getType().isFoodType()) {</span>
<span class="nc" id="L3703">					continue;</span>
				}
<span class="nc" id="L3705">				int amount = tile.getPotentialProduction(output.getType(), null);</span>
<span class="nc bnc" id="L3706" title="All 2 branches missed.">				if (amount &gt; initialFood) {</span>
<span class="nc" id="L3707">					initialFood = amount;</span>
				}
<span class="nc" id="L3709">			}</span>
<span class="nc" id="L3710">		}</span>
<span class="nc bnc" id="L3711" title="All 2 branches missed.">		if (initialFood &lt;= FOOD_VERY_LOW) {</span>
<span class="nc" id="L3712">			values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.FOOD.getDouble());</span>
<span class="nc" id="L3713">			return values;</span>
		}
<span class="nc" id="L3715">		production.incrementCount(foodType, initialFood);</span>
<span class="nc" id="L3716">		values.set(ColonyValueCategory.A_PROD.ordinal(), (double) initialFood * foodType.getProductionWeight());</span>

		// Penalty if there is no direct connection to the high seas, or
		// if it is too long.
<span class="nc" id="L3720">		int tilesToHighSeas = tile.getHighSeasCount();</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">		if (tilesToHighSeas &lt; 0) {</span>
<span class="nc bnc" id="L3722" title="All 2 branches missed.">			if (portCount &lt; LOW_SETTLEMENT_NUMBER) {</span>
<span class="nc" id="L3723">				values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.INLAND.getDouble());</span>
<span class="nc" id="L3724">				return values;</span>
			}
<span class="nc" id="L3726">			values.set(ColonyValueCategory.A_EUROPE.ordinal(), MOD_INLAND);</span>
<span class="nc bnc" id="L3727" title="All 2 branches missed.">		} else if (tilesToHighSeas &gt;= LONG_PATH_TILES) {</span>
			// Normally penalize in direct proportion to length of
			// path, but scale up to penalizing by the square of the
			// path length for the first colony.
<span class="nc" id="L3731">			double trip = (double) LONG_PATH_TILES / tilesToHighSeas;</span>
<span class="nc" id="L3732">			values.set(ColonyValueCategory.A_EUROPE.ordinal(), Math.pow(trip, 2.0 - development));</span>
<span class="nc" id="L3733">		} else {</span>
<span class="nc" id="L3734">			values.set(ColonyValueCategory.A_EUROPE.ordinal(),</span>
<span class="nc" id="L3735">					1.0 + 0.25 * ((double) LONG_PATH_TILES / (LONG_PATH_TILES - tilesToHighSeas)));</span>
		}

		// Penalty for building on a resource tile, because production
		// can not be improved much.
<span class="nc bnc" id="L3740" title="All 2 branches missed.">		values.set(ColonyValueCategory.A_RESOURCE.ordinal(), (tile.hasResource()) ? MOD_HAS_RESOURCE : 1.0);</span>

<span class="nc" id="L3742">		Set&lt;GoodsType&gt; highProduction = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3743">		Set&lt;GoodsType&gt; goodProduction = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3744" title="All 2 branches missed.">		for (Tile t : tile.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L3745" title="All 2 branches missed.">			if (t.getType() == null) {</span>
<span class="nc" id="L3746">				continue; // Unexplored!?!</span>
			}
<span class="nc bnc" id="L3748" title="All 2 branches missed.">			if (t.getSettlement() != null) { // Should not happen, tested above</span>
<span class="nc" id="L3749">				values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3750">				return values;</span>
			}

<span class="nc" id="L3753">			double pf = 1.0;</span>
<span class="nc bnc" id="L3754" title="All 4 branches missed.">			if (t.getOwner() != null &amp;&amp; !this.owns(t)) {</span>
<span class="nc bnc" id="L3755" title="All 2 branches missed.">				if (t.getOwner().isEuropean()) {</span>
<span class="nc bnc" id="L3756" title="All 2 branches missed.">					if (portCount &lt; LOW_SETTLEMENT_NUMBER) {</span>
<span class="nc" id="L3757">						values.set(ColonyValueCategory.A_OVERRIDE.ordinal(), NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3758">						return values;</span>
					}
<span class="nc" id="L3760">					values.set(ColonyValueCategory.A_ADJACENT.ordinal(),</span>
<span class="nc" id="L3761">							values.get(ColonyValueCategory.A_ADJACENT.ordinal()) * MOD_OWNED_EUROPEAN * development);</span>
<span class="nc" id="L3762">					continue; // Always ignore production from this tile</span>
				} else {
<span class="nc" id="L3764">					pf = MOD_OWNED_NATIVE;</span>
<span class="nc bnc" id="L3765" title="All 2 branches missed.">					if (portCount &gt; 0) {</span>
<span class="nc" id="L3766">						pf *= development;</span>
					}
				}
			}

			// Count production
<span class="nc bnc" id="L3772" title="All 2 branches missed.">			for (AbstractGoods ag : t.getSortedPotential()) {</span>
<span class="nc" id="L3773">				GoodsType type = ag.getType();</span>
<span class="nc bnc" id="L3774" title="All 2 branches missed.">				if (type.isFoodType()) {</span>
<span class="nc" id="L3775">					type = foodType;</span>
				}
<span class="nc" id="L3777">				int amount = ag.getAmount();</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">				if (!t.isLand()) {</span>
<span class="nc" id="L3779">					amount *= development;</span>
				}
<span class="nc" id="L3781">				values.set(ColonyValueCategory.A_PROD.ordinal(),</span>
<span class="nc" id="L3782">						values.get(ColonyValueCategory.A_PROD.ordinal()) + amount * type.getProductionWeight() * pf);</span>
<span class="nc" id="L3783">				production.incrementCount(type, amount);</span>
				// A few tiles with distinct high production are
				// better than many tiles with low production.
<span class="nc bnc" id="L3786" title="All 2 branches missed.">				if (amount &gt; HIGH_PRODUCTION) {</span>
<span class="nc" id="L3787">					highProduction.add(type);</span>
<span class="nc bnc" id="L3788" title="All 2 branches missed.">				} else if (amount &gt; GOOD_PRODUCTION) {</span>
<span class="nc" id="L3789">					goodProduction.add(type);</span>
				}
<span class="nc" id="L3791">			}</span>

<span class="nc bnc" id="L3793" title="All 2 branches missed.">			for (Unit u : t.getUnitList()) {</span>
<span class="nc bnc" id="L3794" title="All 6 branches missed.">				if (!owns(u) &amp;&amp; u.isOffensiveUnit() &amp;&amp; atWarWith(u.getOwner())) {</span>
<span class="nc" id="L3795">					values.set(ColonyValueCategory.A_ADJACENT.ordinal(),</span>
<span class="nc" id="L3796">							values.get(ColonyValueCategory.A_ADJACENT.ordinal()) * MOD_ENEMY_UNIT[1]);</span>
				}
<span class="nc" id="L3798">			}</span>
<span class="nc" id="L3799">		}</span>

<span class="nc bnc" id="L3801" title="All 2 branches missed.">		for (GoodsType g : highProduction) {</span>
<span class="nc" id="L3802">			values.set(ColonyValueCategory.A_LEVEL.ordinal(),</span>
<span class="nc" id="L3803">					values.get(ColonyValueCategory.A_LEVEL.ordinal()) * MOD_HIGH_PRODUCTION);</span>
<span class="nc" id="L3804">			goodProduction.remove(g);</span>
<span class="nc" id="L3805">		}</span>
<span class="nc bnc" id="L3806" title="All 2 branches missed.">		if (!goodProduction.isEmpty()) {</span>
<span class="nc" id="L3807">			values.set(ColonyValueCategory.A_LEVEL.ordinal(),</span>
<span class="nc" id="L3808">					values.get(ColonyValueCategory.A_LEVEL.ordinal()) * MOD_GOOD_PRODUCTION * goodProduction.size());</span>
		}

		// Apply modifiers for other settlements and units at distance.
<span class="nc" id="L3812">		boolean supportingColony = false;</span>
<span class="nc bnc" id="L3813" title="All 2 branches missed.">		for (int radius = 2; radius &lt; DISTANCE_MAX; radius++) {</span>
<span class="nc bnc" id="L3814" title="All 2 branches missed.">			for (Tile t : getGame().getMap().getCircleTiles(tile, false, radius)) {</span>
<span class="nc" id="L3815">				Settlement settlement = t.getSettlement();</span>
<span class="nc bnc" id="L3816" title="All 2 branches missed.">				if (settlement != null) {</span>
<span class="nc bnc" id="L3817" title="All 2 branches missed.">					if (owns(settlement)) {</span>
<span class="nc bnc" id="L3818" title="All 2 branches missed.">						if (!supportingColony) {</span>
<span class="nc" id="L3819">							supportingColony = true;</span>
<span class="nc" id="L3820">							values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3821">									values.get(ColonyValueCategory.A_NEARBY.ordinal()) * MOD_OWN_COLONY[radius]);</span>
						}
<span class="nc bnc" id="L3823" title="All 2 branches missed.">					} else if (atWarWith(settlement.getOwner())) {</span>
<span class="nc" id="L3824">						values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3825">								values.get(ColonyValueCategory.A_NEARBY.ordinal()) * MOD_ENEMY_COLONY[radius]);</span>
					} else {
<span class="nc" id="L3827">						values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3828">								values.get(ColonyValueCategory.A_NEARBY.ordinal()) * MOD_NEUTRAL_COLONY[radius]);</span>
					}
				}

<span class="nc bnc" id="L3832" title="All 2 branches missed.">				for (Unit u : t.getUnitList()) {</span>
<span class="nc bnc" id="L3833" title="All 6 branches missed.">					if (!owns(u) &amp;&amp; u.isOffensiveUnit() &amp;&amp; atWarWith(u.getOwner())) {</span>
<span class="nc" id="L3834">						values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3835">								values.get(ColonyValueCategory.A_NEARBY.ordinal()) * MOD_ENEMY_UNIT[radius]);</span>
					}
<span class="nc" id="L3837">				}</span>
<span class="nc" id="L3838">			}</span>
		}

		// Check availability of key goods
<span class="nc bnc" id="L3842" title="All 2 branches missed.">		if (production.getCount(foodType) &lt; FOOD_LOW) {</span>
<span class="nc" id="L3843">			values.set(ColonyValueCategory.A_FOOD.ordinal(),</span>
<span class="nc" id="L3844">					values.get(ColonyValueCategory.A_FOOD.ordinal()) * MOD_FOOD_LOW);</span>
		}
<span class="nc" id="L3846">		int a = ColonyValueCategory.A_GOODS.ordinal() - 1;</span>
<span class="nc bnc" id="L3847" title="All 2 branches missed.">		for (GoodsType type : production.keySet()) {</span>
<span class="nc" id="L3848">			Integer amount = production.getCount(type);</span>
<span class="nc" id="L3849">			double threshold = type.getLowProductionThreshold();</span>
<span class="nc bnc" id="L3850" title="All 2 branches missed.">			if (threshold &gt; 0.0) {</span>
<span class="nc bnc" id="L3851" title="All 2 branches missed.">				if (++a == values.size())</span>
<span class="nc" id="L3852">					values.add(1.0);</span>
<span class="nc bnc" id="L3853" title="All 2 branches missed.">				if (amount &lt; threshold) {</span>
<span class="nc" id="L3854">					double fraction = (double) amount / threshold;</span>
<span class="nc" id="L3855">					double zeroValue = type.getZeroProductionFactor();</span>
<span class="nc" id="L3856">					values.set(a, (1.0 - fraction) * zeroValue + fraction);</span>
				}
			}
<span class="nc" id="L3859">		}</span>

<span class="nc" id="L3861">		return values;</span>
	}

	/**
	 * Gets the value for building a &lt;code&gt;Colony&lt;/code&gt; on the given tile.
	 *
	 * FIXME: tune magic numbers and expose more to the spec.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt;
	 * @return A score for the tile.
	 */
	public int getColonyValue(Tile tile) {
<span class="nc" id="L3874">		List&lt;Double&gt; values = getAllColonyValues(tile);</span>
<span class="nc bnc" id="L3875" title="All 2 branches missed.">		if (values.get(0) &lt; 0.0) {</span>
<span class="nc" id="L3876">			return (int) Math.round(values.get(0));</span>
		}
<span class="nc" id="L3878">		double v = 1.0;</span>
<span class="nc bnc" id="L3879" title="All 2 branches missed.">		for (Double d : values) {</span>
<span class="nc" id="L3880">			v *= d;</span>
<span class="nc" id="L3881">		}</span>
<span class="nc" id="L3882">		return (int) Math.round(v);</span>
	}

	//
	// Miscellaneous
	//

	/**
	 * Standardized log of an instance of cheating by this player.
	 *
	 * @param what
	 *            A description of the cheating.
	 */
	public void logCheat(String what) {
<span class="fc" id="L3896">		logger.finest(&quot;CHEAT: &quot; + getGame().getTurn().getNumber() + &quot; &quot; + lastPart(getNationId(), &quot;.&quot;) + &quot; &quot; + what);</span>
<span class="fc" id="L3897">	}</span>

	/**
	 * Gets the maximum food consumption of any unit types available to this
	 * player.
	 *
	 * @return A maximum food consumption value.
	 */
	public int getMaximumFoodConsumption() {
<span class="pc bpc" id="L3906" title="1 of 2 branches missed.">		if (maximumFoodConsumption &lt; 0) {</span>
<span class="fc" id="L3907">			Specification spec = getSpecification();</span>
<span class="fc bfc" id="L3908" title="All 2 branches covered.">			for (UnitType unitType : spec.getUnitTypeList()) {</span>
<span class="fc bfc" id="L3909" title="All 2 branches covered.">				if (unitType.isAvailableTo(this)) {</span>
<span class="fc" id="L3910">					int foodConsumption = spec.getFoodGoodsTypeList().stream()</span>
<span class="fc" id="L3911">							.mapToInt(ft -&gt; unitType.getConsumptionOf(ft)).sum();</span>
<span class="fc bfc" id="L3912" title="All 2 branches covered.">					if (foodConsumption &gt; maximumFoodConsumption) {</span>
<span class="fc" id="L3913">						maximumFoodConsumption = foodConsumption;</span>
					}
				}
<span class="fc" id="L3916">			}</span>
		}
<span class="fc" id="L3918">		return maximumFoodConsumption;</span>
	}

	/**
	 * Does this player own something?.
	 *
	 * @param ownable
	 *            The &lt;code&gt;Ownable&lt;/code&gt; to check.
	 * @return True if the &lt;code&gt;Ownable&lt;/code&gt; is ours.
	 */
	public boolean owns(Ownable ownable) {
<span class="pc bpc" id="L3929" title="1 of 2 branches missed.">		return (ownable == null) ? false : this.equals(ownable.getOwner());</span>
	}

	/**
	 * Get a &lt;code&gt;FreeColGameObject&lt;/code&gt; with the specified identifier and
	 * class, owned by this player.
	 * 
	 * Used mainly in message decoding.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param id
	 *            The object identifier.
	 * @param returnClass
	 *            The expected class of the object.
	 * @return The game object, or null if not found.
	 * @throws IllegalStateException
	 *             on failure to validate the object in any way.
	 */
	public &lt;T extends FreeColGameObject&gt; T getOurFreeColGameObject(String id, Class&lt;T&gt; returnClass)
			throws IllegalStateException {
<span class="fc" id="L3950">		T t = getGame().getFreeColGameObject(id, returnClass);</span>
<span class="pc bpc" id="L3951" title="1 of 2 branches missed.">		if (t == null) {</span>
<span class="nc" id="L3952">			throw new IllegalStateException(&quot;Not a &quot; + returnClass.getName() + &quot;: &quot; + id);</span>
<span class="pc bpc" id="L3953" title="1 of 2 branches missed.">		} else if (t instanceof Ownable) {</span>
<span class="pc bpc" id="L3954" title="1 of 2 branches missed.">			if (!owns((Ownable) t)) {</span>
<span class="nc" id="L3955">				throw new IllegalStateException(returnClass.getName() + &quot; not owned by &quot; + getId() + &quot;: &quot; + id);</span>
			}
		} else {
<span class="nc" id="L3958">			throw new IllegalStateException(&quot;Not ownable: &quot; + id);</span>
		}
<span class="fc" id="L3960">		return t;</span>
	}

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int checkIntegrity(boolean fix) {
<span class="fc" id="L3970">		int result = super.checkIntegrity(fix);</span>
<span class="fc bfc" id="L3971" title="All 2 branches covered.">		for (Unit unit : getUnits()) {</span>
<span class="pc bpc" id="L3972" title="1 of 2 branches missed.">			if (unit.getOwner() == null) {</span>
<span class="nc bnc" id="L3973" title="All 2 branches missed.">				if (fix) {</span>
<span class="nc" id="L3974">					unit.setOwner(this);</span>
<span class="nc" id="L3975">					logger.warning(&quot;Fixed missing owner for: &quot; + unit.getId());</span>
<span class="nc" id="L3976">					result = 0;</span>
				} else {
<span class="nc" id="L3978">					logger.warning(&quot;Missing owner for: &quot; + unit.getId());</span>
<span class="nc" id="L3979">					result = -1;</span>
				}
			}
<span class="fc" id="L3982">			result = Math.min(result, unit.checkIntegrity(fix));</span>
<span class="fc" id="L3983">		}</span>
<span class="fc bfc" id="L3984" title="All 2 branches covered.">		if (monarch != null) {</span>
<span class="fc" id="L3985">			result = Math.min(result, monarch.checkIntegrity(fix));</span>
		}
<span class="fc" id="L3987">		return result;</span>
	}

	//
	// Override FreeColObject
	//

	/**
	 * {@inheritDoc}
	 */
	@Override
	public final FeatureContainer getFeatureContainer() {
<span class="fc" id="L3999">		return featureContainer;</span>
	}

	// Serialization

	/** The Constant ADMIN_TAG. */
	private static final String ADMIN_TAG = &quot;admin&quot;;

	/** The Constant AI_TAG. */
	private static final String AI_TAG = &quot;ai&quot;;

	/** The Constant ATTACKED_BY_PRIVATEERS_TAG. */
	private static final String ATTACKED_BY_PRIVATEERS_TAG = &quot;attackedByPrivateers&quot;;

	/** The Constant BANKRUPT_TAG. */
	private static final String BANKRUPT_TAG = &quot;bankrupt&quot;;

	/** The Constant BAN_MISSIONS_TAG. */
	private static final String BAN_MISSIONS_TAG = &quot;banMissions&quot;;

	/** The Constant CURRENT_FATHER_TAG. */
	private static final String CURRENT_FATHER_TAG = &quot;currentFather&quot;;

	/** The Constant DEAD_TAG. */
	private static final String DEAD_TAG = &quot;dead&quot;;

	/** The Constant ENTRY_LOCATION_TAG. */
	private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;

	/** The Constant FOUNDING_FATHERS_TAG. */
	private static final String FOUNDING_FATHERS_TAG = &quot;foundingFathers&quot;;

	/** The Constant GOLD_TAG. */
	private static final String GOLD_TAG = &quot;gold&quot;;

	/** The Constant IMMIGRATION_TAG. */
	private static final String IMMIGRATION_TAG = &quot;immigration&quot;;

	/** The Constant IMMIGRATION_REQUIRED_TAG. */
	private static final String IMMIGRATION_REQUIRED_TAG = &quot;immigrationRequired&quot;;

	/** The Constant LIBERTY_TAG. */
	private static final String LIBERTY_TAG = &quot;liberty&quot;;

	/** The Constant INDEPENDENT_NATION_NAME_TAG. */
	private static final String INDEPENDENT_NATION_NAME_TAG = &quot;independentNationName&quot;;

	/** The Constant INTERVENTION_BELLS_TAG. */
	private static final String INTERVENTION_BELLS_TAG = &quot;interventionBells&quot;;

	/** The Constant NATION_ID_TAG. */
	private static final String NATION_ID_TAG = &quot;nationId&quot;;

	/** The Constant NATION_TYPE_TAG. */
	private static final String NATION_TYPE_TAG = &quot;nationType&quot;;

	/** The Constant NEW_LAND_NAME_TAG. */
	private static final String NEW_LAND_NAME_TAG = &quot;newLandName&quot;;

	/** The Constant NUMBER_OF_SETTLEMENTS_TAG. */
	private static final String NUMBER_OF_SETTLEMENTS_TAG = &quot;numberOfSettlements&quot;;

	/** The Constant OFFERED_FATHERS_TAG. */
	private static final String OFFERED_FATHERS_TAG = &quot;offeredFathers&quot;;

	/** The Constant OLD_SOL_TAG. */
	private static final String OLD_SOL_TAG = &quot;oldSoL&quot;;

	/** The Constant PLAYER_TAG. */
	private static final String PLAYER_TAG = &quot;player&quot;;

	/** The Constant PLAYER_TYPE_TAG. */
	private static final String PLAYER_TYPE_TAG = &quot;playerType&quot;;

	/** The Constant READY_TAG. */
	private static final String READY_TAG = &quot;ready&quot;;

	/** The Constant SCORE_TAG. */
	private static final String SCORE_TAG = &quot;score&quot;;

	/** The Constant STANCE_TAG. */
	private static final String STANCE_TAG = &quot;stance&quot;;

	/** The Constant TAX_TAG. */
	private static final String TAX_TAG = &quot;tax&quot;;

	/** The Constant TENSION_TAG. */
	private static final String TENSION_TAG = &quot;tension&quot;;

	/** The Constant USERNAME_TAG. */
	private static final String USERNAME_TAG = &quot;username&quot;;

	/** The Constant OLD_NATION_ID_TAG. */
	// @compat 0.10.7
	private static final String OLD_NATION_ID_TAG = &quot;nationID&quot;;
	// end @compat

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L4101">		super.writeAttributes(xw);</span>

<span class="fc" id="L4103">		xw.writeAttribute(USERNAME_TAG, name);</span>

<span class="fc" id="L4105">		xw.writeAttribute(NATION_ID_TAG, nationId);</span>

<span class="fc bfc" id="L4107" title="All 2 branches covered.">		if (nationType != null) {</span>
<span class="fc" id="L4108">			xw.writeAttribute(NATION_TYPE_TAG, nationType);</span>
		}

<span class="fc" id="L4111">		xw.writeAttribute(ADMIN_TAG, admin);</span>

<span class="fc" id="L4113">		xw.writeAttribute(READY_TAG, ready);</span>

<span class="fc" id="L4115">		xw.writeAttribute(DEAD_TAG, dead);</span>

<span class="fc" id="L4117">		xw.writeAttribute(PLAYER_TYPE_TAG, playerType);</span>

<span class="fc" id="L4119">		xw.writeAttribute(AI_TAG, ai);</span>

<span class="fc bfc" id="L4121" title="All 2 branches covered.">		if (xw.validFor(this)) {</span>

<span class="fc" id="L4123">			xw.writeAttribute(BANKRUPT_TAG, bankrupt);</span>

<span class="fc" id="L4125">			xw.writeAttribute(TAX_TAG, tax);</span>

<span class="fc" id="L4127">			xw.writeAttribute(GOLD_TAG, gold);</span>

<span class="fc" id="L4129">			xw.writeAttribute(IMMIGRATION_TAG, immigration);</span>

<span class="fc" id="L4131">			xw.writeAttribute(LIBERTY_TAG, liberty);</span>

<span class="fc" id="L4133">			xw.writeAttribute(INTERVENTION_BELLS_TAG, interventionBells);</span>

<span class="pc bpc" id="L4135" title="1 of 2 branches missed.">			if (currentFather != null) {</span>
<span class="nc" id="L4136">				xw.writeAttribute(CURRENT_FATHER_TAG, currentFather);</span>
			}

<span class="fc" id="L4139">			xw.writeAttribute(IMMIGRATION_REQUIRED_TAG, immigrationRequired);</span>

<span class="fc" id="L4141">			xw.writeAttribute(ATTACKED_BY_PRIVATEERS_TAG, attackedByPrivateers);</span>

<span class="fc" id="L4143">			xw.writeAttribute(OLD_SOL_TAG, oldSoL);</span>

<span class="fc" id="L4145">			xw.writeAttribute(SCORE_TAG, score);</span>
		}

<span class="pc bpc" id="L4148" title="1 of 2 branches missed.">		if (newLandName != null) {</span>
<span class="nc" id="L4149">			xw.writeAttribute(NEW_LAND_NAME_TAG, newLandName);</span>
		}

<span class="pc bpc" id="L4152" title="1 of 2 branches missed.">		if (independentNationName != null) {</span>
<span class="nc" id="L4153">			xw.writeAttribute(INDEPENDENT_NATION_NAME_TAG, independentNationName);</span>
		}

<span class="fc bfc" id="L4156" title="All 2 branches covered.">		if (entryLocation != null) {</span>
<span class="fc" id="L4157">			xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
		}
<span class="fc" id="L4159">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L4166">		super.writeChildren(xw);</span>

<span class="pc bpc" id="L4168" title="1 of 2 branches missed.">		if (market != null) {</span>
<span class="fc" id="L4169">			market.toXML(xw);</span>
		}

<span class="fc bfc" id="L4172" title="All 2 branches covered.">		if (xw.validFor(this)) {</span>

<span class="fc bfc" id="L4174" title="All 2 branches covered.">			for (Ability ability : getSortedAbilities()) {</span>
<span class="pc bpc" id="L4175" title="1 of 2 branches missed.">				if (ability.isIndependent()) {</span>
<span class="nc" id="L4176">					ability.toXML(xw);</span>
				}
<span class="fc" id="L4178">			}</span>

<span class="fc" id="L4180">			Turn turn = getGame().getTurn();</span>
<span class="fc bfc" id="L4181" title="All 2 branches covered.">			for (Modifier modifier : getSortedModifiers()) {</span>
<span class="pc bpc" id="L4182" title="3 of 4 branches missed.">				if (modifier.isTemporary() &amp;&amp; !modifier.isOutOfDate(turn)) {</span>
<span class="nc" id="L4183">					modifier.toXML(xw);</span>
				}
<span class="fc" id="L4185">			}</span>

<span class="fc bfc" id="L4187" title="All 2 branches covered.">			for (Player p : getSortedCopy(tension.keySet())) {</span>
<span class="fc" id="L4188">				xw.writeStartElement(TENSION_TAG);</span>

<span class="fc" id="L4190">				xw.writeAttribute(PLAYER_TAG, p);</span>

<span class="fc" id="L4192">				xw.writeAttribute(VALUE_TAG, tension.get(p).getValue());</span>

<span class="fc" id="L4194">				xw.writeEndElement();</span>
<span class="fc" id="L4195">			}</span>

<span class="pc bpc" id="L4197" title="1 of 2 branches missed.">			if (bannedMissions != null) {</span>
<span class="nc bnc" id="L4198" title="All 2 branches missed.">				for (Player p : getSortedCopy(bannedMissions)) {</span>
<span class="nc" id="L4199">					xw.writeStartElement(BAN_MISSIONS_TAG);</span>

<span class="nc" id="L4201">					xw.writeAttribute(PLAYER_TAG, p.getId());</span>

<span class="nc" id="L4203">					xw.writeEndElement();</span>
<span class="nc" id="L4204">				}</span>
			}

<span class="fc bfc" id="L4207" title="All 2 branches covered.">			for (Entry&lt;String, Stance&gt; e : mapEntriesByKey(stance)) {</span>
<span class="fc" id="L4208">				Stance s = e.getValue();</span>
<span class="pc bpc" id="L4209" title="1 of 2 branches missed.">				if (s == Stance.UNCONTACTED)</span>
<span class="nc" id="L4210">					continue;</span>

<span class="fc" id="L4212">				xw.writeStartElement(STANCE_TAG);</span>

<span class="fc" id="L4214">				xw.writeAttribute(PLAYER_TAG, e.getKey());</span>

<span class="fc" id="L4216">				xw.writeAttribute(VALUE_TAG, s);</span>

<span class="fc" id="L4218">				xw.writeEndElement();</span>
<span class="fc" id="L4219">			}</span>

<span class="fc bfc" id="L4221" title="All 2 branches covered.">			for (HistoryEvent event : history) { // Already in order</span>
<span class="fc" id="L4222">				event.toXML(xw);</span>
<span class="fc" id="L4223">			}</span>

<span class="pc bpc" id="L4225" title="1 of 2 branches missed.">			for (TradeRoute route : getSortedCopy(tradeRoutes)) {</span>
<span class="nc" id="L4226">				route.toXML(xw);</span>
<span class="nc" id="L4227">			}</span>

<span class="fc bfc" id="L4229" title="All 2 branches covered.">			if (highSeas != null) {</span>
<span class="fc" id="L4230">				highSeas.toXML(xw);</span>
			}

<span class="fc" id="L4233">			xw.writeToListElement(FOUNDING_FATHERS_TAG, foundingFathers);</span>

<span class="fc" id="L4235">			xw.writeToListElement(OFFERED_FATHERS_TAG, offeredFathers);</span>

<span class="fc bfc" id="L4237" title="All 2 branches covered.">			if (europe != null) {</span>
<span class="fc" id="L4238">				europe.toXML(xw);</span>
			}

<span class="fc bfc" id="L4241" title="All 2 branches covered.">			if (monarch != null) {</span>
<span class="fc" id="L4242">				monarch.toXML(xw);</span>
			}

<span class="pc bpc" id="L4245" title="1 of 2 branches missed.">			for (ModelMessage m : getModelMessages()) {</span>
<span class="nc" id="L4246">				m.toXML(xw);</span>
<span class="nc" id="L4247">			}</span>

<span class="pc bpc" id="L4249" title="1 of 2 branches missed.">			if (lastSales != null) {</span>
<span class="nc bnc" id="L4250" title="All 2 branches missed.">				for (LastSale ls : getSortedCopy(lastSales.values())) {</span>
<span class="nc" id="L4251">					ls.toXML(xw);</span>
<span class="nc" id="L4252">				}</span>
			}

<span class="fc" id="L4255">		} else {</span>
<span class="fc" id="L4256">			Player player = xw.getClientPlayer();</span>
<span class="fc" id="L4257">			Tension t = getTension(player);</span>
<span class="pc bpc" id="L4258" title="1 of 2 branches missed.">			if (t != null) {</span>
<span class="fc" id="L4259">				xw.writeStartElement(TENSION_TAG);</span>

<span class="fc" id="L4261">				xw.writeAttribute(PLAYER_TAG, player);</span>

<span class="fc" id="L4263">				xw.writeAttribute(VALUE_TAG, t.getValue());</span>

<span class="fc" id="L4265">				xw.writeEndElement();</span>
			}

<span class="pc bpc" id="L4268" title="1 of 2 branches missed.">			if (missionsBanned(player)) {</span>
<span class="nc" id="L4269">				xw.writeStartElement(BAN_MISSIONS_TAG);</span>

<span class="nc" id="L4271">				xw.writeAttribute(PLAYER_TAG, player.getId());</span>

<span class="nc" id="L4273">				xw.writeEndElement();</span>
			}

<span class="fc" id="L4276">			Stance s = getStance(player);</span>
<span class="pc bpc" id="L4277" title="1 of 4 branches missed.">			if (s != null &amp;&amp; s != Stance.UNCONTACTED) {</span>
<span class="fc" id="L4278">				xw.writeStartElement(STANCE_TAG);</span>

<span class="fc" id="L4280">				xw.writeAttribute(PLAYER_TAG, player);</span>

<span class="fc" id="L4282">				xw.writeAttribute(VALUE_TAG, s);</span>

<span class="fc" id="L4284">				xw.writeEndElement();</span>
			}
		}
<span class="fc" id="L4287">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4294">		super.readAttributes(xr);</span>

<span class="fc" id="L4296">		final Specification spec = getSpecification();</span>
<span class="fc" id="L4297">		final Game game = getGame();</span>

<span class="fc" id="L4299">		name = xr.getAttribute(USERNAME_TAG, (String) null);</span>

<span class="fc" id="L4301">		nationId = xr.getAttribute(NATION_ID_TAG,</span>
				// @compat 0.10.7
<span class="fc" id="L4303">				xr.getAttribute(OLD_NATION_ID_TAG,</span>
						// end @compat 0.10.7
						(String) null));

<span class="fc bfc" id="L4307" title="All 2 branches covered.">		if (isUnknownEnemy()) {</span>
<span class="fc" id="L4308">			nationType = null;</span>
		} else {
<span class="fc" id="L4310">			nationType = xr.getType(spec, NATION_TYPE_TAG, NationType.class, (NationType) null);</span>
		}

<span class="fc" id="L4313">		admin = xr.getAttribute(ADMIN_TAG, false);</span>

<span class="fc" id="L4315">		gold = xr.getAttribute(GOLD_TAG, 0);</span>

<span class="fc" id="L4317">		immigration = xr.getAttribute(IMMIGRATION_TAG, 0);</span>

<span class="fc" id="L4319">		liberty = xr.getAttribute(LIBERTY_TAG, 0);</span>

<span class="fc" id="L4321">		interventionBells = xr.getAttribute(INTERVENTION_BELLS_TAG, 0);</span>

<span class="fc" id="L4323">		oldSoL = xr.getAttribute(OLD_SOL_TAG, 0);</span>

<span class="fc" id="L4325">		score = xr.getAttribute(SCORE_TAG, 0);</span>

<span class="fc" id="L4327">		ready = xr.getAttribute(READY_TAG, false);</span>

<span class="fc" id="L4329">		ai = xr.getAttribute(AI_TAG, false);</span>

<span class="fc" id="L4331">		dead = xr.getAttribute(DEAD_TAG, false);</span>

<span class="fc" id="L4333">		bankrupt = xr.getAttribute(BANKRUPT_TAG, false);</span>

<span class="fc" id="L4335">		tax = xr.getAttribute(TAX_TAG, 0);</span>

<span class="fc" id="L4337">		changePlayerType(xr.getAttribute(PLAYER_TYPE_TAG, PlayerType.class, (PlayerType) null));</span>

<span class="fc" id="L4339">		currentFather = xr.getType(spec, CURRENT_FATHER_TAG, FoundingFather.class, (FoundingFather) null);</span>

<span class="fc" id="L4341">		immigrationRequired = xr.getAttribute(IMMIGRATION_REQUIRED_TAG, 12);</span>

<span class="fc" id="L4343">		newLandName = xr.getAttribute(NEW_LAND_NAME_TAG, (String) null);</span>

<span class="fc" id="L4345">		independentNationName = xr.getAttribute(INDEPENDENT_NATION_NAME_TAG, (String) null);</span>

<span class="fc" id="L4347">		attackedByPrivateers = xr.getAttribute(ATTACKED_BY_PRIVATEERS_TAG, false);</span>

<span class="fc" id="L4349">		entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG, true);</span>
<span class="fc" id="L4350">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// Clear containers.
<span class="fc" id="L4358">		tension.clear();</span>
<span class="pc bpc" id="L4359" title="1 of 2 branches missed.">		if (bannedMissions != null) {</span>
<span class="nc" id="L4360">			bannedMissions.clear();</span>
		}
<span class="fc" id="L4362">		stance.clear();</span>
<span class="fc" id="L4363">		foundingFathers.clear();</span>
<span class="fc" id="L4364">		offeredFathers.clear();</span>
<span class="fc" id="L4365">		europe = null;</span>
<span class="fc" id="L4366">		monarch = null;</span>
<span class="fc" id="L4367">		history.clear();</span>
<span class="fc" id="L4368">		tradeRoutes.clear();</span>
<span class="fc" id="L4369">		clearModelMessages();</span>
<span class="fc" id="L4370">		lastSales = null;</span>
<span class="fc" id="L4371">		highSeas = null;</span>
<span class="fc" id="L4372">		featureContainer.clear();</span>
<span class="fc bfc" id="L4373" title="All 2 branches covered.">		if (nationType != null) {</span>
<span class="fc" id="L4374">			addFeatures(nationType);</span>
		}

<span class="fc" id="L4377">		super.readChildren(xr);</span>

		// @compat 0.10.7
		// Fixup production modifiers deriving from founding fathers
<span class="fc" id="L4381">		final Specification spec = getSpecification();</span>
<span class="fc bfc" id="L4382" title="All 2 branches covered.">		for (Modifier m : getModifiers()) {</span>
<span class="pc bpc" id="L4383" title="1 of 2 branches missed.">			if (m.getSource() == null) {</span>
<span class="nc" id="L4384">				continue;</span>
			}
<span class="fc" id="L4386">			String type = spec.fatherGoodsFixMap.get(m.getSource().getId());</span>
<span class="pc bpc" id="L4387" title="3 of 4 branches missed.">			if (type != null &amp;&amp; m.getId().equals(type)) {</span>
<span class="nc" id="L4388">				m.requireNegatedPersonScope();</span>
			}
<span class="fc" id="L4390">		}</span>
		// end @compat 0.10.7

<span class="fc" id="L4393">		recalculateBellsBonus(); // Bells bonuses depend on tax</span>
<span class="fc" id="L4394">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4401">		final Specification spec = getSpecification();</span>
<span class="fc" id="L4402">		final Game game = getGame();</span>
<span class="fc" id="L4403">		final String tag = xr.getLocalName();</span>

<span class="pc bpc" id="L4405" title="1 of 2 branches missed.">		if (BAN_MISSIONS_TAG.equals(tag)) {</span>
<span class="nc" id="L4406">			Player player = xr.makeFreeColGameObject(game, PLAYER_TAG, Player.class, true);</span>
<span class="nc bnc" id="L4407" title="All 4 branches missed.">			if (player != null &amp;&amp; player.isEuropean()) {</span>
<span class="nc" id="L4408">				addMissionBan(player);</span>
			}
<span class="nc" id="L4410">			xr.closeTag(BAN_MISSIONS_TAG);</span>

<span class="pc bfc" id="L4412" title="All 2 branches covered.">		} else if (FOUNDING_FATHERS_TAG.equals(tag)) {</span>
<span class="fc" id="L4413">			List&lt;FoundingFather&gt; ffs = xr.readList(spec, FOUNDING_FATHERS_TAG, FoundingFather.class);</span>
<span class="pc bpc" id="L4414" title="1 of 2 branches missed.">			if (ffs != null) {</span>
<span class="pc bpc" id="L4415" title="1 of 2 branches missed.">				for (FoundingFather ff : ffs) {</span>
<span class="nc" id="L4416">					addFather(ff); // addFather adds the features</span>
<span class="nc" id="L4417">				}</span>
			}

<span class="fc bfc" id="L4420" title="All 2 branches covered.">		} else if (OFFERED_FATHERS_TAG.equals(tag)) {</span>
<span class="fc" id="L4421">			List&lt;FoundingFather&gt; ofs = xr.readList(spec, OFFERED_FATHERS_TAG, FoundingFather.class);</span>
<span class="fc" id="L4422">			offeredFathers.addAll(ofs);</span>

<span class="fc bfc" id="L4424" title="All 2 branches covered.">		} else if (STANCE_TAG.equals(tag)) {</span>
<span class="fc" id="L4425">			Player player = xr.makeFreeColGameObject(game, PLAYER_TAG, Player.class, true);</span>
<span class="fc" id="L4426">			stance.put(player.getId(), xr.getAttribute(VALUE_TAG, Stance.class, Stance.UNCONTACTED));</span>
<span class="fc" id="L4427">			xr.closeTag(STANCE_TAG);</span>

<span class="fc bfc" id="L4429" title="All 2 branches covered.">		} else if (TENSION_TAG.equals(tag)) {</span>
<span class="fc" id="L4430">			tension.put(xr.makeFreeColGameObject(game, PLAYER_TAG, Player.class, true),</span>
<span class="fc" id="L4431">					new Tension(xr.getAttribute(VALUE_TAG, 0)));</span>
<span class="fc" id="L4432">			xr.closeTag(TENSION_TAG);</span>

<span class="pc bpc" id="L4434" title="1 of 2 branches missed.">		} else if (Ability.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L4435">			Ability ability = new Ability(xr, spec);</span>
<span class="nc bnc" id="L4436" title="All 2 branches missed.">			if (ability.isIndependent()) {</span>
<span class="nc" id="L4437">				addAbility(ability);</span>
			}

<span class="pc bfc" id="L4440" title="All 2 branches covered.">		} else if (Europe.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L4441">			europe = xr.readFreeColGameObject(game, Europe.class);</span>

<span class="fc bfc" id="L4443" title="All 2 branches covered.">		} else if (HighSeas.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L4444">			highSeas = xr.readFreeColGameObject(game, HighSeas.class);</span>

<span class="pc bpc" id="L4446" title="1 of 2 branches missed.">		} else if (HistoryEvent.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L4447">			getHistory().add(new HistoryEvent(xr));</span>

<span class="pc bpc" id="L4449" title="1 of 2 branches missed.">		} else if (LastSale.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L4450">			addLastSale(new LastSale(xr));</span>

<span class="fc bfc" id="L4452" title="All 2 branches covered.">		} else if (Market.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L4453">			market = xr.readFreeColGameObject(game, Market.class);</span>

<span class="pc bpc" id="L4455" title="1 of 2 branches missed.">		} else if (ModelMessage.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L4456">			addModelMessage(new ModelMessage(xr));</span>

<span class="pc bpc" id="L4458" title="1 of 2 branches missed.">		} else if (Modifier.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L4459">			Modifier modifier = new Modifier(xr, spec);</span>
<span class="nc bnc" id="L4460" title="All 2 branches missed.">			if (modifier.isIndependent()) {</span>
<span class="nc" id="L4461">				addModifier(modifier);</span>
			}

<span class="pc bpc" id="L4464" title="1 of 2 branches missed.">		} else if (Monarch.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L4465">			monarch = xr.readFreeColGameObject(game, Monarch.class);</span>

<span class="nc bnc" id="L4467" title="All 2 branches missed.">		} else if (TradeRoute.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L4468">			tradeRoutes.add(xr.readFreeColGameObject(game, TradeRoute.class));</span>

		} else {
<span class="nc" id="L4471">			super.readChild(xr);</span>
		}
<span class="fc" id="L4473">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="nc" id="L4480">		return nationId;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="fc" id="L4488">		return getXMLElementTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;player&quot;
	 */
	public static String getXMLElementTagName() {
<span class="fc" id="L4497">		return &quot;player&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>