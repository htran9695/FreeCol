<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Unit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Unit.java</span></div><h1>Unit.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.ToIntFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.CombatModel;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;


import org.w3c.dom.Element;


/**
 * Represents all pieces that can be moved on the map-board. This includes:
 * colonists, ships, wagon trains e.t.c.
 *
 * Every &lt;code&gt;Unit&lt;/code&gt; is owned by a {@link Player} and has a
 * {@link Location}.
 */
public class Unit extends GoodsLocation
    implements Consumer, Locatable, Movable, Nameable, Ownable {

<span class="fc" id="L63">    private static final Logger logger = Logger.getLogger(Unit.class.getName());</span>

    /**
     * A large number of turns, denoting pathfinding failure.  Do not use
     * INFINITY as further calculation might use this.
     */
    public static final int MANY_TURNS = 10000;

    public static final String CARGO_CHANGE = &quot;CARGO_CHANGE&quot;;
    public static final String MOVE_CHANGE = &quot;MOVE_CHANGE&quot;;
    public static final String ROLE_CHANGE = &quot;ROLE_CHANGE&quot;;

    /**
     * A comparator to compare units by position, top to bottom,
     * left to right.
     */
<span class="fc" id="L79">    public static final Comparator&lt;Unit&gt; locComparator</span>
<span class="pc" id="L80">        = Comparator.comparingInt(u -&gt; Location.getRank(u));</span>

    /** A comparator to compare units by type then role. */
<span class="fc" id="L83">    public static final Comparator&lt;Unit&gt; typeRoleComparator</span>
<span class="fc" id="L84">        = Comparator.comparing(Unit::getType)</span>
<span class="fc" id="L85">            .thenComparing(Comparator.comparing(Unit::getRole));</span>
    
    /** A state a Unit can have. */
<span class="pc" id="L88">    public static enum UnitState {</span>
<span class="fc" id="L89">        ACTIVE,</span>
<span class="fc" id="L90">        FORTIFIED,</span>
<span class="fc" id="L91">        SENTRY,</span>
<span class="fc" id="L92">        IN_COLONY,</span>
<span class="fc" id="L93">        IMPROVING,</span>
        // @compat 0.10.0
<span class="fc" id="L95">        TO_EUROPE,</span>
<span class="fc" id="L96">        TO_AMERICA,</span>
        // end @compat
<span class="fc" id="L98">        FORTIFYING,</span>
<span class="fc" id="L99">        SKIPPED;</span>

        /**
         * Get the stem key for this unit state.
         *
         * @return The stem key.
         */
        public String getKey() {
<span class="nc" id="L107">            return &quot;unitState.&quot; + getEnumKey(this);</span>
        }
    }

    /** The individual name of this unit, not of the unit type. */
<span class="fc" id="L112">    protected String name = null;</span>

    /** The owner player. */
    protected Player owner;

    /** The unit type. */
    protected UnitType unitType;

    /** Current unit state. */
<span class="fc" id="L121">    protected UnitState state = UnitState.ACTIVE;</span>

    /** Current unit role. */
    protected Role role;

    /**
     * The amount of role-equipment this unit carries, subject to
     * role.getMaximumCount().  Currently zero or one except for pioneers.
     */
    protected int roleCount;

    /** The current unit location. */
    protected Location location;

    /** The last entry location used by this unit. */
    protected Location entryLocation;

    /** The number of moves this unit has left this turn. */
    protected int movesLeft;

    /** What type of goods this unit produces in its occupation. */
    protected GoodsType workType;

    /** What type of goods this unit last earned experience producing. */
    protected GoodsType experienceType;

    /** The mount of experience a unit has earned. */
<span class="fc" id="L148">    protected int experience = 0;</span>

    /**
     * The number of turns until the work is finished (e.g. sailing,
     * improving), or '-1' if a Unit can stay in its state forever.
     */
    protected int workLeft;

    /**
     * What is being improved (to be used only for PIONEERs - where
     * they are working.
     */
    protected TileImprovement workImprovement;

    /** The student of this Unit, if it has one. */
    protected Unit student;

    /** The teacher of this Unit, if it has one. */
    protected Unit teacher;

    /** Number of turns of training needed by this unit. */
<span class="fc" id="L169">    protected int turnsOfTraining = 0;</span>

    /** The original nationality. */
<span class="fc" id="L172">    protected String nationality = null;</span>

    /** The original ethnicity. */
<span class="fc" id="L175">    protected String ethnicity = null;</span>

    /** The home settlement of a native unit. */
<span class="fc" id="L178">    protected IndianSettlement indianSettlement = null;</span>

    /** For now; only used by ships when repairing. */
    protected int hitPoints;

    /** A destination for go-to moves. */
<span class="fc" id="L184">    protected Location destination = null;</span>

    /** The trade route this unit has. */
<span class="fc" id="L187">    protected TradeRoute tradeRoute = null;</span>

    /** Which stop in a trade route the unit is going to. */
<span class="fc" id="L190">    protected int currentStop = -1;</span>

    /** To be used only for type == TREASURE_TRAIN */
    protected int treasureAmount;

    /**
     * The attrition this unit has accumulated.  At the moment, this
     * equals the number of turns it has spent in the open.
     */
<span class="fc" id="L199">    protected int attrition = 0;</span>

    /**
     * The amount of goods carried by this unit.  This variable is
     * only used by the clients.  A negative value signals that the
     * variable is not in use.
     *
     * @see #getVisibleGoodsCount()
     */
    protected int visibleGoodsCount;


    /**
     * Constructor for ServerUnit.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     */
    protected Unit(Game game) {
<span class="fc" id="L217">        super(game);</span>
<span class="fc" id="L218">    }</span>

    /**
     * Initialize this object from an XML-representation of this object.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param e An XML-element that will be used to initialize this object.
     */
    public Unit(Game game, Element e) {
<span class="fc" id="L227">        super(game, e);</span>

<span class="fc" id="L229">        readFromXMLElement(e);</span>
<span class="fc" id="L230">    }</span>

    /**
     * Creates a new &lt;code&gt;Unit&lt;/code&gt; with the given
     * identifier.  The object should later be initialized by calling
     * {@link #readFromXML(FreeColXMLReader)}.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param id The object identifier.
     */
    public Unit(Game game, String id) {
<span class="fc" id="L241">        super(game, id);</span>
<span class="fc" id="L242">    }</span>


    /**
     * Get the individual name of this unit.
     *
     * @return The individual name.
     */
    @Override
    public String getName() {
<span class="fc" id="L252">        return name;</span>
    }

    /**
     * Set the individual name of this unit.
     *
     * @param newName The new name.
     */
    @Override
    public void setName(String newName) {
<span class="fc" id="L262">        this.name = newName;</span>
<span class="fc" id="L263">    }</span>

    /**
     * Get the name of the apparent owner of this Unit,
     * (like getOwner().getNationAsString() but handles pirates).
     *
     * @return The name of the apparent owner of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public StringTemplate getApparentOwnerName() {
<span class="fc bfc" id="L272" title="All 2 branches covered.">        Player own = (hasAbility(Ability.PIRACY)) ? getGame().getUnknownEnemy()</span>
            : owner;
<span class="fc" id="L274">        return own.getNationLabel();</span>
    }

    /** What type of unit label do we want? */
<span class="pc" id="L278">    public static enum UnitLabelType {</span>
<span class="fc" id="L279">        PLAIN,      // Just the basics</span>
<span class="fc" id="L280">        NATIONAL,   // Add the nation</span>
<span class="fc" id="L281">        FULL        // Add the equipment and extras</span>
    }

    /**
     * Get a plain string template for a unit.
     *
     * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
     */
    public StringTemplate getLabel() {
<span class="fc" id="L290">        return getLabel(UnitLabelType.PLAIN);</span>
    }

    /**
     * Get a string template for a unit.
     *
     * The PLAIN template contains:
     * - The type of the unit
     * - A role if not the default
     * - The specific name of the unit if it has one
     * The NATIONAL template adds the nation
     * The FULL template adds equipment annotations
     *
     * @param ult The type of label to get.
     * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
     */
    public StringTemplate getLabel(UnitLabelType ult) {
<span class="fc" id="L307">        final UnitType type = getType();</span>
<span class="fc" id="L308">        final Role role = getRole();</span>
<span class="fc" id="L309">        final Player owner = getOwner();</span>
<span class="pc bpc" id="L310" title="3 of 6 branches missed.">        if (type == null || role == null || owner == null) {</span>
<span class="nc" id="L311">            return null; // Probably disposed</span>
        }

<span class="pc bpc" id="L314" title="1 of 4 branches missed.">        switch (ult) {</span>
        case PLAIN:
<span class="fc" id="L316">            return Messages.getUnitLabel(getName(), type.getId(), 1, null,</span>
<span class="fc" id="L317">                                         role.getId(), null);</span>

        case NATIONAL:
<span class="fc bfc" id="L320" title="All 2 branches covered.">            if (role.getMaximumCount() &gt; 1) {</span>
                // If the amount of equipment can vary an equipment
                // label is required, so fall through into the FULL case.
            } else {
<span class="fc" id="L324">                return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="fc" id="L325">                                             owner.getNationId(), role.getId(),</span>
                                             null);
            }
            // Fall through

        case FULL:
<span class="fc" id="L331">            StringTemplate extra = null;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (role.isDefaultRole()) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                if (canCarryTreasure()) {</span>
<span class="fc" id="L334">                    extra = StringTemplate.template(&quot;goldAmount&quot;)</span>
<span class="fc" id="L335">                        .addAmount(&quot;%amount%&quot;, getTreasureAmount());</span>
                } else {
<span class="fc" id="L337">                    boolean noEquipment = false;</span>
                    // unequipped expert has no-equipment label
<span class="fc" id="L339">                    List&lt;Role&gt; expertRoles = type.getExpertRoles();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                    for (Role someRole : expertRoles) {</span>
<span class="fc" id="L341">                        String key = someRole.getId() + &quot;.noequipment&quot;;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                        if (Messages.containsKey(key)) {</span>
<span class="fc" id="L343">                            extra = StringTemplate.key(key);</span>
<span class="fc" id="L344">                            break;</span>
                        }
<span class="fc" id="L346">                    }</span>
<span class="fc" id="L347">                }</span>
            } else {
<span class="fc" id="L349">                String equipmentKey = role.getId() + &quot;.equipment&quot;;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                if (Messages.containsKey(equipmentKey)) {</span>
                    // Currently only used for missionary which does not
                    // have equipment that directly corresponds to goods.
<span class="fc" id="L353">                    extra = AbstractGoods.getLabel(equipmentKey, 1);</span>
                } else {
                    // Other roles can be characterized by their goods.
<span class="fc" id="L356">                    List&lt;AbstractGoods&gt; requiredGoods</span>
<span class="fc" id="L357">                        = role.getRequiredGoods(getRoleCount());</span>
<span class="fc" id="L358">                    boolean first = true;</span>
<span class="fc" id="L359">                    extra = StringTemplate.label(&quot;&quot;);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                    for (AbstractGoods ag : requiredGoods) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                        if (first) first = false; else extra.addName(&quot; &quot;);</span>
<span class="fc" id="L362">                        extra.addStringTemplate(ag.getLabel());</span>
<span class="fc" id="L363">                    }</span>
                }
            }
<span class="fc" id="L366">            return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="fc" id="L367">                                         owner.getNationId(), role.getId(),</span>
                                         extra);
        default: // Can not happen
            break;
        }
<span class="nc" id="L372">        return null;</span>
    }

    /**
     * Get the basic i18n description for this unit.
     *
     * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
     */
    public String getDescription() {
<span class="fc" id="L381">        return Messages.message(getLabel());</span>
    }

    /**
     * Get the basic i18n description for this unit.
     *
     * @param ult The label type required.
     * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
     */
    public String getDescription(UnitLabelType ult) {
<span class="fc" id="L391">        return Messages.message(getLabel(ult));</span>
    }

    /**
     * Get a label for the chance of success in a potential combat.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to attack into.
     * @return A suitable label.
     */
    public StringTemplate getCombatLabel(Tile tile) {
<span class="nc" id="L401">        final CombatModel.CombatOdds combatOdds = getGame().getCombatModel()</span>
<span class="nc" id="L402">            .calculateCombatOdds(this, tile.getDefendingUnit(this));</span>
        // If attacking a settlement, the true odds are never
        // known because units may be hidden within
<span class="nc bnc" id="L405" title="All 2 branches missed.">        boolean unknown = combatOdds.win == CombatModel.CombatOdds.UNKNOWN_ODDS</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            || tile.hasSettlement();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        return StringTemplate.template(&quot;model.unit.attackTileOdds&quot;)</span>
<span class="nc" id="L408">            .addName(&quot;%chance%&quot;, (unknown) ? &quot;??&quot;</span>
<span class="nc" id="L409">                : String.valueOf((int)(combatOdds.win * 100)));</span>
    }
    
    /**
     * Get a destination label for this unit.
     *
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing where this unit
     *     is going.
     */
    public StringTemplate getDestinationLabel() {
        // Create the right tag for the tagged &quot;goingTo&quot; message.
<span class="nc bnc" id="L420" title="All 2 branches missed.">        String type = (isPerson()) ? &quot;person&quot;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            : (isNaval()) ? &quot;ship&quot;</span>
            : &quot;other&quot;;
<span class="nc" id="L423">        return getDestinationLabel(type, getDestination(), getOwner());</span>
    }

    /**
     * Get a destination label for a given unit tag, destination and player.
     *
     * @param tag The unit tag for the &quot;goingTo&quot; message.
     * @param destination The destination &lt;code&gt;Location&lt;/code&gt;.
     * @param player The &lt;code&gt;Player&lt;/code&gt; viewpoint.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing the unit movement.
     */
    public static StringTemplate getDestinationLabel(String tag,
        Location destination, Player player) {
<span class="nc" id="L436">        return StringTemplate.template(&quot;model.unit.goingTo&quot;)</span>
<span class="nc" id="L437">            .add(&quot;%type%&quot;, tag)</span>
<span class="nc" id="L438">            .addStringTemplate(&quot;%location%&quot;,</span>
<span class="nc" id="L439">                destination.getLocationLabelFor(player));</span>
    }

    /**
     * Get a string template describing the repair state of this unit.
     *
     * @return A repair label.
     */
    public StringTemplate getRepairLabel() {
<span class="nc" id="L448">        return StringTemplate.template(&quot;model.unit.underRepair&quot;)</span>
<span class="nc" id="L449">            .addAmount(&quot;%turns%&quot;, getTurnsForRepair());</span>
    }

    /**
     * Get the &lt;code&gt;UnitType&lt;/code&gt; value.
     *
     * @return The current &lt;code&gt;UnitType&lt;/code&gt;.
     */
    public final UnitType getType() {
<span class="fc" id="L458">        return unitType;</span>
    }

    /**
     * Sets the type of the unit.
     *
     * -vis: Has visibility issues as the line of sight may change.
     *
     * @param unitType The new type of the unit.
     */
    public void setType(UnitType unitType) {
<span class="fc" id="L469">        this.unitType = unitType;</span>
<span class="fc" id="L470">    }</span>

    /**
     * Changes the type of the unit.
     *
     * -vis: Has visibility issues as the line of sight may change.
     *
     * @param unitType The new type of the unit.
     * @return True if the type change succeeds.
     */
    public boolean changeType(UnitType unitType) {
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        if (!unitType.isAvailableTo(owner)) return false;</span>

<span class="fc" id="L483">        setType(unitType);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (getMovesLeft() &gt; getInitialMovesLeft()) {</span>
<span class="nc" id="L485">            setMovesLeft(getInitialMovesLeft());</span>
        }
<span class="fc" id="L487">        hitPoints = unitType.getHitPoints();</span>
<span class="fc bfc" id="L488" title="All 4 branches covered.">        if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="fc" id="L489">            getTeacher().setStudent(null);</span>
<span class="fc" id="L490">            setTeacher(null);</span>
        }
<span class="fc" id="L492">        return true;</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is naval.
     *
     * @return True if this is a naval &lt;code&gt;Unit&lt;/code&gt;.
     */
    public boolean isNaval() {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        return (unitType == null) ? false : unitType.isNaval();</span>
    }

    /**
     * Checks if this unit is an undead.
     *
     * @return True if the unit is undead.
     */
    public boolean isUndead() {
<span class="nc" id="L510">        return hasAbility(Ability.UNDEAD);</span>
    }

    /**
     * Can this unit carry treasure (like a treasure train)?
     *
     * @return True if this &lt;code&gt;Unit&lt;/code&gt; can carry treasure.
     */
    public boolean canCarryTreasure() {
<span class="fc" id="L519">        return hasAbility(Ability.CARRY_TREASURE);</span>
    }

    /**
     * Can this unit capture enemy goods?
     *
     * @return True if this &lt;code&gt;Unit&lt;/code&gt; is capable of capturing goods.
     */
    public boolean canCaptureGoods() {
<span class="fc" id="L528">        return hasAbility(Ability.CAPTURE_GOODS);</span>
    }

    /**
     * Checks if this is a trading &lt;code&gt;Unit&lt;/code&gt;, meaning that it
     * can trade with settlements.
     *
     * @return True if this is a trading unit.
     */
    public boolean isTradingUnit() {
<span class="fc bfc" id="L538" title="All 4 branches covered.">        return canCarryGoods() &amp;&amp; owner.isEuropean();</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is a `colonist'.  A unit is a
     * colonist if it is European and can build a new &lt;code&gt;Colony&lt;/code&gt;.
     *
     * @return True if this unit is a colonist.
     */
    public boolean isColonist() {
<span class="fc bfc" id="L548" title="All 2 branches covered.">        return unitType.hasAbility(Ability.FOUND_COLONY)</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            &amp;&amp; owner.hasAbility(Ability.FOUNDS_COLONIES);</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is able to carry {@link Locatable}s.
     *
     * @return True if this unit can carry goods or other units.
     */
    public boolean isCarrier() {
<span class="pc bpc" id="L558" title="1 of 4 branches missed.">        return unitType.canCarryGoods() || unitType.canCarryUnits();</span>
    }

    /**
     * Checks if this unit is a person, that is not a ship or wagon.
     * Surprisingly difficult without explicit enumeration because
     * model.ability.person only arrived in 0.10.1.
     *
     * @return True if this unit is a person.
     */
    public boolean isPerson() {
<span class="fc bfc" id="L569" title="All 2 branches covered.">        return hasAbility(Ability.PERSON)</span>
            // @compat 0.10.0
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.BORN_IN_COLONY)</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.BORN_IN_INDIAN_SETTLEMENT)</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.FOUND_COLONY)</span>
            // Nick also had:
            //     &amp;&amp; (!hasAbility(&quot;model.ability.carryGoods&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.carryUnits&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.carryTreasure&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.bombard&quot;))
            // ...but that should be unnecessary.
            // end @compat
            ;
    }

    /**
     * Gets the state of this &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @return The state of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public UnitState getState() {
<span class="fc" id="L590">        return state;</span>
    }

    /**
     * Checks if a &lt;code&gt;Unit&lt;/code&gt; can get the given state set.
     *
     * @param s The new state for this Unit.  Should be one of
     *     {UnitState.ACTIVE, FORTIFIED, ...}.
     * @return True if the &lt;code&gt;Unit&lt;/code&gt; state can be changed to
     *     the new value.
     */
    public boolean checkSetState(UnitState s) {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (getState() == s) return false;</span>
<span class="pc bpc" id="L603" title="2 of 8 branches missed.">        switch (s) {</span>
        case ACTIVE:
<span class="fc" id="L605">            return true;</span>
        case FORTIFIED:
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            return getState() == UnitState.FORTIFYING;</span>
        case FORTIFYING:
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            return getMovesLeft() &gt; 0;</span>
        case IMPROVING:
<span class="pc bpc" id="L611" title="2 of 4 branches missed.">            return getMovesLeft() &gt; 0</span>
                &amp;&amp; location instanceof Tile
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">                &amp;&amp; getOwner().canAcquireForImprovement(location.getTile());</span>
        case IN_COLONY:
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">            return !isNaval();</span>
        case SENTRY:
<span class="fc" id="L617">            return true;</span>
        case SKIPPED:
<span class="nc bnc" id="L619" title="All 2 branches missed.">            return getState() == UnitState.ACTIVE;</span>
        default:
<span class="nc" id="L621">            logger.warning(&quot;Invalid unit state: &quot; + s);</span>
<span class="nc" id="L622">            return false;</span>
        }
    }

    /**
     * Sets a new state for this unit and initializes the amount of
     * work the unit has left.
     *
     * If the work needs turns to be completed (for instance when
     * plowing), then the moves the unit has still left will be used
     * up. Some work (basically building a road with a hardy pioneer)
     * might actually be finished already in this method-call, in
     * which case the state is set back to UnitState.ACTIVE.
     *
     * @param s The new state for this Unit.  Should be one of
     *     {UnitState.ACTIVE, UnitState.FORTIFIED, ...}.
     */
    public void setState(UnitState s) {
<span class="fc bfc" id="L640" title="All 2 branches covered.">        if (state == s) {</span>
            // No need to do anything when the state is unchanged
<span class="fc" id="L642">            return;</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        } else if (!checkSetState(s)) {</span>
<span class="nc" id="L644">            throw new IllegalStateException(&quot;Illegal UnitState transition: &quot;</span>
                + state + &quot; -&gt; &quot; + s);
        } else {
<span class="fc" id="L647">            setStateUnchecked(s);</span>
        }
<span class="fc" id="L649">    }</span>

    /**
     * Actually set the unit state.
     *
     * @param s The new &lt;code&gt;UnitState&lt;/code&gt;.
     */
    protected void setStateUnchecked(UnitState s) {
        // FIXME: move to the server.
        // Cleanup the old UnitState, for example destroy the
        // TileImprovment being built by a pioneer.
<span class="fc bfc" id="L660" title="All 2 branches covered.">        switch (state) {</span>
        case IMPROVING:
<span class="pc bpc" id="L662" title="3 of 4 branches missed.">            if (workImprovement != null &amp;&amp; getWorkLeft() &gt; 0) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (!workImprovement.isComplete()</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    &amp;&amp; workImprovement.getTile() != null</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                    &amp;&amp; workImprovement.getTile().getTileItemContainer() != null) {</span>
<span class="nc" id="L666">                    workImprovement.getTile().getTileItemContainer()</span>
<span class="nc" id="L667">                        .removeTileItem(workImprovement);</span>
                }
<span class="nc" id="L669">                setWorkImprovement(null);</span>
            }
            break;
        default:
            // do nothing
            break;
        }

        // Now initiate the new UnitState
<span class="pc bpc" id="L678" title="1 of 7 branches missed.">        switch (s) {</span>
        case ACTIVE:
<span class="fc" id="L680">            setWorkLeft(-1);</span>
<span class="fc" id="L681">            break;</span>
        case SENTRY:
<span class="fc" id="L683">            setWorkLeft(-1);</span>
<span class="fc" id="L684">            break;</span>
        case FORTIFIED:
<span class="fc" id="L686">            setWorkLeft(-1);</span>
<span class="fc" id="L687">            movesLeft = 0;</span>
<span class="fc" id="L688">            break;</span>
        case FORTIFYING:
<span class="fc" id="L690">            setWorkLeft(1);</span>
<span class="fc" id="L691">            break;</span>
        case IMPROVING:
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">            if (workImprovement == null) {</span>
<span class="nc" id="L694">                setWorkLeft(-1);</span>
            } else {
<span class="fc" id="L696">                setWorkLeft(workImprovement.getTurnsToComplete()</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                    + ((getMovesLeft() &gt; 0) ? 0 : 1));</span>
            }
<span class="fc" id="L699">            movesLeft = 0;</span>
<span class="fc" id="L700">            break;</span>
        case SKIPPED: // do nothing
<span class="nc" id="L702">            break;</span>
        default:
<span class="fc" id="L704">            setWorkLeft(-1);</span>
        }
<span class="fc" id="L706">        state = s;</span>
<span class="fc" id="L707">    }</span>

    /**
     * Sets the given state to all the units that are carried.
     *
     * @param state The &lt;code&gt;UnitState&lt;/code&gt; to set..
     */
    public void setStateToAllChildren(UnitState state) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (canCarryUnits()) {</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">            for (Unit u : getUnitList()) u.setState(state);</span>
        }
<span class="fc" id="L718">    }</span>

    /**
     * Change the owner of this unit.
     *
     * -vis: This routine calls setOwner() and thus has visibility
     * implications.  Ideally it should be in ServerUnit but we keep
     * it here for the benefit of the test suite.
     *
     * @param owner The new owner &lt;code&gt;Player&lt;/code&gt;.
     */
    public void changeOwner(Player owner) {
<span class="fc" id="L730">        final Player oldOwner = this.owner;</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (oldOwner == owner) return;</span>

<span class="pc bpc" id="L733" title="1 of 2 branches missed.">        if (oldOwner == null) {</span>
<span class="nc" id="L734">            logger.warning(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L735">                + &quot; had no owner, when changing owner to &quot; + owner.getId());</span>
        }

        // This need to be set right away.
<span class="fc" id="L739">        setOwner(owner);</span>

        // Clear trade route and goto orders if changing owner.
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (getTradeRoute() != null) setTradeRoute(null);</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">        if (getDestination() != null) setDestination(null);</span>

        // If its a carrier, we need to update the units it has loaded
        // before finishing with it
<span class="fc bfc" id="L747" title="All 2 branches covered.">        for (Unit u : getUnitList()) u.changeOwner(owner);</span>

<span class="pc bpc" id="L749" title="3 of 4 branches missed.">        if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="nc" id="L750">            getTeacher().setStudent(null);</span>
<span class="nc" id="L751">            setTeacher(null);</span>
        }

<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (oldOwner != null) oldOwner.removeUnit(this);</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">        if (owner != null) owner.addUnit(this);</span>

<span class="fc" id="L757">        getGame().notifyOwnerChanged(this, oldOwner, owner);</span>
<span class="fc" id="L758">    }</span>

    /**
     * Gets the unit role.
     *
     * @return The &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public Role getRole() {
<span class="fc" id="L766">        return role;</span>
    }

    /**
     * Sets the &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt;.
     */
    public void setRole(Role role) {
<span class="fc" id="L775">        this.role = role;</span>
<span class="fc" id="L776">    }</span>

    /**
     * Get the role count.
     *
     * @return The current role count.
     */    
    public int getRoleCount() {
<span class="fc" id="L784">        return roleCount;</span>
    }

    /**
     * Set the role count.
     *
     * @param roleCount The new role count.
     */    
    public void setRoleCount(int roleCount) {
<span class="fc" id="L793">        this.roleCount = roleCount;</span>
<span class="fc" id="L794">    }</span>

    /**
     * Does this unit have the default role?
     *
     * @return True if the unit has the default &lt;code&gt;Role&lt;/code&gt;.
     */
    public boolean hasDefaultRole() {
<span class="fc" id="L802">        return role.isDefaultRole();</span>
    }

    /**
     * Get the last part of the role identifier, which is often used as
     * part of a message key.
     *
     * @return The role suffix.
     */
    public String getRoleSuffix() {
<span class="fc" id="L812">        return Role.getRoleSuffix(role.getId());</span>
    }

    /**
     * Change the current role of this unit.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt;.
     * @param roleCount The new role count.
     */
    public void changeRole(Role role, int roleCount) {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (!role.isCompatibleWith(getRole())) {</span>
            // Clear experience if changing to an incompatible role.
<span class="fc" id="L824">            setExperience(0);</span>
        }
<span class="fc" id="L826">        setRole(role);</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        setRoleCount((role.isDefaultRole()) ? 0 : roleCount);</span>
<span class="fc" id="L828">    }</span>

    /**
     * Change the current role count.  On zero, revert to default role.
     *
     * @param delta The change to apply to the role count.
     * @return True if the role count reached zero.
     */
    public boolean changeRoleCount(int delta) {
<span class="fc" id="L837">        this.roleCount = Math.max(0, this.roleCount + delta);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (this.roleCount != 0) return false;</span>
<span class="fc" id="L839">        this.role = getSpecification().getDefaultRole();</span>
<span class="fc" id="L840">        return true;</span>
    }

    /**
     * Is a role available to this unit?
     *
     * @param role The &lt;code&gt;Role&lt;/code&gt; to test.
     * @return True if the role is available to this unit.
     */
    public boolean roleIsAvailable(Role role) {
<span class="fc" id="L850">        return role.isAvailableTo(this);</span>
    }

    /**
     * Filter a list of roles to return only those available to this unit.
     *
     * @param roles The list of &lt;code&gt;Role&lt;/code&gt;s to filter, if null all
     *     available roles are used.
     * @return A list of available &lt;code&gt;Role&lt;/code&gt;s.
     */
    public List&lt;Role&gt; getAvailableRoles(List&lt;Role&gt; roles) {
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (roles == null) roles = getSpecification().getRoles();</span>
<span class="fc" id="L862">        return roles.stream()</span>
<span class="fc" id="L863">            .filter(r -&gt; roleIsAvailable(r)).collect(Collectors.toList());</span>
    }

    /**
     * Get a military role for this unit.
     *
     * @return A military &lt;code&gt;Role&lt;/code&gt;, or null if none found.
     */
    public Role getMilitaryRole() {
<span class="fc" id="L872">        List&lt;Role&gt; roles</span>
<span class="fc" id="L873">            = getAvailableRoles(getSpecification().getMilitaryRoles());</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">        return (roles.isEmpty()) ? null : roles.get(0);</span>
    }

    /**
     * Get the change in goods required to change to a new role/count.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt; to change to.
     * @param roleCount The new role count.
     * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; defining the change
     *     in goods required.
     */
    public List&lt;AbstractGoods&gt; getGoodsDifference(Role role, int roleCount) {
<span class="fc" id="L886">        return Role.getGoodsDifference(getRole(), getRoleCount(),</span>
                                       role, roleCount);
    }

    /**
     * Sets the units location without updating any other variables
     *
     * get/setLocation are in Locatable interface.
     *
     * -vis: This routine changes player visibility.
     *
     * @param newLocation The new &lt;code&gt;Location&lt;/code&gt;.
     */
    public void setLocationNoUpdate(Location newLocation) {
<span class="fc" id="L900">        location = newLocation;</span>
<span class="fc" id="L901">    }</span>

    /**
     * Verifies if the unit is aboard a carrier
     *
     * @return True if the unit is aboard a carrier.
     */
    public boolean isOnCarrier() {
<span class="fc" id="L909">        return getLocation() instanceof Unit;</span>
    }

    /**
     * Gets the carrier this unit is aboard if any.
     *
     * @return The carrier this unit is aboard, or null if none.
     */
    public Unit getCarrier() {
<span class="fc bfc" id="L918" title="All 2 branches covered.">        return (isOnCarrier()) ? ((Unit)getLocation()) : null;</span>
    }

    /**
     * Checks whether this &lt;code&gt;Unit&lt;/code&gt; is at sea off the map, or
     * on board of a carrier that is.
     *
     * @return True if at sea.
     */
    public boolean isAtSea() {
<span class="fc bfc" id="L928" title="All 2 branches covered.">        return (location instanceof Unit) ? ((Unit)location).isAtSea()</span>
            : location instanceof HighSeas;
    }

    /**
     * Checks if this unit is running a mission.
     *
     * @return True if this unit is running a mission.
     */
    public boolean isInMission() {
<span class="fc bfc" id="L938" title="All 2 branches covered.">        return hasAbility(Ability.ESTABLISH_MISSION)</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            &amp;&amp; (getLocation() instanceof IndianSettlement</span>
                // @compat 0.10.x
                // Remove this when PET missionary serialization is retired
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">                || getLocation() == null</span>
                // end @compat 0.10.x
                );
    }

    /**
     * Checks whether this unit is working inside a colony.
     *
     * @return True if in colony.
     */
    public boolean isInColony() {
<span class="fc" id="L953">        return getLocation() instanceof WorkLocation;</span>
    }

    /**
     * Is this unit on a tile?
     *
     * @return True if this unit is on a tile.
     */
    public boolean hasTile() {
<span class="fc bfc" id="L962" title="All 2 branches covered.">        return getTile() != null;</span>
    }


    /**
     * Gets the work location this unit is working in.
     *
     * @return The current &lt;code&gt;WorkLocation&lt;/code&gt;, or null if none.
     */
    public WorkLocation getWorkLocation() {
<span class="fc bfc" id="L972" title="All 2 branches covered.">        return (isInColony()) ? (WorkLocation)getLocation() : null;</span>
    }

    /**
     * Gets the &lt;code&gt;Building&lt;/code&gt; this unit is working in.
     *
     * @return The current &lt;code&gt;Building&lt;/code&gt;, or null if none.
     */
    public Building getWorkBuilding() {
<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (getLocation() instanceof Building) {</span>
<span class="nc" id="L982">            return ((Building) getLocation());</span>
        }
<span class="nc" id="L984">        return null;</span>
    }

    /**
     * Gets the &lt;code&gt;ColonyTile&lt;/code&gt; this unit is working in.
     *
     * @return The current &lt;code&gt;ColonyTile&lt;/code&gt;, or null if none.
     */
    public ColonyTile getWorkTile() {
<span class="nc bnc" id="L993" title="All 2 branches missed.">        if (getLocation() instanceof ColonyTile) {</span>
<span class="nc" id="L994">            return ((ColonyTile) getLocation());</span>
        }
<span class="nc" id="L996">        return null;</span>
    }

    /**
     * Gets the entry location for this unit to use when returning from
     * {@link Europe}.
     *
     * @return The entry &lt;code&gt;Location&lt;/code&gt;.
     */
    public Location getEntryLocation() {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        if (entryLocation == null) {</span>
<span class="nc" id="L1007">            entryLocation = owner.getEntryLocation();</span>
        }
<span class="nc" id="L1009">        return entryLocation;</span>
    }

    /**
     * Sets the entry location in which this unit will be put when
     * returning from {@link Europe}.
     *
     * @param entryLocation The new entry &lt;code&gt;Location&lt;/code&gt;.
     * @see #getEntryLocation
     */
    public void setEntryLocation(Location entryLocation) {
<span class="fc" id="L1020">        this.entryLocation = entryLocation;</span>
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">        if (entryLocation != null) {</span>
<span class="fc" id="L1022">            owner.setEntryLocation(entryLocation);</span>
        }
<span class="fc" id="L1024">    }</span>

    /**
     * Gets the entry tile for this unit, or if null the default
     * entry location for the owning player.
     *
     * @return The entry &lt;code&gt;Tile&lt;/code&gt;.
     */
    public Tile getFullEntryLocation() {
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        return (entryLocation != null) ? (Tile) entryLocation</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            : (owner.getEntryLocation() == null) ? null</span>
<span class="nc" id="L1035">            : owner.getEntryLocation().getTile();</span>
    }

    /**
     * Get the moves left this turn.
     *
     * @return The number of moves this &lt;code&gt;Unit&lt;/code&gt; has left.
     */
    @Override
    public int getMovesLeft() {
<span class="fc" id="L1045">        return movesLeft;</span>
    }

    /**
     * Sets the moves left this turn.
     *
     * @param moves The new amount of moves left this &lt;code&gt;Unit&lt;/code&gt;
     *     should have.
     */
    public void setMovesLeft(int moves) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">        this.movesLeft = (moves &lt; 0) ? 0 : moves;</span>
<span class="fc" id="L1056">    }</span>

    /**
     * Gets the type of goods this unit is producing in its current occupation.
     *
     * @return The type of goods this unit is producing.
     */
    public GoodsType getWorkType() {
<span class="fc" id="L1064">        return workType;</span>
    }

    /**
     * Set the type of goods this unit is producing in its current
     * occupation.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     */
    public void setWorkType(GoodsType type) {
<span class="fc" id="L1074">        this.workType = type;</span>
<span class="fc" id="L1075">    }</span>

    /**
     * Change the type of goods this unit is producing in its current
     * occupation.  Updates the work location production and the unit
     * experience type if necessary.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     */
    public void changeWorkType(GoodsType type) {
<span class="fc" id="L1085">        setWorkType(type);</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (type != null) experienceType = type;</span>
<span class="fc" id="L1087">        WorkLocation wl = getWorkLocation();</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">        if (wl != null) wl.updateProductionType();</span>
<span class="fc" id="L1089">    }</span>

    /**
     * Gets the type of goods this unit has accrued experience producing.
     *
     * @return The type of goods this unit would produce.
     */
    public GoodsType getExperienceType() {
<span class="fc" id="L1097">        return experienceType;</span>
    }

    /**
     * Gets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @return The experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     *     experienceType.
     * @see #modifyExperience
     */
    public int getExperience() {
<span class="fc" id="L1109">        return experience;</span>
    }

    /**
     * Sets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @param experience The new experience of this &lt;code&gt;Unit&lt;/code&gt;
     *     at its current experienceType.
     * @see #modifyExperience
     */
    public void setExperience(int experience) {
<span class="fc" id="L1121">        this.experience = Math.min(experience,</span>
<span class="fc" id="L1122">                                   getType().getMaximumExperience());</span>
<span class="fc" id="L1123">    }</span>

    /**
     * Modifies the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @param value The value by which to modify the experience of this
     *     &lt;code&gt;Unit&lt;/code&gt;.
     * @see #getExperience
     */
    public void modifyExperience(int value) {
<span class="fc" id="L1134">        experience += value;</span>
<span class="fc" id="L1135">    }</span>

    /**
     * Gets the amount of work left.
     *
     * @return The amount of work left.
     */
    public int getWorkLeft() {
<span class="fc" id="L1143">        return workLeft;</span>
    }

    /**
     * Sets the amount of work left.
     *
     * @param workLeft The new amount of work left.
     */
    public void setWorkLeft(int workLeft) {
<span class="fc" id="L1152">        this.workLeft = workLeft;</span>
<span class="fc" id="L1153">    }</span>

    /**
     * Get the number of turns of work left.
     *
     * @return The number of turns of work left.
     */
    public int getWorkTurnsLeft() {
<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">        return (state == UnitState.IMPROVING</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                &amp;&amp; unitType.hasAbility(Ability.EXPERT_PIONEER))</span>
<span class="fc" id="L1163">            ? (getWorkLeft() + 1) / 2</span>
<span class="fc" id="L1164">            : getWorkLeft();</span>
    }

    /**
     * Gets the TileImprovement that this pioneer is contributing to.
     *
     * @return The &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is working on.
     */
    public TileImprovement getWorkImprovement() {
<span class="fc" id="L1173">        return workImprovement;</span>
    }

    /**
     * Sets the TileImprovement that this pioneer is contributing to.
     *
     * @param imp The new &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is to
     *     work on.
     */
    public void setWorkImprovement(TileImprovement imp) {
<span class="fc" id="L1183">        workImprovement = imp;</span>
<span class="fc" id="L1184">    }</span>

    /**
     * Get the unit being taught.
     *
     * @return A student &lt;code&gt;Unit&lt;/code&gt; if any.
     */
    public final Unit getStudent() {
<span class="fc" id="L1192">        return student;</span>
    }

    /**
     * Set the student unit.
     *
     * @param newStudent The new student &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final void setStudent(final Unit newStudent) {
<span class="fc" id="L1201">        Unit oldStudent = this.student;</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">        if (oldStudent == newStudent) return;</span>

<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (newStudent == null) {</span>
<span class="fc" id="L1205">            this.student = null;</span>
<span class="pc bpc" id="L1206" title="1 of 4 branches missed.">            if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="fc" id="L1207">                oldStudent.setTeacher(null);</span>
            }
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        } else if (newStudent.getColony() != null</span>
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">            &amp;&amp; newStudent.getColony() == getColony()</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">            &amp;&amp; newStudent.canBeStudent(this)) {</span>
<span class="pc bpc" id="L1212" title="3 of 4 branches missed.">            if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="nc" id="L1213">                oldStudent.setTeacher(null);</span>
            }
<span class="fc" id="L1215">            this.student = newStudent;</span>
<span class="fc" id="L1216">            newStudent.setTeacher(this);</span>
        } else {
<span class="nc" id="L1218">            throw new IllegalStateException(&quot;Unit can not be student: &quot;</span>
                + newStudent);
        }
<span class="fc" id="L1221">    }</span>

    /**
     * Get the unit teaching this one.
     *
     * @return A teacher &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final Unit getTeacher() {
<span class="fc" id="L1229">        return teacher;</span>
    }

    /**
     * Set the teacher for this unit.
     *
     * @param newTeacher The new teacher &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final void setTeacher(final Unit newTeacher) {
<span class="fc" id="L1238">        Unit oldTeacher = this.teacher;</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">        if (newTeacher == oldTeacher) return;</span>

<span class="fc bfc" id="L1241" title="All 2 branches covered.">        if (newTeacher == null) {</span>
<span class="fc" id="L1242">            this.teacher = null;</span>
<span class="pc bpc" id="L1243" title="1 of 4 branches missed.">            if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1244">                oldTeacher.setStudent(null);</span>
            }
        } else {
<span class="fc" id="L1247">            UnitType skillTaught = newTeacher.getType().getSkillTaught();</span>
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">            if (newTeacher.getColony() != null</span>
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">                &amp;&amp; newTeacher.getColony() == getColony()</span>
<span class="pc bpc" id="L1250" title="1 of 2 branches missed.">                &amp;&amp; getColony().canTrain(skillTaught)) {</span>
<span class="pc bpc" id="L1251" title="1 of 4 branches missed.">                if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1252">                    oldTeacher.setStudent(null);</span>
                }
<span class="fc" id="L1254">                this.teacher = newTeacher;</span>
<span class="fc" id="L1255">                this.teacher.setStudent(this);</span>
            } else {
<span class="nc" id="L1257">                throw new IllegalStateException(&quot;Unit can not be teacher: &quot;</span>
                    + newTeacher);
            }
        }
<span class="fc" id="L1261">    }</span>

    /**
     * Gets the number of turns this unit has been training.
     *
     * @return The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has
     *     given.
     * @see #setTurnsOfTraining
     * @see #getNeededTurnsOfTraining
     */
    public int getTurnsOfTraining() {
<span class="fc" id="L1272">        return turnsOfTraining;</span>
    }

    /**
     * Sets the number of turns this unit has been training.
     *
     * @param turnsOfTraining The number of turns of training this
     *     &lt;code&gt;Unit&lt;/code&gt; has given.
     * @see #getNeededTurnsOfTraining
     */
    public void setTurnsOfTraining(int turnsOfTraining) {
<span class="fc" id="L1283">        this.turnsOfTraining = turnsOfTraining;</span>
<span class="fc" id="L1284">    }</span>

    /**
     * Gets the number of turns this unit has to train to educate a student.
     * This value is only meaningful for units that can be put in a school.
     *
     * @return The turns of training needed to teach its current type
     *     to a free colonist or to promote an indentured servant or a
     *     petty criminal.
     * @see #getTurnsOfTraining
     */
    public int getNeededTurnsOfTraining() {
        // number of turns is 4/6/8 for skill 1/2/3
<span class="fc" id="L1297">        int result = 0;</span>
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">        if (student != null) {</span>
<span class="fc" id="L1299">            result = getNeededTurnsOfTraining(unitType, student.unitType);</span>
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">            if (getColony() != null) {</span>
<span class="fc" id="L1301">                result -= getColony().getProductionBonus();</span>
            }
        }
<span class="fc" id="L1304">        return result;</span>
    }

    /**
     * Gets the number of turns this unit has to train to educate a student.
     * This value is only meaningful for units that can be put in a school.
     *
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeStudent the student &lt;code&gt;UnitType&lt;/code&gt;.
     * @return The turns of training needed to teach its current type
     *     to a free colonist or to promote an indentured servant or a
     *     petty criminal.
     * @see #getTurnsOfTraining
     */
    public int getNeededTurnsOfTraining(UnitType typeTeacher,
                                        UnitType typeStudent) {
<span class="fc" id="L1320">        UnitType teaching = getUnitTypeTeaching(typeTeacher, typeStudent);</span>
<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">        if (teaching != null) {</span>
<span class="fc" id="L1322">            return typeStudent.getEducationTurns(teaching);</span>
        } else {
<span class="nc" id="L1324">            throw new IllegalStateException(&quot;typeTeacher=&quot; + typeTeacher</span>
                + &quot; typeStudent=&quot; + typeStudent);
        }
    }

    /**
     * Gets the UnitType which a teacher is teaching to a student.
     * This value is only meaningful for teachers that can be put in a
     * school.
     *
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeStudent The student &lt;code&gt;UnitType&lt;/code&gt;.
     * @return The &lt;code&gt;UnitType&lt;/code&gt; taught.
     * @see #getTurnsOfTraining
     *
     */
    public static UnitType getUnitTypeTeaching(UnitType typeTeacher,
                                               UnitType typeStudent) {
<span class="fc" id="L1342">        UnitType skillTaught = typeTeacher.getSkillTaught();</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">        if (typeStudent.canBeUpgraded(skillTaught, ChangeType.EDUCATION)) {</span>
<span class="fc" id="L1344">            return skillTaught;</span>
        } else {
<span class="fc" id="L1346">            return typeStudent.getEducationUnit(0);</span>
        }
    }

    /**
     * Can this unit be a student?
     *
     * @param teacher The teacher &lt;code&gt;Unit&lt;/code&gt; which is trying to
     *     teach it.
     * @return True if the unit can be taught by the teacher.
     */
    public boolean canBeStudent(Unit teacher) {
<span class="fc bfc" id="L1358" title="All 4 branches covered.">        return teacher != this &amp;&amp; canBeStudent(unitType, teacher.unitType);</span>
    }

    /**
     * Can a unit be a student?
     *
     * @param typeStudent The student &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @return True if the student can be taught by the teacher.
     */
    public boolean canBeStudent(UnitType typeStudent, UnitType typeTeacher) {
<span class="fc bfc" id="L1369" title="All 2 branches covered.">        return getUnitTypeTeaching(typeTeacher, typeStudent) != null;</span>
    }

    /**
     * Gets the nationality of this Unit.
     *
     * Nationality represents a Unit's personal allegiance to a
     * nation.  This may conflict with who currently issues orders to
     * the Unit (the owner).
     *
     * @return The nationality of this Unit.
     */
    public String getNationality() {
<span class="nc" id="L1382">        return nationality;</span>
    }

    /**
     * Sets the nationality of this Unit.  A unit will change
     * nationality when it switches owners willingly.  Currently only
     * Converts do this, but it opens the possibility of
     * naturalisation.
     *
     * @param newNationality The new nationality of this Unit.
     */
    public void setNationality(String newNationality) {
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        if (isPerson()) {</span>
<span class="nc" id="L1395">            nationality = newNationality;</span>
        } else {
<span class="nc" id="L1397">            throw new UnsupportedOperationException(&quot;Can not set the nationality of a Unit which is not a person!&quot;);</span>
        }
<span class="nc" id="L1399">    }</span>

    /**
     * Gets the ethnicity of this Unit.
     *
     * Ethnicity is inherited from the inhabitants of the place where
     * the Unit was born.  Allows former converts to become
     * native-looking colonists.
     *
     * @return The ethnicity of this Unit.
     */
    public String getEthnicity() {
<span class="nc" id="L1411">        return ethnicity;</span>
    }

    /**
     * Sets the ethnicity of this Unit.
     *
     * @param newEthnicity The new ethnicity of this Unit.
     */
    public void setEthnicity(String newEthnicity) {
<span class="nc" id="L1420">        this.ethnicity = newEthnicity;</span>
<span class="nc" id="L1421">    }</span>

    /**
     * Identifies whether this unit came from a native tribe.
     *
     * @return Whether this unit looks native or not.
     */
    public boolean hasNativeEthnicity() {
        try {
            // FIXME: getNation() could fail, but getNationType()
            // doesn't work as expected
<span class="nc" id="L1432">            return getGame().getSpecification().getNation(ethnicity)</span>
<span class="nc" id="L1433">                .getType().isIndian();</span>
<span class="nc" id="L1434">        } catch (Exception e) {</span>
<span class="nc" id="L1435">            return false;</span>
        }
    }

    /**
     * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; home for this unit.
     *
     * @return The home &lt;code&gt;IndianSettlement&lt;/code&gt; of this unit.
     */
    public IndianSettlement getHomeIndianSettlement() {
<span class="fc" id="L1445">        return indianSettlement;</span>
    }

    /**
     * Sets the home &lt;code&gt;IndianSettlement&lt;/code&gt; for this unit.
     *
     * @param indianSettlement The &lt;code&gt;IndianSettlement&lt;/code&gt; that should
     *     now own this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public void setHomeIndianSettlement(IndianSettlement indianSettlement) {
<span class="fc bfc" id="L1455" title="All 2 branches covered.">        if (this.indianSettlement != null) {</span>
<span class="fc" id="L1456">            this.indianSettlement.removeOwnedUnit(this);</span>
        }

<span class="fc" id="L1459">        this.indianSettlement = indianSettlement;</span>

<span class="fc bfc" id="L1461" title="All 2 branches covered.">        if (indianSettlement != null) {</span>
<span class="fc" id="L1462">            indianSettlement.addOwnedUnit(this);</span>
        }
<span class="fc" id="L1464">    }</span>

    /**
     * Gets the unit hit points.
     *
     * This is currently only used for damaged ships, but might get an
     * extended use later.
     *
     * @return The hit points this &lt;code&gt;Unit&lt;/code&gt; has.
     * @see UnitType#getHitPoints
     */
    public int getHitPoints() {
<span class="nc" id="L1476">        return hitPoints;</span>
    }

    /**
     * Sets the hit points for this unit.
     *
     * @param hitPoints The new hit points for this unit.
     */
    public void setHitPoints(int hitPoints) {
<span class="fc" id="L1485">        this.hitPoints = hitPoints;</span>
<span class="fc" id="L1486">    }</span>

    /**
     * Checks if this unit is under repair.
     *
     * @return True if under repair.
     */
    public boolean isDamaged() {
<span class="fc bfc" id="L1494" title="All 2 branches covered.">        return hitPoints &lt; unitType.getHitPoints();</span>
    }

    /**
     * Get how many turns left to be repaired
     *
     * @return The number of turns left to be repaired.
     */
    public int getTurnsForRepair() {
<span class="nc" id="L1503">        return unitType.getHitPoints() - getHitPoints();</span>
    }

    /**
     * Get the destination of this unit.
     *
     * @return The destination &lt;code&gt;Location&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public Location getDestination() {
<span class="fc" id="L1512">        return destination;</span>
    }

    /**
     * Sets the destination of this unit.
     *
     * @param newDestination The new destination &lt;code&gt;Location&lt;/code&gt;.
     */
    public void setDestination(Location newDestination) {
<span class="fc" id="L1521">        this.destination = newDestination;</span>
<span class="fc" id="L1522">    }</span>

    /**
     * Get the unit trade route, if any.
     *
     * @return The &lt;code&gt;TradeRoute&lt;/code&gt;, or null if none.
     */
    public final TradeRoute getTradeRoute() {
<span class="fc" id="L1530">        return tradeRoute;</span>
    }

    /**
     * Set the unit trade route.
     *
     * @param newTradeRoute The new &lt;code&gt;TradeRoute&lt;/code&gt; value.
     */
    public final void setTradeRoute(final TradeRoute newTradeRoute) {
<span class="fc" id="L1539">        this.tradeRoute = newTradeRoute;</span>
<span class="fc" id="L1540">    }</span>

    /**
     * Get the stop the unit is heading for or at.
     *
     * @return The target &lt;code&gt;Stop&lt;/code&gt;.
     */
    public TradeRouteStop getStop() {
<span class="nc bnc" id="L1548" title="All 2 branches missed.">        return (validateCurrentStop() &lt; 0) ? null</span>
<span class="nc" id="L1549">            : getTradeRoute().getStops().get(currentStop);</span>
    }

    /**
     * Get the stop the unit is heading for or at.
     *
     * @return The target &lt;code&gt;Stop&lt;/code&gt;.
     */
    public List&lt;TradeRouteStop&gt; getCurrentStops() {
<span class="nc bnc" id="L1558" title="All 2 branches missed.">        if (validateCurrentStop() &lt; 0) return null;</span>
<span class="nc" id="L1559">        List&lt;TradeRouteStop&gt; stops</span>
<span class="nc" id="L1560">            = new ArrayList&lt;TradeRouteStop&gt;(getTradeRoute().getStops());</span>
<span class="nc" id="L1561">        rotate(stops, currentStop);</span>
<span class="nc" id="L1562">        return stops;</span>
    }

    /**
     * Get the current trade route stop.
     *
     * @return The current stop index.
     */
    public int getCurrentStop() {
<span class="nc" id="L1571">        return currentStop;</span>
    }

    /**
     * Set the current stop.
     *
     * @param currentStop A new value for the currentStop.
     */
    public void setCurrentStop(int currentStop) {
<span class="nc" id="L1580">        this.currentStop = currentStop;</span>
<span class="nc" id="L1581">    }</span>

    /**
     * Validate and return the current stop.
     *
     * @return The current stop index, or negative on failure.
     */
    public int validateCurrentStop() {
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        if (tradeRoute == null) {</span>
<span class="nc" id="L1590">            currentStop = -1;</span>
        } else {
<span class="nc" id="L1592">            List&lt;TradeRouteStop&gt; stops = tradeRoute.getStops();</span>
<span class="nc bnc" id="L1593" title="All 4 branches missed.">            if (stops == null || stops.isEmpty()) {</span>
<span class="nc" id="L1594">                currentStop = -1;</span>
            } else {
<span class="nc bnc" id="L1596" title="All 4 branches missed.">                if (currentStop &lt; 0 || currentStop &gt;= stops.size()) {</span>
                    // The current stop can become out of range if the trade
                    // route is modified.
<span class="nc" id="L1599">                    currentStop = 0;</span>
                }
            }
        }
<span class="nc" id="L1603">        return currentStop;</span>
    }

    /**
     * Convenience function to check if a unit is at a stop.
     *
     * @param stop The &lt;code&gt;TradeRouteStop&lt;/code&gt; to check.
     * @return True if the unit is at the given stop.
     */
    public boolean atStop(TradeRouteStop stop) {
<span class="nc" id="L1613">        return Map.isSameLocation(getLocation(), stop.getLocation());</span>
    }

    /**
     * Get the current trade location.
     *
     * @return The &lt;code&gt;TradeLocation&lt;/code&gt; for this unit.
     */
    public TradeLocation getTradeLocation() {
        Colony colony;
        IndianSettlement is;
<span class="nc bnc" id="L1624" title="All 2 branches missed.">        return ((colony = getColony()) != null) ? colony</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            : ((is = getIndianSettlement()) != null) ? is</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            : (isInEurope()) ? (TradeLocation)getOwner().getEurope()</span>
            : null;
    }

    /**
     * Get the current amount of treasure in this unit.
     *
     * @return The amount of treasure.
     * @exception IllegalStateException if this is not a treasure
     *     carrying unit.
     */
    public int getTreasureAmount() {
<span class="pc bpc" id="L1638" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L1639">            throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
        }
<span class="fc" id="L1641">        return treasureAmount;</span>
    }

    /**
     * Set the amount of treasure in this unit.
     *
     * @param amount The new amount of treasure.
     */
    public void setTreasureAmount(int amount) {
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L1651">            throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
        }
<span class="fc" id="L1653">        this.treasureAmount = amount;</span>
<span class="fc" id="L1654">    }</span>

    /**
     * Gets the attrition of this unit.
     *
     * @return The attrition of this unit.
     */
    public int getAttrition() {
<span class="fc" id="L1662">        return attrition;</span>
    }

    /**
     * Sets the attrition of this unit.
     *
     * @param attrition The new attrition of this unit.
     */
    public void setAttrition(int attrition) {
<span class="fc" id="L1671">        this.attrition = attrition;</span>
<span class="fc" id="L1672">    }</span>

    /**
     * Get the visible amount of goods that is carried by this unit.
     *
     * @return The visible amount of goods carried by this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public int getVisibleGoodsCount() {
<span class="pc bpc" id="L1680" title="1 of 2 branches missed.">        return (visibleGoodsCount &gt;= 0) ? visibleGoodsCount</span>
<span class="fc" id="L1681">            : getGoodsSpaceTaken();</span>
    }


    // Combat routines

    /**
     * Gets a role that can be equipped automatically assumed
     * in case of an attack.
     *
     * Paul Revere makes an unarmed colonist in a settlement pick up a
     * stock-piled musket if attacked, so the bonus should be applied
     * for unarmed colonists inside colonies where there are muskets
     * available.  Natives can also auto-arm.
     *
     * @return A &lt;code&gt;Role&lt;/code&gt; that can be automatically assumed
     *     by this unit, or null if none.
     */
    public Role getAutomaticRole() {
<span class="fc bfc" id="L1700" title="All 2 branches covered.">        if (!hasDefaultRole()) return null;</span>
<span class="fc" id="L1701">        Set&lt;Ability&gt; autoDefence = getAbilities(Ability.AUTOMATIC_EQUIPMENT);</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">        if (autoDefence.isEmpty()) return null;</span>
<span class="fc bfc" id="L1703" title="All 2 branches covered.">        Settlement settlement = (isInColony()) ? getColony()</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">            : (getLocation() instanceof IndianSettlement)</span>
<span class="fc" id="L1705">            ? (Settlement)getLocation()</span>
            : null;
<span class="fc bfc" id="L1707" title="All 2 branches covered.">        if (settlement == null) return null;</span>

<span class="fc" id="L1709">        final Specification spec = getSpecification();</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        for (Ability ability : autoDefence) {</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">            for (Scope scope : ability.getScopes()) {</span>
<span class="fc" id="L1712">                Role role = spec.getRole(scope.getType());</span>
<span class="pc bpc" id="L1713" title="1 of 2 branches missed.">                if (role != null</span>
<span class="fc bfc" id="L1714" title="All 2 branches covered.">                    &amp;&amp; settlement.containsGoods(getGoodsDifference(role, 1))) {</span>
<span class="fc" id="L1715">                    return role;</span>
                }
<span class="fc" id="L1717">            }</span>
<span class="fc" id="L1718">        }</span>
<span class="fc" id="L1719">        return null;</span>
    }

    /**
     * After winning a battle, can this unit capture the loser's role
     * equipment?
     *
     * @param role The loser unit &lt;code&gt;Role&lt;/code&gt;.
     * @return The &lt;code&gt;Role&lt;/code&gt; available to this unit as a result
     *     of capturing the loser equipment.
     */
    public Role canCaptureEquipment(Role role) {
<span class="fc bfc" id="L1731" title="All 2 branches covered.">        if (!hasAbility(Ability.CAPTURE_EQUIPMENT)) return null;</span>
<span class="fc" id="L1732">        final Specification spec = getSpecification();</span>
<span class="fc" id="L1733">        final Role oldRole = getRole();</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">        for (Role r : getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="fc bfc" id="L1735" title="All 2 branches covered.">            for (Role.RoleChange rc : r.getRoleChanges()) {</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">                if (rc.getFrom(spec) == oldRole</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">                    &amp;&amp; rc.getCapture(spec) == role) return r;</span>
<span class="fc" id="L1738">            }</span>
<span class="fc" id="L1739">        }</span>
<span class="fc" id="L1740">        return null;</span>
    }

    /**
     * Does losing a piece of equipment mean the death of this unit?
     *
     * @return True if the unit is doomed.
     */
    public boolean losingEquipmentKillsUnit() {
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        return hasAbility(Ability.DISPOSE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="pc bpc" id="L1750" title="1 of 2 branches missed.">            &amp;&amp; getRole().getDowngrade() == null;</span>
    }

    /**
     * Does losing equipment mean the demotion of this unit?
     *
     * @return True if the unit is to be demoted.
     */
    public boolean losingEquipmentDemotesUnit() {
<span class="fc bfc" id="L1759" title="All 2 branches covered.">        return hasAbility(Ability.DEMOTE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">            &amp;&amp; getRole().getDowngrade() == null;</span>
    }

    /**
     * Does the unit have arms?
     *
     * @return True if the unit has arms.
     */
    public boolean isArmed() {
<span class="fc" id="L1769">        return hasAbility(Ability.ARMED);</span>
    }

    /**
     * Does the unit have a mount?
     *
     * @return True if the unit have a mount.
     */
    public boolean isMounted() {
<span class="fc" id="L1778">        return hasAbility(Ability.MOUNTED);</span>
    }

    /**
     * Is the unit a beached ship?
     *
     * @return True if the unit is a beached ship.
     */
    public boolean isBeached() {
<span class="fc" id="L1787">        return isBeached(getTile());</span>
    }

    /**
     * Would this unit be beached if it was on a particular tile?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if the unit is a beached ship.
     */
    public boolean isBeached(Tile tile) {
<span class="pc bpc" id="L1797" title="1 of 6 branches missed.">        return isNaval() &amp;&amp; tile != null &amp;&amp; tile.isLand()</span>
<span class="pc bpc" id="L1798" title="1 of 2 branches missed.">            &amp;&amp; !tile.hasSettlement();</span>
    }

    /**
     * Checks if this is an defensive unit. That is: a unit which can
     * be used to defend a &lt;code&gt;Settlement&lt;/code&gt;.
     *
     * Note! As this method is used by the AI it really means that the
     * unit can defend as is. To be specific an unarmed colonist is
     * not defensive yet, even if Paul Revere and stockpiled muskets
     * are available. That check is only performed on an actual
     * attack.
     *
     * A settlement is lost when there are no more defensive units.
     *
     * @return True if this is a defensive unit meaning it can be used
     *     to defend a &lt;code&gt;Colony&lt;/code&gt;.  This would normally mean
     *     that a defensive unit also will be offensive.
     */
    public boolean isDefensiveUnit() {
<span class="pc bpc" id="L1818" title="1 of 4 branches missed.">        return (unitType.isDefensive() || getRole().isDefensive())</span>
<span class="pc bpc" id="L1819" title="1 of 2 branches missed.">            &amp;&amp; !isCarrier(); // Not wagons or ships</span>
    }

    /**
     * Checks if this is an offensive unit.  That is, one that can
     * attack other units.
     *
     * @return True if this is an offensive unit.
     */
    public boolean isOffensiveUnit() {
<span class="fc bfc" id="L1829" title="All 4 branches covered.">        return unitType.isOffensive() || getRole().isOffensive();</span>
    }

    /**
     * Is an alternate unit a better defender than the current choice.
     * Prefer if there is no current defender, or if the alternate
     * unit is better armed, or provides greater defensive power and
     * does not replace a defensive unit defender with a non-defensive
     * unit.
     *
     * @param defender The current defender &lt;code&gt;Unit&lt;/code&gt;.
     * @param defenderPower Its defence power.
     * @param other An alternate &lt;code&gt;Unit&lt;/code&gt;.
     * @param otherPower Its defence power.
     * @return True if the other unit should be preferred.
     */
    public static boolean betterDefender(Unit defender, double defenderPower,
                                         Unit other, double otherPower) {
<span class="fc bfc" id="L1847" title="All 2 branches covered.">        if (defender == null) {</span>
<span class="fc" id="L1848">            return true;</span>
<span class="pc bpc" id="L1849" title="2 of 4 branches missed.">        } else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="pc bpc" id="L1850" title="1 of 4 branches missed.">            &amp;&amp; !defender.isArmed() &amp;&amp; other.isArmed()) {</span>
<span class="nc" id="L1851">            return true;</span>
<span class="pc bpc" id="L1852" title="2 of 4 branches missed.">        } else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="pc bpc" id="L1853" title="1 of 4 branches missed.">            &amp;&amp; defender.isArmed() &amp;&amp; !other.isArmed()) {</span>
<span class="nc" id="L1854">            return false;</span>
<span class="pc bpc" id="L1855" title="1 of 4 branches missed.">        } else if (!defender.isDefensiveUnit() &amp;&amp; other.isDefensiveUnit()) {</span>
<span class="nc" id="L1856">            return true;</span>
<span class="pc bpc" id="L1857" title="1 of 4 branches missed.">        } else if (defender.isDefensiveUnit() &amp;&amp; !other.isDefensiveUnit()) {</span>
<span class="nc" id="L1858">            return false;</span>
        } else {
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">            return defenderPower &lt; otherPower;</span>
        }
    }

    /**
     * Finds the closest &lt;code&gt;Location&lt;/code&gt; to this tile where
     * this ship can be repaired, excluding the current colony.
     *
     * @return The closest &lt;code&gt;Location&lt;/code&gt; where a ship can be
     *     repaired.
     */
    public Location getRepairLocation() {
<span class="fc" id="L1872">        final Player player = getOwner();</span>
<span class="fc" id="L1873">        final Colony notHere = getTile().getColony();</span>
<span class="fc" id="L1874">        Location best = getClosestColony(player.getColonies().stream()</span>
<span class="pc bpc" id="L1875" title="3 of 4 branches missed.">            .filter(c -&gt; c != notHere &amp;&amp; c.hasAbility(Ability.REPAIR_UNITS)));</span>
<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">        return (best != null) ? best : player.getEurope();</span>
    }


    // Movement handling

    /**
     * A move type.
     *
     * @see Unit#getMoveType(Direction)
     */
<span class="pc" id="L1887">    public static enum MoveType {</span>
<span class="fc" id="L1888">        MOVE(null, true),</span>
<span class="fc" id="L1889">        MOVE_HIGH_SEAS(null, true),</span>
<span class="fc" id="L1890">        EXPLORE_LOST_CITY_RUMOUR(null, true),</span>
<span class="fc" id="L1891">        ATTACK_UNIT(null, false),</span>
<span class="fc" id="L1892">        ATTACK_SETTLEMENT(null, false),</span>
<span class="fc" id="L1893">        EMBARK(null, false),</span>
<span class="fc" id="L1894">        ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST(null, false),</span>
<span class="fc" id="L1895">        ENTER_INDIAN_SETTLEMENT_WITH_SCOUT(null, false),</span>
<span class="fc" id="L1896">        ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY(null, false),</span>
<span class="fc" id="L1897">        ENTER_FOREIGN_COLONY_WITH_SCOUT(null, false),</span>
<span class="fc" id="L1898">        ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS(null, false),</span>
<span class="fc" id="L1899">        MOVE_NO_MOVES(&quot;Attempt to move without moves left&quot;),</span>
<span class="fc" id="L1900">        MOVE_NO_ACCESS_LAND(&quot;Attempt to move a naval unit onto land&quot;),</span>
<span class="fc" id="L1901">        MOVE_NO_ACCESS_BEACHED(&quot;Attempt to move onto foreign beached ship&quot;),</span>
<span class="fc" id="L1902">        MOVE_NO_ACCESS_EMBARK(&quot;Attempt to embark onto absent or foreign carrier&quot;),</span>
<span class="fc" id="L1903">        MOVE_NO_ACCESS_FULL(&quot;Attempt to embark onto full carrier&quot;),</span>
<span class="fc" id="L1904">        MOVE_NO_ACCESS_GOODS(&quot;Attempt to trade without goods&quot;),</span>
<span class="fc" id="L1905">        MOVE_NO_ACCESS_CONTACT(&quot;Attempt to interact with natives before contact&quot;),</span>
<span class="fc" id="L1906">        MOVE_NO_ACCESS_MISSION_BAN(&quot;Attempt to use missionary at banned settlement&quot;),</span>
<span class="fc" id="L1907">        MOVE_NO_ACCESS_SETTLEMENT(&quot;Attempt to move into foreign settlement&quot;),</span>
<span class="fc" id="L1908">        MOVE_NO_ACCESS_SKILL(&quot;Attempt to learn skill with incapable unit&quot;),</span>
<span class="fc" id="L1909">        MOVE_NO_ACCESS_TRADE(&quot;Attempt to trade without authority&quot;),</span>
<span class="fc" id="L1910">        MOVE_NO_ACCESS_WAR(&quot;Attempt to trade while at war&quot;),</span>
<span class="fc" id="L1911">        MOVE_NO_ACCESS_WATER(&quot;Attempt to move into a settlement by water&quot;),</span>
<span class="fc" id="L1912">        MOVE_NO_ATTACK_CIVILIAN(&quot;Attempt to attack with civilian unit&quot;),</span>
<span class="fc" id="L1913">        MOVE_NO_ATTACK_MARINE(&quot;Attempt to attack from on board ship&quot;),</span>
<span class="fc" id="L1914">        MOVE_NO_EUROPE(&quot;Attempt to move to Europe by incapable unit&quot;),</span>
<span class="fc" id="L1915">        MOVE_NO_REPAIR(&quot;Attempt to move a unit that is under repair&quot;),</span>
<span class="fc" id="L1916">        MOVE_NO_TILE(&quot;Attempt to move when not on a tile&quot;),</span>
<span class="fc" id="L1917">        MOVE_ILLEGAL(&quot;Unspecified illegal move&quot;);</span>

        /**
         * The reason why this move type is illegal.
         */
        private final String reason;

        /**
         * Does this move type imply progress towards a destination.
         */
        private final boolean progress;

<span class="fc" id="L1929">        MoveType(String reason) {</span>
<span class="fc" id="L1930">            this.reason = reason;</span>
<span class="fc" id="L1931">            this.progress = false;</span>
<span class="fc" id="L1932">        }</span>

<span class="fc" id="L1934">        MoveType(String reason, boolean progress) {</span>
<span class="fc" id="L1935">            this.reason = reason;</span>
<span class="fc" id="L1936">            this.progress = progress;</span>
<span class="fc" id="L1937">        }</span>

        public boolean isLegal() {
<span class="fc bfc" id="L1940" title="All 2 branches covered.">            return this.reason == null;</span>
        }

        public String whyIllegal() {
<span class="nc bnc" id="L1944" title="All 2 branches missed.">            return (reason == null) ? &quot;(none)&quot; : reason;</span>
        }

        public boolean isProgress() {
<span class="fc" id="L1948">            return progress;</span>
        }

        public boolean isAttack() {
<span class="nc bnc" id="L1952" title="All 4 branches missed.">            return this == ATTACK_UNIT || this == ATTACK_SETTLEMENT;</span>
        }
    }

    /**
     * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; onto the given
     * &lt;code&gt;Tile&lt;/code&gt;. A call to {@link #getMoveType(Tile)} will return
     * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
     * larger than the {@link #getMovesLeft moves left}.
     *
     * @param target The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            onto.
     * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public int getMoveCost(Tile target) {
<span class="fc" id="L1967">        return getMoveCost(getTile(), target, getMovesLeft());</span>
    }

    /**
     * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; from the given
     * &lt;code&gt;Tile&lt;/code&gt; onto the given &lt;code&gt;Tile&lt;/code&gt;. A call to
     * {@link #getMoveType(Tile, Tile, int)} will return
     * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
     * larger than the {@link #getMovesLeft moves left}.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            from.
     * @param target The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            onto.
     * @param ml The amount of moves this Unit has left.
     * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public int getMoveCost(Tile from, Tile target, int ml) {
        // Remember to also change map.findPath(...) if you change anything
        // here.

<span class="fc" id="L1988">        int cost = target.getType().getBasicMoveCost();</span>
<span class="fc bfc" id="L1989" title="All 4 branches covered.">        if (target.isLand() &amp;&amp; !isNaval()) {</span>
<span class="fc" id="L1990">            TileItemContainer container = target.getTileItemContainer();</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">            if (container != null) {</span>
<span class="fc" id="L1992">                cost = container.getMoveCost(from, target, cost);</span>
            }
        }

<span class="pc bpc" id="L1996" title="1 of 2 branches missed.">        if (isBeached(from)) {</span>
            // Ship on land due to it was in a colony which was abandoned
<span class="nc" id="L1998">            cost = ml;</span>
<span class="fc bfc" id="L1999" title="All 2 branches covered.">        } else if (cost &gt; ml) {</span>
            // Using +2 in order to make 1/3 and 2/3 move count as
            // 3/3, only when getMovesLeft &gt; 0
<span class="pc bpc" id="L2002" title="1 of 4 branches missed.">            if ((ml + 2 &gt;= getInitialMovesLeft() || cost &lt;= ml + 2</span>
<span class="fc bfc" id="L2003" title="All 4 branches covered.">                 || target.hasSettlement()) &amp;&amp; ml != 0) {</span>
<span class="fc" id="L2004">                cost = ml;</span>
            }
        }
<span class="fc" id="L2007">        return cost;</span>
    }

    /**
     * Gets the type of a move made in a specified direction.
     *
     * @param direction The &lt;code&gt;Direction&lt;/code&gt; of the move.
     * @return The move type.
     */
    public MoveType getMoveType(Direction direction) {
        Tile target;
<span class="pc bpc" id="L2018" title="1 of 2 branches missed.">        return (!hasTile())</span>
            ? MoveType.MOVE_NO_TILE
<span class="pc bpc" id="L2020" title="1 of 2 branches missed.">            : ((target = getTile().getNeighbourOrNull(direction)) == null)</span>
            ? MoveType.MOVE_ILLEGAL
<span class="fc" id="L2022">            : getMoveType(target);</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another.
     *
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    public MoveType getMoveType(Tile target) {
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">        return (!hasTile())</span>
            ? MoveType.MOVE_NO_TILE
<span class="fc" id="L2035">            : getMoveType(getTile(), target, getMovesLeft());</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param ml The amount of moves this unit has left.
     * @return The move type.
     */
    public MoveType getMoveType(Tile from, Tile target, int ml) {
<span class="fc" id="L2048">        MoveType move = getSimpleMoveType(from, target);</span>
<span class="fc bfc" id="L2049" title="All 2 branches covered.">        if (move.isLegal()) {</span>
<span class="pc bfc" id="L2050" title="All 2 branches covered.">            switch (move) {</span>
            case ATTACK_UNIT: case ATTACK_SETTLEMENT:
                // Needs only a single movement point, regardless of
                // terrain, but suffers penalty.
<span class="fc bfc" id="L2054" title="All 2 branches covered.">                if (ml &lt;= 0) {</span>
<span class="fc" id="L2055">                    move = MoveType.MOVE_NO_MOVES;</span>
                }
                break;
            default:
<span class="pc bpc" id="L2059" title="2 of 4 branches missed.">                if (ml &lt;= 0</span>
<span class="pc bpc" id="L2060" title="1 of 2 branches missed.">                    || (from != null &amp;&amp; getMoveCost(from, target, ml) &gt; ml)) {</span>
<span class="nc" id="L2061">                    move = MoveType.MOVE_NO_MOVES;</span>
                }
                break;
            }
        }
<span class="fc" id="L2066">        return move;</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another, without checking if the unit has moves left or
     * logging errors.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type, which will be one of the extended illegal move
     *         types on failure.
     */
    public MoveType getSimpleMoveType(Tile from, Tile target) {
<span class="fc bfc" id="L2080" title="All 2 branches covered.">        return (isNaval()) ? getNavalMoveType(from, target)</span>
<span class="fc" id="L2081">            : getLandMoveType(from, target);</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another, without checking if the unit has moves left or
     * logging errors.
     *
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type, which will be one of the extended illegal move
     *         types on failure.
     */
    public MoveType getSimpleMoveType(Tile target) {
<span class="nc bnc" id="L2094" title="All 2 branches missed.">        return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="nc" id="L2095">            : getSimpleMoveType(getTile(), target);</span>
    }

    /**
     * Gets the type of a move made in a specified direction,
     * without checking if the unit has moves left or logging errors.
     *
     * @param direction The direction of the move.
     * @return The move type.
     */
    public MoveType getSimpleMoveType(Direction direction) {
        Tile target;
<span class="nc bnc" id="L2107" title="All 2 branches missed.">        return (!hasTile())</span>
            ? MoveType.MOVE_NO_TILE
<span class="nc bnc" id="L2109" title="All 2 branches missed.">            : ((target = getTile().getNeighbourOrNull(direction)) == null)</span>
            ? MoveType.MOVE_ILLEGAL
<span class="nc" id="L2111">            : getSimpleMoveType(getTile(), target);</span>
    }

    /**
     * Gets the type of a move that is made when moving a naval unit
     * from one tile to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    private MoveType getNavalMoveType(@SuppressWarnings(&quot;unused&quot;) Tile from,
                                      Tile target) {
<span class="pc bpc" id="L2124" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            return (getOwner().canMoveToEurope()) ? MoveType.MOVE_HIGH_SEAS</span>
                : MoveType.MOVE_NO_EUROPE;
<span class="pc bpc" id="L2127" title="1 of 2 branches missed.">        } else if (isDamaged()) {</span>
<span class="nc" id="L2128">            return MoveType.MOVE_NO_REPAIR;</span>
        }

<span class="fc bfc" id="L2131" title="All 2 branches covered.">        if (target.isLand()) {</span>
<span class="fc" id="L2132">            Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2133" title="All 2 branches covered.">            if (settlement == null) {</span>
<span class="fc" id="L2134">                return MoveType.MOVE_NO_ACCESS_LAND;</span>
<span class="fc bfc" id="L2135" title="All 2 branches covered.">            } else if (settlement.getOwner() == getOwner()) {</span>
<span class="fc" id="L2136">                return MoveType.MOVE;</span>
<span class="pc bpc" id="L2137" title="1 of 2 branches missed.">            } else if (isTradingUnit()) {</span>
<span class="fc" id="L2138">                return getTradeMoveType(settlement);</span>
            } else {
<span class="nc" id="L2140">                return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
            }
        } else { // target at sea
<span class="fc" id="L2143">            Unit defender = target.getFirstUnit();</span>
<span class="fc bfc" id="L2144" title="All 4 branches covered.">            if (defender != null &amp;&amp; !getOwner().owns(defender)) {</span>
<span class="fc bfc" id="L2145" title="All 2 branches covered.">                return (isOffensiveUnit())</span>
                    ? MoveType.ATTACK_UNIT
                    : MoveType.MOVE_NO_ATTACK_CIVILIAN;
            } else {
<span class="fc bfc" id="L2149" title="All 2 branches covered.">                return (target.isDirectlyHighSeasConnected())</span>
                    ? MoveType.MOVE_HIGH_SEAS
                    : MoveType.MOVE;
            }
        }
    }

    /**
     * Gets the type of a move that is made when moving a land unit to
     * from one tile to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    private MoveType getLandMoveType(Tile from, Tile target) {
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">        if (target == null) return MoveType.MOVE_ILLEGAL;</span>

<span class="fc" id="L2167">        Player owner = getOwner();</span>
<span class="fc" id="L2168">        Unit defender = target.getFirstUnit();</span>

<span class="fc bfc" id="L2170" title="All 2 branches covered.">        if (target.isLand()) {</span>
<span class="fc" id="L2171">            Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">            if (settlement == null) {</span>
<span class="fc bfc" id="L2173" title="All 4 branches covered.">                if (defender != null &amp;&amp; owner != defender.getOwner()) {</span>
<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">                    if (defender.isNaval()) {</span>
<span class="nc" id="L2175">                        return MoveType.ATTACK_UNIT;</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">                    } else if (!isOffensiveUnit()) {</span>
<span class="fc" id="L2177">                        return MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
                    } else {
<span class="pc bpc" id="L2179" title="1 of 2 branches missed.">                        return (allowMoveFrom(from))</span>
                            ? MoveType.ATTACK_UNIT
                            : MoveType.MOVE_NO_ATTACK_MARINE;
                    }
<span class="pc bpc" id="L2183" title="1 of 4 branches missed.">                } else if (target.hasLostCityRumour() &amp;&amp; owner.isEuropean()) {</span>
                    // Natives do not explore rumours, see:
                    // server/control/InGameInputHandler.java:move()
<span class="fc" id="L2186">                    return MoveType.EXPLORE_LOST_CITY_RUMOUR;</span>
                } else {
<span class="fc" id="L2188">                    return MoveType.MOVE;</span>
                }
<span class="fc bfc" id="L2190" title="All 2 branches covered.">            } else if (owner == settlement.getOwner()) {</span>
<span class="fc" id="L2191">                return MoveType.MOVE;</span>
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">            } else if (isTradingUnit()) {</span>
<span class="nc" id="L2193">                return getTradeMoveType(settlement);</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">            } else if (isColonist()) {</span>
<span class="fc bfc" id="L2195" title="All 2 branches covered.">                if (settlement instanceof Colony</span>
<span class="fc bfc" id="L2196" title="All 2 branches covered.">                    &amp;&amp; hasAbility(Ability.NEGOTIATE)) {</span>
<span class="pc bpc" id="L2197" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
                        ? MoveType.ENTER_FOREIGN_COLONY_WITH_SCOUT
                        : MoveType.MOVE_NO_ACCESS_WATER;
<span class="fc bfc" id="L2200" title="All 2 branches covered.">                } else if (settlement instanceof IndianSettlement</span>
<span class="fc bfc" id="L2201" title="All 2 branches covered.">                    &amp;&amp; hasAbility(Ability.SPEAK_WITH_CHIEF)) {</span>
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
                        ? MoveType.ENTER_INDIAN_SETTLEMENT_WITH_SCOUT
                        : MoveType.MOVE_NO_ACCESS_WATER;
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                } else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
                        ? MoveType.ATTACK_SETTLEMENT
                        : MoveType.MOVE_NO_ATTACK_MARINE;
<span class="fc bfc" id="L2209" title="All 2 branches covered.">                } else if (hasAbility(Ability.ESTABLISH_MISSION)) {</span>
<span class="fc" id="L2210">                    return getMissionaryMoveType(from, settlement);</span>
                } else {
<span class="fc" id="L2212">                    return getLearnMoveType(from, settlement);</span>
                }
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">            } else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2215" title="1 of 2 branches missed.">                return (allowMoveFrom(from))</span>
                    ? MoveType.ATTACK_SETTLEMENT
                    : MoveType.MOVE_NO_ATTACK_MARINE;
            } else {
<span class="nc" id="L2219">                return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
            }
        } else { // moving to sea, check for embarkation
<span class="fc bfc" id="L2222" title="All 4 branches covered.">            return (defender == null || !getOwner().owns(defender))</span>
                ? MoveType.MOVE_NO_ACCESS_EMBARK
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">                : (any(target.getUnitList(), u -&gt; u.canAdd(this)))</span>
                ? MoveType.EMBARK
                : MoveType.MOVE_NO_ACCESS_FULL;
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a trading unit to a
     * settlement.
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getTradeMoveType(Settlement settlement) {
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">        if (settlement instanceof Colony) {</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">            return (getOwner().atWarWith(settlement.getOwner()))</span>
                ? MoveType.MOVE_NO_ACCESS_WAR
<span class="nc bnc" id="L2241" title="All 2 branches missed.">                : (!hasAbility(Ability.TRADE_WITH_FOREIGN_COLONIES))</span>
                ? MoveType.MOVE_NO_ACCESS_TRADE
                : MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS;
<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
            // Do not block for war, bringing gifts is allowed
<span class="fc bfc" id="L2246" title="All 2 branches covered.">            return (!allowContact(settlement))</span>
                ? MoveType.MOVE_NO_ACCESS_CONTACT
<span class="fc bfc" id="L2248" title="All 2 branches covered.">                : (hasGoodsCargo() || getSpecification()</span>
<span class="fc bfc" id="L2249" title="All 2 branches covered.">                    .getBoolean(GameOptions.EMPTY_TRADERS))</span>
                ? MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS
                : MoveType.MOVE_NO_ACCESS_GOODS;
        } else {
<span class="nc" id="L2253">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a colonist to a settlement.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to move from.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getLearnMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2265" title="All 2 branches covered.">        if (settlement instanceof Colony) {</span>
<span class="fc" id="L2266">            return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
<span class="fc bfc" id="L2268" title="All 2 branches covered.">            return (!allowContact(settlement))</span>
                ? MoveType.MOVE_NO_ACCESS_CONTACT
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">                : (!allowMoveFrom(from))</span>
                ? MoveType.MOVE_NO_ACCESS_WATER
<span class="pc bpc" id="L2272" title="1 of 2 branches missed.">                : (!getType().canBeUpgraded(null, ChangeType.NATIVES))</span>
                ? MoveType.MOVE_NO_ACCESS_SKILL
                : MoveType.ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST;
        } else {
<span class="nc" id="L2276">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a missionary to a settlement.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to move from.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getMissionaryMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2288" title="All 2 branches covered.">        if (settlement instanceof Colony) {</span>
<span class="fc" id="L2289">            return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2290" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
<span class="pc bpc" id="L2291" title="1 of 2 branches missed.">            return (!allowContact(settlement))</span>
                ? MoveType.MOVE_NO_ACCESS_CONTACT
<span class="pc bpc" id="L2293" title="1 of 2 branches missed.">                : (!allowMoveFrom(from))</span>
                ? MoveType.MOVE_NO_ACCESS_WATER
<span class="pc bpc" id="L2295" title="1 of 2 branches missed.">                : (settlement.getOwner().missionsBanned(getOwner()))</span>
                ? MoveType.MOVE_NO_ACCESS_MISSION_BAN
                : MoveType.ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY;
        } else {
<span class="nc" id="L2299">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Is this unit allowed to move from a source tile?
     * Implements the restrictions on moving from water.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to consider.
     * @return True if the move is allowed.
     */
    private boolean allowMoveFrom(Tile from) {
<span class="fc bfc" id="L2311" title="All 2 branches covered.">        return from.isLand()</span>
<span class="pc bpc" id="L2312" title="1 of 2 branches missed.">            || (!getOwner().isREF()</span>
<span class="pc bpc" id="L2313" title="1 of 2 branches missed.">                &amp;&amp; getSpecification().getBoolean(GameOptions.AMPHIBIOUS_MOVES));</span>
    }

    /**
     * Is this unit allowed to contact a settlement?
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to consider.
     * @return True if the contact is allowed.
     */
    private boolean allowContact(Settlement settlement) {
<span class="fc" id="L2323">        return getOwner().hasContacted(settlement.getOwner());</span>
    }

    /**
     * Does a basic check whether a unit can ever expect to move to a tile.
     *
     * @param tile The code &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if some sort of legal move to the tile exists, including
     *     special cases where there is an interaction but the unit does not
     *     actually move, such as trade.
     */
    public boolean isTileAccessible(Tile tile) {
<span class="fc bfc" id="L2335" title="All 2 branches covered.">        return (isNaval())</span>
<span class="fc bfc" id="L2336" title="All 2 branches covered.">            ? (!tile.isLand()</span>
<span class="fc bfc" id="L2337" title="All 2 branches covered.">                || (tile.hasSettlement()</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">                    &amp;&amp; getOwner().owns(tile.getSettlement())))</span>
<span class="fc" id="L2339">            : tile.isLand();</span>
    }

    /**
     * Gets the amount of moves this unit has at the beginning of each turn.
     *
     * @return The amount of moves this unit has at the beginning of
     *     each turn.
     */
    @Override
    public int getInitialMovesLeft() {
<span class="fc" id="L2350">        Turn turn = getGame().getTurn();</span>
<span class="fc" id="L2351">        return (int)applyModifiers(unitType.getMovement(), turn,</span>
                                   Modifier.MOVEMENT_BONUS, unitType);
    }

    /**
     * Make a label showing the unit moves left.
     *
     * @return A movement label.
     */
    public String getMovesAsString() {
<span class="fc" id="L2361">        StringBuilder sb = new StringBuilder(16);</span>
<span class="fc" id="L2362">        int quotient = getMovesLeft() / 3;</span>
<span class="fc" id="L2363">        int remainder = getMovesLeft() % 3;</span>
<span class="fc bfc" id="L2364" title="All 4 branches covered.">        if (quotient &gt; 0 || remainder == 0) sb.append(quotient);</span>
<span class="fc bfc" id="L2365" title="All 2 branches covered.">        if (remainder &gt; 0) {</span>
<span class="fc" id="L2366">            sb.append(&quot;(&quot;).append(remainder).append(&quot;/3) &quot;);</span>
        }
<span class="fc" id="L2368">        sb.append(&quot;/&quot;).append(getInitialMovesLeft() / 3);</span>
<span class="fc" id="L2369">        return sb.toString();</span>
    }

    /**
     * Gets the number of turns this unit will need to sail to/from Europe.
     *
     * @return The number of turns to sail to/from Europe.
     */
    public int getSailTurns() {
<span class="fc" id="L2378">        float base = getSpecification().getInteger(GameOptions.TURNS_TO_SAIL);</span>
<span class="fc" id="L2379">        return (int)getOwner().applyModifiers(base, getGame().getTurn(),</span>
                                              Modifier.SAIL_HIGH_SEAS,
                                              unitType);
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; can be moved to the high seas
     * from its current location.
     *
     * @return True if this unit can move immediately to the high seas.
     */
    public boolean canMoveToHighSeas() {
<span class="nc bnc" id="L2391" title="All 4 branches missed.">        if (isInEurope() || isAtSea()) return true;</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">        if (!getOwner().canMoveToEurope()</span>
<span class="nc bnc" id="L2393" title="All 2 branches missed.">            || !getType().canMoveToHighSeas()) return false;</span>
<span class="nc" id="L2394">        return getTile().isDirectlyHighSeasConnected();</span>
    }

    /**
     * Does this unit have a valid move to the high seas this turn.
     *
     * @return True if the unit can either move immediately to the high
     *      seas or can make a move to a neighbouring high seas tile.
     */
    public boolean hasHighSeasMove() {
<span class="nc bnc" id="L2404" title="All 2 branches missed.">        return (canMoveToHighSeas())</span>
            ? true
<span class="nc bnc" id="L2406" title="All 4 branches missed.">            : (hasTile() &amp;&amp; getMovesLeft() &gt; 0)</span>
<span class="nc" id="L2407">            ? any(getTile().getSurroundingTiles(1, 1),</span>
                Tile::isDirectlyHighSeasConnected)
            : false;
    }

    /**
     * Check if this unit can build a colony.  Does not consider whether
     * the tile where the unit is located is suitable,
     * @see Player#canClaimToFoundSettlement(Tile)
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this unit can build a colony.
     */
    public boolean canBuildColony() {
<span class="fc" id="L2420">        final Specification spec = getSpecification();</span>
<span class="pc bpc" id="L2421" title="1 of 6 branches missed.">        return hasTile() &amp;&amp; unitType.canBuildColony() &amp;&amp; getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L2422" title="1 of 2 branches missed.">            &amp;&amp; (!getOwner().isRebel()</span>
<span class="pc bnc" id="L2423" title="All 2 branches missed.">                || spec.getBoolean(GameOptions.FOUND_COLONY_DURING_REBELLION));</span>
    }

    /**
     * Is this unit at a specified location?
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to test.
     * @return True if the locations are the same, or on the same tile.
     */
    public boolean isAtLocation(Location loc) {
<span class="fc" id="L2433">        Location ourLoc = getLocation(),</span>
<span class="fc bfc" id="L2434" title="All 2 branches covered.">            otherLoc = (loc instanceof Unit) ? ((Unit)loc).getLocation() : loc;</span>
<span class="pc bpc" id="L2435" title="1 of 2 branches missed.">        if (ourLoc instanceof Unit) ourLoc = ((Unit)ourLoc).getLocation();</span>
<span class="fc" id="L2436">        return Map.isSameLocation(ourLoc, otherLoc);</span>
    }

    /**
     * Gets the best (closest) entry location for this unit to reach a
     * given tile.
     *
     * @param tile The target &lt;code&gt;Tile&lt;/code&gt;.
     * @return The best entry location tile to arrive on the map at, or null
     *     if none found.
     */
    public Tile getBestEntryTile(Tile tile) {
<span class="nc" id="L2448">        return getGame().getMap().getBestEntryTile(this, tile, null, null);</span>
    }

    /**
     * Resolves a destination for a unit on the high seas.
     * That is, the location where the unit will appear when it leaves
     * the high seas, which will either be Europe or a tile.
     *
     * @return The location the unit should appear next after leaving
     *      the high seas.
     */
    public Location resolveDestination() {
<span class="nc bnc" id="L2460" title="All 2 branches missed.">        if (!isAtSea()) throw new IllegalArgumentException(&quot;Not at sea.&quot;);</span>
<span class="nc" id="L2461">        TradeRouteStop stop = getStop();</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">        Location dst = (TradeRoute.isStopValid(this, stop))</span>
<span class="nc" id="L2463">            ? stop.getLocation()</span>
<span class="nc" id="L2464">            : getDestination();</span>
        Tile best;
<span class="nc bnc" id="L2466" title="All 4 branches missed.">        return (dst == null) ? getFullEntryLocation()</span>
            : (dst instanceof Europe) ? dst
<span class="nc bnc" id="L2468" title="All 2 branches missed.">            : (dst.getTile() != null</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">                &amp;&amp; (best = getBestEntryTile(dst.getTile())) != null) ? best</span>
<span class="nc" id="L2470">            : getFullEntryLocation();</span>
    }

    /**
     * Set movesLeft to 0 if has some spent moves and it's in a colony
     *
     * @see #add(Locatable)
     * @see #remove(Locatable)
     */
    private void spendAllMoves() {
<span class="pc bpc" id="L2480" title="3 of 4 branches missed.">        if (getColony() != null &amp;&amp; getMovesLeft() &lt; getInitialMovesLeft()) {</span>
<span class="nc" id="L2481">            setMovesLeft(0);</span>
        }
<span class="fc" id="L2483">    }</span>

    /**
     * Is this unit a suitable `next active unit', that is, the unit
     * needs to be currently movable by the player.
     *
     * @return True if this unit could still be moved by the player.
     */
    public boolean couldMove() {
<span class="nc bnc" id="L2492" title="All 2 branches missed.">        return !isDisposed()</span>
<span class="nc bnc" id="L2493" title="All 2 branches missed.">            &amp;&amp; getState() == UnitState.ACTIVE</span>
<span class="nc bnc" id="L2494" title="All 6 branches missed.">            &amp;&amp; getMovesLeft() &gt; 0</span>
            &amp;&amp; destination == null // Can not reach next tile
            &amp;&amp; tradeRoute == null
<span class="nc bnc" id="L2497" title="All 2 branches missed.">            &amp;&amp; !isDamaged()</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            &amp;&amp; !isAtSea()</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">            &amp;&amp; !isOnCarrier()</span>
            // this should never happen anyway, since these units
            // should have state IN_COLONY, but better safe than sorry
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            &amp;&amp; !isInColony();</span>
    }


    // Map support routines

    /**
     * Gets a suitable location to start path searches for a unit.
     *
     * Must handle all the cases where the unit is off the map, and
     * take account of the use of a carrier.
     *
     * @return A suitable starting location, or null if none found.
     */
    public Location getPathStartLocation() {
<span class="fc" id="L2517">        final Unit carrier = getCarrier();</span>
<span class="fc" id="L2518">        Location ret = getTile();</span>
<span class="pc bpc" id="L2519" title="1 of 2 branches missed.">        if (isOnCarrier()) {</span>
<span class="nc bnc" id="L2520" title="All 2 branches missed.">            if (ret != null) {</span>
                ; // OK
<span class="nc bnc" id="L2522" title="All 2 branches missed.">            } else if (carrier.getDestination() == null) {</span>
<span class="nc" id="L2523">                ret = null;</span>
<span class="nc bnc" id="L2524" title="All 2 branches missed.">            } else if (carrier.getDestination() instanceof Map) {</span>
<span class="nc" id="L2525">                ret = carrier.getFullEntryLocation();</span>
<span class="nc bnc" id="L2526" title="All 2 branches missed.">            } else if (carrier.getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2527">                ret = carrier.getDestination();</span>
            } else { // destination must be Europe
<span class="nc" id="L2529">                ret = null;</span>
            }
<span class="pc bpc" id="L2531" title="1 of 2 branches missed.">        } else if (isNaval()) {</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">            if (ret != null) {</span>
                ; // OK
<span class="nc bnc" id="L2534" title="All 2 branches missed.">            } else if (getDestination() == null</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">                || getDestination() instanceof Map) {</span>
<span class="nc" id="L2536">                ret = getFullEntryLocation();</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">            } else if (getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2538">                ret = getDestination();</span>
            } else {
<span class="nc" id="L2540">                ret = getFullEntryLocation();</span>
            }
        }
<span class="pc bpc" id="L2543" title="1 of 2 branches missed.">        if (ret != null) return ret;</span>

        // Must be a land unit not on the map.  May have a carrier.
        // Get our nearest settlement to Europe, fallback to any other.
<span class="nc" id="L2547">        final Player owner = getOwner();</span>
<span class="nc" id="L2548">        int bestValue = INFINITY;</span>
<span class="nc bnc" id="L2549" title="All 2 branches missed.">        for (Settlement s : owner.getSettlements()) {</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">            if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2551">                int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">                if (bestValue &gt; value) {</span>
<span class="nc" id="L2553">                    bestValue = value;</span>
<span class="nc" id="L2554">                    ret = s;</span>
                }
<span class="nc bnc" id="L2556" title="All 2 branches missed.">            } else if (bestValue == INFINITY) ret = s;</span>
<span class="nc" id="L2557">        }</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">        if (ret != null) return ret;</span>

        // Owner has no settlements.  If it is the REF, start from a
        // rebel colony.  Prefer the closest port.
<span class="nc bnc" id="L2562" title="All 2 branches missed.">        if (owner.isREF()) {</span>
<span class="nc" id="L2563">            bestValue = INFINITY;</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">            for (Player p : owner.getRebels()) {</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">                for (Settlement s : p.getSettlements()) {</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">                    if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2567">                        int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                        if (bestValue &gt; value) {</span>
<span class="nc" id="L2569">                            bestValue = value;</span>
<span class="nc" id="L2570">                            ret = s;</span>
                        }
<span class="nc bnc" id="L2572" title="All 2 branches missed.">                    } else if (bestValue == INFINITY) ret = s;</span>
<span class="nc" id="L2573">                }</span>
<span class="nc" id="L2574">            }</span>
<span class="nc bnc" id="L2575" title="All 2 branches missed.">            if (ret != null) return ret;</span>
        }

        // Desperately find the nearest land to the entry location.
<span class="nc" id="L2579">        Location entry = getFullEntryLocation();</span>
<span class="nc bnc" id="L2580" title="All 4 branches missed.">        if (entry != null &amp;&amp; entry.getTile() != null) {</span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">            for (Tile t : entry.getTile().getSurroundingTiles(INFINITY)) {</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                if (t.isLand()) return t;</span>
<span class="nc" id="L2583">            }</span>
        }

<span class="nc" id="L2586">        return null; // Fail</span>
    }

    /**
     * Should the unit use transport to get to a specified tile?
     *
     * True if:
     * - The location is not null
     * - The unit is not naval
     * - The unit is not there already
     * AND
     *   - there is no path OR the path uses an existing carrier
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to go to.
     * @return True if the unit should use transport.
     */
    public boolean shouldTakeTransportTo(Location loc) {
        PathNode path;
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">        return loc != null</span>
<span class="pc bpc" id="L2605" title="1 of 2 branches missed.">            &amp;&amp; !isNaval()</span>
<span class="fc bfc" id="L2606" title="All 2 branches covered.">            &amp;&amp; !isAtLocation(loc)</span>
<span class="pc bpc" id="L2607" title="1 of 2 branches missed.">            &amp;&amp; ((path = findPath(getLocation(), loc,</span>
<span class="fc" id="L2608">                                 getCarrier(), null)) == null</span>
<span class="pc bpc" id="L2609" title="1 of 2 branches missed.">                || path.usesCarrier());</span>
    }

    /**
     * Gets the trivial path for this unit.  That is, the path to the
     * nearest available safe settlement.
     *
     * @return A path to the trivial target, or null if none found.
     */
    public PathNode getTrivialPath() {
<span class="pc bpc" id="L2619" title="2 of 4 branches missed.">        if (isDisposed() || getLocation() == null) return null;</span>
<span class="fc bfc" id="L2620" title="All 2 branches covered.">        if (!isNaval()) return findOurNearestSettlement();</span>
<span class="fc" id="L2621">        PathNode path = findOurNearestPort();</span>
<span class="fc bfc" id="L2622" title="All 2 branches covered.">        if (path == null) {</span>
            // This is unusual, but can happen when a ship is up a
            // river and foreign ship creates a blockage downstream.
            // If so, the rational thing to do is to go to a tile
            // where other units can pass and which has the best
            // connectivity to the high seas.
<span class="fc" id="L2628">            Tile tile = getTile();</span>
<span class="pc bpc" id="L2629" title="2 of 4 branches missed.">            if (tile != null &amp;&amp; tile.isOnRiver()</span>
<span class="nc bnc" id="L2630" title="All 2 branches missed.">                &amp;&amp; tile.isHighSeasConnected()) {</span>
<span class="nc" id="L2631">                path = search(getLocation(), </span>
<span class="nc" id="L2632">                    GoalDeciders.getCornerGoalDecider(),</span>
<span class="nc" id="L2633">                    CostDeciders.avoidSettlementsAndBlockingUnits(),</span>
                    INFINITY, null);
<span class="nc bnc" id="L2635" title="All 4 branches missed.">                if (path == null &amp;&amp; tile.isRiverCorner()) {</span>
                    // Return trivial path if already present.
<span class="nc" id="L2637">                    return new PathNode(tile, 0, 0, false, null, null);</span>
                }
            }
        }
<span class="fc" id="L2641">        return path;</span>
    }

    /**
     * Finds the fastest path from the current location to the
     * specified one.  No carrier is provided, and the default cost
     * decider for this unit is used.
     *
     * @param end The &lt;code&gt;Location&lt;/code&gt; in which the path ends.
     * @return A &lt;code&gt;PathNode&lt;/code&gt; from the current location to the
     *     end location, or null if none found.
     */
    public PathNode findPath(Location end) {
<span class="fc" id="L2654">        return findPath(getLocation(), end, null, null);</span>
    }

    /**
     * Finds a quickest path between specified locations, optionally
     * using a carrier and special purpose cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start at.
     * @param end The &lt;code&gt;Location&lt;/code&gt; to end at.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
     */
    public PathNode findPath(Location start, Location end, Unit carrier,
                             CostDecider costDecider) {
<span class="fc" id="L2671">        return getGame().getMap().findPath(this, start, end,</span>
                                           carrier, costDecider, null);
    }

    /**
     * Finds a quickest path to a neighbouring tile to a specified target
     * tile, optionally using a carrier and special purpose cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start at.
     * @param end The &lt;code&gt;Tile&lt;/code&gt; to end at a neighbour of.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
     */
    public PathNode findPathToNeighbour(Location start, Tile end, Unit carrier,
                                        CostDecider costDecider) {
<span class="nc" id="L2689">        final Player owner = getOwner();</span>
<span class="nc" id="L2690">        int bestValue = INFINITY;</span>
<span class="nc" id="L2691">        PathNode best = null;</span>
<span class="nc bnc" id="L2692" title="All 2 branches missed.">        for (Tile t : end.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">            if (isTileAccessible(t)</span>
<span class="nc bnc" id="L2694" title="All 4 branches missed.">                &amp;&amp; (t.getFirstUnit() == null || owner.owns(t.getFirstUnit()))) {</span>
<span class="nc" id="L2695">                PathNode p = findPath(start, t, carrier, costDecider);</span>
<span class="nc bnc" id="L2696" title="All 4 branches missed.">                if (p != null &amp;&amp; bestValue &gt; p.getTotalTurns()) {</span>
<span class="nc" id="L2697">                    bestValue = p.getTotalTurns();</span>
<span class="nc" id="L2698">                    best = p;</span>
                }
            }
<span class="nc" id="L2701">        }</span>
<span class="nc" id="L2702">        return best;</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from its current position.  If the unit is
     * currently on a carrier, it will be used.
     *
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return The number of turns it will take to reach the destination,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location end) {
<span class="fc" id="L2715">        return getTurnsToReach(getLocation(), end);</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from a starting location.  If the unit is
     * currently on a carrier, it will be used.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location start, Location end) {
<span class="fc" id="L2729">        return getTurnsToReach(start, end, getCarrier(),</span>
<span class="fc" id="L2730">            CostDeciders.avoidSettlementsAndBlockingUnits());</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from a starting location, using an optional
     * carrier and cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; to
     *     score the path with.
     * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location start, Location end, Unit carrier,
                               CostDecider costDecider) {
<span class="fc" id="L2748">        PathNode path = findPath(start, end, carrier, costDecider);</span>
<span class="pc bpc" id="L2749" title="1 of 2 branches missed.">        return (path == null) ? MANY_TURNS : path.getTotalTurns();</span>
    }

    /**
     * Get the colony that can be reached by this unit in the least number
     * of turns.
     *
     * @param colonies A list of &lt;code&gt;Colony&lt;/code&gt;s.
     * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
     */
    public Colony getClosestColony(List&lt;Colony&gt; colonies) {
<span class="nc" id="L2760">        return getClosestColony(colonies.stream());</span>
    }
    
    /**
     * Get the colony that can be reached by this unit in the least number
     * of turns.
     *
     * @param colonies A stream of &lt;code&gt;Colony&lt;/code&gt;s.
     * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
     */
    public Colony getClosestColony(Stream&lt;Colony&gt; colonies) {
<span class="pc bnc" id="L2771" title="All 2 branches missed.">        ToIntFunction&lt;Colony&gt; closeness = c -&gt; (c == null) ? MANY_TURNS-1</span>
<span class="nc" id="L2772">            : this.getTurnsToReach(c);</span>
<span class="fc" id="L2773">        return Stream.concat(Stream.of((Colony)null), colonies)</span>
<span class="fc" id="L2774">            .collect(Collectors.minBy(Comparator.comparingInt(closeness)))</span>
<span class="fc" id="L2775">            .orElse(null);</span>
    }
    
    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @param excludeStart If true, ignore any settlement the unit is
     *     currently in.
     * @param range An upper bound on the number of moves.
     * @param coastal If true, the settlement must have a path to Europe.
     * @return The nearest matching settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement(final boolean excludeStart,
                                             int range, final boolean coastal) {
<span class="fc" id="L2790">        final Player player = getOwner();</span>
<span class="pc bpc" id="L2791" title="1 of 4 branches missed.">        if (player.getNumberOfSettlements() &lt;= 0 || !hasTile()) return null;</span>
<span class="fc" id="L2792">        return findOurNearestSettlement(getTile(), excludeStart,</span>
                                        range, coastal);
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @param startTile The &lt;code&gt;Tile&lt;/code&gt; to start searching from.
     * @param excludeStart If true, ignore any settlement the unit is
     *     currently in.
     * @param range An upper bound on the number of moves.
     * @param coastal If true, the settlement must have a path to Europe.
     * @return The nearest matching settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement(final Tile startTile,
                                             final boolean excludeStart,
                                             int range, final boolean coastal) {
<span class="fc" id="L2810">        final Player player = getOwner();</span>
<span class="pc bpc" id="L2811" title="1 of 2 branches missed.">        if (startTile == null</span>
<span class="pc bpc" id="L2812" title="1 of 2 branches missed.">            || player.getNumberOfSettlements() &lt;= 0) return null;</span>
<span class="fc" id="L2813">        final GoalDecider gd = new GoalDecider() {</span>

<span class="fc" id="L2815">                private int bestValue = Integer.MAX_VALUE;</span>
<span class="fc" id="L2816">                private PathNode best = null;</span>

                @Override
<span class="fc" id="L2819">                public PathNode getGoal() { return best; }</span>
                @Override
<span class="fc" id="L2821">                public boolean hasSubGoals() { return true; }</span>
                @Override
                public boolean check(Unit u, PathNode path) {
<span class="fc" id="L2824">                    Tile t = path.getTile();</span>
<span class="pc bpc" id="L2825" title="2 of 6 branches missed.">                    if (t == null</span>
<span class="nc" id="L2826">                        || (t == startTile &amp;&amp; excludeStart)) return false;</span>
<span class="fc" id="L2827">                    Settlement settlement = t.getSettlement();</span>
                    int value;
<span class="fc bfc" id="L2829" title="All 2 branches covered.">                    if (settlement != null</span>
<span class="pc bpc" id="L2830" title="1 of 4 branches missed.">                        &amp;&amp; player.owns(settlement)</span>
<span class="pc bpc" id="L2831" title="1 of 2 branches missed.">                        &amp;&amp; (!coastal || settlement.isConnectedPort())</span>
<span class="fc bfc" id="L2832" title="All 2 branches covered.">                        &amp;&amp; (value = path.getTotalTurns()) &lt; bestValue) {</span>
<span class="fc" id="L2833">                        bestValue = value;</span>
<span class="fc" id="L2834">                        best = path;</span>
<span class="fc" id="L2835">                        return true;</span>
                    }
<span class="fc" id="L2837">                    return false;</span>
                }
            };
<span class="fc" id="L2840">        return search(startTile, gd, CostDeciders.avoidIllegal(), range, null);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @return A path to the nearest settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement() {
<span class="fc" id="L2850">        return findOurNearestSettlement(false, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier and is connected to
     * Europe by sea, or Europe if it is closer.
     *
     * @return A path to the nearest settlement if any, otherwise null
     *     (for now including if in Europe or at sea).
     */
    public PathNode findOurNearestPort() {
<span class="fc" id="L2862">        PathNode ePath = null;</span>
<span class="fc" id="L2863">        int eTurns = -1;</span>
<span class="fc" id="L2864">        Europe europe = getOwner().getEurope();</span>
<span class="pc bpc" id="L2865" title="1 of 2 branches missed.">        if (getType().canMoveToHighSeas()) {</span>
<span class="pc bpc" id="L2866" title="1 of 2 branches missed.">            ePath = (europe == null) ? null : findPath(europe);</span>
<span class="fc bfc" id="L2867" title="All 2 branches covered.">            eTurns = (ePath == null) ? -1 : ePath.getTotalTurns();</span>
        }
<span class="fc" id="L2869">        PathNode sPath = findOurNearestSettlement(false, INFINITY, true);</span>
<span class="fc bfc" id="L2870" title="All 2 branches covered.">        int sTurns = (sPath == null) ? -1 : sPath.getTotalTurns();</span>
<span class="pc bpc" id="L2871" title="1 of 6 branches missed.">        return (ePath == null) ? sPath</span>
            : (sPath == null) ? ePath
            : (sTurns &lt;= eTurns) ? sPath : ePath;
    }

    /**
     * Find a path to a settlement nearer to a destination.
     *
     * Used to find where to deliver goods to/from inland colonies,
     * or when blocked.
     *
     * @param dst The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return A path to the port, or null if none found.
     */
    public PathNode findIntermediatePort(Location dst) {
<span class="nc" id="L2886">        final Settlement ignoreSrc = getSettlement();</span>
<span class="nc" id="L2887">        final Settlement ignoreDst = dst.getSettlement();</span>
<span class="nc" id="L2888">        final Tile srcTile = getTile();</span>
<span class="nc" id="L2889">        final Tile dstTile = dst.getTile();</span>
<span class="nc bnc" id="L2890" title="All 2 branches missed.">        final int dstCont = (dstTile == null) ? -1 : dstTile.getContiguity();</span>
<span class="nc" id="L2891">        PathNode path, best = null;</span>
<span class="nc" id="L2892">        int value, bestValue = INFINITY;</span>
        int type;

<span class="nc bnc" id="L2895" title="All 2 branches missed.">        if (isNaval()) {</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">            if (!srcTile.isHighSeasConnected()) {</span>
                // On a lake!  FIXME: do better
<span class="nc" id="L2898">                type = 0;</span>
<span class="nc bnc" id="L2899" title="All 2 branches missed.">            } else if (dstTile == null) {</span>
                // Carrier must be blocked from high seas
<span class="nc" id="L2901">                type = 1;</span>
<span class="nc bnc" id="L2902" title="All 2 branches missed.">            } else if (dstTile.isHighSeasConnected()) {</span>
                // Carrier is blocked or destination is blocked.
<span class="nc bnc" id="L2904" title="All 2 branches missed.">                type = (getTile().isOnRiver()) ? 1 : 2;</span>
            } else {
                // Destination must be blocked
<span class="nc" id="L2907">                type = 2;</span>
            }
        } else {
<span class="nc bnc" id="L2910" title="All 4 branches missed.">            if (dstTile == null || getTile().getContiguity() != dstCont) {</span>
                // Ocean travel will be required
                // If already at port try to improve its connectivity,
                // otherwise go to a port.
<span class="nc bnc" id="L2914" title="All 2 branches missed.">                type = (srcTile.isHighSeasConnected()) ? 1 : 2;</span>
            } else {
                // Pure land travel, just find a nearer settlement.
<span class="nc" id="L2917">                type = 3;</span>
            }
        }

<span class="nc bnc" id="L2921" title="All 5 branches missed.">        switch (type) {</span>
        case 0:
            // No progress possible.
<span class="nc" id="L2924">            break;</span>
        case 1:
            // Starting on a river, probably blocked in there.
            // Find the settlement that most reduces the high seas count.
<span class="nc" id="L2928">            best = search(getLocation(),</span>
<span class="nc" id="L2929">                          GoalDeciders.getReduceHighSeasCountGoalDecider(this),</span>
                          null, INFINITY, null);
<span class="nc" id="L2931">            break;</span>
        case 2:
            // Ocean travel required, destination blocked.
            // Find the closest available connected port.
<span class="nc bnc" id="L2935" title="All 2 branches missed.">            for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L2936" title="All 6 branches missed.">                if (s != ignoreSrc &amp;&amp; s != ignoreDst &amp;&amp; s.isConnectedPort()</span>
<span class="nc bnc" id="L2937" title="All 2 branches missed.">                    &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L2938">                    value = path.getTotalTurns()</span>
<span class="nc" id="L2939">                        + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L2940" title="All 2 branches missed.">                    if (bestValue &gt; value) {</span>
<span class="nc" id="L2941">                        bestValue = value;</span>
<span class="nc" id="L2942">                        best = path;</span>
                    }
                }
<span class="nc" id="L2945">            }</span>
<span class="nc" id="L2946">            break;</span>
        case 3:
            // Land travel.  Find nearby settlement with correct contiguity.
<span class="nc bnc" id="L2949" title="All 2 branches missed.">            for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L2950" title="All 4 branches missed.">                if (s != ignoreSrc &amp;&amp; s != ignoreDst</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">                    &amp;&amp; s.getTile().getContiguity() == dstCont</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">                    &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L2953">                    value = path.getTotalTurns()</span>
<span class="nc" id="L2954">                        + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L2955" title="All 2 branches missed.">                    if (bestValue &gt; value) {</span>
<span class="nc" id="L2956">                        bestValue = value;</span>
<span class="nc" id="L2957">                        best = path;</span>
                    }
                }
<span class="nc" id="L2960">            }</span>
        }
<span class="nc bnc" id="L2962" title="All 2 branches missed.">        return (best != null) ? best</span>
<span class="nc" id="L2963">            : findOurNearestSettlement(false, INFINITY, false);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier, excepting any
     * on the current tile.
     *
     * @return The nearest settlement if any, otherwise null.
     */
    public PathNode findOurNearestOtherSettlement() {
<span class="nc" id="L2974">        return findOurNearestSettlement(true, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Convenience wrapper for the
     * {@link net.sf.freecol.common.model.Map#search} function.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param gd The object responsible for determining whether a
     *     given &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
     * @param cd An optional &lt;code&gt;CostDecider&lt;/code&gt;
     *     responsible for determining the path cost.
     * @param maxTurns The maximum number of turns the given
     *     &lt;code&gt;Unit&lt;/code&gt; is allowed to move. This is the
     *     maximum search range for a goal.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @return The path to a goal, or null if none can be found.
     */
    public PathNode search(Location start, GoalDecider gd,
                           CostDecider cd, int maxTurns, Unit carrier) {
<span class="pc bpc" id="L2994" title="1 of 2 branches missed.">        return (start == null) ? null</span>
<span class="fc" id="L2995">            : getGame().getMap().search(this, start, gd, cd, maxTurns,</span>
                                        carrier, null);
    }

    /**
     * Can this unit attack a specified defender?
     *
     * A naval unit can never attack a land unit or settlement,
     * but a land unit *can* attack a naval unit if it is beached.
     * Otherwise naval units can only fight at sea, land units
     * only on land.
     *
     * @param defender The defending &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if this unit can attack.
     */
    public boolean canAttack(Unit defender) {
<span class="pc bpc" id="L3011" title="2 of 4 branches missed.">        if (!isOffensiveUnit() || defender == null</span>
<span class="pc bpc" id="L3012" title="1 of 2 branches missed.">            || !defender.hasTile()) return false;</span>

<span class="fc" id="L3014">        Tile tile = defender.getTile();</span>
<span class="pc bpc" id="L3015" title="1 of 2 branches missed.">        return (isNaval())</span>
<span class="pc bnc" id="L3016" title="All 4 branches missed.">            ? !tile.hasSettlement() &amp;&amp; defender.isNaval()</span>
<span class="pc bpc" id="L3017" title="3 of 4 branches missed.">            : !defender.isNaval() || defender.isBeached();</span>
    }

    /**
     * Searches for a unit that is a credible threatening unit to this
     * unit within a range.
     *
     * @param range The number of turns to search for a threat in.
     * @param threat The maximum tolerable probability of a potentially
     *            threatening unit defeating this unit in combat.
     * @return A path to the threat, or null if not found.
     */
    public PathNode searchForDanger(final int range, final float threat) {
<span class="nc" id="L3030">        final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L3031">        final Tile start = getTile();</span>
<span class="nc" id="L3032">        final GoalDecider threatDecider = new GoalDecider() {</span>
<span class="nc" id="L3033">                private PathNode found = null;</span>

                @Override
<span class="nc" id="L3036">                public PathNode getGoal() { return found; }</span>
                @Override
<span class="nc" id="L3038">                public boolean hasSubGoals() { return false; }</span>
                @Override
                public boolean check(Unit unit, PathNode path) {
<span class="nc" id="L3041">                    Tile tile = path.getTile();</span>
<span class="nc bnc" id="L3042" title="All 2 branches missed.">                    if (tile == null) return false;</span>
<span class="nc" id="L3043">                    Unit first = tile.getFirstUnit();</span>
<span class="nc bnc" id="L3044" title="All 2 branches missed.">                    if (first == null</span>
<span class="nc bnc" id="L3045" title="All 2 branches missed.">                        || !getOwner().atWarWith(first.getOwner())) {</span>
<span class="nc" id="L3046">                        return false;</span>
                    }
<span class="nc bnc" id="L3048" title="All 2 branches missed.">                    for (Unit u : tile.getUnitList()) {</span>
                        PathNode reverse;
<span class="nc bnc" id="L3050" title="All 2 branches missed.">                        if (u.canAttack(unit)</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">                            &amp;&amp; cm.calculateCombatOdds(u, unit).win &gt;= threat</span>
<span class="nc bnc" id="L3052" title="All 2 branches missed.">                            &amp;&amp; (reverse = u.findPath(start)) != null</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">                            &amp;&amp; reverse.getTotalTurns() &lt; range) {</span>
<span class="nc" id="L3054">                            found = path;</span>
<span class="nc" id="L3055">                            return true;</span>
                        }
<span class="nc" id="L3057">                    }</span>
<span class="nc" id="L3058">                    return false;</span>
                }
            };
        // The range to search will depend on the speed of the other
        // unit.  We can not know what it will be in advance, and it
        // might be significantly faster than this unit.  We do not
        // want to just use an unbounded search range because this
        // routine must be quick (especially when the supplied range
        // is low).  So use the heuristic of increasing the range by
        // the ratio of the fastest appropriate (land/naval) unit type
        // speed over the unit speed.
<span class="nc bnc" id="L3069" title="All 2 branches missed.">        int reverseRange = range * (((isNaval())</span>
<span class="nc" id="L3070">                ? getSpecification().getFastestNavalUnitType()</span>
<span class="nc" id="L3071">                : getSpecification().getFastestLandUnitType())</span>
<span class="nc" id="L3072">            .getMovement()) / this.getType().getMovement();</span>

<span class="nc bnc" id="L3074" title="All 2 branches missed.">        return (start == null) ? null</span>
<span class="nc" id="L3075">            : search(start, threatDecider, CostDeciders.avoidIllegal(),</span>
<span class="nc" id="L3076">                     reverseRange, getCarrier());</span>
    }

    /**
     * Checks if there is a credible threatening unit to this unit
     * within a range of moves.
     *
     * @param range The number of turns to search for a threat within.
     * @param threat The maximum tolerable probability of a potentially
     *            threatening unit defeating this unit in combat.
     * @return True if a threat was found.
     */
    public boolean isInDanger(int range, float threat) {
<span class="nc bnc" id="L3089" title="All 2 branches missed.">        return searchForDanger(range, threat) != null;</span>
    }

    /**
     * Gets the line of sight of this &lt;code&gt;Unit&lt;/code&gt;.  That is the
     * distance this &lt;code&gt;Unit&lt;/code&gt; can sight new tiles.
     *
     * @return The line of sight of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public int getLineOfSight() {
<span class="fc" id="L3099">        final Turn turn = getGame().getTurn();</span>
<span class="fc" id="L3100">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L3101">        result.addAll(this.getModifiers(Modifier.LINE_OF_SIGHT_BONUS,</span>
                                        unitType, turn));
<span class="pc bpc" id="L3103" title="1 of 4 branches missed.">        if (hasTile() &amp;&amp; getTile().isExplored()) {</span>
<span class="fc" id="L3104">            result.addAll(getTile().getType()</span>
<span class="fc" id="L3105">                .getModifiers(Modifier.LINE_OF_SIGHT_BONUS, unitType, turn));</span>
        }
<span class="fc" id="L3107">        float base = unitType.getLineOfSight();</span>
<span class="fc" id="L3108">        return (int)applyModifiers(base, turn, result);</span>
    }


    // Goods handling

    /**
     * Get the goods carried by this unit.
     *
     * @return A list of &lt;code&gt;Goods&lt;/code&gt;.
     */
    public List&lt;Goods&gt; getGoodsList() {
<span class="pc bpc" id="L3120" title="1 of 2 branches missed.">        return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList()</span>
<span class="fc" id="L3121">            : getGoodsContainer().getGoods();</span>
    }

    /**
     * Get a compact version of the goods carried by this unit.
     *
     * @return A compact list of &lt;code&gt;Goods&lt;/code&gt;.
     */
    public List&lt;Goods&gt; getCompactGoodsList() {
<span class="pc bpc" id="L3130" title="1 of 2 branches missed.">        return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList()</span>
<span class="fc" id="L3131">            : getGoodsContainer().getCompactGoods();</span>
    }

    /**
     * Can this unit carry other units?
     *
     * @return True if the unit can carry units.
     */
    public boolean canCarryUnits() {
<span class="fc" id="L3140">        return hasAbility(Ability.CARRY_UNITS);</span>
    }

    /**
     * Could this unit carry a specified one?
     * This ignores the current load.
     *
     * @param u The potential cargo &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if this unit can carry the cargo.
     */
    public boolean couldCarry(Unit u) {
<span class="fc bfc" id="L3151" title="All 2 branches covered.">        return canCarryUnits()</span>
<span class="pc bpc" id="L3152" title="1 of 2 branches missed.">            &amp;&amp; getCargoCapacity() &gt;= u.getSpaceTaken();</span>
    }

    /**
     * Can this unit carry goods.
     *
     * @return True if the unit can carry goods.
     */
    public boolean canCarryGoods() {
<span class="fc" id="L3161">        return hasAbility(Ability.CARRY_GOODS);</span>
    }

    /**
     * Could this unit carry some specified goods?
     * This ignores the current load.
     *
     * @param g The potential cargo &lt;code&gt;Goods&lt;/code&gt;.
     * @return True if this unit can carry the cargo.
     */
    public boolean couldCarry(Goods g) {
<span class="pc bpc" id="L3172" title="1 of 2 branches missed.">        return canCarryGoods()</span>
<span class="pc bpc" id="L3173" title="1 of 2 branches missed.">            &amp;&amp; getCargoCapacity() &gt;= g.getSpaceTaken();</span>
    }

    /**
     * Gets the number of free cargo slots left on this unit.
     *
     * @return The number of free cargo slots on this unit.
     */
    public int getSpaceLeft() {
<span class="fc" id="L3182">        return getCargoCapacity() - getCargoSpaceTaken();</span>
    }

    /**
     * Is there free space left on this unit?
     *
     * @return True if there is free space.
     */
    public boolean hasSpaceLeft() {
<span class="fc bfc" id="L3191" title="All 2 branches covered.">        return getSpaceLeft() &gt; 0;</span>
    }

    /**
     * Gets the total space this unit has to carry cargo.
     *
     * @return The total space.
     */
    public int getCargoCapacity() {
<span class="fc" id="L3200">        return unitType.getSpace();</span>
    }

    /**
     * Gets the space occupied by goods in this unit.  Must defend
     * against goods container being null as this can be called in the
     * client on foreign units, which will not have goods containers.
     *
     * @return The number cargo slots occupied by goods.
     */
    public int getGoodsSpaceTaken() {
<span class="pc bpc" id="L3211" title="1 of 2 branches missed.">        if (!canCarryGoods()) return 0;</span>
<span class="fc" id="L3212">        GoodsContainer gc = getGoodsContainer();</span>
<span class="pc bpc" id="L3213" title="1 of 2 branches missed.">        return (gc == null) ? 0 : gc.getSpaceTaken();</span>
    }

    /**
     * Gets the space occupied by units in this unit.
     *
     * @return The number of cargo slots occupied by units.
     */
    public int getUnitSpaceTaken() {
<span class="fc bfc" id="L3222" title="All 2 branches covered.">        return (canCarryUnits())</span>
<span class="fc" id="L3223">            ? getUnitList().stream().mapToInt(u -&gt; u.getSpaceTaken()).sum()</span>
            : 0;
    }

    /**
     * Gets the space occupied by cargo in this unit (both goods and units).
     *
     * @return The number of occupied cargo slots.
     */
    public int getCargoSpaceTaken() {
<span class="fc" id="L3233">        return getGoodsSpaceTaken() + getUnitSpaceTaken();</span>
    }

    /**
     * Is this unit carrying any goods cargo?
     *
     * @return True if the unit is carrying any goods cargo.
     */
    public boolean hasGoodsCargo() {
<span class="fc bfc" id="L3242" title="All 2 branches covered.">        return getGoodsSpaceTaken() &gt; 0;</span>
    }

    /**
     * Is this unit carrying any cargo (goods or unit).
     *
     * @return True if the unit is carrying any cargo.
     */
    public boolean hasCargo() {
<span class="nc bnc" id="L3251" title="All 2 branches missed.">        return getCargoSpaceTaken() &gt; 0;</span>
    }

    /**
     * Gets the extra amount of a specified type of goods that could
     * be loaded onto this unit.  Includes empty cargo slots and any
     * spare space in a slot partially filled with the specified
     * goods.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to examine.
     * @return The amount of goods that could be loaded onto this unit.
     */
    public int getLoadableAmount(GoodsType type) {
<span class="pc bpc" id="L3264" title="1 of 2 branches missed.">        if (!canCarryGoods()) return 0;</span>
<span class="fc" id="L3265">        int result = getSpaceLeft() * GoodsContainer.CARGO_SIZE;</span>
<span class="fc" id="L3266">        int count = getGoodsCount(type) % GoodsContainer.CARGO_SIZE;</span>
<span class="fc bfc" id="L3267" title="All 2 branches covered.">        if (count != 0) result += GoodsContainer.CARGO_SIZE - count;</span>
<span class="fc" id="L3268">        return result;</span>
    }


    // Miscellaneous more complex functionality

    /**
     * Get a label for the current unit occupation.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; viewing the unit, as the
     *     owner has access to more information.
     * @param full If true, return a more detailed result.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the unit occupation.
     */
    public StringTemplate getOccupationLabel(Player player, boolean full) {
<span class="nc" id="L3283">        final TradeRoute tradeRoute = getTradeRoute();</span>
        StringTemplate ret;
<span class="nc bnc" id="L3285" title="All 4 branches missed.">        if (player != null &amp;&amp; player.owns(this)) {</span>
<span class="nc bnc" id="L3286" title="All 2 branches missed.">            if (isDamaged()) {</span>
<span class="nc bnc" id="L3287" title="All 2 branches missed.">                if (full) {</span>
<span class="nc" id="L3288">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3289">                        .add(&quot;model.unit.occupation.underRepair&quot;)</span>
<span class="nc" id="L3290">                        .addName(String.valueOf(getTurnsForRepair()));</span>
                } else {
<span class="nc" id="L3292">                    ret = StringTemplate.key(&quot;model.unit.occupation.underRepair&quot;);</span>
                }
<span class="nc bnc" id="L3294" title="All 2 branches missed.">            } else if (tradeRoute != null) {</span>
<span class="nc bnc" id="L3295" title="All 2 branches missed.">                if (full) {</span>
<span class="nc" id="L3296">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3297">                        .add(&quot;model.unit.occupation.inTradeRoute&quot;)</span>
<span class="nc" id="L3298">                        .addName(tradeRoute.getName());</span>
                } else {
<span class="nc" id="L3300">                    ret = StringTemplate.key(&quot;model.unit.occupation.inTradeRoute&quot;);</span>
                }
<span class="nc bnc" id="L3302" title="All 4 branches missed.">            } else if (getState() == UnitState.ACTIVE &amp;&amp; getMovesLeft() == 0) {</span>
<span class="nc" id="L3303">                ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
<span class="nc bnc" id="L3304" title="All 2 branches missed.">            } else if (getState() == UnitState.IMPROVING</span>
<span class="nc bnc" id="L3305" title="All 2 branches missed.">                &amp;&amp; getWorkImprovement() != null) {</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">                if (full) {</span>
<span class="nc" id="L3307">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3308">                        .add(getWorkImprovement().getType() + &quot;.occupationString&quot;)</span>
<span class="nc" id="L3309">                        .addName(String.valueOf(getWorkTurnsLeft()));</span>
                } else {
<span class="nc" id="L3311">                    ret = StringTemplate.key(getWorkImprovement().getType() + &quot;.occupationString&quot;);</span>
                }
<span class="nc bnc" id="L3313" title="All 2 branches missed.">            } else if (getDestination() != null) {</span>
<span class="nc" id="L3314">                ret = StringTemplate.key(&quot;model.unit.occupation.goingSomewhere&quot;);</span>
            } else {
<span class="nc" id="L3316">                ret = StringTemplate.key(&quot;model.unit.&quot; + getState().getKey());</span>
            }
        } else {
<span class="nc bnc" id="L3319" title="All 2 branches missed.">            if (isNaval()) {</span>
<span class="nc" id="L3320">                ret = StringTemplate.name(String.valueOf(getVisibleGoodsCount()));</span>
            } else {
<span class="nc" id="L3322">                ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
            }
        }
<span class="nc" id="L3325">        return ret;</span>
    }

    /**
     * Gets the probability that an attack by this unit will provoke a
     * native to convert.
     *
     * @return A probability of conversion.
     */
    public float getConvertProbability() {
<span class="fc" id="L3335">        final Specification spec = getSpecification();</span>
<span class="fc" id="L3336">        int opt = spec.getInteger(GameOptions.NATIVE_CONVERT_PROBABILITY);</span>
<span class="fc" id="L3337">        return 0.01f * applyModifiers(opt, getGame().getTurn(),</span>
                                      Modifier.NATIVE_CONVERT_BONUS);
    }

    /**
     * Gets the probability that an attack by this unit will provoke natives
     * to burn our missions.
     *
     * FIXME: enhance burn probability proportionally with tension
     *
     * @return A probability of burning missions.
     */
    public float getBurnProbability() {
<span class="nc" id="L3350">        final Specification spec = getSpecification();</span>
<span class="nc" id="L3351">        return 0.01f * spec.getInteger(GameOptions.BURN_PROBABILITY);</span>
    }

    /**
     * Get a type change for this unit.
     *
     * @param change The &lt;code&gt;ChangeType&lt;/code&gt; to consider.
     * @param owner The &lt;code&gt;Player&lt;/code&gt; to own this unit after a
     *    change of type CAPTURE or UNDEAD.
     * @return The resulting unit type or null if there is no change suitable.
     */
    public UnitType getTypeChange(ChangeType change, Player owner) {
<span class="fc" id="L3363">        return getType().getTargetType(change, owner);</span>
    }

    /**
     * Checks if the treasure train can be cashed in at it's current
     * &lt;code&gt;Location&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
     * @exception IllegalStateException if this unit is not a treasure train.
     */
    public boolean canCashInTreasureTrain() {
<span class="fc" id="L3374">        return canCashInTreasureTrain(getLocation());</span>
    }

    /**
     * Checks if the treasure train can be cashed in at the given
     * &lt;code&gt;Location&lt;/code&gt;.
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
     * @exception IllegalStateException if this unit is not a treasure train.
     */
    public boolean canCashInTreasureTrain(Location loc) {
<span class="pc bpc" id="L3386" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L3387">            throw new IllegalStateException(&quot;Can't carry treasure&quot;);</span>
        }
<span class="fc bfc" id="L3389" title="All 2 branches covered.">        if (loc == null) return false;</span>

<span class="pc bpc" id="L3391" title="1 of 2 branches missed.">        if (getOwner().getEurope() == null) {</span>
            // Any colony will do once independent, as the treasure stays
            // in the New World.
<span class="nc bnc" id="L3394" title="All 2 branches missed.">            return loc.getColony() != null;</span>
        }
<span class="fc bfc" id="L3396" title="All 2 branches covered.">        if (loc.getColony() != null) {</span>
            // Cash in if at a colony which has connectivity to Europe
            // unless the player has a suitable carrier and no free transport.
<span class="fc bfc" id="L3399" title="All 2 branches covered.">            return loc.getColony().isConnectedPort()</span>
<span class="fc bfc" id="L3400" title="All 2 branches covered.">                &amp;&amp; (getOwner().getCarriersForUnit(this).isEmpty()</span>
<span class="pc bpc" id="L3401" title="1 of 2 branches missed.">                    || getTransportFee() == 0);</span>
        }
        // Otherwise, cash in if in Europe.
<span class="pc bpc" id="L3404" title="2 of 4 branches missed.">        return loc instanceof Europe</span>
<span class="fc bfc" id="L3405" title="All 2 branches covered.">            || (loc instanceof Unit &amp;&amp; ((Unit)loc).isInEurope());</span>
    }

    /**
     * Get the fee that would have to be paid to transport this
     * treasure to Europe.
     *
     * @return The fee required for transport.
     */
    public int getTransportFee() {
<span class="pc bpc" id="L3415" title="1 of 4 branches missed.">        if (!isInEurope() &amp;&amp; getOwner().getEurope() != null) {</span>
<span class="fc" id="L3416">            float fee = (getSpecification()</span>
<span class="fc" id="L3417">                .getInteger(GameOptions.TREASURE_TRANSPORT_FEE)</span>
<span class="fc" id="L3418">                * getTreasureAmount()) / 100.0f;</span>
<span class="fc" id="L3419">            return (int)getOwner().applyModifiers(fee, getGame().getTurn(),</span>
                Modifier.TREASURE_TRANSPORT_FEE, unitType);
        }
<span class="fc" id="L3422">        return 0;</span>
    }

    /**
     * Gets the skill level.
     *
     * @return The level of skill for this unit.  A higher value
     *     signals a more advanced type of units.
     */
    public int getSkillLevel() {
<span class="fc" id="L3432">        return getSkillLevel(unitType);</span>
    }

    /**
     * Gets the skill level of the given type of &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @param unitType The type of &lt;code&gt;Unit&lt;/code&gt;.
     * @return The level of skill for the given unit.  A higher value
     *     signals a more advanced type of units.
     */
    public static int getSkillLevel(UnitType unitType) {
<span class="pc bpc" id="L3443" title="1 of 2 branches missed.">        return (unitType.hasSkill()) ? unitType.getSkill() : 0;</span>
    }

    /**
     * Gets the appropriate trade bonuses due to a missionary unit.
     *
     * @param sense The sense to apply the modifiers.
     * @return The missionary trade bonuses.
     */
    public Set&lt;Modifier&gt; getMissionaryTradeModifiers(boolean sense) {
<span class="nc" id="L3453">        HashSet&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">        for (Modifier m : getModifiers(Modifier.MISSIONARY_TRADE_BONUS)) {</span>
<span class="nc" id="L3455">            Modifier modifier = new Modifier(m);</span>
<span class="nc bnc" id="L3456" title="All 2 branches missed.">            if (!sense) modifier.setValue(-m.getValue());</span>
<span class="nc" id="L3457">            result.add(modifier);</span>
<span class="nc" id="L3458">        }</span>
<span class="nc" id="L3459">        return result;</span>
    }

    /**
     * Adds a feature to the Unit.  This method always throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, since features can
     * not be added to Units directly.
     *
     * @param feature The &lt;code&gt;Feature&lt;/code&gt; to add.
     */
    public void addFeature(Feature feature) {
<span class="nc" id="L3470">        throw new UnsupportedOperationException(&quot;Can not add Feature to Unit directly!&quot;);</span>
    }

    /**
     * Gets the &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
     *
     * FIXME: the input parameter is ignored! Fix?
     *
     * @param input A list of input &lt;code&gt;AbstractGoods&lt;/code&gt;.
     * @return The &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
     */
    public ProductionInfo getProductionInfo(List&lt;AbstractGoods&gt; input) {
<span class="fc" id="L3482">        ProductionInfo result = new ProductionInfo();</span>
<span class="fc" id="L3483">        result.setConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3484">        result.setMaximumConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3485">        return result;</span>
    }

    /**
     * Score this unit with its suitability for pioneering.
     *
     * A pioneer must be a colonst.  Favour:
     * - existing pioneers especially if on the map
     * - expert pioneer units
     * - then by skill but not other experts
     *
     * @return A pioneering score.
     */
    public int getPioneerScore() {
<span class="nc bnc" id="L3499" title="All 2 branches missed.">        int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3500" title="All 4 branches missed.">        return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3501" title="All 2 branches missed.">            : (hasAbility(Ability.IMPROVE_TERRAIN)) ? 900 + ht</span>
<span class="nc bnc" id="L3502" title="All 2 branches missed.">            : (hasAbility(Ability.EXPERT_PIONEER)) ? 700</span>
<span class="nc bnc" id="L3503" title="All 2 branches missed.">            : (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3504" title="All 2 branches missed.">            : (getSkillLevel() &gt; 0) ? 0</span>
<span class="nc" id="L3505">            : 200 + getSkillLevel() * 50;</span>
    }

    /**
     * Score this unit with its suitability for scouting.
     *
     * A scout must be a colonist.  Favour:
     * - existing scouts especially if on the map
     * - expert scouts
     * - lower skill level as scouting is a good career for crims and servants
     *   which might become seasoned scouts
     *
     * @return A scouting score.
     */
    public int getScoutScore() {
<span class="nc bnc" id="L3520" title="All 2 branches missed.">        int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3521" title="All 4 branches missed.">        return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3522" title="All 2 branches missed.">            : (hasAbility(Ability.SPEAK_WITH_CHIEF)) ? 900 + ht</span>
<span class="nc bnc" id="L3523" title="All 2 branches missed.">            : (hasAbility(Ability.EXPERT_SCOUT)) ? 700</span>
<span class="nc bnc" id="L3524" title="All 2 branches missed.">            : (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3525" title="All 2 branches missed.">            : (getSkillLevel() &lt;= 0) ? -200 * getSkillLevel()</span>
            : 0;
    }

    /**
     * Evaluate this unit for trade purposes.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
     * @return A value of this unit.
     */
    public int evaluateFor(Player player) {
<span class="nc" id="L3536">        final Europe europe = player.getEurope();</span>
<span class="nc bnc" id="L3537" title="All 4 branches missed.">        if (player.isAI() &amp;&amp; player.getUnits().size() &lt; 10) {</span>
<span class="nc" id="L3538">            return Integer.MIN_VALUE;</span>
        }
<span class="nc bnc" id="L3540" title="All 2 branches missed.">        return (europe == null) ? 500 : europe.getUnitPrice(getType());</span>
    }

    // @compat 0.11.0
    /**
     * Get modifiers required for combat.
     *
     * This can be replaced with just getModifiers() when accepted
     * specifications have all combat modifiers with correct index
     * values.
     */
    public Set&lt;Modifier&gt; getCombatModifiers(String id,
        FreeColGameObjectType fcgot, Turn turn) {
<span class="fc" id="L3553">        final Player owner = getOwner();</span>
<span class="fc" id="L3554">        final UnitType unitType = getType();</span>
<span class="fc" id="L3555">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType modifiers always apply
<span class="fc bfc" id="L3558" title="All 2 branches covered.">        for (Modifier m : unitType.getModifiers(id, fcgot, turn)) {</span>
<span class="pc bfc" id="L3559" title="All 2 branches covered.">            switch (m.getType()) {</span>
            case ADDITIVE:
<span class="fc" id="L3561">                m.setModifierIndex(Modifier.UNIT_ADDITIVE_COMBAT_INDEX);</span>
<span class="fc" id="L3562">                break;</span>
            default:
<span class="fc" id="L3564">                m.setModifierIndex(Modifier.UNIT_NORMAL_COMBAT_INDEX);</span>
                break;
            }
<span class="fc" id="L3567">            result.add(m);</span>
<span class="fc" id="L3568">        }</span>

        // The player's modifiers may not all apply
<span class="fc bfc" id="L3571" title="All 2 branches covered.">        for (Modifier m : owner.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3572">            m.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
<span class="fc" id="L3573">            result.add(m);</span>
<span class="fc" id="L3574">        }</span>
        
        // Role modifiers apply
<span class="fc bfc" id="L3577" title="All 2 branches covered.">        for (Modifier m : role.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3578">            m.setModifierIndex(Modifier.ROLE_COMBAT_INDEX);</span>
<span class="fc" id="L3579">            result.add(m);</span>
<span class="fc" id="L3580">        }</span>

<span class="fc" id="L3582">        return result;</span>
    }
    // end @compat 0.11.0


    // Message unpacking support.

    /**
     * Gets the tile in a given direction.
     *
     * @param directionString The direction.
     * @return The &lt;code&gt;Tile&lt;/code&gt; in the given direction.
     * @throws IllegalStateException if there is trouble.
     */
    public Tile getNeighbourTile(String directionString) {
<span class="nc bnc" id="L3597" title="All 2 branches missed.">        if (!hasTile()) {</span>
<span class="nc" id="L3598">            throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3599">                + getId());</span>
        }

<span class="nc" id="L3602">        Direction direction = Enum.valueOf(Direction.class, directionString);</span>
<span class="nc" id="L3603">        Tile tile = getTile().getNeighbourOrNull(direction);</span>
<span class="nc bnc" id="L3604" title="All 2 branches missed.">        if (tile == null) {</span>
<span class="nc" id="L3605">            throw new IllegalStateException(&quot;Could not find tile&quot;</span>
<span class="nc" id="L3606">                + &quot; in direction: &quot; + direction + &quot; from unit: &quot; + getId());</span>
        }
<span class="nc" id="L3608">        return tile;</span>
    }

    /**
     * Get a settlement by identifier, validating as much as possible.
     * Designed for message unpacking where the identifier should not
     * be trusted.
     *
     * @param settlementId The identifier of the
     *     &lt;code&gt;Settlement&lt;/code&gt; to be found.
     * @return The settlement corresponding to the settlementId argument.
     * @throws IllegalStateException on failure to validate the settlementId
     *     in any way.
     */
    public Settlement getAdjacentSettlementSafely(String settlementId)
        throws IllegalStateException {
<span class="nc" id="L3624">        Game game = getOwner().getGame();</span>

<span class="nc" id="L3626">        Settlement settlement = game.getFreeColGameObject(settlementId,</span>
                                                          Settlement.class);
<span class="nc bnc" id="L3628" title="All 2 branches missed.">        if (settlement == null) {</span>
<span class="nc" id="L3629">            throw new IllegalStateException(&quot;Not a settlement: &quot;</span>
                + settlementId);
<span class="nc bnc" id="L3631" title="All 2 branches missed.">        } else if (settlement.getTile() == null) {</span>
<span class="nc" id="L3632">            throw new IllegalStateException(&quot;Settlement is not on the map: &quot;</span>
                + settlementId);
        }

<span class="nc bnc" id="L3636" title="All 2 branches missed.">        if (!hasTile()) {</span>
<span class="nc" id="L3637">            throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3638">                + getId());</span>
<span class="nc bnc" id="L3639" title="All 2 branches missed.">        } else if (getTile().getDistanceTo(settlement.getTile()) &gt; 1) {</span>
<span class="nc" id="L3640">            throw new IllegalStateException(&quot;Unit &quot; + getId()</span>
                + &quot; is not adjacent to settlement: &quot; + settlementId);
<span class="nc bnc" id="L3642" title="All 2 branches missed.">        } else if (getOwner() == settlement.getOwner()) {</span>
<span class="nc" id="L3643">            throw new IllegalStateException(&quot;Unit: &quot; + getId()</span>
                + &quot; and settlement: &quot; + settlementId
<span class="nc" id="L3645">                + &quot; are both owned by player: &quot; + getOwner().getId());</span>
        }

<span class="nc" id="L3648">        return settlement;</span>
    }

    /**
     * Get an adjacent Indian settlement by identifier, validating as
     * much as possible, including checking whether the nation
     * involved has been contacted.  Designed for message unpacking
     * where the identifier should not be trusted.
     *
     * @param id The identifier of the &lt;code&gt;IndianSettlement&lt;/code&gt;
     *     to be found.
     * @return The settlement corresponding to the settlementId argument.
     * @throws IllegalStateException on failure to validate the settlementId
     *     in any way.
     */
    public IndianSettlement getAdjacentIndianSettlementSafely(String id)
        throws IllegalStateException {
<span class="nc" id="L3665">        Settlement settlement = getAdjacentSettlementSafely(id);</span>
<span class="nc bnc" id="L3666" title="All 2 branches missed.">        if (!(settlement instanceof IndianSettlement)) {</span>
<span class="nc" id="L3667">            throw new IllegalStateException(&quot;Not an indianSettlement: &quot; + id);</span>
<span class="nc bnc" id="L3668" title="All 2 branches missed.">        } else if (!getOwner().hasContacted(settlement.getOwner())) {</span>
<span class="nc" id="L3669">            throw new IllegalStateException(&quot;Player has not contacted the &quot;</span>
<span class="nc" id="L3670">                + settlement.getOwner().getNation());</span>
        }

<span class="nc" id="L3673">        return (IndianSettlement)settlement;</span>
    }


    // Interface Consumer

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;AbstractGoods&gt; getConsumedGoods() {
<span class="fc" id="L3684">        return unitType.getConsumedGoods();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getPriority() {
<span class="fc" id="L3692">        return unitType.getPriority();</span>
    }


    // Interface Ownable

    /**
     * {@inheritDoc}
     */
    @Override
    public Player getOwner() {
<span class="fc" id="L3703">        return owner;</span>
    }

    /**
     * {@inheritDoc}
     *
     * -vis: This routine has visibility implications.
     */
    @Override
    public void setOwner(Player player) {
<span class="fc" id="L3713">        this.owner = player;</span>
<span class="fc" id="L3714">    }</span>


    // Interface Locatable
    //   getTile and getSpaceTaken are shared with Location below

    /**
     * Gets the location of this unit.
     *
     * @return The location of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    @Override
    public Location getLocation() {
<span class="fc" id="L3727">        return location;</span>
    }

    /**
     * Sets the location of this unit.
     *
     * -vis: This routine changes player visibility.
     * -til: While units do not contribute to tile appearance as such, if
     *     they move in/out of a colony the visible colony size changes.
     *
     * @param newLocation The new &lt;code&gt;Location&lt;/code&gt;.
     * @return True if the location change succeeds.
     */
    @Override
    public boolean setLocation(Location newLocation) {
        // It is possible to add a unit to a non-specific location
        // within a colony by specifying the colony as the new
        // location.  Colony.joinColony handles this special case.
<span class="fc bfc" id="L3745" title="All 2 branches covered.">        if (newLocation instanceof Colony) {</span>
<span class="fc" id="L3746">            return ((Colony)newLocation).joinColony(this);</span>
        }

<span class="fc bfc" id="L3749" title="All 2 branches covered.">        if (newLocation == location) return true;</span>
<span class="fc bfc" id="L3750" title="All 4 branches covered.">        if (newLocation != null &amp;&amp; !newLocation.canAdd(this)) {</span>
<span class="fc" id="L3751">            logger.warning(&quot;Can not add &quot; + this + &quot; to &quot;</span>
<span class="fc" id="L3752">                + newLocation.getId());</span>
<span class="fc" id="L3753">            return false;</span>
        }

        // If the unit either starts or ends this move in a colony
        // then teaching status can change.  However, if it moves
        // between locations within the same colony with the same
        // teaching ability, the teaching state should *not* change.
        // We have to handle this issue here in setLocation as this is
        // the only place that contains information about both
        // locations.
<span class="fc bfc" id="L3763" title="All 2 branches covered.">        Colony oldColony = (isInColony()) ? location.getColony() : null;</span>
<span class="fc bfc" id="L3764" title="All 2 branches covered.">        Colony newColony = (newLocation instanceof WorkLocation)</span>
<span class="fc" id="L3765">            ? newLocation.getColony() : null;</span>
<span class="fc bfc" id="L3766" title="All 4 branches covered.">        boolean withinColony = newColony != null &amp;&amp; newColony == oldColony;</span>
<span class="fc bfc" id="L3767" title="All 2 branches covered.">        boolean preserveEducation = withinColony</span>
<span class="fc" id="L3768">            &amp;&amp; (((WorkLocation)location).canTeach()</span>
<span class="fc bfc" id="L3769" title="All 2 branches covered.">                == ((WorkLocation)newLocation).canTeach());</span>

        // First disable education that will fail due to the move.
<span class="fc bfc" id="L3772" title="All 4 branches covered.">        if (oldColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3773">            oldColony.updateEducation(this, false);</span>
        }

        // Move out of the old location.
<span class="fc bfc" id="L3777" title="All 2 branches covered.">        if (location == null) {</span>
            ; // do nothing
<span class="pc bpc" id="L3779" title="1 of 2 branches missed.">        } else if (!location.remove(this)) {//-vis</span>
            // &quot;Should not happen&quot; (should always be able to remove)
<span class="nc" id="L3781">            throw new RuntimeException(&quot;Failed to remove &quot; + this</span>
<span class="nc" id="L3782">                + &quot; from &quot; + location.getId());</span>
        }

        // Move in to the new location.
<span class="fc bfc" id="L3786" title="All 2 branches covered.">        if (newLocation == null) {</span>
<span class="fc" id="L3787">            setLocationNoUpdate(null);//-vis</span>
<span class="pc bpc" id="L3788" title="1 of 2 branches missed.">        } else if (!newLocation.add(this)) {//-vis</span>
            // &quot;Should not happen&quot; (canAdd was checked above)
<span class="nc" id="L3790">            throw new RuntimeException(&quot;Failed to add &quot;</span>
<span class="nc" id="L3791">                + this + &quot; to &quot; + newLocation.getId());</span>
        }

        // See if education needs to be re-enabled.
<span class="fc bfc" id="L3795" title="All 4 branches covered.">        if (newColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3796">            newColony.updateEducation(this, true);</span>
        }

        // Update population of any colonies involved.
<span class="fc bfc" id="L3800" title="All 2 branches covered.">        if (!withinColony) {</span>
<span class="fc bfc" id="L3801" title="All 2 branches covered.">            if (oldColony != null) oldColony.updatePopulation();</span>
<span class="fc bfc" id="L3802" title="All 2 branches covered.">            if (newColony != null) newColony.updatePopulation();</span>
        }
<span class="fc" id="L3804">        return true;</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is located in Europe.  That
     * is; either directly or onboard a carrier which is in Europe.
     *
     * @return True if in &lt;code&gt;Europe&lt;/code&gt;.
     */
    @Override
    public boolean isInEurope() {
<span class="fc bfc" id="L3815" title="All 2 branches covered.">        return (location instanceof Unit) ? ((Unit)location).isInEurope()</span>
<span class="fc" id="L3816">            : getLocation() instanceof Europe;</span>
    }


    // Interface Location (from GoodsLocation via UnitLocation)
    // Inherits
    //   FreeColObject.getId
    //   UnitLocation.getLocationLabelFor
    //   UnitLocation.contains
    //   UnitLocation.canAdd
    //   UnitLocation.getUnitCount
    //   UnitLocation.getUnitList
    //   GoodsLocation.getGoodsContainer

    /**
     * {@inheritDoc}
     */
    @Override
    public Tile getTile() {
<span class="fc bfc" id="L3835" title="All 2 branches covered.">        return (location != null) ? location.getTile() : null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getLocationLabel() {
<span class="nc" id="L3843">        return StringTemplate.template(&quot;model.unit.onBoard&quot;)</span>
<span class="nc" id="L3844">            .addStringTemplate(&quot;%unit%&quot;, this.getLabel());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean add(Locatable locatable) {
<span class="fc bfc" id="L3852" title="All 2 branches covered.">        if (!canAdd(locatable)) {</span>
<span class="fc" id="L3853">            return false;</span>
<span class="fc bfc" id="L3854" title="All 2 branches covered.">        } else if (locatable instanceof Unit) {</span>
<span class="fc" id="L3855">            Unit unit = (Unit)locatable;</span>
<span class="pc bpc" id="L3856" title="1 of 2 branches missed.">            if (super.add(locatable)) {</span>
                // FIXME: there seems to be an inconsistency between
                // units moving from an adjacent tile onto a ship and
                // units boarding a ship in-colony.  The former does not
                // appear to come through here (which it probably should)
                // as the ship's moves do not get zeroed.
<span class="fc" id="L3862">                spendAllMoves();</span>
<span class="fc" id="L3863">                unit.setState(UnitState.SENTRY);</span>
<span class="fc" id="L3864">                return true;</span>
            }
<span class="pc bpc" id="L3866" title="1 of 2 branches missed.">        } else if (locatable instanceof Goods) {</span>
<span class="fc" id="L3867">            Goods goods = (Goods)locatable;</span>
<span class="pc bpc" id="L3868" title="1 of 2 branches missed.">            if (super.addGoods(goods)) {</span>
<span class="fc" id="L3869">                spendAllMoves();</span>
<span class="fc" id="L3870">                return true;</span>
            }
<span class="nc" id="L3872">        } else {</span>
<span class="nc" id="L3873">            throw new IllegalStateException(&quot;Can not be added to unit: &quot;</span>
                + locatable);
        }
<span class="nc" id="L3876">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(Locatable locatable) {
<span class="pc bpc" id="L3884" title="1 of 2 branches missed.">        if (locatable == null) {</span>
<span class="nc" id="L3885">            throw new IllegalArgumentException(&quot;Locatable must not be 'null'.&quot;);</span>
<span class="pc bpc" id="L3886" title="2 of 4 branches missed.">        } else if (locatable instanceof Unit &amp;&amp; canCarryUnits()) {</span>
<span class="pc bpc" id="L3887" title="1 of 2 branches missed.">            if (super.remove(locatable)) {</span>
<span class="fc" id="L3888">                spendAllMoves();</span>
<span class="fc" id="L3889">                return true;</span>
            }
<span class="nc bnc" id="L3891" title="All 4 branches missed.">        } else if (locatable instanceof Goods &amp;&amp; canCarryGoods()) {</span>
<span class="nc bnc" id="L3892" title="All 2 branches missed.">            if (super.removeGoods((Goods)locatable) != null) {</span>
<span class="nc" id="L3893">                spendAllMoves();</span>
<span class="nc" id="L3894">                return true;</span>
            }
        } else {
<span class="nc" id="L3897">            logger.warning(&quot;Tried to remove from unit: &quot;</span>
                + locatable);
        }
<span class="nc" id="L3900">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Settlement getSettlement() {
<span class="fc" id="L3908">        Location location = getLocation();</span>
<span class="fc bfc" id="L3909" title="All 2 branches covered.">        return (location != null) ? location.getSettlement() : null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Location up() {
<span class="nc bnc" id="L3917" title="All 2 branches missed.">        return (isInEurope()) ? getLocation().up()</span>
<span class="nc bnc" id="L3918" title="All 2 branches missed.">            : (isInColony()) ? getColony()</span>
<span class="nc bnc" id="L3919" title="All 2 branches missed.">            : (hasTile()) ? getTile().up()</span>
            : this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getRank() {
<span class="nc" id="L3928">        return Location.getRank(getLocation());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toShortString() {
<span class="fc" id="L3936">        StringBuilder sb = new StringBuilder(32);</span>
<span class="fc" id="L3937">        sb.append(getId()).append(&quot;-&quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L3938" title="All 2 branches covered.">        if (!hasDefaultRole()) {</span>
<span class="fc" id="L3939">            sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L3940">            int count = getRoleCount();</span>
<span class="fc bfc" id="L3941" title="All 2 branches covered.">            if (count &gt; 1) sb.append(&quot;.&quot;).append(count);</span>
        }
<span class="fc" id="L3943">        return sb.toString();</span>
    }


    // UnitLocation
    // Inherits
    //   UnitLocation.getSpaceTaken
    //   UnitLocation.moveToFront
    //   UnitLocation.clearUnitList

    /**
     * {@inheritDoc}
     */
    @Override
    public int getSpaceTaken() {
        // We do not have to consider what this unit is carrying
        // because carriers can not be put onto carriers.  Yet.
<span class="fc" id="L3960">        return unitType.getSpaceTaken();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public NoAddReason getNoAddReason(Locatable locatable) {
<span class="fc bfc" id="L3968" title="All 2 branches covered.">        if (locatable == this) {</span>
<span class="fc" id="L3969">            return NoAddReason.ALREADY_PRESENT;</span>
<span class="fc bfc" id="L3970" title="All 2 branches covered.">        } else if (locatable instanceof Unit) {</span>
<span class="pc bpc" id="L3971" title="1 of 2 branches missed.">            return (!canCarryUnits())</span>
                ? NoAddReason.WRONG_TYPE
<span class="fc bfc" id="L3973" title="All 2 branches covered.">                : (locatable.getSpaceTaken() &gt; getSpaceLeft())</span>
                ? NoAddReason.CAPACITY_EXCEEDED
<span class="fc" id="L3975">                : super.getNoAddReason(locatable);</span>
<span class="pc bpc" id="L3976" title="1 of 2 branches missed.">        } else if (locatable instanceof Goods) {</span>
<span class="fc" id="L3977">            Goods goods = (Goods)locatable;</span>
<span class="pc bpc" id="L3978" title="1 of 2 branches missed.">            return (!canCarryGoods())</span>
                ? NoAddReason.WRONG_TYPE
<span class="fc bfc" id="L3980" title="All 2 branches covered.">                : (goods.getAmount() &gt; getLoadableAmount(goods.getType()))</span>
                ? NoAddReason.CAPACITY_EXCEEDED
                : NoAddReason.NONE;
            // Do not call super.getNoAddReason for goods because
            // the capacity test in GoodsLocation.getNoAddReason does not
            // account for packing and is thus too conservative.
        }
<span class="nc" id="L3987">        return super.getNoAddReason(locatable);</span>
    }


    // GoodsLocation
    // Inherits
    //   GoodsLocation.addGoods
    //   GoodsLocation.removeGoods

    /**
     * {@inheritDoc}
     */
    @Override
    public int getGoodsCapacity() {
<span class="nc" id="L4001">        return getCargoCapacity();</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     *
     * -vis: This routine can change player visibility.
     */
    @Override
    public void disposeResources() {
<span class="fc bfc" id="L4014" title="All 2 branches covered.">        if (location != null) {</span>
<span class="fc" id="L4015">            location.remove(this);</span>
            // Do not set location to null, units that are slaughtered in
            // battle need to remain valid during the animation.
        }

<span class="pc bpc" id="L4020" title="1 of 2 branches missed.">        if (teacher != null) {</span>
<span class="nc" id="L4021">            teacher.setStudent(null);</span>
<span class="nc" id="L4022">            teacher = null;</span>
        }

<span class="pc bpc" id="L4025" title="1 of 2 branches missed.">        if (student != null) {</span>
<span class="nc" id="L4026">            student.setTeacher(null);</span>
<span class="nc" id="L4027">            student = null;</span>
        }

<span class="fc" id="L4030">        setHomeIndianSettlement(null);</span>

<span class="fc" id="L4032">        getOwner().removeUnit(this);</span>

<span class="fc" id="L4034">        super.disposeResources();</span>
<span class="fc" id="L4035">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public FreeColGameObject getLinkTarget(Player player) {
<span class="nc bnc" id="L4042" title="All 2 branches missed.">        return (hasTile()) ? (FreeColGameObject)getTile().up()</span>
<span class="nc" id="L4043">            : player.getEurope();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int checkIntegrity(boolean fix) {
<span class="fc" id="L4051">        int result = super.checkIntegrity(fix);</span>
<span class="pc bpc" id="L4052" title="1 of 2 branches missed.">        if (this.role == null) {</span>
<span class="nc bnc" id="L4053" title="All 2 branches missed.">            if (fix) {</span>
<span class="nc" id="L4054">                this.role = getSpecification().getDefaultRole();</span>
<span class="nc" id="L4055">                logger.warning(&quot;Fixed missing role for: &quot; + getId());</span>
<span class="nc" id="L4056">                result = 0;</span>
            } else {
<span class="nc" id="L4058">                logger.warning(&quot;Missing role for: &quot; + getId());</span>
<span class="nc" id="L4059">                result = -1;</span>
            }
        }
<span class="pc bpc" id="L4062" title="1 of 2 branches missed.">        if (this.destination != null) {</span>
<span class="nc bnc" id="L4063" title="All 2 branches missed.">            if (((FreeColGameObject)this.destination).isUninitialized()) {</span>
<span class="nc bnc" id="L4064" title="All 2 branches missed.">                if (fix) {</span>
<span class="nc" id="L4065">                    this.destination = null;</span>
<span class="nc" id="L4066">                    logger.warning(&quot;Cleared uninitialized destination for: &quot;</span>
<span class="nc" id="L4067">                        + getId());</span>
<span class="nc" id="L4068">                    result = Math.min(result, 0);</span>
                } else {
<span class="nc" id="L4070">                    logger.warning(&quot;Uninitialized destination for: &quot;</span>
<span class="nc" id="L4071">                        + getId());</span>
<span class="nc" id="L4072">                    result = -1;</span>
                }
            }
        }
<span class="fc" id="L4076">        return result;</span>
    }


    // Override FreeColObject

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Ability&gt; getAbilities(String id, FreeColGameObjectType fcgot,
                                     Turn turn) {
<span class="fc" id="L4088">        final Player owner = getOwner();</span>
<span class="fc" id="L4089">        final UnitType unitType = getType();</span>
<span class="fc" id="L4090">        Set&lt;Ability&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType abilities always apply.
<span class="fc" id="L4093">        result.addAll(unitType.getAbilities(id));</span>

        // Roles apply with qualification.
<span class="fc" id="L4096">        result.addAll(role.getAbilities(id, fcgot, turn));</span>

        // The player's abilities require more qualification.
<span class="fc" id="L4099">        result.addAll(owner.getAbilities(id, fcgot, turn));</span>

        // Location abilities may apply.
        // FIXME: extend this to all locations?  May simplify
        // code.  Units are also Locations however, which complicates
        // the issue as we do not want Units aboard other Units to share
        // the abilities of the carriers.
<span class="fc bfc" id="L4106" title="All 2 branches covered.">        if (getSettlement() != null) {</span>
<span class="fc" id="L4107">            result.addAll(getSettlement().getAbilities(id, unitType, turn));</span>
<span class="fc bfc" id="L4108" title="All 2 branches covered.">        } else if (isInEurope()) {</span>
            // @compat 0.10.x
            // It makes sense here to do:
            //   Europe europe = owner.getEurope();
            // However while there is fixup code in readChildren that calls
            // this routine we can not rely on owner.europe being initialized
            // yet.  Hence the following:
<span class="fc" id="L4115">            Location loc = getLocation();</span>
<span class="pc bpc" id="L4116" title="1 of 4 branches missed.">            Europe europe = (loc instanceof Europe) ? (Europe)loc</span>
<span class="pc" id="L4117">                : (loc instanceof Unit) ? (Europe)((Unit)loc).getLocation()</span>
                : null;
            // end @compat 0.10.x
<span class="fc" id="L4120">            result.addAll(europe.getAbilities(id, unitType, turn));</span>
        }
<span class="fc" id="L4122">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Modifier&gt; getModifiers(String id, FreeColGameObjectType fcgot,
                                      Turn turn) {
<span class="fc" id="L4131">        final Player owner = getOwner();</span>
<span class="fc" id="L4132">        final UnitType unitType = getType();</span>
<span class="fc" id="L4133">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType modifiers always apply
<span class="fc" id="L4136">        result.addAll(unitType.getModifiers(id, fcgot, turn));</span>

        // The player's modifiers may not all apply
<span class="fc" id="L4139">        result.addAll(owner.getModifiers(id, fcgot, turn));</span>
        
        // Role modifiers apply
<span class="fc" id="L4142">        result.addAll(role.getModifiers(id, fcgot, turn));</span>

<span class="fc" id="L4144">        return result;</span>
    }


    // Serialization

    private static final String ATTRITION_TAG = &quot;attrition&quot;;
    private static final String COUNT_TAG = &quot;count&quot;;
    private static final String CURRENT_STOP_TAG = &quot;currentStop&quot;;
    private static final String DESTINATION_TAG = &quot;destination&quot;;
    private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;
    private static final String ETHNICITY_TAG = &quot;ethnicity&quot;;
    private static final String EXPERIENCE_TAG = &quot;experience&quot;;
    private static final String EXPERIENCE_TYPE_TAG = &quot;experienceType&quot;;
    private static final String HIT_POINTS_TAG = &quot;hitPoints&quot;;
    private static final String INDIAN_SETTLEMENT_TAG = &quot;indianSettlement&quot;;
    private static final String LOCATION_TAG = &quot;location&quot;;
    private static final String MOVES_LEFT_TAG = &quot;movesLeft&quot;;
    private static final String NAME_TAG = &quot;name&quot;;
    private static final String NATIONALITY_TAG = &quot;nationality&quot;;
    private static final String OWNER_TAG = &quot;owner&quot;;
    private static final String ROLE_TAG = &quot;role&quot;;
    private static final String ROLE_COUNT_TAG = &quot;roleCount&quot;;
    private static final String STATE_TAG = &quot;state&quot;;
    private static final String STUDENT_TAG = &quot;student&quot;;
    private static final String TRADE_ROUTE_TAG = &quot;tradeRoute&quot;;
    private static final String TEACHER_TAG = &quot;teacher&quot;;
    private static final String TREASURE_AMOUNT_TAG = &quot;treasureAmount&quot;;
    private static final String TURNS_OF_TRAINING_TAG = &quot;turnsOfTraining&quot;;
    private static final String UNIT_TYPE_TAG = &quot;unitType&quot;;
    private static final String VISIBLE_GOODS_COUNT_TAG = &quot;visibleGoodsCount&quot;;
    private static final String WORK_LEFT_TAG = &quot;workLeft&quot;;
    private static final String WORK_TYPE_TAG = &quot;workType&quot;;
    // @compat 0.10.5
    private static final String OLD_UNITS_TAG = &quot;units&quot;;
    // end @compat
    // @compat 0.10.7
    private static final String OLD_HIT_POINTS_TAG = &quot;hitpoints&quot;;
    private static final String EQUIPMENT_TAG = &quot;equipment&quot;;
    /** The equipment this Unit carries.  Now subsumed into roles. */
<span class="fc" id="L4184">    private final TypeCountMap&lt;EquipmentType&gt; equipment</span>
        = new TypeCountMap&lt;&gt;();
    // end @compat 0.10.x
    // @compat 0.11.3
    private static final String OLD_TILE_IMPROVEMENT_TAG = &quot;tileimprovement&quot;;
    // end @compat 0.11.3


    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L4197">        super.writeAttributes(xw);</span>

<span class="fc" id="L4199">        boolean full = xw.validFor(getOwner());</span>

<span class="fc bfc" id="L4201" title="All 2 branches covered.">        if (name != null) xw.writeAttribute(NAME_TAG, name);</span>

<span class="fc" id="L4203">        xw.writeAttribute(UNIT_TYPE_TAG, unitType);</span>

<span class="fc" id="L4205">        xw.writeAttribute(MOVES_LEFT_TAG, movesLeft);</span>

<span class="fc" id="L4207">        xw.writeAttribute(STATE_TAG, state);</span>

<span class="fc" id="L4209">        xw.writeAttribute(ROLE_TAG, role);</span>

<span class="fc" id="L4211">        xw.writeAttribute(ROLE_COUNT_TAG, roleCount);</span>

<span class="pc bpc" id="L4213" title="1 of 4 branches missed.">        if (!full &amp;&amp; hasAbility(Ability.PIRACY)) {</span>
            // Pirates do not disclose national characteristics.
<span class="nc" id="L4215">            xw.writeAttribute(OWNER_TAG, getGame().getUnknownEnemy());</span>

        } else {
<span class="fc" id="L4218">            xw.writeAttribute(OWNER_TAG, getOwner());</span>

<span class="fc bfc" id="L4220" title="All 2 branches covered.">            if (isPerson()) {</span>
                // Do not write out nationality and ethnicity for non-persons.
<span class="pc bpc" id="L4222" title="1 of 2 branches missed.">                xw.writeAttribute(NATIONALITY_TAG, (nationality != null)</span>
                    ? nationality
<span class="nc" id="L4224">                    : getOwner().getNationId());</span>

<span class="pc bpc" id="L4226" title="1 of 2 branches missed.">                xw.writeAttribute(ETHNICITY_TAG, (ethnicity != null)</span>
                    ? ethnicity
<span class="nc" id="L4228">                    : getOwner().getNationId());</span>
            }
        }

<span class="fc bfc" id="L4232" title="All 2 branches covered.">        if (location != null) {</span>
<span class="pc bpc" id="L4233" title="1 of 4 branches missed.">            if (!full &amp;&amp; isInColony()) {</span>
                // Really special case.  This happens in attack
                // animations when a defender unit is invisible
                // working inside a colony and has to be specially
                // serialized to the client.
<span class="nc" id="L4238">                xw.writeLocationAttribute(LOCATION_TAG, getColony());</span>

            } else {
<span class="fc" id="L4241">                xw.writeLocationAttribute(LOCATION_TAG, location);</span>
            }
        }

<span class="fc" id="L4245">        xw.writeAttribute(TREASURE_AMOUNT_TAG, treasureAmount);</span>

<span class="fc bfc" id="L4247" title="All 2 branches covered.">        if (full) {</span>
<span class="fc bfc" id="L4248" title="All 2 branches covered.">            if (entryLocation != null) {</span>
<span class="fc" id="L4249">                xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
            }

<span class="fc" id="L4252">            xw.writeAttribute(TURNS_OF_TRAINING_TAG, turnsOfTraining);</span>

<span class="fc bfc" id="L4254" title="All 2 branches covered.">            if (workType != null) xw.writeAttribute(WORK_TYPE_TAG, workType);</span>

<span class="fc bfc" id="L4256" title="All 2 branches covered.">            if (experienceType != null) {</span>
<span class="fc" id="L4257">                xw.writeAttribute(EXPERIENCE_TYPE_TAG, experienceType);</span>
            }

<span class="fc" id="L4260">            xw.writeAttribute(EXPERIENCE_TAG, experience);</span>

<span class="fc" id="L4262">            xw.writeAttribute(INDIAN_SETTLEMENT_TAG, indianSettlement);</span>

<span class="fc" id="L4264">            xw.writeAttribute(WORK_LEFT_TAG, workLeft);</span>

<span class="fc" id="L4266">            xw.writeAttribute(HIT_POINTS_TAG, hitPoints);</span>

<span class="fc" id="L4268">            xw.writeAttribute(ATTRITION_TAG, attrition);</span>

<span class="pc bpc" id="L4270" title="1 of 2 branches missed.">            if (student != null) xw.writeAttribute(STUDENT_TAG, student);</span>

<span class="pc bpc" id="L4272" title="1 of 2 branches missed.">            if (teacher != null) xw.writeAttribute(TEACHER_TAG, teacher);</span>

<span class="fc bfc" id="L4274" title="All 2 branches covered.">            if (destination != null) {</span>
<span class="fc" id="L4275">                xw.writeLocationAttribute(DESTINATION_TAG, destination);</span>
            }

<span class="pc bpc" id="L4278" title="1 of 2 branches missed.">            if (tradeRoute != null) {</span>
<span class="nc" id="L4279">                xw.writeAttribute(TRADE_ROUTE_TAG, tradeRoute);</span>

<span class="nc" id="L4281">                xw.writeAttribute(CURRENT_STOP_TAG, currentStop);</span>
            }
        }
<span class="fc" id="L4284">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc bfc" id="L4291" title="All 2 branches covered.">        if (xw.validFor(getOwner())) {</span>

            // Do not show goods or units carried by this unit.
<span class="fc" id="L4294">            super.writeChildren(xw);</span>

<span class="fc bfc" id="L4296" title="All 2 branches covered.">            if (workImprovement != null) workImprovement.toXML(xw);</span>

<span class="fc bfc" id="L4298" title="All 2 branches covered.">        } else if (getType().canCarryGoods()) {</span>
<span class="fc" id="L4299">            xw.writeAttribute(VISIBLE_GOODS_COUNT_TAG, getVisibleGoodsCount());</span>
        }
<span class="fc" id="L4301">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4308">        super.readAttributes(xr);</span>

<span class="fc" id="L4310">        final Specification spec = getSpecification();</span>
<span class="fc" id="L4311">        final Game game = getGame();</span>

<span class="fc" id="L4313">        name = xr.getAttribute(NAME_TAG, (String)null);</span>

<span class="fc" id="L4315">        Player oldOwner = owner;</span>
<span class="fc" id="L4316">        owner = xr.findFreeColGameObject(game, OWNER_TAG,</span>
                                         Player.class, (Player)null, true);
<span class="fc bfc" id="L4318" title="All 2 branches covered.">        if (xr.shouldIntern()) game.checkOwners(this, oldOwner);</span>

<span class="fc" id="L4320">        UnitType oldUnitType = unitType;</span>
<span class="fc" id="L4321">        unitType = xr.getType(spec, UNIT_TYPE_TAG,</span>
                              UnitType.class, (UnitType)null);

<span class="fc" id="L4324">        state = xr.getAttribute(STATE_TAG, UnitState.class, UnitState.ACTIVE);</span>

<span class="fc" id="L4326">        role = xr.getRole(spec, ROLE_TAG, Role.class,</span>
<span class="fc" id="L4327">                          spec.getDefaultRole());</span>
        // @compat 0.10.x
        // Fix roles
<span class="fc bfc" id="L4330" title="All 2 branches covered.">        if (owner.isIndian()) {</span>
<span class="pc bpc" id="L4331" title="1 of 2 branches missed.">            if (&quot;model.role.scout&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4332">                role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="pc bpc" id="L4333" title="1 of 2 branches missed.">            } else if (&quot;model.role.soldier&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4334">                role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="pc bpc" id="L4335" title="1 of 2 branches missed.">            } else if (&quot;model.role.dragoon&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4336">                role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
            }
<span class="fc bfc" id="L4338" title="All 2 branches covered.">        } else if (owner.isREF()) {</span>
<span class="pc bpc" id="L4339" title="1 of 2 branches missed.">            if (&quot;model.role.soldier&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4340" title="All 2 branches missed.">                &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4341">                role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="pc bpc" id="L4342" title="1 of 2 branches missed.">            } else if (&quot;model.role.dragoon&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4343" title="All 2 branches missed.">                &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4344">                role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="pc bpc" id="L4345" title="1 of 2 branches missed.">            } else if (&quot;model.role.infantry&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4346" title="All 2 branches missed.">                &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4347">                role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="pc bpc" id="L4348" title="1 of 2 branches missed.">            } else if (&quot;model.role.cavalry&quot;.equals(role.getId())</span>
<span class="pc bpc" id="L4349" title="1 of 2 branches missed.">                &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4350">                role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
            }
        } else {
<span class="pc bpc" id="L4353" title="1 of 2 branches missed.">            if (&quot;model.role.infantry&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4354">                role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="fc bfc" id="L4355" title="All 2 branches covered.">            } else if (&quot;model.role.cavalry&quot;.equals(role.getId())) {</span>
<span class="fc" id="L4356">                role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
            }
        }            
        // end @compat 0.10.x

<span class="fc" id="L4361">        roleCount = xr.getAttribute(ROLE_COUNT_TAG,</span>
            // @compat 0.10.x
            -1
            // Should be role.getMaximumCount()
            // end @compat 0.10.x
            );

<span class="fc" id="L4368">        location = xr.getLocationAttribute(game, LOCATION_TAG, true);</span>

<span class="fc" id="L4370">        entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG,</span>
                                                true);

<span class="fc" id="L4373">        movesLeft = xr.getAttribute(MOVES_LEFT_TAG, 0);</span>

<span class="fc" id="L4375">        workLeft = xr.getAttribute(WORK_LEFT_TAG, 0);</span>

<span class="fc" id="L4377">        attrition = xr.getAttribute(ATTRITION_TAG, 0);</span>

<span class="fc" id="L4379">        nationality = xr.getAttribute(NATIONALITY_TAG, (String)null);</span>

<span class="fc" id="L4381">        ethnicity = xr.getAttribute(ETHNICITY_TAG, (String)null);</span>

<span class="fc" id="L4383">        turnsOfTraining = xr.getAttribute(TURNS_OF_TRAINING_TAG, 0);</span>

<span class="fc" id="L4385">        hitPoints = xr.getAttribute(HIT_POINTS_TAG, -1);</span>
        // @compat 0.10.7
<span class="pc bpc" id="L4387" title="1 of 2 branches missed.">        if (hitPoints &lt; 0) hitPoints = xr.getAttribute(OLD_HIT_POINTS_TAG, -1);</span>
        // end @compat

<span class="fc" id="L4390">        teacher = xr.makeFreeColGameObject(game, TEACHER_TAG,</span>
                                           Unit.class, false);

<span class="fc" id="L4393">        student = xr.makeFreeColGameObject(game, STUDENT_TAG,</span>
                                           Unit.class, false);

<span class="fc" id="L4396">        setHomeIndianSettlement(xr.makeFreeColGameObject(game,</span>
                INDIAN_SETTLEMENT_TAG, IndianSettlement.class, false));

<span class="fc" id="L4399">        treasureAmount = xr.getAttribute(TREASURE_AMOUNT_TAG, 0);</span>

<span class="fc" id="L4401">        destination = xr.getLocationAttribute(game, DESTINATION_TAG, true);</span>

<span class="fc" id="L4403">        tradeRoute = xr.findFreeColGameObject(game, TRADE_ROUTE_TAG,</span>
            TradeRoute.class, (TradeRoute)null, false);

<span class="pc bpc" id="L4406" title="1 of 2 branches missed.">        currentStop = (tradeRoute == null) ? -1</span>
<span class="pc" id="L4407">            : xr.getAttribute(CURRENT_STOP_TAG, 0);</span>

<span class="fc" id="L4409">        experienceType = xr.getType(spec, EXPERIENCE_TYPE_TAG,</span>
                                    GoodsType.class, (GoodsType)null);
<span class="pc bpc" id="L4411" title="1 of 4 branches missed.">        if (experienceType == null &amp;&amp; workType != null) {</span>
<span class="nc" id="L4412">            experienceType = workType;</span>
        }

<span class="fc" id="L4415">        experience = xr.getAttribute(EXPERIENCE_TAG, 0);</span>

<span class="fc" id="L4417">        visibleGoodsCount = xr.getAttribute(VISIBLE_GOODS_COUNT_TAG, -1);</span>

        // Make sure you do this after experience and location stuff.
<span class="fc" id="L4420">        changeWorkType(xr.getType(spec, WORK_TYPE_TAG, GoodsType.class, null));</span>
<span class="fc" id="L4421">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
        // Clear containers.
<span class="pc bpc" id="L4429" title="1 of 2 branches missed.">        if (getGoodsContainer() != null) getGoodsContainer().removeAll();</span>
<span class="fc" id="L4430">        equipment.clear();</span>
<span class="fc" id="L4431">        workImprovement = null;</span>

<span class="fc" id="L4433">        super.readChildren(xr);</span>

        // @compat 0.10.x
<span class="fc bfc" id="L4436" title="All 2 branches covered.">        if (roleCount &lt; 0) {</span>
            // If roleCount was not present, set it from equipment
<span class="fc" id="L4438">            final Specification spec = getSpecification();</span>
<span class="fc" id="L4439">            Role role = spec.getDefaultRole();</span>
<span class="fc" id="L4440">            boolean horses = false, muskets = false;</span>
<span class="fc" id="L4441">            int count = 1;</span>
<span class="pc bpc" id="L4442" title="1 of 2 branches missed.">            for (EquipmentType type : equipment.keySet()) {</span>
<span class="nc bnc" id="L4443" title="All 2 branches missed.">                if (&quot;model.equipment.horses&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4444" title="All 2 branches missed.">                    || &quot;model.equipment.indian.horses&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4445">                    horses = true;</span>
<span class="nc bnc" id="L4446" title="All 2 branches missed.">                } else if (&quot;model.equipment.muskets&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4447" title="All 2 branches missed.">                    || &quot;model.equipment.indian.muskets&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4448">                    muskets = true;</span>
                } else {
<span class="nc" id="L4450">                    role = type.getRole();</span>
<span class="nc bnc" id="L4451" title="All 2 branches missed.">                    if (&quot;model.equipment.tools&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4452">                        count = equipment.getCount(type);</span>
                    }
                }
<span class="nc" id="L4455">            }</span>
<span class="pc bpc" id="L4456" title="3 of 4 branches missed.">            if (horses &amp;&amp; muskets) {</span>
<span class="nc bnc" id="L4457" title="All 2 branches missed.">                if (owner.isIndian()) {</span>
<span class="nc" id="L4458">                    role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
<span class="nc bnc" id="L4459" title="All 4 branches missed.">                } else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4460">                    role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
                } else {
<span class="nc" id="L4462">                    role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
                }
<span class="pc bpc" id="L4464" title="1 of 2 branches missed.">            } else if (horses) {</span>
<span class="nc bnc" id="L4465" title="All 2 branches missed.">                if (owner.isIndian()) {</span>
<span class="nc" id="L4466">                    role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="nc bnc" id="L4467" title="All 4 branches missed.">                } else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4468">                    logger.warning(&quot;Undefined role: REF Scout&quot;);</span>
                } else {
<span class="nc" id="L4470">                    role = spec.getRole(&quot;model.role.scout&quot;);</span>
                }
<span class="pc bpc" id="L4472" title="1 of 2 branches missed.">            } else if (muskets) {</span>
<span class="nc bnc" id="L4473" title="All 2 branches missed.">                if (owner.isIndian()) {</span>
<span class="nc" id="L4474">                    role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="nc bnc" id="L4475" title="All 4 branches missed.">                } else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4476">                    role = spec.getRole(&quot;model.role.infantry&quot;);</span>
                } else {
<span class="nc" id="L4478">                    role = spec.getRole(&quot;model.role.soldier&quot;);</span>
                }
            }
<span class="fc" id="L4481">            setRoleCount(Math.min(role.getMaximumCount(), count));</span>
<span class="fc" id="L4482">        } else {</span>
            // If roleCount was present, we are now ignoring equipment.
<span class="fc" id="L4484">            equipment.clear();</span>
        }
        // end @compat 0.10.x

        // @compat 0.10.x
        // There was a bug in 0.10.x that did not clear tile
        // improvements after they were complete, leading to units
        // that still had a tile improvement after they had moved
        // away.  Consequently when reading such bogus improvements,
        // there is no guarantee that the tile is defined so
        // compatibility code in TileImprovement.readAttributes
        // tolerates null tile references.  These are obviously bogus,
        // so drop them.
<span class="pc bpc" id="L4497" title="3 of 4 branches missed.">        if (workImprovement != null &amp;&amp; workImprovement.getTile() == null) {</span>
<span class="nc" id="L4498">            workImprovement = null;</span>
        }
        // end @compat 0.10.x
<span class="fc" id="L4501">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4508">        final Specification spec = getSpecification();</span>
<span class="fc" id="L4509">        final Game game = getGame();</span>
<span class="fc" id="L4510">        final String tag = xr.getLocalName();</span>

        // @compat 0.10.x
<span class="pc bpc" id="L4513" title="1 of 2 branches missed.">        if (EQUIPMENT_TAG.equals(tag)) {</span>
<span class="nc" id="L4514">            equipment.incrementCount(spec.getEquipmentType(xr.readId()),</span>
<span class="nc" id="L4515">                                     xr.getAttribute(COUNT_TAG, 0));</span>
<span class="nc" id="L4516">            xr.closeTag(EQUIPMENT_TAG);</span>
        // end @compat 0.10.x

        // @compat 0.10.5
<span class="pc bpc" id="L4520" title="1 of 2 branches missed.">        } else if (OLD_UNITS_TAG.equals(tag)) {</span>
<span class="nc bnc" id="L4521" title="All 2 branches missed.">            while (xr.nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="nc" id="L4522">                super.readChild(xr);</span>
            }
        // end @compat 0.10.5

<span class="pc bpc" id="L4526" title="1 of 2 branches missed.">        } else if (TileImprovement.getXMLElementTagName().equals(tag)</span>
                   // @compat 0.11.3
<span class="pc bpc" id="L4528" title="1 of 2 branches missed.">                   || OLD_TILE_IMPROVEMENT_TAG.equals(tag)</span>
                   // end @compat 0.11.3
                   ) {
<span class="nc" id="L4531">            workImprovement = xr.readFreeColGameObject(game,</span>
                                                       TileImprovement.class);

        } else {
<span class="fc" id="L4535">            super.readChild(xr);</span>
        }
<span class="fc" id="L4537">    }</span>

    /**
     * Gets a string representation of this unit.
     *
     * @param prefix A prefix (e.g. &quot;AIUnit&quot;)
     * @return A string representation of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public String toString(String prefix) {
<span class="fc" id="L4546">        StringBuilder sb = new StringBuilder(64);</span>
<span class="fc" id="L4547">        sb.append(&quot;[&quot;).append(prefix).append(getId());</span>
<span class="pc bpc" id="L4548" title="1 of 2 branches missed.">        if (isUninitialized()) {</span>
<span class="nc" id="L4549">            sb.append(&quot; uninitialized&quot;);</span>
<span class="pc bpc" id="L4550" title="1 of 2 branches missed.">        } else if (isDisposed()) {</span>
<span class="nc" id="L4551">            sb.append(&quot; disposed&quot;);</span>
        } else {
<span class="fc" id="L4553">            sb.append(&quot; &quot;).append(lastPart(owner.getNationId(), &quot;.&quot;))</span>
<span class="fc" id="L4554">                .append(&quot; &quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L4555" title="All 2 branches covered.">            if (!hasDefaultRole()) {</span>
<span class="fc" id="L4556">                sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L4557">                int count = getRoleCount();</span>
<span class="pc bpc" id="L4558" title="1 of 2 branches missed.">                if (count &gt; 1) sb.append(&quot;.&quot;).append(count);</span>
            }
<span class="fc" id="L4560">            sb.append(&quot; &quot;).append(getMovesAsString());</span>
        }
<span class="fc" id="L4562">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L4563">        return sb.toString();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="fc" id="L4571">        return toString(&quot;&quot;);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
<span class="fc" id="L4578">    public String getXMLTagName() { return getXMLElementTagName(); }</span>

    /**
     * Gets the tag name of the root element representing this object.
     *
     * @return &quot;unit&quot;
     */
    public static String getXMLElementTagName() {
<span class="fc" id="L4586">        return &quot;unit&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>