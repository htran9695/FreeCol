<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Unit.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Unit.java</span></div><h1>Unit.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.ToIntFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;

import org.w3c.dom.Element;

/**
 * Represents all pieces that can be moved on the map-board. This includes:
 * colonists, ships, wagon trains e.t.c.
 *
 * Every &lt;code&gt;Unit&lt;/code&gt; is owned by a {@link Player} and has a
 * {@link Location}.
 */
public class Unit extends GoodsLocation implements Consumer, Locatable, Movable, Nameable, Ownable {

	/** The Constant logger. */
<span class="fc" id="L59">	private static final Logger logger = Logger.getLogger(Unit.class.getName());</span>

	/**
	 * A large number of turns, denoting pathfinding failure. Do not use
	 * INFINITY as further calculation might use this.
	 */
	public static final int MANY_TURNS = 10000;

	/** The Constant CARGO_CHANGE. */
	public static final String CARGO_CHANGE = &quot;CARGO_CHANGE&quot;;

	/** The Constant MOVE_CHANGE. */
	public static final String MOVE_CHANGE = &quot;MOVE_CHANGE&quot;;

	/** The Constant ROLE_CHANGE. */
	public static final String ROLE_CHANGE = &quot;ROLE_CHANGE&quot;;

	/**
	 * A comparator to compare units by position, top to bottom, left to right.
	 */
<span class="pc" id="L79">	public static final Comparator&lt;Unit&gt; locComparator = Comparator.comparingInt(u -&gt; Location.getRank(u));</span>

	/** A comparator to compare units by type then role. */
<span class="fc" id="L82">	public static final Comparator&lt;Unit&gt; typeRoleComparator = Comparator.comparing(Unit::getType)</span>
<span class="fc" id="L83">			.thenComparing(Comparator.comparing(Unit::getRole));</span>

	/** A state a Unit can have. */
<span class="pc" id="L86">	public static enum UnitState {</span>

		/** The active. */
<span class="fc" id="L89">		ACTIVE,</span>
		/** The fortified. */
<span class="fc" id="L91">		FORTIFIED,</span>
		/** The sentry. */
<span class="fc" id="L93">		SENTRY,</span>
		/** The in colony. */
<span class="fc" id="L95">		IN_COLONY,</span>
		/** The improving. */
<span class="fc" id="L97">		IMPROVING,</span>

		/** The to europe. */
		// @compat 0.10.0
<span class="fc" id="L101">		TO_EUROPE,</span>
		/** The to america. */
<span class="fc" id="L103">		TO_AMERICA,</span>

		/** The fortifying. */
		// end @compat
<span class="fc" id="L107">		FORTIFYING,</span>
		/** The skipped. */
<span class="fc" id="L109">		SKIPPED;</span>

		/**
		 * Get the stem key for this unit state.
		 *
		 * @return The stem key.
		 */
		public String getKey() {
<span class="nc" id="L117">			return &quot;unitState.&quot; + getEnumKey(this);</span>
		}
	}

	/** The individual name of this unit, not of the unit type. */
<span class="fc" id="L122">	protected String name = null;</span>

	/** The owner player. */
	protected Player owner;

	/** The unit type. */
	protected UnitType unitType;

	/** Current unit state. */
<span class="fc" id="L131">	protected UnitState state = UnitState.ACTIVE;</span>

	/** Current unit role. */
	protected Role role;

	/**
	 * The amount of role-equipment this unit carries, subject to
	 * role.getMaximumCount(). Currently zero or one except for pioneers.
	 */
	protected int roleCount;

	/** The current unit location. */
	protected Location location;

	/** The last entry location used by this unit. */
	protected Location entryLocation;

	/** The number of moves this unit has left this turn. */
	protected int movesLeft;

	/** What type of goods this unit produces in its occupation. */
	protected GoodsType workType;

	/** What type of goods this unit last earned experience producing. */
	protected GoodsType experienceType;

	/** The mount of experience a unit has earned. */
<span class="fc" id="L158">	protected int experience = 0;</span>

	/**
	 * The number of turns until the work is finished (e.g. sailing, improving),
	 * or '-1' if a Unit can stay in its state forever.
	 */
	protected int workLeft;

	/**
	 * What is being improved (to be used only for PIONEERs - where they are
	 * working.
	 */
	protected TileImprovement workImprovement;

	/** The student of this Unit, if it has one. */
	protected Unit student;

	/** The teacher of this Unit, if it has one. */
	protected Unit teacher;

	/** Number of turns of training needed by this unit. */
<span class="fc" id="L179">	protected int turnsOfTraining = 0;</span>

	/** The original nationality. */
<span class="fc" id="L182">	protected String nationality = null;</span>

	/** The original ethnicity. */
<span class="fc" id="L185">	protected String ethnicity = null;</span>

	/** The home settlement of a native unit. */
<span class="fc" id="L188">	protected IndianSettlement indianSettlement = null;</span>

	/** For now; only used by ships when repairing. */
	protected int hitPoints;

	/** A destination for go-to moves. */
<span class="fc" id="L194">	protected Location destination = null;</span>

	/** The trade route this unit has. */
<span class="fc" id="L197">	protected TradeRoute tradeRoute = null;</span>

	/** Which stop in a trade route the unit is going to. */
<span class="fc" id="L200">	protected int currentStop = -1;</span>

	/** To be used only for type == TREASURE_TRAIN. */
	protected int treasureAmount;

	/**
	 * The attrition this unit has accumulated. At the moment, this equals the
	 * number of turns it has spent in the open.
	 */
<span class="fc" id="L209">	protected int attrition = 0;</span>

	/**
	 * The amount of goods carried by this unit. This variable is only used by
	 * the clients. A negative value signals that the variable is not in use.
	 *
	 * @see #getVisibleGoodsCount()
	 */
	protected int visibleGoodsCount;

	/**
	 * Constructor for ServerUnit.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 */
	protected Unit(Game game) {
<span class="fc" id="L226">		super(game);</span>
<span class="fc" id="L227">	}</span>

	/**
	 * Initialize this object from an XML-representation of this object.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param e
	 *            An XML-element that will be used to initialize this object.
	 */
	public Unit(Game game, Element e) {
<span class="fc" id="L238">		super(game, e);</span>

<span class="fc" id="L240">		readFromXMLElement(e);</span>
<span class="fc" id="L241">	}</span>

	/**
	 * Creates a new &lt;code&gt;Unit&lt;/code&gt; with the given identifier. The object
	 * should later be initialized by calling
	 * {@link #readFromXML(FreeColXMLReader)}.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param id
	 *            The object identifier.
	 */
	public Unit(Game game, String id) {
<span class="fc" id="L254">		super(game, id);</span>
<span class="fc" id="L255">	}</span>

	/**
	 * Get the individual name of this unit.
	 *
	 * @return The individual name.
	 */
	@Override
	public String getName() {
<span class="fc" id="L264">		return name;</span>
	}

	/**
	 * Set the individual name of this unit.
	 *
	 * @param newName
	 *            The new name.
	 */
	@Override
	public void setName(String newName) {
<span class="fc" id="L275">		this.name = newName;</span>
<span class="fc" id="L276">	}</span>

	/**
	 * Get the name of the apparent owner of this Unit, (like
	 * getOwner().getNationAsString() but handles pirates).
	 *
	 * @return The name of the apparent owner of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public StringTemplate getApparentOwnerName() {
<span class="fc bfc" id="L285" title="All 2 branches covered.">		Player own = (hasAbility(Ability.PIRACY)) ? getGame().getUnknownEnemy() : owner;</span>
<span class="fc" id="L286">		return own.getNationLabel();</span>
	}

	/**
	 * What type of unit label do we want?.
	 */
<span class="pc" id="L292">	public static enum UnitLabelType {</span>

		/** The plain. */
<span class="fc" id="L295">		PLAIN,</span>
		/** The national. */
		// Just the basics
<span class="fc" id="L298">		NATIONAL,</span>
		/** The full. */
		// Add the nation
<span class="fc" id="L301">		FULL // Add the equipment and extras</span>
	}

	/**
	 * Get a plain string template for a unit.
	 *
	 * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
	 */
	public StringTemplate getLabel() {
<span class="fc" id="L310">		return getLabel(UnitLabelType.PLAIN);</span>
	}

	/**
	 * Get a string template for a unit.
	 *
	 * The PLAIN template contains: - The type of the unit - A role if not the
	 * default - The specific name of the unit if it has one The NATIONAL
	 * template adds the nation The FULL template adds equipment annotations
	 *
	 * @param ult
	 *            The type of label to get.
	 * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
	 */
	public StringTemplate getLabel(UnitLabelType ult) {
<span class="fc" id="L325">		final UnitType type = getType();</span>
<span class="fc" id="L326">		final Role role = getRole();</span>
<span class="fc" id="L327">		final Player owner = getOwner();</span>
<span class="pc bpc" id="L328" title="3 of 6 branches missed.">		if (type == null || role == null || owner == null) {</span>
<span class="nc" id="L329">			return null; // Probably disposed</span>
		}

<span class="pc bpc" id="L332" title="1 of 4 branches missed.">		switch (ult) {</span>
		case PLAIN:
<span class="fc" id="L334">			return Messages.getUnitLabel(getName(), type.getId(), 1, null, role.getId(), null);</span>

		case NATIONAL:
<span class="fc bfc" id="L337" title="All 2 branches covered.">			if (role.getMaximumCount() &gt; 1) {</span>
				// If the amount of equipment can vary an equipment
				// label is required, so fall through into the FULL case.
			} else {
<span class="fc" id="L341">				return Messages.getUnitLabel(getName(), type.getId(), 1, owner.getNationId(), role.getId(), null);</span>
			}
			// Fall through

		case FULL:
<span class="fc" id="L346">			StringTemplate extra = null;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">			if (role.isDefaultRole()) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">				if (canCarryTreasure()) {</span>
<span class="fc" id="L349">					extra = StringTemplate.template(&quot;goldAmount&quot;).addAmount(&quot;%amount%&quot;, getTreasureAmount());</span>
				} else {
<span class="fc" id="L351">					boolean noEquipment = false;</span>
					// unequipped expert has no-equipment label
<span class="fc" id="L353">					List&lt;Role&gt; expertRoles = type.getExpertRoles();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">					for (Role someRole : expertRoles) {</span>
<span class="fc" id="L355">						String key = someRole.getId() + &quot;.noequipment&quot;;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">						if (Messages.containsKey(key)) {</span>
<span class="fc" id="L357">							extra = StringTemplate.key(key);</span>
<span class="fc" id="L358">							break;</span>
						}
<span class="fc" id="L360">					}</span>
<span class="fc" id="L361">				}</span>
			} else {
<span class="fc" id="L363">				String equipmentKey = role.getId() + &quot;.equipment&quot;;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">				if (Messages.containsKey(equipmentKey)) {</span>
					// Currently only used for missionary which does not
					// have equipment that directly corresponds to goods.
<span class="fc" id="L367">					extra = AbstractGoods.getLabel(equipmentKey, 1);</span>

				} else {
					// Other roles can be characterized by their goods.
<span class="fc" id="L371">					List&lt;AbstractGoods&gt; requiredGoods = role.getRequiredGoods(getRoleCount());</span>
<span class="fc" id="L372">					boolean first = true;</span>
<span class="fc" id="L373">					extra = StringTemplate.label(&quot;&quot;);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">					for (AbstractGoods ag : requiredGoods) {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">						if (first) {</span>
<span class="fc" id="L376">							first = false;</span>
						} else {
<span class="fc" id="L378">							extra.addName(&quot; &quot;);</span>
						}
<span class="fc" id="L380">						extra.addStringTemplate(ag.getLabel());</span>
<span class="fc" id="L381">					}</span>
				}
			}
<span class="fc" id="L384">			return Messages.getUnitLabel(getName(), type.getId(), 1, owner.getNationId(), role.getId(), extra);</span>
		default: // Can not happen
			break;
		}
<span class="nc" id="L388">		return null;</span>
	}

	/**
	 * Get the basic i18n description for this unit.
	 *
	 * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
	 */
	public String getDescription() {
<span class="fc" id="L397">		return Messages.message(getLabel());</span>
	}

	/**
	 * Get the basic i18n description for this unit.
	 *
	 * @param ult
	 *            The label type required.
	 * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
	 */
	public String getDescription(UnitLabelType ult) {
<span class="fc" id="L408">		return Messages.message(getLabel(ult));</span>
	}

	/**
	 * Get a label for the chance of success in a potential combat.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to attack into.
	 * @return A suitable label.
	 */
	public StringTemplate getCombatLabel(Tile tile) {
<span class="nc" id="L419">		final CombatModel.CombatOdds combatOdds = getGame().getCombatModel().calculateCombatOdds(this,</span>
<span class="nc" id="L420">				tile.getDefendingUnit(this));</span>

		// If attacking a settlement, the true odds are never
		// known because units may be hidden within
<span class="nc bnc" id="L424" title="All 4 branches missed.">		boolean unknown = combatOdds.win == CombatModel.CombatOdds.UNKNOWN_ODDS || tile.hasSettlement();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">		return StringTemplate.template(&quot;model.unit.attackTileOdds&quot;).addName(&quot;%chance%&quot;,</span>
<span class="nc" id="L426">				(unknown) ? &quot;??&quot; : String.valueOf((int) (combatOdds.win * 100)));</span>
	}

	/**
	 * Get a destination label for this unit.
	 *
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing where this unit is
	 *         going.
	 */
	public StringTemplate getDestinationLabel() {
		// Create the right tag for the tagged &quot;goingTo&quot; message.
<span class="nc bnc" id="L437" title="All 4 branches missed.">		String type = (isPerson()) ? &quot;person&quot; : (isNaval()) ? &quot;ship&quot; : &quot;other&quot;;</span>
<span class="nc" id="L438">		return getDestinationLabel(type, getDestination(), getOwner());</span>
	}

	/**
	 * Get a destination label for a given unit tag, destination and player.
	 *
	 * @param tag
	 *            The unit tag for the &quot;goingTo&quot; message.
	 * @param destination
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; viewpoint.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing the unit movement.
	 */
	public static StringTemplate getDestinationLabel(String tag, Location destination, Player player) {
<span class="nc" id="L453">		return StringTemplate.template(&quot;model.unit.goingTo&quot;).add(&quot;%type%&quot;, tag).addStringTemplate(&quot;%location%&quot;,</span>
<span class="nc" id="L454">				destination.getLocationLabelFor(player));</span>
	}

	/**
	 * Get a string template describing the repair state of this unit.
	 *
	 * @return A repair label.
	 */
	public StringTemplate getRepairLabel() {
<span class="nc" id="L463">		return StringTemplate.template(&quot;model.unit.underRepair&quot;).addAmount(&quot;%turns%&quot;, getTurnsForRepair());</span>
	}

	/**
	 * Get the &lt;code&gt;UnitType&lt;/code&gt; value.
	 *
	 * @return The current &lt;code&gt;UnitType&lt;/code&gt;.
	 */
	public final UnitType getType() {
<span class="fc" id="L472">		return unitType;</span>
	}

	/**
	 * Sets the type of the unit.
	 *
	 * -vis: Has visibility issues as the line of sight may change.
	 *
	 * @param unitType
	 *            The new type of the unit.
	 */
	public void setType(UnitType unitType) {
<span class="fc" id="L484">		this.unitType = unitType;</span>
<span class="fc" id="L485">	}</span>

	/**
	 * Changes the type of the unit.
	 *
	 * -vis: Has visibility issues as the line of sight may change.
	 *
	 * @param unitType
	 *            The new type of the unit.
	 * @return True if the type change succeeds.
	 */
	public boolean changeType(UnitType unitType) {
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">		if (!unitType.isAvailableTo(owner))</span>
<span class="nc" id="L498">			return false;</span>

<span class="fc" id="L500">		setType(unitType);</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">		if (getMovesLeft() &gt; getInitialMovesLeft()) {</span>
<span class="nc" id="L502">			setMovesLeft(getInitialMovesLeft());</span>
		}
<span class="fc" id="L504">		hitPoints = unitType.getHitPoints();</span>
<span class="fc bfc" id="L505" title="All 4 branches covered.">		if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="fc" id="L506">			getTeacher().setStudent(null);</span>
<span class="fc" id="L507">			setTeacher(null);</span>
		}
<span class="fc" id="L509">		return true;</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is naval.
	 *
	 * @return True if this is a naval &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public boolean isNaval() {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">		return (unitType == null) ? false : unitType.isNaval();</span>
	}

	/**
	 * Checks if this unit is an undead.
	 *
	 * @return True if the unit is undead.
	 */
	public boolean isUndead() {
<span class="nc" id="L527">		return hasAbility(Ability.UNDEAD);</span>
	}

	/**
	 * Can this unit carry treasure (like a treasure train)?.
	 *
	 * @return True if this &lt;code&gt;Unit&lt;/code&gt; can carry treasure.
	 */
	public boolean canCarryTreasure() {
<span class="fc" id="L536">		return hasAbility(Ability.CARRY_TREASURE);</span>
	}

	/**
	 * Can this unit capture enemy goods?.
	 *
	 * @return True if this &lt;code&gt;Unit&lt;/code&gt; is capable of capturing goods.
	 */
	public boolean canCaptureGoods() {
<span class="fc" id="L545">		return hasAbility(Ability.CAPTURE_GOODS);</span>
	}

	/**
	 * Checks if this is a trading &lt;code&gt;Unit&lt;/code&gt;, meaning that it can trade
	 * with settlements.
	 *
	 * @return True if this is a trading unit.
	 */
	public boolean isTradingUnit() {
<span class="fc bfc" id="L555" title="All 4 branches covered.">		return canCarryGoods() &amp;&amp; owner.isEuropean();</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is a `colonist'. A unit is a colonist if
	 * it is European and can build a new &lt;code&gt;Colony&lt;/code&gt;.
	 *
	 * @return True if this unit is a colonist.
	 */
	public boolean isColonist() {
<span class="fc bfc" id="L565" title="All 4 branches covered.">		return unitType.hasAbility(Ability.FOUND_COLONY) &amp;&amp; owner.hasAbility(Ability.FOUNDS_COLONIES);</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is able to carry {@link Locatable}s.
	 *
	 * @return True if this unit can carry goods or other units.
	 */
	public boolean isCarrier() {
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">		return unitType.canCarryGoods() || unitType.canCarryUnits();</span>
	}

	/**
	 * Checks if this unit is a person, that is not a ship or wagon.
	 * Surprisingly difficult without explicit enumeration because
	 * model.ability.person only arrived in 0.10.1.
	 *
	 * @return True if this unit is a person.
	 */
	public boolean isPerson() {
<span class="fc bfc" id="L585" title="All 2 branches covered.">		return hasAbility(Ability.PERSON)</span>
				// @compat 0.10.0
<span class="pc bpc" id="L587" title="2 of 4 branches missed.">				|| unitType.hasAbility(Ability.BORN_IN_COLONY) || unitType.hasAbility(Ability.BORN_IN_INDIAN_SETTLEMENT)</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">				|| unitType.hasAbility(Ability.FOUND_COLONY)</span>
		// Nick also had:
		// &amp;&amp; (!hasAbility(&quot;model.ability.carryGoods&quot;)
		// &amp;&amp; !hasAbility(&quot;model.ability.carryUnits&quot;)
		// &amp;&amp; !hasAbility(&quot;model.ability.carryTreasure&quot;)
		// &amp;&amp; !hasAbility(&quot;model.ability.bombard&quot;))
		// ...but that should be unnecessary.
		// end @compat
		;
	}

	/**
	 * Gets the state of this &lt;code&gt;Unit&lt;/code&gt;.
	 *
	 * @return The state of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public UnitState getState() {
<span class="fc" id="L605">		return state;</span>
	}

	/**
	 * Checks if a &lt;code&gt;Unit&lt;/code&gt; can get the given state set.
	 *
	 * @param s
	 *            The new state for this Unit. Should be one of
	 *            {UnitState.ACTIVE, FORTIFIED, ...}.
	 * @return True if the &lt;code&gt;Unit&lt;/code&gt; state can be changed to the new
	 *         value.
	 */
	public boolean checkSetState(UnitState s) {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">		if (getState() == s) {</span>
<span class="nc" id="L619">			return false;</span>
		}
<span class="pc bpc" id="L621" title="2 of 8 branches missed.">		switch (s) {</span>
		case ACTIVE:
<span class="fc" id="L623">			return true;</span>
		case FORTIFIED:
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">			return getState() == UnitState.FORTIFYING;</span>
		case FORTIFYING:
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">			return getMovesLeft() &gt; 0;</span>
		case IMPROVING:
<span class="pc bpc" id="L629" title="2 of 4 branches missed.">			return getMovesLeft() &gt; 0 &amp;&amp; location instanceof Tile</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">					&amp;&amp; getOwner().canAcquireForImprovement(location.getTile());</span>
		case IN_COLONY:
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">			return !isNaval();</span>
		case SENTRY:
<span class="fc" id="L634">			return true;</span>
		case SKIPPED:
<span class="nc bnc" id="L636" title="All 2 branches missed.">			return getState() == UnitState.ACTIVE;</span>
		default:
<span class="nc" id="L638">			logger.warning(&quot;Invalid unit state: &quot; + s);</span>
<span class="nc" id="L639">			return false;</span>
		}
	}

	/**
	 * Sets a new state for this unit and initializes the amount of work the
	 * unit has left.
	 *
	 * If the work needs turns to be completed (for instance when plowing), then
	 * the moves the unit has still left will be used up. Some work (basically
	 * building a road with a hardy pioneer) might actually be finished already
	 * in this method-call, in which case the state is set back to
	 * UnitState.ACTIVE.
	 *
	 * @param s
	 *            The new state for this Unit. Should be one of
	 *            {UnitState.ACTIVE, UnitState.FORTIFIED, ...}.
	 */
	public void setState(UnitState s) {
<span class="fc bfc" id="L658" title="All 2 branches covered.">		if (state == s) {</span>
			// No need to do anything when the state is unchanged
<span class="fc" id="L660">			return;</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">		} else if (!checkSetState(s)) {</span>
<span class="nc" id="L662">			throw new IllegalStateException(&quot;Illegal UnitState transition: &quot; + state + &quot; -&gt; &quot; + s);</span>
		} else {
<span class="fc" id="L664">			setStateUnchecked(s);</span>
		}
<span class="fc" id="L666">	}</span>

	/**
	 * Actually set the unit state.
	 *
	 * @param s
	 *            The new &lt;code&gt;UnitState&lt;/code&gt;.
	 */
	protected void setStateUnchecked(UnitState s) {
		// FIXME: move to the server.
		// Cleanup the old UnitState, for example destroy the
		// TileImprovment being built by a pioneer.
<span class="fc bfc" id="L678" title="All 2 branches covered.">		switch (state) {</span>
		case IMPROVING:
<span class="pc bpc" id="L680" title="3 of 4 branches missed.">			if (workImprovement != null &amp;&amp; getWorkLeft() &gt; 0) {</span>
<span class="nc bnc" id="L681" title="All 4 branches missed.">				if (!workImprovement.isComplete() &amp;&amp; workImprovement.getTile() != null</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">						&amp;&amp; workImprovement.getTile().getTileItemContainer() != null) {</span>
<span class="nc" id="L683">					workImprovement.getTile().getTileItemContainer().removeTileItem(workImprovement);</span>
				}
<span class="nc" id="L685">				setWorkImprovement(null);</span>
			}
			break;
		default:
			// do nothing
			break;
		}

		// Now initiate the new UnitState
<span class="pc bpc" id="L694" title="1 of 7 branches missed.">		switch (s) {</span>
		case ACTIVE:
<span class="fc" id="L696">			setWorkLeft(-1);</span>
<span class="fc" id="L697">			break;</span>
		case SENTRY:
<span class="fc" id="L699">			setWorkLeft(-1);</span>
<span class="fc" id="L700">			break;</span>
		case FORTIFIED:
<span class="fc" id="L702">			setWorkLeft(-1);</span>
<span class="fc" id="L703">			movesLeft = 0;</span>
<span class="fc" id="L704">			break;</span>
		case FORTIFYING:
<span class="fc" id="L706">			setWorkLeft(1);</span>
<span class="fc" id="L707">			break;</span>
		case IMPROVING:
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">			if (workImprovement == null) {</span>
<span class="nc" id="L710">				setWorkLeft(-1);</span>
			} else {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">				setWorkLeft(workImprovement.getTurnsToComplete() + ((getMovesLeft() &gt; 0) ? 0 : 1));</span>
			}
<span class="fc" id="L714">			movesLeft = 0;</span>
<span class="fc" id="L715">			break;</span>
		case SKIPPED: // do nothing
<span class="nc" id="L717">			break;</span>
		default:
<span class="fc" id="L719">			setWorkLeft(-1);</span>
		}
<span class="fc" id="L721">		state = s;</span>
<span class="fc" id="L722">	}</span>

	/**
	 * Sets the given state to all the units that are carried.
	 *
	 * @param state
	 *            The &lt;code&gt;UnitState&lt;/code&gt; to set..
	 */
	public void setStateToAllChildren(UnitState state) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">		if (canCarryUnits()) {</span>
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">			for (Unit u : getUnitList()) {</span>
<span class="nc" id="L733">				u.setState(state);</span>
<span class="nc" id="L734">			}</span>
		}
<span class="fc" id="L736">	}</span>

	/**
	 * Change the owner of this unit.
	 *
	 * -vis: This routine calls setOwner() and thus has visibility implications.
	 * Ideally it should be in ServerUnit but we keep it here for the benefit of
	 * the test suite.
	 *
	 * @param owner
	 *            The new owner &lt;code&gt;Player&lt;/code&gt;.
	 */
	public void changeOwner(Player owner) {
<span class="fc" id="L749">		final Player oldOwner = this.owner;</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">		if (oldOwner == owner) {</span>
<span class="nc" id="L751">			return;</span>
		}

<span class="pc bpc" id="L754" title="1 of 2 branches missed.">		if (oldOwner == null) {</span>
<span class="nc" id="L755">			logger.warning(&quot;Unit &quot; + getId() + &quot; had no owner, when changing owner to &quot; + owner.getId());</span>
		}

		// This need to be set right away.
<span class="fc" id="L759">		setOwner(owner);</span>

		// Clear trade route and goto orders if changing owner.
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">		if (getTradeRoute() != null) {</span>
<span class="nc" id="L763">			setTradeRoute(null);</span>
		}
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">		if (getDestination() != null) {</span>
<span class="nc" id="L766">			setDestination(null);</span>
		}

		// If its a carrier, we need to update the units it has loaded
		// before finishing with it
<span class="fc bfc" id="L771" title="All 2 branches covered.">		for (Unit u : getUnitList()) {</span>
<span class="fc" id="L772">			u.changeOwner(owner);</span>
<span class="fc" id="L773">		}</span>

<span class="pc bpc" id="L775" title="3 of 4 branches missed.">		if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="nc" id="L776">			getTeacher().setStudent(null);</span>
<span class="nc" id="L777">			setTeacher(null);</span>
		}

<span class="pc bpc" id="L780" title="1 of 2 branches missed.">		if (oldOwner != null) {</span>
<span class="fc" id="L781">			oldOwner.removeUnit(this);</span>
		}
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">		if (owner != null) {</span>
<span class="fc" id="L784">			owner.addUnit(this);</span>
		}

<span class="fc" id="L787">		getGame().notifyOwnerChanged(this, oldOwner, owner);</span>
<span class="fc" id="L788">	}</span>

	/**
	 * Gets the unit role.
	 *
	 * @return The &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public Role getRole() {
<span class="fc" id="L796">		return role;</span>
	}

	/**
	 * Sets the &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
	 *
	 * @param role
	 *            The new &lt;code&gt;Role&lt;/code&gt;.
	 */
	public void setRole(Role role) {
<span class="fc" id="L806">		this.role = role;</span>
<span class="fc" id="L807">	}</span>

	/**
	 * Get the role count.
	 *
	 * @return The current role count.
	 */
	public int getRoleCount() {
<span class="fc" id="L815">		return roleCount;</span>
	}

	/**
	 * Set the role count.
	 *
	 * @param roleCount
	 *            The new role count.
	 */
	public void setRoleCount(int roleCount) {
<span class="fc" id="L825">		this.roleCount = roleCount;</span>
<span class="fc" id="L826">	}</span>

	/**
	 * Does this unit have the default role?.
	 *
	 * @return True if the unit has the default &lt;code&gt;Role&lt;/code&gt;.
	 */
	public boolean hasDefaultRole() {
<span class="fc" id="L834">		return role.isDefaultRole();</span>
	}

	/**
	 * Get the last part of the role identifier, which is often used as part of
	 * a message key.
	 *
	 * @return The role suffix.
	 */
	public String getRoleSuffix() {
<span class="fc" id="L844">		return Role.getRoleSuffix(role.getId());</span>
	}

	/**
	 * Change the current role of this unit.
	 *
	 * @param role
	 *            The new &lt;code&gt;Role&lt;/code&gt;.
	 * @param roleCount
	 *            The new role count.
	 */
	public void changeRole(Role role, int roleCount) {
<span class="fc bfc" id="L856" title="All 2 branches covered.">		if (!role.isCompatibleWith(getRole())) {</span>
			// Clear experience if changing to an incompatible role.
<span class="fc" id="L858">			setExperience(0);</span>
		}
<span class="fc" id="L860">		setRole(role);</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">		setRoleCount((role.isDefaultRole()) ? 0 : roleCount);</span>
<span class="fc" id="L862">	}</span>

	/**
	 * Change the current role count. On zero, revert to default role.
	 *
	 * @param delta
	 *            The change to apply to the role count.
	 * @return True if the role count reached zero.
	 */
	public boolean changeRoleCount(int delta) {
<span class="fc" id="L872">		this.roleCount = Math.max(0, this.roleCount + delta);</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">		if (this.roleCount != 0) {</span>
<span class="fc" id="L874">			return false;</span>
		}
<span class="fc" id="L876">		this.role = getSpecification().getDefaultRole();</span>
<span class="fc" id="L877">		return true;</span>
	}

	/**
	 * Is a role available to this unit?.
	 *
	 * @param role
	 *            The &lt;code&gt;Role&lt;/code&gt; to test.
	 * @return True if the role is available to this unit.
	 */
	public boolean roleIsAvailable(Role role) {
<span class="fc" id="L888">		return role.isAvailableTo(this);</span>
	}

	/**
	 * Filter a list of roles to return only those available to this unit.
	 *
	 * @param roles
	 *            The list of &lt;code&gt;Role&lt;/code&gt;s to filter, if null all
	 *            available roles are used.
	 * @return A list of available &lt;code&gt;Role&lt;/code&gt;s.
	 */
	public List&lt;Role&gt; getAvailableRoles(List&lt;Role&gt; roles) {
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">		if (roles == null) {</span>
<span class="nc" id="L901">			roles = getSpecification().getRoles();</span>
		}
<span class="fc" id="L903">		return roles.stream().filter(r -&gt; roleIsAvailable(r)).collect(Collectors.toList());</span>
	}

	/**
	 * Get a military role for this unit.
	 *
	 * @return A military &lt;code&gt;Role&lt;/code&gt;, or null if none found.
	 */
	public Role getMilitaryRole() {
<span class="fc" id="L912">		List&lt;Role&gt; roles = getAvailableRoles(getSpecification().getMilitaryRoles());</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">		return (roles.isEmpty()) ? null : roles.get(0);</span>
	}

	/**
	 * Get the change in goods required to change to a new role/count.
	 *
	 * @param role
	 *            The new &lt;code&gt;Role&lt;/code&gt; to change to.
	 * @param roleCount
	 *            The new role count.
	 * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; defining the change in goods
	 *         required.
	 */
	public List&lt;AbstractGoods&gt; getGoodsDifference(Role role, int roleCount) {
<span class="fc" id="L927">		return Role.getGoodsDifference(getRole(), getRoleCount(), role, roleCount);</span>
	}

	/**
	 * Sets the units location without updating any other variables
	 *
	 * get/setLocation are in Locatable interface.
	 *
	 * -vis: This routine changes player visibility.
	 *
	 * @param newLocation
	 *            The new &lt;code&gt;Location&lt;/code&gt;.
	 */
	public void setLocationNoUpdate(Location newLocation) {
<span class="fc" id="L941">		location = newLocation;</span>
<span class="fc" id="L942">	}</span>

	/**
	 * Verifies if the unit is aboard a carrier.
	 *
	 * @return True if the unit is aboard a carrier.
	 */
	public boolean isOnCarrier() {
<span class="fc" id="L950">		return getLocation() instanceof Unit;</span>
	}

	/**
	 * Gets the carrier this unit is aboard if any.
	 *
	 * @return The carrier this unit is aboard, or null if none.
	 */
	public Unit getCarrier() {
<span class="fc bfc" id="L959" title="All 2 branches covered.">		return (isOnCarrier()) ? ((Unit) getLocation()) : null;</span>
	}

	/**
	 * Checks whether this &lt;code&gt;Unit&lt;/code&gt; is at sea off the map, or on board
	 * of a carrier that is.
	 *
	 * @return True if at sea.
	 */
	public boolean isAtSea() {
<span class="fc bfc" id="L969" title="All 2 branches covered.">		return (location instanceof Unit) ? ((Unit) location).isAtSea() : location instanceof HighSeas;</span>
	}

	/**
	 * Checks if this unit is running a mission.
	 *
	 * @return True if this unit is running a mission.
	 */
	public boolean isInMission() {
<span class="pc bpc" id="L978" title="3 of 4 branches missed.">		return hasAbility(Ability.ESTABLISH_MISSION) &amp;&amp; (getLocation() instanceof IndianSettlement</span>
				// @compat 0.10.x
				// Remove this when PET missionary serialization is retired
<span class="pc bnc" id="L981" title="All 2 branches missed.">				|| getLocation() == null</span>
		// end @compat 0.10.x
		);
	}

	/**
	 * Checks whether this unit is working inside a colony.
	 *
	 * @return True if in colony.
	 */
	public boolean isInColony() {
<span class="fc" id="L992">		return getLocation() instanceof WorkLocation;</span>
	}

	/**
	 * Is this unit on a tile?.
	 *
	 * @return True if this unit is on a tile.
	 */
	public boolean hasTile() {
<span class="fc bfc" id="L1001" title="All 2 branches covered.">		return getTile() != null;</span>
	}

	/**
	 * Gets the work location this unit is working in.
	 *
	 * @return The current &lt;code&gt;WorkLocation&lt;/code&gt;, or null if none.
	 */
	public WorkLocation getWorkLocation() {
<span class="fc bfc" id="L1010" title="All 2 branches covered.">		return (isInColony()) ? (WorkLocation) getLocation() : null;</span>
	}

	/**
	 * Gets the &lt;code&gt;Building&lt;/code&gt; this unit is working in.
	 *
	 * @return The current &lt;code&gt;Building&lt;/code&gt;, or null if none.
	 */
	public Building getWorkBuilding() {
<span class="nc bnc" id="L1019" title="All 2 branches missed.">		if (getLocation() instanceof Building) {</span>
<span class="nc" id="L1020">			return ((Building) getLocation());</span>
		}
<span class="nc" id="L1022">		return null;</span>
	}

	/**
	 * Gets the &lt;code&gt;ColonyTile&lt;/code&gt; this unit is working in.
	 *
	 * @return The current &lt;code&gt;ColonyTile&lt;/code&gt;, or null if none.
	 */
	public ColonyTile getWorkTile() {
<span class="nc bnc" id="L1031" title="All 2 branches missed.">		if (getLocation() instanceof ColonyTile) {</span>
<span class="nc" id="L1032">			return ((ColonyTile) getLocation());</span>
		}
<span class="nc" id="L1034">		return null;</span>
	}

	/**
	 * Gets the entry location for this unit to use when returning from
	 * {@link Europe}.
	 *
	 * @return The entry &lt;code&gt;Location&lt;/code&gt;.
	 */
	public Location getEntryLocation() {
<span class="nc bnc" id="L1044" title="All 2 branches missed.">		if (entryLocation == null) {</span>
<span class="nc" id="L1045">			entryLocation = owner.getEntryLocation();</span>
		}
<span class="nc" id="L1047">		return entryLocation;</span>
	}

	/**
	 * Sets the entry location in which this unit will be put when returning
	 * from {@link Europe}.
	 *
	 * @param entryLocation
	 *            The new entry &lt;code&gt;Location&lt;/code&gt;.
	 * @see #getEntryLocation
	 */
	public void setEntryLocation(Location entryLocation) {
<span class="fc" id="L1059">		this.entryLocation = entryLocation;</span>
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">		if (entryLocation != null) {</span>
<span class="fc" id="L1061">			owner.setEntryLocation(entryLocation);</span>
		}
<span class="fc" id="L1063">	}</span>

	/**
	 * Gets the entry tile for this unit, or if null the default entry location
	 * for the owning player.
	 *
	 * @return The entry &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public Tile getFullEntryLocation() {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">		return (entryLocation != null) ? (Tile) entryLocation</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">				: (owner.getEntryLocation() == null) ? null : owner.getEntryLocation().getTile();</span>
	}

	/**
	 * Get the moves left this turn.
	 *
	 * @return The number of moves this &lt;code&gt;Unit&lt;/code&gt; has left.
	 */
	@Override
	public int getMovesLeft() {
<span class="fc" id="L1083">		return movesLeft;</span>
	}

	/**
	 * Sets the moves left this turn.
	 *
	 * @param moves
	 *            The new amount of moves left this &lt;code&gt;Unit&lt;/code&gt; should
	 *            have.
	 */
	public void setMovesLeft(int moves) {
<span class="fc bfc" id="L1094" title="All 2 branches covered.">		this.movesLeft = (moves &lt; 0) ? 0 : moves;</span>
<span class="fc" id="L1095">	}</span>

	/**
	 * Gets the type of goods this unit is producing in its current occupation.
	 *
	 * @return The type of goods this unit is producing.
	 */
	public GoodsType getWorkType() {
<span class="fc" id="L1103">		return workType;</span>
	}

	/**
	 * Set the type of goods this unit is producing in its current occupation.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 */
	public void setWorkType(GoodsType type) {
<span class="fc" id="L1113">		this.workType = type;</span>
<span class="fc" id="L1114">	}</span>

	/**
	 * Change the type of goods this unit is producing in its current
	 * occupation. Updates the work location production and the unit experience
	 * type if necessary.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 */
	public void changeWorkType(GoodsType type) {
<span class="fc" id="L1125">		setWorkType(type);</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">		if (type != null) {</span>
<span class="fc" id="L1127">			experienceType = type;</span>
		}
<span class="fc" id="L1129">		WorkLocation wl = getWorkLocation();</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">		if (wl != null) {</span>
<span class="fc" id="L1131">			wl.updateProductionType();</span>
		}
<span class="fc" id="L1133">	}</span>

	/**
	 * Gets the type of goods this unit has accrued experience producing.
	 *
	 * @return The type of goods this unit would produce.
	 */
	public GoodsType getExperienceType() {
<span class="fc" id="L1141">		return experienceType;</span>
	}

	/**
	 * Gets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 * experienceType.
	 *
	 * @return The experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 *         experienceType.
	 * @see #modifyExperience
	 */
	public int getExperience() {
<span class="fc" id="L1153">		return experience;</span>
	}

	/**
	 * Sets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 * experienceType.
	 *
	 * @param experience
	 *            The new experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 *            experienceType.
	 * @see #modifyExperience
	 */
	public void setExperience(int experience) {
<span class="fc" id="L1166">		this.experience = Math.min(experience, getType().getMaximumExperience());</span>
<span class="fc" id="L1167">	}</span>

	/**
	 * Modifies the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
	 * experienceType.
	 *
	 * @param value
	 *            The value by which to modify the experience of this
	 *            &lt;code&gt;Unit&lt;/code&gt;.
	 * @see #getExperience
	 */
	public void modifyExperience(int value) {
<span class="fc" id="L1179">		experience += value;</span>
<span class="fc" id="L1180">	}</span>

	/**
	 * Gets the amount of work left.
	 *
	 * @return The amount of work left.
	 */
	public int getWorkLeft() {
<span class="fc" id="L1188">		return workLeft;</span>
	}

	/**
	 * Sets the amount of work left.
	 *
	 * @param workLeft
	 *            The new amount of work left.
	 */
	public void setWorkLeft(int workLeft) {
<span class="fc" id="L1198">		this.workLeft = workLeft;</span>
<span class="fc" id="L1199">	}</span>

	/**
	 * Get the number of turns of work left.
	 *
	 * @return The number of turns of work left.
	 */
	public int getWorkTurnsLeft() {
<span class="pc bpc" id="L1207" title="1 of 4 branches missed.">		return (state == UnitState.IMPROVING &amp;&amp; unitType.hasAbility(Ability.EXPERT_PIONEER)) ? (getWorkLeft() + 1) / 2</span>
<span class="fc" id="L1208">				: getWorkLeft();</span>
	}

	/**
	 * Gets the TileImprovement that this pioneer is contributing to.
	 *
	 * @return The &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is working on.
	 */
	public TileImprovement getWorkImprovement() {
<span class="fc" id="L1217">		return workImprovement;</span>
	}

	/**
	 * Sets the TileImprovement that this pioneer is contributing to.
	 *
	 * @param imp
	 *            The new &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is to work
	 *            on.
	 */
	public void setWorkImprovement(TileImprovement imp) {
<span class="fc" id="L1228">		workImprovement = imp;</span>
<span class="fc" id="L1229">	}</span>

	/**
	 * Get the unit being taught.
	 *
	 * @return A student &lt;code&gt;Unit&lt;/code&gt; if any.
	 */
	public final Unit getStudent() {
<span class="fc" id="L1237">		return student;</span>
	}

	/**
	 * Set the student unit.
	 *
	 * @param newStudent
	 *            The new student &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final void setStudent(final Unit newStudent) {
<span class="fc" id="L1247">		Unit oldStudent = this.student;</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">		if (oldStudent == newStudent) {</span>
<span class="fc" id="L1249">			return;</span>
		}

<span class="fc bfc" id="L1252" title="All 2 branches covered.">		if (newStudent == null) {</span>
<span class="fc" id="L1253">			this.student = null;</span>
<span class="pc bpc" id="L1254" title="1 of 4 branches missed.">			if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="fc" id="L1255">				oldStudent.setTeacher(null);</span>
			}
<span class="pc bpc" id="L1257" title="2 of 4 branches missed.">		} else if (newStudent.getColony() != null &amp;&amp; newStudent.getColony() == getColony()</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">				&amp;&amp; newStudent.canBeStudent(this)) {</span>
<span class="pc bpc" id="L1259" title="3 of 4 branches missed.">			if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="nc" id="L1260">				oldStudent.setTeacher(null);</span>
			}
<span class="fc" id="L1262">			this.student = newStudent;</span>
<span class="fc" id="L1263">			newStudent.setTeacher(this);</span>
		} else {
<span class="nc" id="L1265">			throw new IllegalStateException(&quot;Unit can not be student: &quot; + newStudent);</span>
		}
<span class="fc" id="L1267">	}</span>

	/**
	 * Get the unit teaching this one.
	 *
	 * @return A teacher &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final Unit getTeacher() {
<span class="fc" id="L1275">		return teacher;</span>
	}

	/**
	 * Set the teacher for this unit.
	 *
	 * @param newTeacher
	 *            The new teacher &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final void setTeacher(final Unit newTeacher) {
<span class="fc" id="L1285">		Unit oldTeacher = this.teacher;</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">		if (newTeacher == oldTeacher) {</span>
<span class="fc" id="L1287">			return;</span>
		}

<span class="fc bfc" id="L1290" title="All 2 branches covered.">		if (newTeacher == null) {</span>
<span class="fc" id="L1291">			this.teacher = null;</span>
<span class="pc bpc" id="L1292" title="1 of 4 branches missed.">			if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1293">				oldTeacher.setStudent(null);</span>
			}
		} else {
<span class="fc" id="L1296">			UnitType skillTaught = newTeacher.getType().getSkillTaught();</span>
<span class="pc bpc" id="L1297" title="2 of 4 branches missed.">			if (newTeacher.getColony() != null &amp;&amp; newTeacher.getColony() == getColony()</span>
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">					&amp;&amp; getColony().canTrain(skillTaught)) {</span>
<span class="pc bpc" id="L1299" title="1 of 4 branches missed.">				if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1300">					oldTeacher.setStudent(null);</span>
				}
<span class="fc" id="L1302">				this.teacher = newTeacher;</span>
<span class="fc" id="L1303">				this.teacher.setStudent(this);</span>
			} else {
<span class="nc" id="L1305">				throw new IllegalStateException(&quot;Unit can not be teacher: &quot; + newTeacher);</span>
			}
		}
<span class="fc" id="L1308">	}</span>

	/**
	 * Gets the number of turns this unit has been training.
	 *
	 * @return The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has given.
	 * @see #setTurnsOfTraining
	 * @see #getNeededTurnsOfTraining
	 */
	public int getTurnsOfTraining() {
<span class="fc" id="L1318">		return turnsOfTraining;</span>
	}

	/**
	 * Sets the number of turns this unit has been training.
	 *
	 * @param turnsOfTraining
	 *            The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has
	 *            given.
	 * @see #getNeededTurnsOfTraining
	 */
	public void setTurnsOfTraining(int turnsOfTraining) {
<span class="fc" id="L1330">		this.turnsOfTraining = turnsOfTraining;</span>
<span class="fc" id="L1331">	}</span>

	/**
	 * Gets the number of turns this unit has to train to educate a student.
	 * This value is only meaningful for units that can be put in a school.
	 *
	 * @return The turns of training needed to teach its current type to a free
	 *         colonist or to promote an indentured servant or a petty criminal.
	 * @see #getTurnsOfTraining
	 */
	public int getNeededTurnsOfTraining() {
		// number of turns is 4/6/8 for skill 1/2/3
<span class="fc" id="L1343">		int result = 0;</span>
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">		if (student != null) {</span>
<span class="fc" id="L1345">			result = getNeededTurnsOfTraining(unitType, student.unitType);</span>
<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">			if (getColony() != null) {</span>
<span class="fc" id="L1347">				result -= getColony().getProductionBonus();</span>
			}
		}
<span class="fc" id="L1350">		return result;</span>
	}

	/**
	 * Gets the number of turns this unit has to train to educate a student.
	 * This value is only meaningful for units that can be put in a school.
	 *
	 * @param typeTeacher
	 *            The teacher &lt;code&gt;UnitType&lt;/code&gt;.
	 * @param typeStudent
	 *            the student &lt;code&gt;UnitType&lt;/code&gt;.
	 * @return The turns of training needed to teach its current type to a free
	 *         colonist or to promote an indentured servant or a petty criminal.
	 * @see #getTurnsOfTraining
	 */
	public int getNeededTurnsOfTraining(UnitType typeTeacher, UnitType typeStudent) {
<span class="fc" id="L1366">		UnitType teaching = getUnitTypeTeaching(typeTeacher, typeStudent);</span>
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">		if (teaching != null) {</span>
<span class="fc" id="L1368">			return typeStudent.getEducationTurns(teaching);</span>
		} else {
<span class="nc" id="L1370">			throw new IllegalStateException(&quot;typeTeacher=&quot; + typeTeacher + &quot; typeStudent=&quot; + typeStudent);</span>
		}
	}

	/**
	 * Gets the UnitType which a teacher is teaching to a student. This value is
	 * only meaningful for teachers that can be put in a school.
	 *
	 * @param typeTeacher
	 *            The teacher &lt;code&gt;UnitType&lt;/code&gt;.
	 * @param typeStudent
	 *            The student &lt;code&gt;UnitType&lt;/code&gt;.
	 * @return The &lt;code&gt;UnitType&lt;/code&gt; taught.
	 * @see #getTurnsOfTraining
	 *
	 */
	public static UnitType getUnitTypeTeaching(UnitType typeTeacher, UnitType typeStudent) {
<span class="fc" id="L1387">		UnitType skillTaught = typeTeacher.getSkillTaught();</span>
<span class="fc bfc" id="L1388" title="All 2 branches covered.">		if (typeStudent.canBeUpgraded(skillTaught, ChangeType.EDUCATION)) {</span>
<span class="fc" id="L1389">			return skillTaught;</span>
		} else {
<span class="fc" id="L1391">			return typeStudent.getEducationUnit(0);</span>
		}
	}

	/**
	 * Can this unit be a student?.
	 *
	 * @param teacher
	 *            The teacher &lt;code&gt;Unit&lt;/code&gt; which is trying to teach it.
	 * @return True if the unit can be taught by the teacher.
	 */
	public boolean canBeStudent(Unit teacher) {
<span class="fc bfc" id="L1403" title="All 4 branches covered.">		return teacher != this &amp;&amp; canBeStudent(unitType, teacher.unitType);</span>
	}

	/**
	 * Can a unit be a student?.
	 *
	 * @param typeStudent
	 *            The student &lt;code&gt;UnitType&lt;/code&gt;.
	 * @param typeTeacher
	 *            The teacher &lt;code&gt;UnitType&lt;/code&gt;.
	 * @return True if the student can be taught by the teacher.
	 */
	public boolean canBeStudent(UnitType typeStudent, UnitType typeTeacher) {
<span class="fc bfc" id="L1416" title="All 2 branches covered.">		return getUnitTypeTeaching(typeTeacher, typeStudent) != null;</span>
	}

	/**
	 * Gets the nationality of this Unit.
	 *
	 * Nationality represents a Unit's personal allegiance to a nation. This may
	 * conflict with who currently issues orders to the Unit (the owner).
	 *
	 * @return The nationality of this Unit.
	 */
	public String getNationality() {
<span class="nc" id="L1428">		return nationality;</span>
	}

	/**
	 * Sets the nationality of this Unit. A unit will change nationality when it
	 * switches owners willingly. Currently only Converts do this, but it opens
	 * the possibility of naturalisation.
	 *
	 * @param newNationality
	 *            The new nationality of this Unit.
	 */
	public void setNationality(String newNationality) {
<span class="nc bnc" id="L1440" title="All 2 branches missed.">		if (isPerson()) {</span>
<span class="nc" id="L1441">			nationality = newNationality;</span>
		} else {
<span class="nc" id="L1443">			throw new UnsupportedOperationException(&quot;Can not set the nationality of a Unit which is not a person!&quot;);</span>
		}
<span class="nc" id="L1445">	}</span>

	/**
	 * Gets the ethnicity of this Unit.
	 *
	 * Ethnicity is inherited from the inhabitants of the place where the Unit
	 * was born. Allows former converts to become native-looking colonists.
	 *
	 * @return The ethnicity of this Unit.
	 */
	public String getEthnicity() {
<span class="nc" id="L1456">		return ethnicity;</span>
	}

	/**
	 * Sets the ethnicity of this Unit.
	 *
	 * @param newEthnicity
	 *            The new ethnicity of this Unit.
	 */
	public void setEthnicity(String newEthnicity) {
<span class="nc" id="L1466">		this.ethnicity = newEthnicity;</span>
<span class="nc" id="L1467">	}</span>

	/**
	 * Identifies whether this unit came from a native tribe.
	 *
	 * @return Whether this unit looks native or not.
	 */
	public boolean hasNativeEthnicity() {
		try {
			// FIXME: getNation() could fail, but getNationType()
			// doesn't work as expected
<span class="nc" id="L1478">			return getGame().getSpecification().getNation(ethnicity).getType().isIndian();</span>
<span class="nc" id="L1479">		} catch (Exception e) {</span>
<span class="nc" id="L1480">			return false;</span>
		}
	}

	/**
	 * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; home for this unit.
	 *
	 * @return The home &lt;code&gt;IndianSettlement&lt;/code&gt; of this unit.
	 */
	public IndianSettlement getHomeIndianSettlement() {
<span class="fc" id="L1490">		return indianSettlement;</span>
	}

	/**
	 * Sets the home &lt;code&gt;IndianSettlement&lt;/code&gt; for this unit.
	 *
	 * @param indianSettlement
	 *            The &lt;code&gt;IndianSettlement&lt;/code&gt; that should now own this
	 *            &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public void setHomeIndianSettlement(IndianSettlement indianSettlement) {
<span class="fc bfc" id="L1501" title="All 2 branches covered.">		if (this.indianSettlement != null) {</span>
<span class="fc" id="L1502">			this.indianSettlement.removeOwnedUnit(this);</span>
		}

<span class="fc" id="L1505">		this.indianSettlement = indianSettlement;</span>

<span class="fc bfc" id="L1507" title="All 2 branches covered.">		if (indianSettlement != null) {</span>
<span class="fc" id="L1508">			indianSettlement.addOwnedUnit(this);</span>
		}
<span class="fc" id="L1510">	}</span>

	/**
	 * Gets the unit hit points.
	 *
	 * This is currently only used for damaged ships, but might get an extended
	 * use later.
	 *
	 * @return The hit points this &lt;code&gt;Unit&lt;/code&gt; has.
	 * @see UnitType#getHitPoints
	 */
	public int getHitPoints() {
<span class="nc" id="L1522">		return hitPoints;</span>
	}

	/**
	 * Sets the hit points for this unit.
	 *
	 * @param hitPoints
	 *            The new hit points for this unit.
	 */
	public void setHitPoints(int hitPoints) {
<span class="fc" id="L1532">		this.hitPoints = hitPoints;</span>
<span class="fc" id="L1533">	}</span>

	/**
	 * Checks if this unit is under repair.
	 *
	 * @return True if under repair.
	 */
	public boolean isDamaged() {
<span class="fc bfc" id="L1541" title="All 2 branches covered.">		return hitPoints &lt; unitType.getHitPoints();</span>
	}

	/**
	 * Get how many turns left to be repaired.
	 *
	 * @return The number of turns left to be repaired.
	 */
	public int getTurnsForRepair() {
<span class="nc" id="L1550">		return unitType.getHitPoints() - getHitPoints();</span>
	}

	/**
	 * Get the destination of this unit.
	 *
	 * @return The destination &lt;code&gt;Location&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public Location getDestination() {
<span class="fc" id="L1559">		return destination;</span>
	}

	/**
	 * Sets the destination of this unit.
	 *
	 * @param newDestination
	 *            The new destination &lt;code&gt;Location&lt;/code&gt;.
	 */
	public void setDestination(Location newDestination) {
<span class="fc" id="L1569">		this.destination = newDestination;</span>
<span class="fc" id="L1570">	}</span>

	/**
	 * Get the unit trade route, if any.
	 *
	 * @return The &lt;code&gt;TradeRoute&lt;/code&gt;, or null if none.
	 */
	public final TradeRoute getTradeRoute() {
<span class="fc" id="L1578">		return tradeRoute;</span>
	}

	/**
	 * Set the unit trade route.
	 *
	 * @param newTradeRoute
	 *            The new &lt;code&gt;TradeRoute&lt;/code&gt; value.
	 */
	public final void setTradeRoute(final TradeRoute newTradeRoute) {
<span class="fc" id="L1588">		this.tradeRoute = newTradeRoute;</span>
<span class="fc" id="L1589">	}</span>

	/**
	 * Get the stop the unit is heading for or at.
	 *
	 * @return The target &lt;code&gt;Stop&lt;/code&gt;.
	 */
	public TradeRouteStop getStop() {
<span class="nc bnc" id="L1597" title="All 2 branches missed.">		return (validateCurrentStop() &lt; 0) ? null : getTradeRoute().getStops().get(currentStop);</span>
	}

	/**
	 * Get the stop the unit is heading for or at.
	 *
	 * @return The target &lt;code&gt;Stop&lt;/code&gt;.
	 */
	public List&lt;TradeRouteStop&gt; getCurrentStops() {
<span class="nc bnc" id="L1606" title="All 2 branches missed.">		if (validateCurrentStop() &lt; 0) {</span>
<span class="nc" id="L1607">			return null;</span>
		}
<span class="nc" id="L1609">		List&lt;TradeRouteStop&gt; stops = new ArrayList&lt;TradeRouteStop&gt;(getTradeRoute().getStops());</span>
<span class="nc" id="L1610">		rotate(stops, currentStop);</span>
<span class="nc" id="L1611">		return stops;</span>
	}

	/**
	 * Get the current trade route stop.
	 *
	 * @return The current stop index.
	 */
	public int getCurrentStop() {
<span class="nc" id="L1620">		return currentStop;</span>
	}

	/**
	 * Set the current stop.
	 *
	 * @param currentStop
	 *            A new value for the currentStop.
	 */
	public void setCurrentStop(int currentStop) {
<span class="nc" id="L1630">		this.currentStop = currentStop;</span>
<span class="nc" id="L1631">	}</span>

	/**
	 * Validate and return the current stop.
	 *
	 * @return The current stop index, or negative on failure.
	 */
	public int validateCurrentStop() {
<span class="nc bnc" id="L1639" title="All 2 branches missed.">		if (tradeRoute == null) {</span>
<span class="nc" id="L1640">			currentStop = -1;</span>
		} else {
<span class="nc" id="L1642">			List&lt;TradeRouteStop&gt; stops = tradeRoute.getStops();</span>
<span class="nc bnc" id="L1643" title="All 4 branches missed.">			if (stops == null || stops.isEmpty()) {</span>
<span class="nc" id="L1644">				currentStop = -1;</span>
			} else {
<span class="nc bnc" id="L1646" title="All 4 branches missed.">				if (currentStop &lt; 0 || currentStop &gt;= stops.size()) {</span>
					// The current stop can become out of range if the trade
					// route is modified.
<span class="nc" id="L1649">					currentStop = 0;</span>
				}
			}
		}
<span class="nc" id="L1653">		return currentStop;</span>
	}

	/**
	 * Convenience function to check if a unit is at a stop.
	 *
	 * @param stop
	 *            The &lt;code&gt;TradeRouteStop&lt;/code&gt; to check.
	 * @return True if the unit is at the given stop.
	 */
	public boolean atStop(TradeRouteStop stop) {
<span class="nc" id="L1664">		return Map.isSameLocation(getLocation(), stop.getLocation());</span>
	}

	/**
	 * Get the current trade location.
	 *
	 * @return The &lt;code&gt;TradeLocation&lt;/code&gt; for this unit.
	 */
	public TradeLocation getTradeLocation() {
		Colony colony;
		IndianSettlement is;
<span class="nc bnc" id="L1675" title="All 2 branches missed.">		return ((colony = getColony()) != null) ? colony</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">				: ((is = getIndianSettlement()) != null) ? is</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">						: (isInEurope()) ? (TradeLocation) getOwner().getEurope() : null;</span>
	}

	/**
	 * Get the current amount of treasure in this unit.
	 *
	 * @return The amount of treasure.
	 * @exception IllegalStateException
	 *                if this is not a treasure carrying unit.
	 */
	public int getTreasureAmount() {
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">		if (!canCarryTreasure()) {</span>
<span class="nc" id="L1689">			throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
		}
<span class="fc" id="L1691">		return treasureAmount;</span>
	}

	/**
	 * Set the amount of treasure in this unit.
	 *
	 * @param amount
	 *            The new amount of treasure.
	 */
	public void setTreasureAmount(int amount) {
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">		if (!canCarryTreasure()) {</span>
<span class="nc" id="L1702">			throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
		}
<span class="fc" id="L1704">		this.treasureAmount = amount;</span>
<span class="fc" id="L1705">	}</span>

	/**
	 * Gets the attrition of this unit.
	 *
	 * @return The attrition of this unit.
	 */
	public int getAttrition() {
<span class="fc" id="L1713">		return attrition;</span>
	}

	/**
	 * Sets the attrition of this unit.
	 *
	 * @param attrition
	 *            The new attrition of this unit.
	 */
	public void setAttrition(int attrition) {
<span class="fc" id="L1723">		this.attrition = attrition;</span>
<span class="fc" id="L1724">	}</span>

	/**
	 * Get the visible amount of goods that is carried by this unit.
	 *
	 * @return The visible amount of goods carried by this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public int getVisibleGoodsCount() {
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">		return (visibleGoodsCount &gt;= 0) ? visibleGoodsCount : getGoodsSpaceTaken();</span>
	}

	// Combat routines

	/**
	 * Gets a role that can be equipped automatically assumed in case of an
	 * attack.
	 *
	 * Paul Revere makes an unarmed colonist in a settlement pick up a
	 * stock-piled musket if attacked, so the bonus should be applied for
	 * unarmed colonists inside colonies where there are muskets available.
	 * Natives can also auto-arm.
	 *
	 * @return A &lt;code&gt;Role&lt;/code&gt; that can be automatically assumed by this
	 *         unit, or null if none.
	 */
	public Role getAutomaticRole() {
<span class="fc bfc" id="L1750" title="All 2 branches covered.">		if (!hasDefaultRole()) {</span>
<span class="fc" id="L1751">			return null;</span>
		}
<span class="fc" id="L1753">		Set&lt;Ability&gt; autoDefence = getAbilities(Ability.AUTOMATIC_EQUIPMENT);</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">		if (autoDefence.isEmpty())</span>
<span class="fc" id="L1755">			return null;</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">		Settlement settlement = (isInColony()) ? getColony()</span>
<span class="fc bfc" id="L1757" title="All 2 branches covered.">				: (getLocation() instanceof IndianSettlement) ? (Settlement) getLocation() : null;</span>
<span class="fc bfc" id="L1758" title="All 2 branches covered.">		if (settlement == null) {</span>
<span class="fc" id="L1759">			return null;</span>
		}

<span class="fc" id="L1762">		final Specification spec = getSpecification();</span>
<span class="fc bfc" id="L1763" title="All 2 branches covered.">		for (Ability ability : autoDefence) {</span>
<span class="fc bfc" id="L1764" title="All 2 branches covered.">			for (Scope scope : ability.getScopes()) {</span>
<span class="fc" id="L1765">				Role role = spec.getRole(scope.getType());</span>
<span class="pc bpc" id="L1766" title="1 of 4 branches missed.">				if (role != null &amp;&amp; settlement.containsGoods(getGoodsDifference(role, 1))) {</span>
<span class="fc" id="L1767">					return role;</span>
				}
<span class="fc" id="L1769">			}</span>
<span class="fc" id="L1770">		}</span>
<span class="fc" id="L1771">		return null;</span>
	}

	/**
	 * After winning a battle, can this unit capture the loser's role
	 * equipment?.
	 *
	 * @param role
	 *            The loser unit &lt;code&gt;Role&lt;/code&gt;.
	 * @return The &lt;code&gt;Role&lt;/code&gt; available to this unit as a result of
	 *         capturing the loser equipment.
	 */
	public Role canCaptureEquipment(Role role) {
<span class="fc bfc" id="L1784" title="All 2 branches covered.">		if (!hasAbility(Ability.CAPTURE_EQUIPMENT)) {</span>
<span class="fc" id="L1785">			return null;</span>
		}
<span class="fc" id="L1787">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1788">		final Role oldRole = getRole();</span>
<span class="fc bfc" id="L1789" title="All 2 branches covered.">		for (Role r : getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="fc bfc" id="L1790" title="All 2 branches covered.">			for (Role.RoleChange rc : r.getRoleChanges()) {</span>
<span class="fc bfc" id="L1791" title="All 4 branches covered.">				if (rc.getFrom(spec) == oldRole &amp;&amp; rc.getCapture(spec) == role)</span>
<span class="fc" id="L1792">					return r;</span>
<span class="fc" id="L1793">			}</span>
<span class="fc" id="L1794">		}</span>
<span class="fc" id="L1795">		return null;</span>
	}

	/**
	 * Does losing a piece of equipment mean the death of this unit?.
	 *
	 * @return True if the unit is doomed.
	 */
	public boolean losingEquipmentKillsUnit() {
<span class="pc bpc" id="L1804" title="1 of 4 branches missed.">		return hasAbility(Ability.DISPOSE_ON_ALL_EQUIPMENT_LOST) &amp;&amp; getRole().getDowngrade() == null;</span>
	}

	/**
	 * Does losing equipment mean the demotion of this unit?.
	 *
	 * @return True if the unit is to be demoted.
	 */
	public boolean losingEquipmentDemotesUnit() {
<span class="fc bfc" id="L1813" title="All 4 branches covered.">		return hasAbility(Ability.DEMOTE_ON_ALL_EQUIPMENT_LOST) &amp;&amp; getRole().getDowngrade() == null;</span>
	}

	/**
	 * Does the unit have arms?.
	 *
	 * @return True if the unit has arms.
	 */
	public boolean isArmed() {
<span class="fc" id="L1822">		return hasAbility(Ability.ARMED);</span>
	}

	/**
	 * Does the unit have a mount?.
	 *
	 * @return True if the unit have a mount.
	 */
	public boolean isMounted() {
<span class="fc" id="L1831">		return hasAbility(Ability.MOUNTED);</span>
	}

	/**
	 * Is the unit a beached ship?.
	 *
	 * @return True if the unit is a beached ship.
	 */
	public boolean isBeached() {
<span class="fc" id="L1840">		return isBeached(getTile());</span>
	}

	/**
	 * Would this unit be beached if it was on a particular tile?.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if the unit is a beached ship.
	 */
	public boolean isBeached(Tile tile) {
<span class="pc bpc" id="L1851" title="2 of 8 branches missed.">		return isNaval() &amp;&amp; tile != null &amp;&amp; tile.isLand() &amp;&amp; !tile.hasSettlement();</span>
	}

	/**
	 * Checks if this is an defensive unit. That is: a unit which can be used to
	 * defend a &lt;code&gt;Settlement&lt;/code&gt;.
	 *
	 * Note! As this method is used by the AI it really means that the unit can
	 * defend as is. To be specific an unarmed colonist is not defensive yet,
	 * even if Paul Revere and stockpiled muskets are available. That check is
	 * only performed on an actual attack.
	 *
	 * A settlement is lost when there are no more defensive units.
	 *
	 * @return True if this is a defensive unit meaning it can be used to defend
	 *         a &lt;code&gt;Colony&lt;/code&gt;. This would normally mean that a defensive
	 *         unit also will be offensive.
	 */
	public boolean isDefensiveUnit() {
<span class="pc bpc" id="L1870" title="2 of 6 branches missed.">		return (unitType.isDefensive() || getRole().isDefensive()) &amp;&amp; !isCarrier(); // Not</span>
																					// wagons
																					// or
																					// ships
	}

	/**
	 * Checks if this is an offensive unit. That is, one that can attack other
	 * units.
	 *
	 * @return True if this is an offensive unit.
	 */
	public boolean isOffensiveUnit() {
<span class="fc bfc" id="L1883" title="All 4 branches covered.">		return unitType.isOffensive() || getRole().isOffensive();</span>
	}

	/**
	 * Is an alternate unit a better defender than the current choice. Prefer if
	 * there is no current defender, or if the alternate unit is better armed,
	 * or provides greater defensive power and does not replace a defensive unit
	 * defender with a non-defensive unit.
	 *
	 * @param defender
	 *            The current defender &lt;code&gt;Unit&lt;/code&gt;.
	 * @param defenderPower
	 *            Its defence power.
	 * @param other
	 *            An alternate &lt;code&gt;Unit&lt;/code&gt;.
	 * @param otherPower
	 *            Its defence power.
	 * @return True if the other unit should be preferred.
	 */
	public static boolean betterDefender(Unit defender, double defenderPower, Unit other, double otherPower) {
<span class="fc bfc" id="L1903" title="All 2 branches covered.">		if (defender == null) {</span>
<span class="fc" id="L1904">			return true;</span>
<span class="pc bpc" id="L1905" title="3 of 8 branches missed.">		} else if (defender.isPerson() &amp;&amp; other.isPerson() &amp;&amp; !defender.isArmed() &amp;&amp; other.isArmed()) {</span>
<span class="nc" id="L1906">			return true;</span>
<span class="pc bpc" id="L1907" title="3 of 8 branches missed.">		} else if (defender.isPerson() &amp;&amp; other.isPerson() &amp;&amp; defender.isArmed() &amp;&amp; !other.isArmed()) {</span>
<span class="nc" id="L1908">			return false;</span>
<span class="pc bpc" id="L1909" title="1 of 4 branches missed.">		} else if (!defender.isDefensiveUnit() &amp;&amp; other.isDefensiveUnit()) {</span>
<span class="nc" id="L1910">			return true;</span>
<span class="pc bpc" id="L1911" title="1 of 4 branches missed.">		} else if (defender.isDefensiveUnit() &amp;&amp; !other.isDefensiveUnit()) {</span>
<span class="nc" id="L1912">			return false;</span>
		} else {
<span class="pc bpc" id="L1914" title="1 of 2 branches missed.">			return defenderPower &lt; otherPower;</span>
		}
	}

	/**
	 * Finds the closest &lt;code&gt;Location&lt;/code&gt; to this tile where this ship can
	 * be repaired, excluding the current colony.
	 *
	 * @return The closest &lt;code&gt;Location&lt;/code&gt; where a ship can be repaired.
	 */
	public Location getRepairLocation() {
<span class="fc" id="L1925">		final Player player = getOwner();</span>
<span class="fc" id="L1926">		final Colony notHere = getTile().getColony();</span>
<span class="fc" id="L1927">		Location best = getClosestColony(</span>
<span class="pc bpc" id="L1928" title="3 of 4 branches missed.">				player.getColonies().stream().filter(c -&gt; c != notHere &amp;&amp; c.hasAbility(Ability.REPAIR_UNITS)));</span>
<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">		return (best != null) ? best : player.getEurope();</span>
	}

	// Movement handling

	/**
	 * A move type.
	 *
	 * @see Unit#getMoveType(Direction)
	 */
<span class="pc" id="L1939">	public static enum MoveType {</span>

		/** The move. */
<span class="fc" id="L1942">		MOVE(null, true),</span>
		/** The move high seas. */
<span class="fc" id="L1944">		MOVE_HIGH_SEAS(null, true),</span>
		/** The explore lost city rumour. */
<span class="fc" id="L1946">		EXPLORE_LOST_CITY_RUMOUR(null, true),</span>
		/** The attack unit. */
<span class="fc" id="L1948">		ATTACK_UNIT(null, false),</span>

		/** The attack settlement. */
<span class="fc" id="L1951">		ATTACK_SETTLEMENT(null, false),</span>
		/** The embark. */
<span class="fc" id="L1953">		EMBARK(null, false),</span>
		/** The enter indian settlement with free colonist. */
<span class="fc" id="L1955">		ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST(null, false),</span>

		/** The enter indian settlement with scout. */
<span class="fc" id="L1958">		ENTER_INDIAN_SETTLEMENT_WITH_SCOUT(null, false),</span>
		/** The enter indian settlement with missionary. */
<span class="fc" id="L1960">		ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY(null, false),</span>

		/** The enter foreign colony with scout. */
<span class="fc" id="L1963">		ENTER_FOREIGN_COLONY_WITH_SCOUT(null, false),</span>
		/** The enter settlement with carrier and goods. */
<span class="fc" id="L1965">		ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS(null, false),</span>

		/** The move no moves. */
<span class="fc" id="L1968">		MOVE_NO_MOVES(&quot;Attempt to move without moves left&quot;),</span>
		/** The move no access land. */
<span class="fc" id="L1970">		MOVE_NO_ACCESS_LAND(&quot;Attempt to move a naval unit onto land&quot;),</span>

		/** The move no access beached. */
<span class="fc" id="L1973">		MOVE_NO_ACCESS_BEACHED(&quot;Attempt to move onto foreign beached ship&quot;),</span>
		/** The move no access embark. */
<span class="fc" id="L1975">		MOVE_NO_ACCESS_EMBARK(&quot;Attempt to embark onto absent or foreign carrier&quot;),</span>

		/** The move no access full. */
<span class="fc" id="L1978">		MOVE_NO_ACCESS_FULL(&quot;Attempt to embark onto full carrier&quot;),</span>
		/** The move no access goods. */
<span class="fc" id="L1980">		MOVE_NO_ACCESS_GOODS(&quot;Attempt to trade without goods&quot;),</span>

		/** The move no access contact. */
<span class="fc" id="L1983">		MOVE_NO_ACCESS_CONTACT(&quot;Attempt to interact with natives before contact&quot;),</span>
		/** The move no access mission ban. */
<span class="fc" id="L1985">		MOVE_NO_ACCESS_MISSION_BAN(&quot;Attempt to use missionary at banned settlement&quot;),</span>

		/** The move no access settlement. */
<span class="fc" id="L1988">		MOVE_NO_ACCESS_SETTLEMENT(&quot;Attempt to move into foreign settlement&quot;),</span>
		/** The move no access skill. */
<span class="fc" id="L1990">		MOVE_NO_ACCESS_SKILL(&quot;Attempt to learn skill with incapable unit&quot;),</span>

		/** The move no access trade. */
<span class="fc" id="L1993">		MOVE_NO_ACCESS_TRADE(&quot;Attempt to trade without authority&quot;),</span>
		/** The move no access war. */
<span class="fc" id="L1995">		MOVE_NO_ACCESS_WAR(&quot;Attempt to trade while at war&quot;),</span>

		/** The move no access water. */
<span class="fc" id="L1998">		MOVE_NO_ACCESS_WATER(&quot;Attempt to move into a settlement by water&quot;),</span>
		/** The move no attack civilian. */
<span class="fc" id="L2000">		MOVE_NO_ATTACK_CIVILIAN(&quot;Attempt to attack with civilian unit&quot;),</span>

		/** The move no attack marine. */
<span class="fc" id="L2003">		MOVE_NO_ATTACK_MARINE(&quot;Attempt to attack from on board ship&quot;),</span>
		/** The move no europe. */
<span class="fc" id="L2005">		MOVE_NO_EUROPE(&quot;Attempt to move to Europe by incapable unit&quot;),</span>

		/** The move no repair. */
<span class="fc" id="L2008">		MOVE_NO_REPAIR(&quot;Attempt to move a unit that is under repair&quot;),</span>
		/** The move no tile. */
<span class="fc" id="L2010">		MOVE_NO_TILE(&quot;Attempt to move when not on a tile&quot;),</span>
		/** The move illegal. */
<span class="fc" id="L2012">		MOVE_ILLEGAL(&quot;Unspecified illegal move&quot;);</span>

		/**
		 * The reason why this move type is illegal.
		 */
		private final String reason;

		/**
		 * Does this move type imply progress towards a destination.
		 */
		private final boolean progress;

		/**
		 * Instantiates a new move type.
		 *
		 * @param reason
		 *            the reason
		 */
<span class="fc" id="L2030">		MoveType(String reason) {</span>
<span class="fc" id="L2031">			this.reason = reason;</span>
<span class="fc" id="L2032">			this.progress = false;</span>
<span class="fc" id="L2033">		}</span>

		/**
		 * Instantiates a new move type.
		 *
		 * @param reason
		 *            the reason
		 * @param progress
		 *            the progress
		 */
<span class="fc" id="L2043">		MoveType(String reason, boolean progress) {</span>
<span class="fc" id="L2044">			this.reason = reason;</span>
<span class="fc" id="L2045">			this.progress = progress;</span>
<span class="fc" id="L2046">		}</span>

		/**
		 * Checks if is legal.
		 *
		 * @return true, if is legal
		 */
		public boolean isLegal() {
<span class="fc bfc" id="L2054" title="All 2 branches covered.">			return this.reason == null;</span>
		}

		/**
		 * Why illegal.
		 *
		 * @return the string
		 */
		public String whyIllegal() {
<span class="nc bnc" id="L2063" title="All 2 branches missed.">			return (reason == null) ? &quot;(none)&quot; : reason;</span>
		}

		/**
		 * Checks if is progress.
		 *
		 * @return true, if is progress
		 */
		public boolean isProgress() {
<span class="fc" id="L2072">			return progress;</span>
		}

		/**
		 * Checks if is attack.
		 *
		 * @return true, if is attack
		 */
		public boolean isAttack() {
<span class="nc bnc" id="L2081" title="All 4 branches missed.">			return this == ATTACK_UNIT || this == ATTACK_SETTLEMENT;</span>
		}
	}

	/**
	 * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; onto the given
	 * &lt;code&gt;Tile&lt;/code&gt;. A call to {@link #getMoveType(Tile)} will return
	 * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
	 * larger than the {@link #getMovesLeft moves left}.
	 *
	 * @param target
	 *            The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move onto.
	 * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public int getMoveCost(Tile target) {
<span class="fc" id="L2096">		return getMoveCost(getTile(), target, getMovesLeft());</span>
	}

	/**
	 * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; from the given
	 * &lt;code&gt;Tile&lt;/code&gt; onto the given &lt;code&gt;Tile&lt;/code&gt;. A call to
	 * {@link #getMoveType(Tile, Tile, int)} will return
	 * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
	 * larger than the {@link #getMovesLeft moves left}.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move from.
	 * @param target
	 *            The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move onto.
	 * @param ml
	 *            The amount of moves this Unit has left.
	 * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public int getMoveCost(Tile from, Tile target, int ml) {
		// Remember to also change map.findPath(...) if you change anything
		// here.

<span class="fc" id="L2118">		int cost = target.getType().getBasicMoveCost();</span>
<span class="fc bfc" id="L2119" title="All 4 branches covered.">		if (target.isLand() &amp;&amp; !isNaval()) {</span>
<span class="fc" id="L2120">			TileItemContainer container = target.getTileItemContainer();</span>
<span class="fc bfc" id="L2121" title="All 2 branches covered.">			if (container != null) {</span>
<span class="fc" id="L2122">				cost = container.getMoveCost(from, target, cost);</span>
			}
		}

<span class="pc bpc" id="L2126" title="1 of 2 branches missed.">		if (isBeached(from)) {</span>
			// Ship on land due to it was in a colony which was abandoned
<span class="nc" id="L2128">			cost = ml;</span>
<span class="fc bfc" id="L2129" title="All 2 branches covered.">		} else if (cost &gt; ml) {</span>
			// Using +2 in order to make 1/3 and 2/3 move count as
			// 3/3, only when getMovesLeft &gt; 0
<span class="pc bpc" id="L2132" title="1 of 8 branches missed.">			if ((ml + 2 &gt;= getInitialMovesLeft() || cost &lt;= ml + 2 || target.hasSettlement()) &amp;&amp; ml != 0) {</span>
<span class="fc" id="L2133">				cost = ml;</span>
			}
		}
<span class="fc" id="L2136">		return cost;</span>
	}

	/**
	 * Gets the type of a move made in a specified direction.
	 *
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	public MoveType getMoveType(Direction direction) {
		Tile target;
<span class="pc bpc" id="L2148" title="1 of 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="pc bpc" id="L2149" title="1 of 2 branches missed.">				: ((target = getTile().getNeighbourOrNull(direction)) == null) ? MoveType.MOVE_ILLEGAL</span>
<span class="fc" id="L2150">						: getMoveType(target);</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another.
	 *
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	public MoveType getMoveType(Tile target) {
<span class="pc bpc" id="L2162" title="1 of 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE : getMoveType(getTile(), target, getMovesLeft());</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param ml
	 *            The amount of moves this unit has left.
	 * @return The move type.
	 */
	public MoveType getMoveType(Tile from, Tile target, int ml) {
<span class="fc" id="L2178">		MoveType move = getSimpleMoveType(from, target);</span>
<span class="fc bfc" id="L2179" title="All 2 branches covered.">		if (move.isLegal()) {</span>
<span class="pc bfc" id="L2180" title="All 2 branches covered.">			switch (move) {</span>
			case ATTACK_UNIT:
			case ATTACK_SETTLEMENT:
				// Needs only a single movement point, regardless of
				// terrain, but suffers penalty.
<span class="fc bfc" id="L2185" title="All 2 branches covered.">				if (ml &lt;= 0) {</span>
<span class="fc" id="L2186">					move = MoveType.MOVE_NO_MOVES;</span>
				}
				break;
			default:
<span class="pc bpc" id="L2190" title="3 of 6 branches missed.">				if (ml &lt;= 0 || (from != null &amp;&amp; getMoveCost(from, target, ml) &gt; ml)) {</span>
<span class="nc" id="L2191">					move = MoveType.MOVE_NO_MOVES;</span>
				}
				break;
			}
		}
<span class="fc" id="L2196">		return move;</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another, without checking if the unit has moves left or logging errors.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type, which will be one of the extended illegal move
	 *         types on failure.
	 */
	public MoveType getSimpleMoveType(Tile from, Tile target) {
<span class="fc bfc" id="L2211" title="All 2 branches covered.">		return (isNaval()) ? getNavalMoveType(from, target) : getLandMoveType(from, target);</span>
	}

	/**
	 * Gets the type of a move that is made when moving from one tile to
	 * another, without checking if the unit has moves left or logging errors.
	 *
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type, which will be one of the extended illegal move
	 *         types on failure.
	 */
	public MoveType getSimpleMoveType(Tile target) {
<span class="nc bnc" id="L2224" title="All 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE : getSimpleMoveType(getTile(), target);</span>
	}

	/**
	 * Gets the type of a move made in a specified direction, without checking
	 * if the unit has moves left or logging errors.
	 *
	 * @param direction
	 *            The direction of the move.
	 * @return The move type.
	 */
	public MoveType getSimpleMoveType(Direction direction) {
		Tile target;
<span class="nc bnc" id="L2237" title="All 2 branches missed.">		return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">				: ((target = getTile().getNeighbourOrNull(direction)) == null) ? MoveType.MOVE_ILLEGAL</span>
<span class="nc" id="L2239">						: getSimpleMoveType(getTile(), target);</span>
	}

	/**
	 * Gets the type of a move that is made when moving a naval unit from one
	 * tile to another.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;code&gt; of the move.
	 * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	private MoveType getNavalMoveType(@SuppressWarnings(&quot;unused&quot;) Tile from, Tile target) {
<span class="pc bpc" id="L2252" title="1 of 2 branches missed.">		if (target == null) {</span>
<span class="nc bnc" id="L2253" title="All 2 branches missed.">			return (getOwner().canMoveToEurope()) ? MoveType.MOVE_HIGH_SEAS : MoveType.MOVE_NO_EUROPE;</span>
<span class="pc bpc" id="L2254" title="1 of 2 branches missed.">		} else if (isDamaged()) {</span>
<span class="nc" id="L2255">			return MoveType.MOVE_NO_REPAIR;</span>
		}

<span class="fc bfc" id="L2258" title="All 2 branches covered.">		if (target.isLand()) {</span>
<span class="fc" id="L2259">			Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2260" title="All 2 branches covered.">			if (settlement == null) {</span>
<span class="fc" id="L2261">				return MoveType.MOVE_NO_ACCESS_LAND;</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">			} else if (settlement.getOwner() == getOwner()) {</span>
<span class="fc" id="L2263">				return MoveType.MOVE;</span>
<span class="pc bpc" id="L2264" title="1 of 2 branches missed.">			} else if (isTradingUnit()) {</span>
<span class="fc" id="L2265">				return getTradeMoveType(settlement);</span>
			} else {
<span class="nc" id="L2267">				return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
			}
		} else { // target at sea
<span class="fc" id="L2270">			Unit defender = target.getFirstUnit();</span>
<span class="fc bfc" id="L2271" title="All 4 branches covered.">			if (defender != null &amp;&amp; !getOwner().owns(defender)) {</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">				return (isOffensiveUnit()) ? MoveType.ATTACK_UNIT : MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
			} else {
<span class="fc bfc" id="L2274" title="All 2 branches covered.">				return (target.isDirectlyHighSeasConnected()) ? MoveType.MOVE_HIGH_SEAS : MoveType.MOVE;</span>
			}
		}
	}

	/**
	 * Gets the type of a move that is made when moving a land unit to from one
	 * tile to another.
	 *
	 * @param from
	 *            The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @param target
	 *            The target &lt;code&gt;Tile&lt;/code&gt; of the move.
	 * @return The move type.
	 */
	private MoveType getLandMoveType(Tile from, Tile target) {
<span class="pc bpc" id="L2290" title="1 of 2 branches missed.">		if (target == null) {</span>
<span class="nc" id="L2291">			return MoveType.MOVE_ILLEGAL;</span>
		}

<span class="fc" id="L2294">		Player owner = getOwner();</span>
<span class="fc" id="L2295">		Unit defender = target.getFirstUnit();</span>

<span class="fc bfc" id="L2297" title="All 2 branches covered.">		if (target.isLand()) {</span>
<span class="fc" id="L2298">			Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">			if (settlement == null) {</span>
<span class="fc bfc" id="L2300" title="All 4 branches covered.">				if (defender != null &amp;&amp; owner != defender.getOwner()) {</span>
<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">					if (defender.isNaval()) {</span>
<span class="nc" id="L2302">						return MoveType.ATTACK_UNIT;</span>
<span class="fc bfc" id="L2303" title="All 2 branches covered.">					} else if (!isOffensiveUnit()) {</span>
<span class="fc" id="L2304">						return MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
					} else {
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">						return (allowMoveFrom(from)) ? MoveType.ATTACK_UNIT : MoveType.MOVE_NO_ATTACK_MARINE;</span>
					}
<span class="pc bpc" id="L2308" title="1 of 4 branches missed.">				} else if (target.hasLostCityRumour() &amp;&amp; owner.isEuropean()) {</span>
					// Natives do not explore rumours, see:
					// server/control/InGameInputHandler.java:move()
<span class="fc" id="L2311">					return MoveType.EXPLORE_LOST_CITY_RUMOUR;</span>
				} else {
<span class="fc" id="L2313">					return MoveType.MOVE;</span>
				}
<span class="fc bfc" id="L2315" title="All 2 branches covered.">			} else if (owner == settlement.getOwner()) {</span>
<span class="fc" id="L2316">				return MoveType.MOVE;</span>
<span class="pc bpc" id="L2317" title="1 of 2 branches missed.">			} else if (isTradingUnit()) {</span>
<span class="nc" id="L2318">				return getTradeMoveType(settlement);</span>
<span class="fc bfc" id="L2319" title="All 2 branches covered.">			} else if (isColonist()) {</span>
<span class="fc bfc" id="L2320" title="All 4 branches covered.">				if (settlement instanceof Colony &amp;&amp; hasAbility(Ability.NEGOTIATE)) {</span>
<span class="pc bpc" id="L2321" title="1 of 2 branches missed.">					return (allowMoveFrom(from)) ? MoveType.ENTER_FOREIGN_COLONY_WITH_SCOUT</span>
							: MoveType.MOVE_NO_ACCESS_WATER;
<span class="fc bfc" id="L2323" title="All 4 branches covered.">				} else if (settlement instanceof IndianSettlement &amp;&amp; hasAbility(Ability.SPEAK_WITH_CHIEF)) {</span>
<span class="pc bpc" id="L2324" title="1 of 2 branches missed.">					return (allowMoveFrom(from)) ? MoveType.ENTER_INDIAN_SETTLEMENT_WITH_SCOUT</span>
							: MoveType.MOVE_NO_ACCESS_WATER;
<span class="fc bfc" id="L2326" title="All 2 branches covered.">				} else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2327" title="1 of 2 branches missed.">					return (allowMoveFrom(from)) ? MoveType.ATTACK_SETTLEMENT : MoveType.MOVE_NO_ATTACK_MARINE;</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">				} else if (hasAbility(Ability.ESTABLISH_MISSION)) {</span>
<span class="fc" id="L2329">					return getMissionaryMoveType(from, settlement);</span>
				} else {
<span class="fc" id="L2331">					return getLearnMoveType(from, settlement);</span>
				}
<span class="pc bpc" id="L2333" title="1 of 2 branches missed.">			} else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2334" title="1 of 2 branches missed.">				return (allowMoveFrom(from)) ? MoveType.ATTACK_SETTLEMENT : MoveType.MOVE_NO_ATTACK_MARINE;</span>
			} else {
<span class="nc" id="L2336">				return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
			}
		} else { // moving to sea, check for embarkation
<span class="fc bfc" id="L2339" title="All 4 branches covered.">			return (defender == null || !getOwner().owns(defender)) ? MoveType.MOVE_NO_ACCESS_EMBARK</span>
<span class="pc bpc" id="L2340" title="1 of 2 branches missed.">					: (any(target.getUnitList(), u -&gt; u.canAdd(this))) ? MoveType.EMBARK : MoveType.MOVE_NO_ACCESS_FULL;</span>
		}
	}

	/**
	 * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a trading unit to a settlement.
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to move to.
	 * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
	 */
	private MoveType getTradeMoveType(Settlement settlement) {
<span class="pc bpc" id="L2352" title="1 of 2 branches missed.">		if (settlement instanceof Colony) {</span>
<span class="nc bnc" id="L2353" title="All 2 branches missed.">			return (getOwner().atWarWith(settlement.getOwner())) ? MoveType.MOVE_NO_ACCESS_WAR</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">					: (!hasAbility(Ability.TRADE_WITH_FOREIGN_COLONIES)) ? MoveType.MOVE_NO_ACCESS_TRADE</span>
							: MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS;
<span class="pc bpc" id="L2356" title="1 of 2 branches missed.">		} else if (settlement instanceof IndianSettlement) {</span>
			// Do not block for war, bringing gifts is allowed
<span class="fc bfc" id="L2358" title="All 2 branches covered.">			return (!allowContact(settlement)) ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="fc bfc" id="L2359" title="All 4 branches covered.">					: (hasGoodsCargo() || getSpecification().getBoolean(GameOptions.EMPTY_TRADERS))</span>
							? MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS : MoveType.MOVE_NO_ACCESS_GOODS;
		} else {
<span class="nc" id="L2362">			return MoveType.MOVE_ILLEGAL; // should not happen</span>
		}
	}

	/**
	 * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a colonist to a settlement.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; to move from.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to move to.
	 * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
	 */
	private MoveType getLearnMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2376" title="All 2 branches covered.">		if (settlement instanceof Colony) {</span>
<span class="fc" id="L2377">			return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2378" title="1 of 2 branches missed.">		} else if (settlement instanceof IndianSettlement) {</span>
<span class="fc bfc" id="L2379" title="All 2 branches covered.">			return (!allowContact(settlement)) ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="pc bpc" id="L2380" title="1 of 2 branches missed.">					: (!allowMoveFrom(from)) ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="pc bpc" id="L2381" title="1 of 2 branches missed.">							: (!getType().canBeUpgraded(null, ChangeType.NATIVES)) ? MoveType.MOVE_NO_ACCESS_SKILL</span>
									: MoveType.ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST;
		} else {
<span class="nc" id="L2384">			return MoveType.MOVE_ILLEGAL; // should not happen</span>
		}
	}

	/**
	 * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a missionary to a settlement.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; to move from.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to move to.
	 * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
	 */
	private MoveType getMissionaryMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2398" title="All 2 branches covered.">		if (settlement instanceof Colony) {</span>
<span class="fc" id="L2399">			return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2400" title="1 of 2 branches missed.">		} else if (settlement instanceof IndianSettlement) {</span>
<span class="pc bpc" id="L2401" title="1 of 2 branches missed.">			return (!allowContact(settlement)) ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="pc bpc" id="L2402" title="1 of 2 branches missed.">					: (!allowMoveFrom(from)) ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="pc bpc" id="L2403" title="1 of 2 branches missed.">							: (settlement.getOwner().missionsBanned(getOwner())) ? MoveType.MOVE_NO_ACCESS_MISSION_BAN</span>
									: MoveType.ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY;
		} else {
<span class="nc" id="L2406">			return MoveType.MOVE_ILLEGAL; // should not happen</span>
		}
	}

	/**
	 * Is this unit allowed to move from a source tile? Implements the
	 * restrictions on moving from water.
	 *
	 * @param from
	 *            The &lt;code&gt;Tile&lt;/code&gt; to consider.
	 * @return True if the move is allowed.
	 */
	private boolean allowMoveFrom(Tile from) {
<span class="pc bpc" id="L2419" title="2 of 6 branches missed.">		return from.isLand() || (!getOwner().isREF() &amp;&amp; getSpecification().getBoolean(GameOptions.AMPHIBIOUS_MOVES));</span>
	}

	/**
	 * Is this unit allowed to contact a settlement?.
	 *
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to consider.
	 * @return True if the contact is allowed.
	 */
	private boolean allowContact(Settlement settlement) {
<span class="fc" id="L2430">		return getOwner().hasContacted(settlement.getOwner());</span>
	}

	/**
	 * Does a basic check whether a unit can ever expect to move to a tile.
	 *
	 * @param tile
	 *            The code &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return True if some sort of legal move to the tile exists, including
	 *         special cases where there is an interaction but the unit does not
	 *         actually move, such as trade.
	 */
	public boolean isTileAccessible(Tile tile) {
<span class="fc bfc" id="L2443" title="All 8 branches covered.">		return (isNaval()) ? (!tile.isLand() || (tile.hasSettlement() &amp;&amp; getOwner().owns(tile.getSettlement())))</span>
<span class="fc" id="L2444">				: tile.isLand();</span>
	}

	/**
	 * Gets the amount of moves this unit has at the beginning of each turn.
	 *
	 * @return The amount of moves this unit has at the beginning of each turn.
	 */
	@Override
	public int getInitialMovesLeft() {
<span class="fc" id="L2454">		Turn turn = getGame().getTurn();</span>
<span class="fc" id="L2455">		return (int) applyModifiers(unitType.getMovement(), turn, Modifier.MOVEMENT_BONUS, unitType);</span>
	}

	/**
	 * Make a label showing the unit moves left.
	 *
	 * @return A movement label.
	 */
	public String getMovesAsString() {
<span class="fc" id="L2464">		StringBuilder sb = new StringBuilder(16);</span>
<span class="fc" id="L2465">		int quotient = getMovesLeft() / 3;</span>
<span class="fc" id="L2466">		int remainder = getMovesLeft() % 3;</span>
<span class="fc bfc" id="L2467" title="All 4 branches covered.">		if (quotient &gt; 0 || remainder == 0) {</span>
<span class="fc" id="L2468">			sb.append(quotient);</span>
		}
<span class="fc bfc" id="L2470" title="All 2 branches covered.">		if (remainder &gt; 0) {</span>
<span class="fc" id="L2471">			sb.append(&quot;(&quot;).append(remainder).append(&quot;/3) &quot;);</span>
		}
<span class="fc" id="L2473">		sb.append(&quot;/&quot;).append(getInitialMovesLeft() / 3);</span>
<span class="fc" id="L2474">		return sb.toString();</span>
	}

	/**
	 * Gets the number of turns this unit will need to sail to/from Europe.
	 *
	 * @return The number of turns to sail to/from Europe.
	 */
	public int getSailTurns() {
<span class="fc" id="L2483">		float base = getSpecification().getInteger(GameOptions.TURNS_TO_SAIL);</span>
<span class="fc" id="L2484">		return (int) getOwner().applyModifiers(base, getGame().getTurn(), Modifier.SAIL_HIGH_SEAS, unitType);</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; can be moved to the high seas from its
	 * current location.
	 *
	 * @return True if this unit can move immediately to the high seas.
	 */
	public boolean canMoveToHighSeas() {
<span class="nc bnc" id="L2494" title="All 4 branches missed.">		if (isInEurope() || isAtSea()) {</span>
<span class="nc" id="L2495">			return true;</span>
		}
<span class="nc bnc" id="L2497" title="All 4 branches missed.">		if (!getOwner().canMoveToEurope() || !getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L2498">			return false;</span>
		}
<span class="nc" id="L2500">		return getTile().isDirectlyHighSeasConnected();</span>
	}

	/**
	 * Does this unit have a valid move to the high seas this turn.
	 *
	 * @return True if the unit can either move immediately to the high seas or
	 *         can make a move to a neighbouring high seas tile.
	 */
	public boolean hasHighSeasMove() {
<span class="nc bnc" id="L2510" title="All 2 branches missed.">		return (canMoveToHighSeas()) ? true</span>
<span class="nc bnc" id="L2511" title="All 4 branches missed.">				: (hasTile() &amp;&amp; getMovesLeft() &gt; 0)</span>
<span class="nc" id="L2512">						? any(getTile().getSurroundingTiles(1, 1), Tile::isDirectlyHighSeasConnected) : false;</span>
	}

	/**
	 * Check if this unit can build a colony. Does not consider whether the tile
	 * where the unit is located is suitable,
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if this unit can build a colony.
	 * @see Player#canClaimToFoundSettlement(Tile)
	 */
	public boolean canBuildColony() {
<span class="fc" id="L2523">		final Specification spec = getSpecification();</span>
<span class="pc bpc" id="L2524" title="1 of 6 branches missed.">		return hasTile() &amp;&amp; unitType.canBuildColony() &amp;&amp; getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L2525" title="3 of 4 branches missed.">				&amp;&amp; (!getOwner().isRebel() || spec.getBoolean(GameOptions.FOUND_COLONY_DURING_REBELLION));</span>
	}

	/**
	 * Is this unit at a specified location?.
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; to test.
	 * @return True if the locations are the same, or on the same tile.
	 */
	public boolean isAtLocation(Location loc) {
<span class="fc bfc" id="L2536" title="All 2 branches covered.">		Location ourLoc = getLocation(), otherLoc = (loc instanceof Unit) ? ((Unit) loc).getLocation() : loc;</span>
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">		if (ourLoc instanceof Unit) {</span>
<span class="nc" id="L2538">			ourLoc = ((Unit) ourLoc).getLocation();</span>
		}
<span class="fc" id="L2540">		return Map.isSameLocation(ourLoc, otherLoc);</span>
	}

	/**
	 * Gets the best (closest) entry location for this unit to reach a given
	 * tile.
	 *
	 * @param tile
	 *            The target &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The best entry location tile to arrive on the map at, or null if
	 *         none found.
	 */
	public Tile getBestEntryTile(Tile tile) {
<span class="nc" id="L2553">		return getGame().getMap().getBestEntryTile(this, tile, null, null);</span>
	}

	/**
	 * Resolves a destination for a unit on the high seas. That is, the location
	 * where the unit will appear when it leaves the high seas, which will
	 * either be Europe or a tile.
	 *
	 * @return The location the unit should appear next after leaving the high
	 *         seas.
	 */
	public Location resolveDestination() {
<span class="nc bnc" id="L2565" title="All 2 branches missed.">		if (!isAtSea()) {</span>
<span class="nc" id="L2566">			throw new IllegalArgumentException(&quot;Not at sea.&quot;);</span>
		}
<span class="nc" id="L2568">		TradeRouteStop stop = getStop();</span>
<span class="nc bnc" id="L2569" title="All 2 branches missed.">		Location dst = (TradeRoute.isStopValid(this, stop)) ? stop.getLocation() : getDestination();</span>
		Tile best;
<span class="nc bnc" id="L2571" title="All 4 branches missed.">		return (dst == null) ? getFullEntryLocation()</span>
				: (dst instanceof Europe) ? dst
<span class="nc bnc" id="L2573" title="All 4 branches missed.">						: (dst.getTile() != null &amp;&amp; (best = getBestEntryTile(dst.getTile())) != null) ? best</span>
<span class="nc" id="L2574">								: getFullEntryLocation();</span>
	}

	/**
	 * Set movesLeft to 0 if has some spent moves and it's in a colony.
	 *
	 * @see #add(Locatable)
	 * @see #remove(Locatable)
	 */
	private void spendAllMoves() {
<span class="pc bpc" id="L2584" title="3 of 4 branches missed.">		if (getColony() != null &amp;&amp; getMovesLeft() &lt; getInitialMovesLeft()) {</span>
<span class="nc" id="L2585">			setMovesLeft(0);</span>
		}
<span class="fc" id="L2587">	}</span>

	/**
	 * Is this unit a suitable `next active unit', that is, the unit needs to be
	 * currently movable by the player.
	 *
	 * @return True if this unit could still be moved by the player.
	 */
	public boolean couldMove() {
<span class="nc bnc" id="L2596" title="All 10 branches missed.">		return !isDisposed() &amp;&amp; getState() == UnitState.ACTIVE &amp;&amp; getMovesLeft() &gt; 0 &amp;&amp; destination == null // Can</span>
																											// not
																											// reach
																											// next
																											// tile
<span class="nc bnc" id="L2601" title="All 6 branches missed.">				&amp;&amp; tradeRoute == null &amp;&amp; !isDamaged() &amp;&amp; !isAtSea() &amp;&amp; !isOnCarrier()</span>
				// this should never happen anyway, since these units
				// should have state IN_COLONY, but better safe than sorry
<span class="nc bnc" id="L2604" title="All 2 branches missed.">				&amp;&amp; !isInColony();</span>
	}

	// Map support routines

	/**
	 * Gets a suitable location to start path searches for a unit.
	 *
	 * Must handle all the cases where the unit is off the map, and take account
	 * of the use of a carrier.
	 *
	 * @return A suitable starting location, or null if none found.
	 */
	public Location getPathStartLocation() {
<span class="fc" id="L2618">		final Unit carrier = getCarrier();</span>
<span class="fc" id="L2619">		Location ret = getTile();</span>
<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">		if (isOnCarrier()) {</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">			if (ret != null) {</span>
				; // OK
<span class="nc bnc" id="L2623" title="All 2 branches missed.">			} else if (carrier.getDestination() == null) {</span>
<span class="nc" id="L2624">				ret = null;</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">			} else if (carrier.getDestination() instanceof Map) {</span>
<span class="nc" id="L2626">				ret = carrier.getFullEntryLocation();</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">			} else if (carrier.getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2628">				ret = carrier.getDestination();</span>
			} else { // destination must be Europe
<span class="nc" id="L2630">				ret = null;</span>
			}
<span class="pc bpc" id="L2632" title="1 of 2 branches missed.">		} else if (isNaval()) {</span>
<span class="nc bnc" id="L2633" title="All 2 branches missed.">			if (ret != null) {</span>
				; // OK
<span class="nc bnc" id="L2635" title="All 4 branches missed.">			} else if (getDestination() == null || getDestination() instanceof Map) {</span>
<span class="nc" id="L2636">				ret = getFullEntryLocation();</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">			} else if (getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2638">				ret = getDestination();</span>
			} else {
<span class="nc" id="L2640">				ret = getFullEntryLocation();</span>
			}
		}
<span class="pc bpc" id="L2643" title="1 of 2 branches missed.">		if (ret != null) {</span>
<span class="fc" id="L2644">			return ret;</span>
		}

		// Must be a land unit not on the map. May have a carrier.
		// Get our nearest settlement to Europe, fallback to any other.
<span class="nc" id="L2649">		final Player owner = getOwner();</span>
<span class="nc" id="L2650">		int bestValue = INFINITY;</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">		for (Settlement s : owner.getSettlements()) {</span>
<span class="nc bnc" id="L2652" title="All 2 branches missed.">			if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2653">				int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">				if (bestValue &gt; value) {</span>
<span class="nc" id="L2655">					bestValue = value;</span>
<span class="nc" id="L2656">					ret = s;</span>
				}
<span class="nc bnc" id="L2658" title="All 2 branches missed.">			} else if (bestValue == INFINITY)</span>
<span class="nc" id="L2659">				ret = s;</span>
<span class="nc" id="L2660">		}</span>
<span class="nc bnc" id="L2661" title="All 2 branches missed.">		if (ret != null) {</span>
<span class="nc" id="L2662">			return ret;</span>
		}

		// Owner has no settlements. If it is the REF, start from a
		// rebel colony. Prefer the closest port.
<span class="nc bnc" id="L2667" title="All 2 branches missed.">		if (owner.isREF()) {</span>
<span class="nc" id="L2668">			bestValue = INFINITY;</span>
<span class="nc bnc" id="L2669" title="All 2 branches missed.">			for (Player p : owner.getRebels()) {</span>
<span class="nc bnc" id="L2670" title="All 2 branches missed.">				for (Settlement s : p.getSettlements()) {</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">					if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2672">						int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2673" title="All 2 branches missed.">						if (bestValue &gt; value) {</span>
<span class="nc" id="L2674">							bestValue = value;</span>
<span class="nc" id="L2675">							ret = s;</span>
						}
<span class="nc bnc" id="L2677" title="All 2 branches missed.">					} else if (bestValue == INFINITY)</span>
<span class="nc" id="L2678">						ret = s;</span>
<span class="nc" id="L2679">				}</span>
<span class="nc" id="L2680">			}</span>
<span class="nc bnc" id="L2681" title="All 2 branches missed.">			if (ret != null)</span>
<span class="nc" id="L2682">				return ret;</span>
		}

		// Desperately find the nearest land to the entry location.
<span class="nc" id="L2686">		Location entry = getFullEntryLocation();</span>
<span class="nc bnc" id="L2687" title="All 4 branches missed.">		if (entry != null &amp;&amp; entry.getTile() != null) {</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">			for (Tile t : entry.getTile().getSurroundingTiles(INFINITY)) {</span>
<span class="nc bnc" id="L2689" title="All 2 branches missed.">				if (t.isLand())</span>
<span class="nc" id="L2690">					return t;</span>
<span class="nc" id="L2691">			}</span>
		}

<span class="nc" id="L2694">		return null; // Fail</span>
	}

	/**
	 * Should the unit use transport to get to a specified tile?
	 * 
	 * True if: - The location is not null - The unit is not naval - The unit is
	 * not there already AND - there is no path OR the path uses an existing
	 * carrier.
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; to go to.
	 * @return True if the unit should use transport.
	 */
	public boolean shouldTakeTransportTo(Location loc) {
		PathNode path;
<span class="pc bpc" id="L2710" title="2 of 6 branches missed.">		return loc != null &amp;&amp; !isNaval() &amp;&amp; !isAtLocation(loc)</span>
<span class="pc bpc" id="L2711" title="2 of 4 branches missed.">				&amp;&amp; ((path = findPath(getLocation(), loc, getCarrier(), null)) == null || path.usesCarrier());</span>
	}

	/**
	 * Gets the trivial path for this unit. That is, the path to the nearest
	 * available safe settlement.
	 *
	 * @return A path to the trivial target, or null if none found.
	 */
	public PathNode getTrivialPath() {
<span class="pc bpc" id="L2721" title="2 of 4 branches missed.">		if (isDisposed() || getLocation() == null) {</span>
<span class="nc" id="L2722">			return null;</span>
		}
<span class="fc bfc" id="L2724" title="All 2 branches covered.">		if (!isNaval()) {</span>
<span class="fc" id="L2725">			return findOurNearestSettlement();</span>
		}
<span class="fc" id="L2727">		PathNode path = findOurNearestPort();</span>
<span class="fc bfc" id="L2728" title="All 2 branches covered.">		if (path == null) {</span>
			// This is unusual, but can happen when a ship is up a
			// river and foreign ship creates a blockage downstream.
			// If so, the rational thing to do is to go to a tile
			// where other units can pass and which has the best
			// connectivity to the high seas.
<span class="fc" id="L2734">			Tile tile = getTile();</span>
<span class="pc bpc" id="L2735" title="4 of 6 branches missed.">			if (tile != null &amp;&amp; tile.isOnRiver() &amp;&amp; tile.isHighSeasConnected()) {</span>
<span class="nc" id="L2736">				path = search(getLocation(), GoalDeciders.getCornerGoalDecider(),</span>
<span class="nc" id="L2737">						CostDeciders.avoidSettlementsAndBlockingUnits(), INFINITY, null);</span>

<span class="nc bnc" id="L2739" title="All 4 branches missed.">				if (path == null &amp;&amp; tile.isRiverCorner()) {</span>
					// Return trivial path if already present.
<span class="nc" id="L2741">					return new PathNode(tile, 0, 0, false, null, null);</span>
				}
			}
		}
<span class="fc" id="L2745">		return path;</span>
	}

	/**
	 * Finds the fastest path from the current location to the specified one. No
	 * carrier is provided, and the default cost decider for this unit is used.
	 *
	 * @param end
	 *            The &lt;code&gt;Location&lt;/code&gt; in which the path ends.
	 * @return A &lt;code&gt;PathNode&lt;/code&gt; from the current location to the end
	 *         location, or null if none found.
	 */
	public PathNode findPath(Location end) {
<span class="fc" id="L2758">		return findPath(getLocation(), end, null, null);</span>
	}

	/**
	 * Finds a quickest path between specified locations, optionally using a
	 * carrier and special purpose cost decider.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start at.
	 * @param end
	 *            The &lt;code&gt;Location&lt;/code&gt; to end at.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; for determining the
	 *            movement costs (uses default cost deciders for the unit/s if
	 *            not provided).
	 * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
	 */
	public PathNode findPath(Location start, Location end, Unit carrier, CostDecider costDecider) {
<span class="fc" id="L2778">		return getGame().getMap().findPath(this, start, end, carrier, costDecider, null);</span>
	}

	/**
	 * Finds a quickest path to a neighbouring tile to a specified target tile,
	 * optionally using a carrier and special purpose cost decider.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start at.
	 * @param end
	 *            The &lt;code&gt;Tile&lt;/code&gt; to end at a neighbour of.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; for determining the
	 *            movement costs (uses default cost deciders for the unit/s if
	 *            not provided).
	 * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
	 */
	public PathNode findPathToNeighbour(Location start, Tile end, Unit carrier, CostDecider costDecider) {
<span class="nc" id="L2798">		final Player owner = getOwner();</span>
<span class="nc" id="L2799">		int bestValue = INFINITY;</span>
<span class="nc" id="L2800">		PathNode best = null;</span>
<span class="nc bnc" id="L2801" title="All 2 branches missed.">		for (Tile t : end.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2802" title="All 6 branches missed.">			if (isTileAccessible(t) &amp;&amp; (t.getFirstUnit() == null || owner.owns(t.getFirstUnit()))) {</span>
<span class="nc" id="L2803">				PathNode p = findPath(start, t, carrier, costDecider);</span>
<span class="nc bnc" id="L2804" title="All 4 branches missed.">				if (p != null &amp;&amp; bestValue &gt; p.getTotalTurns()) {</span>
<span class="nc" id="L2805">					bestValue = p.getTotalTurns();</span>
<span class="nc" id="L2806">					best = p;</span>
				}
			}
<span class="nc" id="L2809">		}</span>
<span class="nc" id="L2810">		return best;</span>
	}

	/**
	 * Gets the number of turns required for this unit to reach a destination
	 * location from its current position. If the unit is currently on a
	 * carrier, it will be used.
	 *
	 * @param end
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @return The number of turns it will take to reach the destination, or
	 *         &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
	 */
	public int getTurnsToReach(Location end) {
<span class="fc" id="L2824">		return getTurnsToReach(getLocation(), end);</span>
	}

	/**
	 * Gets the number of turns required for this unit to reach a destination
	 * location from a starting location. If the unit is currently on a carrier,
	 * it will be used.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param end
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
	 *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
	 */
	public int getTurnsToReach(Location start, Location end) {
<span class="fc" id="L2840">		return getTurnsToReach(start, end, getCarrier(), CostDeciders.avoidSettlementsAndBlockingUnits());</span>
	}

	/**
	 * Gets the number of turns required for this unit to reach a destination
	 * location from a starting location, using an optional carrier and cost
	 * decider.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param end
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; to score the path with.
	 * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
	 *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
	 */
	public int getTurnsToReach(Location start, Location end, Unit carrier, CostDecider costDecider) {
<span class="fc" id="L2860">		PathNode path = findPath(start, end, carrier, costDecider);</span>
<span class="pc bpc" id="L2861" title="1 of 2 branches missed.">		return (path == null) ? MANY_TURNS : path.getTotalTurns();</span>
	}

	/**
	 * Get the colony that can be reached by this unit in the least number of
	 * turns.
	 *
	 * @param colonies
	 *            A list of &lt;code&gt;Colony&lt;/code&gt;s.
	 * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
	 */
	public Colony getClosestColony(List&lt;Colony&gt; colonies) {
<span class="nc" id="L2873">		return getClosestColony(colonies.stream());</span>
	}

	/**
	 * Get the colony that can be reached by this unit in the least number of
	 * turns.
	 *
	 * @param colonies
	 *            A stream of &lt;code&gt;Colony&lt;/code&gt;s.
	 * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
	 */
	public Colony getClosestColony(Stream&lt;Colony&gt; colonies) {
<span class="pc bnc" id="L2885" title="All 2 branches missed.">		ToIntFunction&lt;Colony&gt; closeness = c -&gt; (c == null) ? MANY_TURNS - 1 : this.getTurnsToReach(c);</span>
<span class="fc" id="L2886">		return Stream.concat(Stream.of((Colony) null), colonies)</span>
<span class="fc" id="L2887">				.collect(Collectors.minBy(Comparator.comparingInt(closeness))).orElse(null);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier.
	 *
	 * @param excludeStart
	 *            If true, ignore any settlement the unit is currently in.
	 * @param range
	 *            An upper bound on the number of moves.
	 * @param coastal
	 *            If true, the settlement must have a path to Europe.
	 * @return The nearest matching settlement if any, otherwise null.
	 */
	public PathNode findOurNearestSettlement(final boolean excludeStart, int range, final boolean coastal) {
<span class="fc" id="L2903">		final Player player = getOwner();</span>
<span class="pc bpc" id="L2904" title="1 of 4 branches missed.">		if (player.getNumberOfSettlements() &lt;= 0 || !hasTile()) {</span>
<span class="fc" id="L2905">			return null;</span>
		}
<span class="fc" id="L2907">		return findOurNearestSettlement(getTile(), excludeStart, range, coastal);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier.
	 *
	 * @param startTile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to start searching from.
	 * @param excludeStart
	 *            If true, ignore any settlement the unit is currently in.
	 * @param range
	 *            An upper bound on the number of moves.
	 * @param coastal
	 *            If true, the settlement must have a path to Europe.
	 * @return The nearest matching settlement if any, otherwise null.
	 */
	public PathNode findOurNearestSettlement(final Tile startTile, final boolean excludeStart, int range,
			final boolean coastal) {
<span class="fc" id="L2926">		final Player player = getOwner();</span>
<span class="pc bpc" id="L2927" title="2 of 4 branches missed.">		if (startTile == null || player.getNumberOfSettlements() &lt;= 0) {</span>
<span class="nc" id="L2928">			return null;</span>
		}
<span class="fc" id="L2930">		final GoalDecider gd = new GoalDecider() {</span>

<span class="fc" id="L2932">			private int bestValue = Integer.MAX_VALUE;</span>
<span class="fc" id="L2933">			private PathNode best = null;</span>

			@Override
			public PathNode getGoal() {
<span class="fc" id="L2937">				return best;</span>
			}

			@Override
			public boolean hasSubGoals() {
<span class="fc" id="L2942">				return true;</span>
			}

			@Override
			public boolean check(Unit u, PathNode path) {
<span class="fc" id="L2947">				Tile t = path.getTile();</span>
<span class="pc bpc" id="L2948" title="2 of 6 branches missed.">				if (t == null || (t == startTile &amp;&amp; excludeStart)) {</span>
<span class="nc" id="L2949">					return false;</span>
				}
<span class="fc" id="L2951">				Settlement settlement = t.getSettlement();</span>
				int value;
<span class="pc bpc" id="L2953" title="2 of 8 branches missed.">				if (settlement != null &amp;&amp; player.owns(settlement) &amp;&amp; (!coastal || settlement.isConnectedPort())</span>
<span class="fc bfc" id="L2954" title="All 2 branches covered.">						&amp;&amp; (value = path.getTotalTurns()) &lt; bestValue) {</span>
<span class="fc" id="L2955">					bestValue = value;</span>
<span class="fc" id="L2956">					best = path;</span>
<span class="fc" id="L2957">					return true;</span>
				}
<span class="fc" id="L2959">				return false;</span>
			}
		};
<span class="fc" id="L2962">		return search(startTile, gd, CostDeciders.avoidIllegal(), range, null);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier.
	 *
	 * @return A path to the nearest settlement if any, otherwise null.
	 */
	public PathNode findOurNearestSettlement() {
<span class="fc" id="L2972">		return findOurNearestSettlement(false, Integer.MAX_VALUE, false);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier and is connected to Europe by sea, or
	 * Europe if it is closer.
	 *
	 * @return A path to the nearest settlement if any, otherwise null (for now
	 *         including if in Europe or at sea).
	 */
	public PathNode findOurNearestPort() {
<span class="fc" id="L2984">		PathNode ePath = null;</span>
<span class="fc" id="L2985">		int eTurns = -1;</span>
<span class="fc" id="L2986">		Europe europe = getOwner().getEurope();</span>
<span class="pc bpc" id="L2987" title="1 of 2 branches missed.">		if (getType().canMoveToHighSeas()) {</span>
<span class="pc bpc" id="L2988" title="1 of 2 branches missed.">			ePath = (europe == null) ? null : findPath(europe);</span>
<span class="fc bfc" id="L2989" title="All 2 branches covered.">			eTurns = (ePath == null) ? -1 : ePath.getTotalTurns();</span>
		}
<span class="fc" id="L2991">		PathNode sPath = findOurNearestSettlement(false, INFINITY, true);</span>
<span class="fc bfc" id="L2992" title="All 2 branches covered.">		int sTurns = (sPath == null) ? -1 : sPath.getTotalTurns();</span>
<span class="pc bpc" id="L2993" title="1 of 6 branches missed.">		return (ePath == null) ? sPath : (sPath == null) ? ePath : (sTurns &lt;= eTurns) ? sPath : ePath;</span>
	}

	/**
	 * Find a path to a settlement nearer to a destination.
	 *
	 * Used to find where to deliver goods to/from inland colonies, or when
	 * blocked.
	 *
	 * @param dst
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @return A path to the port, or null if none found.
	 */
	public PathNode findIntermediatePort(Location dst) {
<span class="nc" id="L3007">		final Settlement ignoreSrc = getSettlement();</span>
<span class="nc" id="L3008">		final Settlement ignoreDst = dst.getSettlement();</span>
<span class="nc" id="L3009">		final Tile srcTile = getTile();</span>
<span class="nc" id="L3010">		final Tile dstTile = dst.getTile();</span>
<span class="nc bnc" id="L3011" title="All 2 branches missed.">		final int dstCont = (dstTile == null) ? -1 : dstTile.getContiguity();</span>
<span class="nc" id="L3012">		PathNode path, best = null;</span>
<span class="nc" id="L3013">		int value, bestValue = INFINITY;</span>
		int type;

<span class="nc bnc" id="L3016" title="All 2 branches missed.">		if (isNaval()) {</span>
<span class="nc bnc" id="L3017" title="All 2 branches missed.">			if (!srcTile.isHighSeasConnected()) {</span>
				// On a lake! FIXME: do better
<span class="nc" id="L3019">				type = 0;</span>
<span class="nc bnc" id="L3020" title="All 2 branches missed.">			} else if (dstTile == null) {</span>
				// Carrier must be blocked from high seas
<span class="nc" id="L3022">				type = 1;</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">			} else if (dstTile.isHighSeasConnected()) {</span>
				// Carrier is blocked or destination is blocked.
<span class="nc bnc" id="L3025" title="All 2 branches missed.">				type = (getTile().isOnRiver()) ? 1 : 2;</span>
			} else {
				// Destination must be blocked
<span class="nc" id="L3028">				type = 2;</span>
			}
		} else {
<span class="nc bnc" id="L3031" title="All 4 branches missed.">			if (dstTile == null || getTile().getContiguity() != dstCont) {</span>
				// Ocean travel will be required
				// If already at port try to improve its connectivity,
				// otherwise go to a port.
<span class="nc bnc" id="L3035" title="All 2 branches missed.">				type = (srcTile.isHighSeasConnected()) ? 1 : 2;</span>
			} else {
				// Pure land travel, just find a nearer settlement.
<span class="nc" id="L3038">				type = 3;</span>
			}
		}

<span class="nc bnc" id="L3042" title="All 5 branches missed.">		switch (type) {</span>
		case 0:
			// No progress possible.
<span class="nc" id="L3045">			break;</span>
		case 1:
			// Starting on a river, probably blocked in there.
			// Find the settlement that most reduces the high seas count.
<span class="nc" id="L3049">			best = search(getLocation(), GoalDeciders.getReduceHighSeasCountGoalDecider(this), null, INFINITY, null);</span>
<span class="nc" id="L3050">			break;</span>
		case 2:
			// Ocean travel required, destination blocked.
			// Find the closest available connected port.
<span class="nc bnc" id="L3054" title="All 2 branches missed.">			for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L3055" title="All 8 branches missed.">				if (s != ignoreSrc &amp;&amp; s != ignoreDst &amp;&amp; s.isConnectedPort() &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L3056">					value = path.getTotalTurns() + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">					if (bestValue &gt; value) {</span>
<span class="nc" id="L3058">						bestValue = value;</span>
<span class="nc" id="L3059">						best = path;</span>
					}
				}
<span class="nc" id="L3062">			}</span>
<span class="nc" id="L3063">			break;</span>
		case 3:
			// Land travel. Find nearby settlement with correct contiguity.
<span class="nc bnc" id="L3066" title="All 2 branches missed.">			for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L3067" title="All 6 branches missed.">				if (s != ignoreSrc &amp;&amp; s != ignoreDst &amp;&amp; s.getTile().getContiguity() == dstCont</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">						&amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L3069">					value = path.getTotalTurns() + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L3070" title="All 2 branches missed.">					if (bestValue &gt; value) {</span>
<span class="nc" id="L3071">						bestValue = value;</span>
<span class="nc" id="L3072">						best = path;</span>
					}
				}
<span class="nc" id="L3075">			}</span>
		}
<span class="nc bnc" id="L3077" title="All 2 branches missed.">		return (best != null) ? best : findOurNearestSettlement(false, INFINITY, false);</span>
	}

	/**
	 * Find a path for this unit to the nearest settlement with the same owner
	 * that is reachable without a carrier, excepting any on the current tile.
	 *
	 * @return The nearest settlement if any, otherwise null.
	 */
	public PathNode findOurNearestOtherSettlement() {
<span class="nc" id="L3087">		return findOurNearestSettlement(true, Integer.MAX_VALUE, false);</span>
	}

	/**
	 * Convenience wrapper for the
	 * {@link net.sf.freecol.common.model.Map#search} function.
	 *
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param gd
	 *            The object responsible for determining whether a given
	 *            &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
	 * @param cd
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; responsible for
	 *            determining the path cost.
	 * @param maxTurns
	 *            The maximum number of turns the given &lt;code&gt;Unit&lt;/code&gt; is
	 *            allowed to move. This is the maximum search range for a goal.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @return The path to a goal, or null if none can be found.
	 */
	public PathNode search(Location start, GoalDecider gd, CostDecider cd, int maxTurns, Unit carrier) {
<span class="pc bpc" id="L3110" title="1 of 2 branches missed.">		return (start == null) ? null : getGame().getMap().search(this, start, gd, cd, maxTurns, carrier, null);</span>
	}

	/**
	 * Can this unit attack a specified defender?
	 *
	 * A naval unit can never attack a land unit or settlement, but a land unit
	 * *can* attack a naval unit if it is beached. Otherwise naval units can
	 * only fight at sea, land units only on land.
	 *
	 * @param defender
	 *            The defending &lt;code&gt;Unit&lt;/code&gt;.
	 * @return True if this unit can attack.
	 */
	public boolean canAttack(Unit defender) {
<span class="pc bpc" id="L3125" title="3 of 6 branches missed.">		if (!isOffensiveUnit() || defender == null || !defender.hasTile()) {</span>
<span class="nc" id="L3126">			return false;</span>
		}

<span class="fc" id="L3129">		Tile tile = defender.getTile();</span>
<span class="pc bpc" id="L3130" title="8 of 10 branches missed.">		return (isNaval()) ? !tile.hasSettlement() &amp;&amp; defender.isNaval() : !defender.isNaval() || defender.isBeached();</span>
	}

	/**
	 * Searches for a unit that is a credible threatening unit to this unit
	 * within a range.
	 *
	 * @param range
	 *            The number of turns to search for a threat in.
	 * @param threat
	 *            The maximum tolerable probability of a potentially threatening
	 *            unit defeating this unit in combat.
	 * @return A path to the threat, or null if not found.
	 */
	public PathNode searchForDanger(final int range, final float threat) {
<span class="nc" id="L3145">		final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L3146">		final Tile start = getTile();</span>
<span class="nc" id="L3147">		final GoalDecider threatDecider = new GoalDecider() {</span>
<span class="nc" id="L3148">			private PathNode found = null;</span>

			@Override
			public PathNode getGoal() {
<span class="nc" id="L3152">				return found;</span>
			}

			@Override
			public boolean hasSubGoals() {
<span class="nc" id="L3157">				return false;</span>
			}

			@Override
			public boolean check(Unit unit, PathNode path) {
<span class="nc" id="L3162">				Tile tile = path.getTile();</span>
<span class="nc bnc" id="L3163" title="All 2 branches missed.">				if (tile == null) {</span>
<span class="nc" id="L3164">					return false;</span>
				}
<span class="nc" id="L3166">				Unit first = tile.getFirstUnit();</span>
<span class="nc bnc" id="L3167" title="All 4 branches missed.">				if (first == null || !getOwner().atWarWith(first.getOwner())) {</span>
<span class="nc" id="L3168">					return false;</span>
				}
<span class="nc bnc" id="L3170" title="All 2 branches missed.">				for (Unit u : tile.getUnitList()) {</span>
					PathNode reverse;
<span class="nc bnc" id="L3172" title="All 4 branches missed.">					if (u.canAttack(unit) &amp;&amp; cm.calculateCombatOdds(u, unit).win &gt;= threat</span>
<span class="nc bnc" id="L3173" title="All 4 branches missed.">							&amp;&amp; (reverse = u.findPath(start)) != null &amp;&amp; reverse.getTotalTurns() &lt; range) {</span>
<span class="nc" id="L3174">						found = path;</span>
<span class="nc" id="L3175">						return true;</span>
					}
<span class="nc" id="L3177">				}</span>
<span class="nc" id="L3178">				return false;</span>
			}
		};
		// The range to search will depend on the speed of the other
		// unit. We can not know what it will be in advance, and it
		// might be significantly faster than this unit. We do not
		// want to just use an unbounded search range because this
		// routine must be quick (especially when the supplied range
		// is low). So use the heuristic of increasing the range by
		// the ratio of the fastest appropriate (land/naval) unit type
		// speed over the unit speed.
<span class="nc bnc" id="L3189" title="All 2 branches missed.">		int reverseRange = range * (((isNaval()) ? getSpecification().getFastestNavalUnitType()</span>
<span class="nc" id="L3190">				: getSpecification().getFastestLandUnitType()).getMovement()) / this.getType().getMovement();</span>

<span class="nc bnc" id="L3192" title="All 2 branches missed.">		return (start == null) ? null</span>
<span class="nc" id="L3193">				: search(start, threatDecider, CostDeciders.avoidIllegal(), reverseRange, getCarrier());</span>
	}

	/**
	 * Checks if there is a credible threatening unit to this unit within a
	 * range of moves.
	 *
	 * @param range
	 *            The number of turns to search for a threat within.
	 * @param threat
	 *            The maximum tolerable probability of a potentially threatening
	 *            unit defeating this unit in combat.
	 * @return True if a threat was found.
	 */
	public boolean isInDanger(int range, float threat) {
<span class="nc bnc" id="L3208" title="All 2 branches missed.">		return searchForDanger(range, threat) != null;</span>
	}

	/**
	 * Gets the line of sight of this &lt;code&gt;Unit&lt;/code&gt;. That is the distance
	 * this &lt;code&gt;Unit&lt;/code&gt; can sight new tiles.
	 *
	 * @return The line of sight of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public int getLineOfSight() {
<span class="fc" id="L3218">		final Turn turn = getGame().getTurn();</span>
<span class="fc" id="L3219">		Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L3220">		result.addAll(this.getModifiers(Modifier.LINE_OF_SIGHT_BONUS, unitType, turn));</span>
<span class="pc bpc" id="L3221" title="1 of 4 branches missed.">		if (hasTile() &amp;&amp; getTile().isExplored()) {</span>
<span class="fc" id="L3222">			result.addAll(getTile().getType().getModifiers(Modifier.LINE_OF_SIGHT_BONUS, unitType, turn));</span>
		}
<span class="fc" id="L3224">		float base = unitType.getLineOfSight();</span>
<span class="fc" id="L3225">		return (int) applyModifiers(base, turn, result);</span>
	}

	// Goods handling

	/**
	 * Get the goods carried by this unit.
	 *
	 * @return A list of &lt;code&gt;Goods&lt;/code&gt;.
	 */
	public List&lt;Goods&gt; getGoodsList() {
<span class="pc bpc" id="L3236" title="1 of 2 branches missed.">		return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList() : getGoodsContainer().getGoods();</span>
	}

	/**
	 * Get a compact version of the goods carried by this unit.
	 *
	 * @return A compact list of &lt;code&gt;Goods&lt;/code&gt;.
	 */
	public List&lt;Goods&gt; getCompactGoodsList() {
<span class="pc bpc" id="L3245" title="1 of 2 branches missed.">		return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList() : getGoodsContainer().getCompactGoods();</span>
	}

	/**
	 * Can this unit carry other units?.
	 *
	 * @return True if the unit can carry units.
	 */
	public boolean canCarryUnits() {
<span class="fc" id="L3254">		return hasAbility(Ability.CARRY_UNITS);</span>
	}

	/**
	 * Could this unit carry a specified one? This ignores the current load.
	 *
	 * @param u
	 *            The potential cargo &lt;code&gt;Unit&lt;/code&gt;.
	 * @return True if this unit can carry the cargo.
	 */
	public boolean couldCarry(Unit u) {
<span class="pc bpc" id="L3265" title="1 of 4 branches missed.">		return canCarryUnits() &amp;&amp; getCargoCapacity() &gt;= u.getSpaceTaken();</span>
	}

	/**
	 * Can this unit carry goods.
	 *
	 * @return True if the unit can carry goods.
	 */
	public boolean canCarryGoods() {
<span class="fc" id="L3274">		return hasAbility(Ability.CARRY_GOODS);</span>
	}

	/**
	 * Could this unit carry some specified goods? This ignores the current
	 * load.
	 *
	 * @param g
	 *            The potential cargo &lt;code&gt;Goods&lt;/code&gt;.
	 * @return True if this unit can carry the cargo.
	 */
	public boolean couldCarry(Goods g) {
<span class="pc bpc" id="L3286" title="2 of 4 branches missed.">		return canCarryGoods() &amp;&amp; getCargoCapacity() &gt;= g.getSpaceTaken();</span>
	}

	/**
	 * Gets the number of free cargo slots left on this unit.
	 *
	 * @return The number of free cargo slots on this unit.
	 */
	public int getSpaceLeft() {
<span class="fc" id="L3295">		return getCargoCapacity() - getCargoSpaceTaken();</span>
	}

	/**
	 * Is there free space left on this unit?.
	 *
	 * @return True if there is free space.
	 */
	public boolean hasSpaceLeft() {
<span class="fc bfc" id="L3304" title="All 2 branches covered.">		return getSpaceLeft() &gt; 0;</span>
	}

	/**
	 * Gets the total space this unit has to carry cargo.
	 *
	 * @return The total space.
	 */
	public int getCargoCapacity() {
<span class="fc" id="L3313">		return unitType.getSpace();</span>
	}

	/**
	 * Gets the space occupied by goods in this unit. Must defend against goods
	 * container being null as this can be called in the client on foreign
	 * units, which will not have goods containers.
	 *
	 * @return The number cargo slots occupied by goods.
	 */
	public int getGoodsSpaceTaken() {
<span class="pc bpc" id="L3324" title="1 of 2 branches missed.">		if (!canCarryGoods())</span>
<span class="nc" id="L3325">			return 0;</span>
<span class="fc" id="L3326">		GoodsContainer gc = getGoodsContainer();</span>
<span class="pc bpc" id="L3327" title="1 of 2 branches missed.">		return (gc == null) ? 0 : gc.getSpaceTaken();</span>
	}

	/**
	 * Gets the space occupied by units in this unit.
	 *
	 * @return The number of cargo slots occupied by units.
	 */
	public int getUnitSpaceTaken() {
<span class="fc bfc" id="L3336" title="All 2 branches covered.">		return (canCarryUnits()) ? getUnitList().stream().mapToInt(u -&gt; u.getSpaceTaken()).sum() : 0;</span>
	}

	/**
	 * Gets the space occupied by cargo in this unit (both goods and units).
	 *
	 * @return The number of occupied cargo slots.
	 */
	public int getCargoSpaceTaken() {
<span class="fc" id="L3345">		return getGoodsSpaceTaken() + getUnitSpaceTaken();</span>
	}

	/**
	 * Is this unit carrying any goods cargo?.
	 *
	 * @return True if the unit is carrying any goods cargo.
	 */
	public boolean hasGoodsCargo() {
<span class="fc bfc" id="L3354" title="All 2 branches covered.">		return getGoodsSpaceTaken() &gt; 0;</span>
	}

	/**
	 * Is this unit carrying any cargo (goods or unit).
	 *
	 * @return True if the unit is carrying any cargo.
	 */
	public boolean hasCargo() {
<span class="nc bnc" id="L3363" title="All 2 branches missed.">		return getCargoSpaceTaken() &gt; 0;</span>
	}

	/**
	 * Gets the extra amount of a specified type of goods that could be loaded
	 * onto this unit. Includes empty cargo slots and any spare space in a slot
	 * partially filled with the specified goods.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to examine.
	 * @return The amount of goods that could be loaded onto this unit.
	 */
	public int getLoadableAmount(GoodsType type) {
<span class="pc bpc" id="L3376" title="1 of 2 branches missed.">		if (!canCarryGoods()) {</span>
<span class="nc" id="L3377">			return 0;</span>
		}
<span class="fc" id="L3379">		int result = getSpaceLeft() * GoodsContainer.CARGO_SIZE;</span>
<span class="fc" id="L3380">		int count = getGoodsCount(type) % GoodsContainer.CARGO_SIZE;</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">		if (count != 0) {</span>
<span class="fc" id="L3382">			result += GoodsContainer.CARGO_SIZE - count;</span>
		}
<span class="fc" id="L3384">		return result;</span>
	}

	// Miscellaneous more complex functionality

	/**
	 * Get a label for the current unit occupation.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; viewing the unit, as the owner has
	 *            access to more information.
	 * @param full
	 *            If true, return a more detailed result.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the unit occupation.
	 */
	public StringTemplate getOccupationLabel(Player player, boolean full) {
<span class="nc" id="L3400">		final TradeRoute tradeRoute = getTradeRoute();</span>
		StringTemplate ret;
<span class="nc bnc" id="L3402" title="All 4 branches missed.">		if (player != null &amp;&amp; player.owns(this)) {</span>
<span class="nc bnc" id="L3403" title="All 2 branches missed.">			if (isDamaged()) {</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">				if (full) {</span>
<span class="nc" id="L3405">					ret = StringTemplate.label(&quot;:&quot;).add(&quot;model.unit.occupation.underRepair&quot;)</span>
<span class="nc" id="L3406">							.addName(String.valueOf(getTurnsForRepair()));</span>
				} else {
<span class="nc" id="L3408">					ret = StringTemplate.key(&quot;model.unit.occupation.underRepair&quot;);</span>
				}
<span class="nc bnc" id="L3410" title="All 2 branches missed.">			} else if (tradeRoute != null) {</span>
<span class="nc bnc" id="L3411" title="All 2 branches missed.">				if (full) {</span>
<span class="nc" id="L3412">					ret = StringTemplate.label(&quot;:&quot;).add(&quot;model.unit.occupation.inTradeRoute&quot;)</span>
<span class="nc" id="L3413">							.addName(tradeRoute.getName());</span>
				} else {
<span class="nc" id="L3415">					ret = StringTemplate.key(&quot;model.unit.occupation.inTradeRoute&quot;);</span>
				}
<span class="nc bnc" id="L3417" title="All 4 branches missed.">			} else if (getState() == UnitState.ACTIVE &amp;&amp; getMovesLeft() == 0) {</span>
<span class="nc" id="L3418">				ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
<span class="nc bnc" id="L3419" title="All 4 branches missed.">			} else if (getState() == UnitState.IMPROVING &amp;&amp; getWorkImprovement() != null) {</span>
<span class="nc bnc" id="L3420" title="All 2 branches missed.">				if (full) {</span>
<span class="nc" id="L3421">					ret = StringTemplate.label(&quot;:&quot;).add(getWorkImprovement().getType() + &quot;.occupationString&quot;)</span>
<span class="nc" id="L3422">							.addName(String.valueOf(getWorkTurnsLeft()));</span>
				} else {
<span class="nc" id="L3424">					ret = StringTemplate.key(getWorkImprovement().getType() + &quot;.occupationString&quot;);</span>
				}
<span class="nc bnc" id="L3426" title="All 2 branches missed.">			} else if (getDestination() != null) {</span>
<span class="nc" id="L3427">				ret = StringTemplate.key(&quot;model.unit.occupation.goingSomewhere&quot;);</span>
			} else {
<span class="nc" id="L3429">				ret = StringTemplate.key(&quot;model.unit.&quot; + getState().getKey());</span>
			}
		} else {
<span class="nc bnc" id="L3432" title="All 2 branches missed.">			if (isNaval()) {</span>
<span class="nc" id="L3433">				ret = StringTemplate.name(String.valueOf(getVisibleGoodsCount()));</span>
			} else {
<span class="nc" id="L3435">				ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
			}
		}
<span class="nc" id="L3438">		return ret;</span>
	}

	/**
	 * Gets the probability that an attack by this unit will provoke a native to
	 * convert.
	 *
	 * @return A probability of conversion.
	 */
	public float getConvertProbability() {
<span class="fc" id="L3448">		final Specification spec = getSpecification();</span>
<span class="fc" id="L3449">		int opt = spec.getInteger(GameOptions.NATIVE_CONVERT_PROBABILITY);</span>
<span class="fc" id="L3450">		return 0.01f * applyModifiers(opt, getGame().getTurn(), Modifier.NATIVE_CONVERT_BONUS);</span>
	}

	/**
	 * Gets the probability that an attack by this unit will provoke natives to
	 * burn our missions.
	 *
	 * FIXME: enhance burn probability proportionally with tension
	 *
	 * @return A probability of burning missions.
	 */
	public float getBurnProbability() {
<span class="nc" id="L3462">		final Specification spec = getSpecification();</span>
<span class="nc" id="L3463">		return 0.01f * spec.getInteger(GameOptions.BURN_PROBABILITY);</span>
	}

	/**
	 * Get a type change for this unit.
	 *
	 * @param change
	 *            The &lt;code&gt;ChangeType&lt;/code&gt; to consider.
	 * @param owner
	 *            The &lt;code&gt;Player&lt;/code&gt; to own this unit after a change of
	 *            type CAPTURE or UNDEAD.
	 * @return The resulting unit type or null if there is no change suitable.
	 */
	public UnitType getTypeChange(ChangeType change, Player owner) {
<span class="fc" id="L3477">		return getType().getTargetType(change, owner);</span>
	}

	/**
	 * Checks if the treasure train can be cashed in at it's current
	 * &lt;code&gt;Location&lt;/code&gt;.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
	 * @exception IllegalStateException
	 *                if this unit is not a treasure train.
	 */
	public boolean canCashInTreasureTrain() {
<span class="fc" id="L3489">		return canCashInTreasureTrain(getLocation());</span>
	}

	/**
	 * Checks if the treasure train can be cashed in at the given
	 * &lt;code&gt;Location&lt;/code&gt;.
	 *
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt;.
	 * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
	 * @exception IllegalStateException
	 *                if this unit is not a treasure train.
	 */
	public boolean canCashInTreasureTrain(Location loc) {
<span class="pc bpc" id="L3503" title="1 of 2 branches missed.">		if (!canCarryTreasure()) {</span>
<span class="nc" id="L3504">			throw new IllegalStateException(&quot;Can't carry treasure&quot;);</span>
		}
<span class="fc bfc" id="L3506" title="All 2 branches covered.">		if (loc == null) {</span>
<span class="fc" id="L3507">			return false;</span>
		}

<span class="pc bpc" id="L3510" title="1 of 2 branches missed.">		if (getOwner().getEurope() == null) {</span>
			// Any colony will do once independent, as the treasure stays
			// in the New World.
<span class="nc bnc" id="L3513" title="All 2 branches missed.">			return loc.getColony() != null;</span>
		}
<span class="fc bfc" id="L3515" title="All 2 branches covered.">		if (loc.getColony() != null) {</span>
			// Cash in if at a colony which has connectivity to Europe
			// unless the player has a suitable carrier and no free transport.
<span class="fc bfc" id="L3518" title="All 2 branches covered.">			return loc.getColony().isConnectedPort()</span>
<span class="pc bpc" id="L3519" title="1 of 4 branches missed.">					&amp;&amp; (getOwner().getCarriersForUnit(this).isEmpty() || getTransportFee() == 0);</span>
		}
		// Otherwise, cash in if in Europe.
<span class="pc bpc" id="L3522" title="2 of 6 branches missed.">		return loc instanceof Europe || (loc instanceof Unit &amp;&amp; ((Unit) loc).isInEurope());</span>
	}

	/**
	 * Get the fee that would have to be paid to transport this treasure to
	 * Europe.
	 *
	 * @return The fee required for transport.
	 */
	public int getTransportFee() {
<span class="pc bpc" id="L3532" title="1 of 4 branches missed.">		if (!isInEurope() &amp;&amp; getOwner().getEurope() != null) {</span>
<span class="fc" id="L3533">			float fee = (getSpecification().getInteger(GameOptions.TREASURE_TRANSPORT_FEE) * getTreasureAmount())</span>
					/ 100.0f;
<span class="fc" id="L3535">			return (int) getOwner().applyModifiers(fee, getGame().getTurn(), Modifier.TREASURE_TRANSPORT_FEE, unitType);</span>
		}
<span class="fc" id="L3537">		return 0;</span>
	}

	/**
	 * Gets the skill level.
	 *
	 * @return The level of skill for this unit. A higher value signals a more
	 *         advanced type of units.
	 */
	public int getSkillLevel() {
<span class="fc" id="L3547">		return getSkillLevel(unitType);</span>
	}

	/**
	 * Gets the skill level of the given type of &lt;code&gt;Unit&lt;/code&gt;.
	 *
	 * @param unitType
	 *            The type of &lt;code&gt;Unit&lt;/code&gt;.
	 * @return The level of skill for the given unit. A higher value signals a
	 *         more advanced type of units.
	 */
	public static int getSkillLevel(UnitType unitType) {
<span class="pc bpc" id="L3559" title="1 of 2 branches missed.">		return (unitType.hasSkill()) ? unitType.getSkill() : 0;</span>
	}

	/**
	 * Gets the appropriate trade bonuses due to a missionary unit.
	 *
	 * @param sense
	 *            The sense to apply the modifiers.
	 * @return The missionary trade bonuses.
	 */
	public Set&lt;Modifier&gt; getMissionaryTradeModifiers(boolean sense) {
<span class="nc" id="L3570">		HashSet&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">		for (Modifier m : getModifiers(Modifier.MISSIONARY_TRADE_BONUS)) {</span>
<span class="nc" id="L3572">			Modifier modifier = new Modifier(m);</span>
<span class="nc bnc" id="L3573" title="All 2 branches missed.">			if (!sense) {</span>
<span class="nc" id="L3574">				modifier.setValue(-m.getValue());</span>
			}
<span class="nc" id="L3576">			result.add(modifier);</span>
<span class="nc" id="L3577">		}</span>
<span class="nc" id="L3578">		return result;</span>
	}

	/**
	 * Adds a feature to the Unit. This method always throws an
	 * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, since features can not be
	 * added to Units directly.
	 *
	 * @param feature
	 *            The &lt;code&gt;Feature&lt;/code&gt; to add.
	 */
	public void addFeature(Feature feature) {
<span class="nc" id="L3590">		throw new UnsupportedOperationException(&quot;Can not add Feature to Unit directly!&quot;);</span>
	}

	/**
	 * Gets the &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
	 *
	 * FIXME: the input parameter is ignored! Fix?
	 *
	 * @param input
	 *            A list of input &lt;code&gt;AbstractGoods&lt;/code&gt;.
	 * @return The &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
	 */
	public ProductionInfo getProductionInfo(List&lt;AbstractGoods&gt; input) {
<span class="fc" id="L3603">		ProductionInfo result = new ProductionInfo();</span>
<span class="fc" id="L3604">		result.setConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3605">		result.setMaximumConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3606">		return result;</span>
	}

	/**
	 * Score this unit with its suitability for pioneering.
	 *
	 * A pioneer must be a colonst. Favour: - existing pioneers especially if on
	 * the map - expert pioneer units - then by skill but not other experts
	 *
	 * @return A pioneering score.
	 */
	public int getPioneerScore() {
<span class="nc bnc" id="L3618" title="All 2 branches missed.">		int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3619" title="All 4 branches missed.">		return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3620" title="All 2 branches missed.">				: (hasAbility(Ability.IMPROVE_TERRAIN)) ? 900 + ht</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">						: (hasAbility(Ability.EXPERT_PIONEER)) ? 700</span>
<span class="nc bnc" id="L3622" title="All 4 branches missed.">								: (!hasDefaultRole()) ? 0 : (getSkillLevel() &gt; 0) ? 0 : 200 + getSkillLevel() * 50;</span>
	}

	/**
	 * Score this unit with its suitability for scouting.
	 *
	 * A scout must be a colonist. Favour: - existing scouts especially if on
	 * the map - expert scouts - lower skill level as scouting is a good career
	 * for crims and servants which might become seasoned scouts
	 *
	 * @return A scouting score.
	 */
	public int getScoutScore() {
<span class="nc bnc" id="L3635" title="All 2 branches missed.">		int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3636" title="All 4 branches missed.">		return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3637" title="All 2 branches missed.">				: (hasAbility(Ability.SPEAK_WITH_CHIEF)) ? 900 + ht</span>
<span class="nc bnc" id="L3638" title="All 2 branches missed.">						: (hasAbility(Ability.EXPERT_SCOUT)) ? 700</span>
<span class="nc bnc" id="L3639" title="All 4 branches missed.">								: (!hasDefaultRole()) ? 0 : (getSkillLevel() &lt;= 0) ? -200 * getSkillLevel() : 0;</span>
	}

	/**
	 * Evaluate this unit for trade purposes.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
	 * @return A value of this unit.
	 */
	public int evaluateFor(Player player) {
<span class="nc" id="L3650">		final Europe europe = player.getEurope();</span>
<span class="nc bnc" id="L3651" title="All 4 branches missed.">		if (player.isAI() &amp;&amp; player.getUnits().size() &lt; 10) {</span>
<span class="nc" id="L3652">			return Integer.MIN_VALUE;</span>
		}
<span class="nc bnc" id="L3654" title="All 2 branches missed.">		return (europe == null) ? 500 : europe.getUnitPrice(getType());</span>
	}

	// @compat 0.11.0
	/**
	 * Get modifiers required for combat.
	 * 
	 * This can be replaced with just getModifiers() when accepted
	 * specifications have all combat modifiers with correct index values.
	 *
	 * @param id
	 *            the id
	 * @param fcgot
	 *            the fcgot
	 * @param turn
	 *            the turn
	 * @return the combat modifiers
	 */
	public Set&lt;Modifier&gt; getCombatModifiers(String id, FreeColGameObjectType fcgot, Turn turn) {
<span class="fc" id="L3673">		final Player owner = getOwner();</span>
<span class="fc" id="L3674">		final UnitType unitType = getType();</span>
<span class="fc" id="L3675">		Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

		// UnitType modifiers always apply
<span class="fc bfc" id="L3678" title="All 2 branches covered.">		for (Modifier m : unitType.getModifiers(id, fcgot, turn)) {</span>
<span class="pc bfc" id="L3679" title="All 2 branches covered.">			switch (m.getType()) {</span>
			case ADDITIVE:
<span class="fc" id="L3681">				m.setModifierIndex(Modifier.UNIT_ADDITIVE_COMBAT_INDEX);</span>
<span class="fc" id="L3682">				break;</span>
			default:
<span class="fc" id="L3684">				m.setModifierIndex(Modifier.UNIT_NORMAL_COMBAT_INDEX);</span>
				break;
			}
<span class="fc" id="L3687">			result.add(m);</span>
<span class="fc" id="L3688">		}</span>

		// The player's modifiers may not all apply
<span class="fc bfc" id="L3691" title="All 2 branches covered.">		for (Modifier m : owner.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3692">			m.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
<span class="fc" id="L3693">			result.add(m);</span>
<span class="fc" id="L3694">		}</span>

		// Role modifiers apply
<span class="fc bfc" id="L3697" title="All 2 branches covered.">		for (Modifier m : role.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3698">			m.setModifierIndex(Modifier.ROLE_COMBAT_INDEX);</span>
<span class="fc" id="L3699">			result.add(m);</span>
<span class="fc" id="L3700">		}</span>

<span class="fc" id="L3702">		return result;</span>
	}
	// end @compat 0.11.0

	// Message unpacking support.

	/**
	 * Gets the tile in a given direction.
	 *
	 * @param directionString
	 *            The direction.
	 * @return The &lt;code&gt;Tile&lt;/code&gt; in the given direction.
	 * @throws IllegalStateException
	 *             if there is trouble.
	 */
	public Tile getNeighbourTile(String directionString) {
<span class="nc bnc" id="L3718" title="All 2 branches missed.">		if (!hasTile()) {</span>
<span class="nc" id="L3719">			throw new IllegalStateException(&quot;Unit is not on the map: &quot; + getId());</span>
		}

<span class="nc" id="L3722">		Direction direction = Enum.valueOf(Direction.class, directionString);</span>
<span class="nc" id="L3723">		Tile tile = getTile().getNeighbourOrNull(direction);</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">		if (tile == null) {</span>
<span class="nc" id="L3725">			throw new IllegalStateException(</span>
<span class="nc" id="L3726">					&quot;Could not find tile&quot; + &quot; in direction: &quot; + direction + &quot; from unit: &quot; + getId());</span>
		}
<span class="nc" id="L3728">		return tile;</span>
	}

	/**
	 * Get a settlement by identifier, validating as much as possible. Designed
	 * for message unpacking where the identifier should not be trusted.
	 *
	 * @param settlementId
	 *            The identifier of the &lt;code&gt;Settlement&lt;/code&gt; to be found.
	 * @return The settlement corresponding to the settlementId argument.
	 * @throws IllegalStateException
	 *             on failure to validate the settlementId in any way.
	 */
	public Settlement getAdjacentSettlementSafely(String settlementId) throws IllegalStateException {
<span class="nc" id="L3742">		Game game = getOwner().getGame();</span>

<span class="nc" id="L3744">		Settlement settlement = game.getFreeColGameObject(settlementId, Settlement.class);</span>
<span class="nc bnc" id="L3745" title="All 2 branches missed.">		if (settlement == null) {</span>
<span class="nc" id="L3746">			throw new IllegalStateException(&quot;Not a settlement: &quot; + settlementId);</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">		} else if (settlement.getTile() == null) {</span>
<span class="nc" id="L3748">			throw new IllegalStateException(&quot;Settlement is not on the map: &quot; + settlementId);</span>
		}

<span class="nc bnc" id="L3751" title="All 2 branches missed.">		if (!hasTile()) {</span>
<span class="nc" id="L3752">			throw new IllegalStateException(&quot;Unit is not on the map: &quot; + getId());</span>
<span class="nc bnc" id="L3753" title="All 2 branches missed.">		} else if (getTile().getDistanceTo(settlement.getTile()) &gt; 1) {</span>
<span class="nc" id="L3754">			throw new IllegalStateException(&quot;Unit &quot; + getId() + &quot; is not adjacent to settlement: &quot; + settlementId);</span>
<span class="nc bnc" id="L3755" title="All 2 branches missed.">		} else if (getOwner() == settlement.getOwner()) {</span>
<span class="nc" id="L3756">			throw new IllegalStateException(&quot;Unit: &quot; + getId() + &quot; and settlement: &quot; + settlementId</span>
<span class="nc" id="L3757">					+ &quot; are both owned by player: &quot; + getOwner().getId());</span>
		}

<span class="nc" id="L3760">		return settlement;</span>
	}

	/**
	 * Get an adjacent Indian settlement by identifier, validating as much as
	 * possible, including checking whether the nation involved has been
	 * contacted. Designed for message unpacking where the identifier should not
	 * be trusted.
	 *
	 * @param id
	 *            The identifier of the &lt;code&gt;IndianSettlement&lt;/code&gt; to be
	 *            found.
	 * @return The settlement corresponding to the settlementId argument.
	 * @throws IllegalStateException
	 *             on failure to validate the settlementId in any way.
	 */
	public IndianSettlement getAdjacentIndianSettlementSafely(String id) throws IllegalStateException {
<span class="nc" id="L3777">		Settlement settlement = getAdjacentSettlementSafely(id);</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">		if (!(settlement instanceof IndianSettlement)) {</span>
<span class="nc" id="L3779">			throw new IllegalStateException(&quot;Not an indianSettlement: &quot; + id);</span>
<span class="nc bnc" id="L3780" title="All 2 branches missed.">		} else if (!getOwner().hasContacted(settlement.getOwner())) {</span>
<span class="nc" id="L3781">			throw new IllegalStateException(&quot;Player has not contacted the &quot; + settlement.getOwner().getNation());</span>
		}

<span class="nc" id="L3784">		return (IndianSettlement) settlement;</span>
	}

	// Interface Consumer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List&lt;AbstractGoods&gt; getConsumedGoods() {
<span class="fc" id="L3794">		return unitType.getConsumedGoods();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getPriority() {
<span class="fc" id="L3802">		return unitType.getPriority();</span>
	}

	// Interface Ownable

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Player getOwner() {
<span class="fc" id="L3812">		return owner;</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * -vis: This routine has visibility implications.
	 */
	@Override
	public void setOwner(Player player) {
<span class="fc" id="L3822">		this.owner = player;</span>
<span class="fc" id="L3823">	}</span>

	// Interface Locatable
	// getTile and getSpaceTaken are shared with Location below

	/**
	 * Gets the location of this unit.
	 *
	 * @return The location of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	@Override
	public Location getLocation() {
<span class="fc" id="L3835">		return location;</span>
	}

	/**
	 * Sets the location of this unit.
	 *
	 * -vis: This routine changes player visibility. -til: While units do not
	 * contribute to tile appearance as such, if they move in/out of a colony
	 * the visible colony size changes.
	 *
	 * @param newLocation
	 *            The new &lt;code&gt;Location&lt;/code&gt;.
	 * @return True if the location change succeeds.
	 */
	@Override
	public boolean setLocation(Location newLocation) {
		// It is possible to add a unit to a non-specific location
		// within a colony by specifying the colony as the new
		// location. Colony.joinColony handles this special case.
<span class="fc bfc" id="L3854" title="All 2 branches covered.">		if (newLocation instanceof Colony) {</span>
<span class="fc" id="L3855">			return ((Colony) newLocation).joinColony(this);</span>
		}

<span class="fc bfc" id="L3858" title="All 2 branches covered.">		if (newLocation == location) {</span>
<span class="fc" id="L3859">			return true;</span>
		}
<span class="fc bfc" id="L3861" title="All 4 branches covered.">		if (newLocation != null &amp;&amp; !newLocation.canAdd(this)) {</span>
<span class="fc" id="L3862">			logger.warning(&quot;Can not add &quot; + this + &quot; to &quot; + newLocation.getId());</span>
<span class="fc" id="L3863">			return false;</span>
		}

		// If the unit either starts or ends this move in a colony
		// then teaching status can change. However, if it moves
		// between locations within the same colony with the same
		// teaching ability, the teaching state should *not* change.
		// We have to handle this issue here in setLocation as this is
		// the only place that contains information about both
		// locations.
<span class="fc bfc" id="L3873" title="All 2 branches covered.">		Colony oldColony = (isInColony()) ? location.getColony() : null;</span>
<span class="fc bfc" id="L3874" title="All 2 branches covered.">		Colony newColony = (newLocation instanceof WorkLocation) ? newLocation.getColony() : null;</span>
<span class="fc bfc" id="L3875" title="All 4 branches covered.">		boolean withinColony = newColony != null &amp;&amp; newColony == oldColony;</span>
<span class="fc bfc" id="L3876" title="All 2 branches covered.">		boolean preserveEducation = withinColony</span>
<span class="fc bfc" id="L3877" title="All 2 branches covered.">				&amp;&amp; (((WorkLocation) location).canTeach() == ((WorkLocation) newLocation).canTeach());</span>

		// First disable education that will fail due to the move.
<span class="fc bfc" id="L3880" title="All 4 branches covered.">		if (oldColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3881">			oldColony.updateEducation(this, false);</span>
		}

		// Move out of the old location.
<span class="fc bfc" id="L3885" title="All 2 branches covered.">		if (location == null) {</span>
			; // do nothing
<span class="pc bpc" id="L3887" title="1 of 2 branches missed.">		} else if (!location.remove(this)) {// -vis</span>
			// &quot;Should not happen&quot; (should always be able to remove)
<span class="nc" id="L3889">			throw new RuntimeException(&quot;Failed to remove &quot; + this + &quot; from &quot; + location.getId());</span>
		}

		// Move in to the new location.
<span class="fc bfc" id="L3893" title="All 2 branches covered.">		if (newLocation == null) {</span>
<span class="fc" id="L3894">			setLocationNoUpdate(null);// -vis</span>
<span class="pc bpc" id="L3895" title="1 of 2 branches missed.">		} else if (!newLocation.add(this)) {// -vis</span>
			// &quot;Should not happen&quot; (canAdd was checked above)
<span class="nc" id="L3897">			throw new RuntimeException(&quot;Failed to add &quot; + this + &quot; to &quot; + newLocation.getId());</span>
		}

		// See if education needs to be re-enabled.
<span class="fc bfc" id="L3901" title="All 4 branches covered.">		if (newColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3902">			newColony.updateEducation(this, true);</span>
		}

		// Update population of any colonies involved.
<span class="fc bfc" id="L3906" title="All 2 branches covered.">		if (!withinColony) {</span>
<span class="fc bfc" id="L3907" title="All 2 branches covered.">			if (oldColony != null)</span>
<span class="fc" id="L3908">				oldColony.updatePopulation();</span>
<span class="fc bfc" id="L3909" title="All 2 branches covered.">			if (newColony != null)</span>
<span class="fc" id="L3910">				newColony.updatePopulation();</span>
		}
<span class="fc" id="L3912">		return true;</span>
	}

	/**
	 * Checks if this &lt;code&gt;Unit&lt;/code&gt; is located in Europe. That is; either
	 * directly or onboard a carrier which is in Europe.
	 *
	 * @return True if in &lt;code&gt;Europe&lt;/code&gt;.
	 */
	@Override
	public boolean isInEurope() {
<span class="fc bfc" id="L3923" title="All 2 branches covered.">		return (location instanceof Unit) ? ((Unit) location).isInEurope() : getLocation() instanceof Europe;</span>
	}

	// Interface Location (from GoodsLocation via UnitLocation)
	// Inherits
	// FreeColObject.getId
	// UnitLocation.getLocationLabelFor
	// UnitLocation.contains
	// UnitLocation.canAdd
	// UnitLocation.getUnitCount
	// UnitLocation.getUnitList
	// GoodsLocation.getGoodsContainer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Tile getTile() {
<span class="fc bfc" id="L3941" title="All 2 branches covered.">		return (location != null) ? location.getTile() : null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabel() {
<span class="nc" id="L3949">		return StringTemplate.template(&quot;model.unit.onBoard&quot;).addStringTemplate(&quot;%unit%&quot;, this.getLabel());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean add(Locatable locatable) {
<span class="fc bfc" id="L3957" title="All 2 branches covered.">		if (!canAdd(locatable)) {</span>
<span class="fc" id="L3958">			return false;</span>
<span class="fc bfc" id="L3959" title="All 2 branches covered.">		} else if (locatable instanceof Unit) {</span>
<span class="fc" id="L3960">			Unit unit = (Unit) locatable;</span>
<span class="pc bpc" id="L3961" title="1 of 2 branches missed.">			if (super.add(locatable)) {</span>
				// FIXME: there seems to be an inconsistency between
				// units moving from an adjacent tile onto a ship and
				// units boarding a ship in-colony. The former does not
				// appear to come through here (which it probably should)
				// as the ship's moves do not get zeroed.
<span class="fc" id="L3967">				spendAllMoves();</span>
<span class="fc" id="L3968">				unit.setState(UnitState.SENTRY);</span>
<span class="fc" id="L3969">				return true;</span>
			}
<span class="pc bpc" id="L3971" title="1 of 2 branches missed.">		} else if (locatable instanceof Goods) {</span>
<span class="fc" id="L3972">			Goods goods = (Goods) locatable;</span>
<span class="pc bpc" id="L3973" title="1 of 2 branches missed.">			if (super.addGoods(goods)) {</span>
<span class="fc" id="L3974">				spendAllMoves();</span>
<span class="fc" id="L3975">				return true;</span>
			}
<span class="nc" id="L3977">		} else {</span>
<span class="nc" id="L3978">			throw new IllegalStateException(&quot;Can not be added to unit: &quot; + locatable);</span>
		}
<span class="nc" id="L3980">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean remove(Locatable locatable) {
<span class="pc bpc" id="L3988" title="1 of 2 branches missed.">		if (locatable == null) {</span>
<span class="nc" id="L3989">			throw new IllegalArgumentException(&quot;Locatable must not be 'null'.&quot;);</span>
<span class="pc bpc" id="L3990" title="2 of 4 branches missed.">		} else if (locatable instanceof Unit &amp;&amp; canCarryUnits()) {</span>
<span class="pc bpc" id="L3991" title="1 of 2 branches missed.">			if (super.remove(locatable)) {</span>
<span class="fc" id="L3992">				spendAllMoves();</span>
<span class="fc" id="L3993">				return true;</span>
			}
<span class="nc bnc" id="L3995" title="All 4 branches missed.">		} else if (locatable instanceof Goods &amp;&amp; canCarryGoods()) {</span>
<span class="nc bnc" id="L3996" title="All 2 branches missed.">			if (super.removeGoods((Goods) locatable) != null) {</span>
<span class="nc" id="L3997">				spendAllMoves();</span>
<span class="nc" id="L3998">				return true;</span>
			}
		} else {
<span class="nc" id="L4001">			logger.warning(&quot;Tried to remove from unit: &quot; + locatable);</span>
		}
<span class="nc" id="L4003">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Settlement getSettlement() {
<span class="fc" id="L4011">		Location location = getLocation();</span>
<span class="fc bfc" id="L4012" title="All 2 branches covered.">		return (location != null) ? location.getSettlement() : null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location up() {
<span class="nc bnc" id="L4020" title="All 6 branches missed.">		return (isInEurope()) ? getLocation().up() : (isInColony()) ? getColony() : (hasTile()) ? getTile().up() : this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getRank() {
<span class="nc" id="L4028">		return Location.getRank(getLocation());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toShortString() {
<span class="fc" id="L4036">		StringBuilder sb = new StringBuilder(32);</span>
<span class="fc" id="L4037">		sb.append(getId()).append(&quot;-&quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L4038" title="All 2 branches covered.">		if (!hasDefaultRole()) {</span>
<span class="fc" id="L4039">			sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L4040">			int count = getRoleCount();</span>
<span class="fc bfc" id="L4041" title="All 2 branches covered.">			if (count &gt; 1)</span>
<span class="fc" id="L4042">				sb.append(&quot;.&quot;).append(count);</span>
		}
<span class="fc" id="L4044">		return sb.toString();</span>
	}

	// UnitLocation
	// Inherits
	// UnitLocation.getSpaceTaken
	// UnitLocation.moveToFront
	// UnitLocation.clearUnitList

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getSpaceTaken() {
		// We do not have to consider what this unit is carrying
		// because carriers can not be put onto carriers. Yet.
<span class="fc" id="L4060">		return unitType.getSpaceTaken();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public NoAddReason getNoAddReason(Locatable locatable) {
<span class="fc bfc" id="L4068" title="All 2 branches covered.">		if (locatable == this) {</span>
<span class="fc" id="L4069">			return NoAddReason.ALREADY_PRESENT;</span>
<span class="fc bfc" id="L4070" title="All 2 branches covered.">		} else if (locatable instanceof Unit) {</span>
<span class="pc bpc" id="L4071" title="1 of 2 branches missed.">			return (!canCarryUnits()) ? NoAddReason.WRONG_TYPE</span>
<span class="fc bfc" id="L4072" title="All 2 branches covered.">					: (locatable.getSpaceTaken() &gt; getSpaceLeft()) ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="fc" id="L4073">							: super.getNoAddReason(locatable);</span>
<span class="pc bpc" id="L4074" title="1 of 2 branches missed.">		} else if (locatable instanceof Goods) {</span>
<span class="fc" id="L4075">			Goods goods = (Goods) locatable;</span>
<span class="pc bpc" id="L4076" title="1 of 2 branches missed.">			return (!canCarryGoods()) ? NoAddReason.WRONG_TYPE</span>
<span class="fc bfc" id="L4077" title="All 2 branches covered.">					: (goods.getAmount() &gt; getLoadableAmount(goods.getType())) ? NoAddReason.CAPACITY_EXCEEDED</span>
							: NoAddReason.NONE;
			// Do not call super.getNoAddReason for goods because
			// the capacity test in GoodsLocation.getNoAddReason does not
			// account for packing and is thus too conservative.
		}
<span class="nc" id="L4083">		return super.getNoAddReason(locatable);</span>
	}

	// GoodsLocation
	// Inherits
	// GoodsLocation.addGoods
	// GoodsLocation.removeGoods

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getGoodsCapacity() {
<span class="nc" id="L4096">		return getCargoCapacity();</span>
	}

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 *
	 * -vis: This routine can change player visibility.
	 */
	@Override
	public void disposeResources() {
<span class="fc bfc" id="L4108" title="All 2 branches covered.">		if (location != null) {</span>
<span class="fc" id="L4109">			location.remove(this);</span>
			// Do not set location to null, units that are slaughtered in
			// battle need to remain valid during the animation.
		}

<span class="pc bpc" id="L4114" title="1 of 2 branches missed.">		if (teacher != null) {</span>
<span class="nc" id="L4115">			teacher.setStudent(null);</span>
<span class="nc" id="L4116">			teacher = null;</span>
		}

<span class="pc bpc" id="L4119" title="1 of 2 branches missed.">		if (student != null) {</span>
<span class="nc" id="L4120">			student.setTeacher(null);</span>
<span class="nc" id="L4121">			student = null;</span>
		}

<span class="fc" id="L4124">		setHomeIndianSettlement(null);</span>

<span class="fc" id="L4126">		getOwner().removeUnit(this);</span>

<span class="fc" id="L4128">		super.disposeResources();</span>
<span class="fc" id="L4129">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public FreeColGameObject getLinkTarget(Player player) {
<span class="nc bnc" id="L4136" title="All 2 branches missed.">		return (hasTile()) ? (FreeColGameObject) getTile().up() : player.getEurope();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int checkIntegrity(boolean fix) {
<span class="fc" id="L4144">		int result = super.checkIntegrity(fix);</span>
<span class="pc bpc" id="L4145" title="1 of 2 branches missed.">		if (this.role == null) {</span>
<span class="nc bnc" id="L4146" title="All 2 branches missed.">			if (fix) {</span>
<span class="nc" id="L4147">				this.role = getSpecification().getDefaultRole();</span>
<span class="nc" id="L4148">				logger.warning(&quot;Fixed missing role for: &quot; + getId());</span>
<span class="nc" id="L4149">				result = 0;</span>
			} else {
<span class="nc" id="L4151">				logger.warning(&quot;Missing role for: &quot; + getId());</span>
<span class="nc" id="L4152">				result = -1;</span>
			}
		}
<span class="pc bpc" id="L4155" title="1 of 2 branches missed.">		if (this.destination != null) {</span>
<span class="nc bnc" id="L4156" title="All 2 branches missed.">			if (((FreeColGameObject) this.destination).isUninitialized()) {</span>
<span class="nc bnc" id="L4157" title="All 2 branches missed.">				if (fix) {</span>
<span class="nc" id="L4158">					this.destination = null;</span>
<span class="nc" id="L4159">					logger.warning(&quot;Cleared uninitialized destination for: &quot; + getId());</span>
<span class="nc" id="L4160">					result = Math.min(result, 0);</span>
				} else {
<span class="nc" id="L4162">					logger.warning(&quot;Uninitialized destination for: &quot; + getId());</span>
<span class="nc" id="L4163">					result = -1;</span>
				}
			}
		}
<span class="fc" id="L4167">		return result;</span>
	}

	// Override FreeColObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Set&lt;Ability&gt; getAbilities(String id, FreeColGameObjectType fcgot, Turn turn) {
<span class="fc" id="L4177">		final Player owner = getOwner();</span>
<span class="fc" id="L4178">		final UnitType unitType = getType();</span>
<span class="fc" id="L4179">		Set&lt;Ability&gt; result = new HashSet&lt;&gt;();</span>

		// UnitType abilities always apply.
<span class="fc" id="L4182">		result.addAll(unitType.getAbilities(id));</span>

		// Roles apply with qualification.
<span class="fc" id="L4185">		result.addAll(role.getAbilities(id, fcgot, turn));</span>

		// The player's abilities require more qualification.
<span class="fc" id="L4188">		result.addAll(owner.getAbilities(id, fcgot, turn));</span>

		// Location abilities may apply.
		// FIXME: extend this to all locations? May simplify
		// code. Units are also Locations however, which complicates
		// the issue as we do not want Units aboard other Units to share
		// the abilities of the carriers.
<span class="fc bfc" id="L4195" title="All 2 branches covered.">		if (getSettlement() != null) {</span>
<span class="fc" id="L4196">			result.addAll(getSettlement().getAbilities(id, unitType, turn));</span>
<span class="fc bfc" id="L4197" title="All 2 branches covered.">		} else if (isInEurope()) {</span>
			// @compat 0.10.x
			// It makes sense here to do:
			// Europe europe = owner.getEurope();
			// However while there is fixup code in readChildren that calls
			// this routine we can not rely on owner.europe being initialized
			// yet. Hence the following:
<span class="fc" id="L4204">			Location loc = getLocation();</span>
<span class="pc bpc" id="L4205" title="1 of 4 branches missed.">			Europe europe = (loc instanceof Europe) ? (Europe) loc</span>
<span class="pc" id="L4206">					: (loc instanceof Unit) ? (Europe) ((Unit) loc).getLocation() : null;</span>
			// end @compat 0.10.x
<span class="fc" id="L4208">			result.addAll(europe.getAbilities(id, unitType, turn));</span>
		}
<span class="fc" id="L4210">		return result;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Set&lt;Modifier&gt; getModifiers(String id, FreeColGameObjectType fcgot, Turn turn) {
<span class="fc" id="L4218">		final Player owner = getOwner();</span>
<span class="fc" id="L4219">		final UnitType unitType = getType();</span>
<span class="fc" id="L4220">		Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

		// UnitType modifiers always apply
<span class="fc" id="L4223">		result.addAll(unitType.getModifiers(id, fcgot, turn));</span>

		// The player's modifiers may not all apply
<span class="fc" id="L4226">		result.addAll(owner.getModifiers(id, fcgot, turn));</span>

		// Role modifiers apply
<span class="fc" id="L4229">		result.addAll(role.getModifiers(id, fcgot, turn));</span>

<span class="fc" id="L4231">		return result;</span>
	}

	// Serialization

	/** The Constant ATTRITION_TAG. */
	private static final String ATTRITION_TAG = &quot;attrition&quot;;

	/** The Constant COUNT_TAG. */
	private static final String COUNT_TAG = &quot;count&quot;;

	/** The Constant CURRENT_STOP_TAG. */
	private static final String CURRENT_STOP_TAG = &quot;currentStop&quot;;

	/** The Constant DESTINATION_TAG. */
	private static final String DESTINATION_TAG = &quot;destination&quot;;

	/** The Constant ENTRY_LOCATION_TAG. */
	private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;

	/** The Constant ETHNICITY_TAG. */
	private static final String ETHNICITY_TAG = &quot;ethnicity&quot;;

	/** The Constant EXPERIENCE_TAG. */
	private static final String EXPERIENCE_TAG = &quot;experience&quot;;

	/** The Constant EXPERIENCE_TYPE_TAG. */
	private static final String EXPERIENCE_TYPE_TAG = &quot;experienceType&quot;;

	/** The Constant HIT_POINTS_TAG. */
	private static final String HIT_POINTS_TAG = &quot;hitPoints&quot;;

	/** The Constant INDIAN_SETTLEMENT_TAG. */
	private static final String INDIAN_SETTLEMENT_TAG = &quot;indianSettlement&quot;;

	/** The Constant LOCATION_TAG. */
	private static final String LOCATION_TAG = &quot;location&quot;;

	/** The Constant MOVES_LEFT_TAG. */
	private static final String MOVES_LEFT_TAG = &quot;movesLeft&quot;;

	/** The Constant NAME_TAG. */
	private static final String NAME_TAG = &quot;name&quot;;

	/** The Constant NATIONALITY_TAG. */
	private static final String NATIONALITY_TAG = &quot;nationality&quot;;

	/** The Constant OWNER_TAG. */
	private static final String OWNER_TAG = &quot;owner&quot;;

	/** The Constant ROLE_TAG. */
	private static final String ROLE_TAG = &quot;role&quot;;

	/** The Constant ROLE_COUNT_TAG. */
	private static final String ROLE_COUNT_TAG = &quot;roleCount&quot;;

	/** The Constant STATE_TAG. */
	private static final String STATE_TAG = &quot;state&quot;;

	/** The Constant STUDENT_TAG. */
	private static final String STUDENT_TAG = &quot;student&quot;;

	/** The Constant TRADE_ROUTE_TAG. */
	private static final String TRADE_ROUTE_TAG = &quot;tradeRoute&quot;;

	/** The Constant TEACHER_TAG. */
	private static final String TEACHER_TAG = &quot;teacher&quot;;

	/** The Constant TREASURE_AMOUNT_TAG. */
	private static final String TREASURE_AMOUNT_TAG = &quot;treasureAmount&quot;;

	/** The Constant TURNS_OF_TRAINING_TAG. */
	private static final String TURNS_OF_TRAINING_TAG = &quot;turnsOfTraining&quot;;

	/** The Constant UNIT_TYPE_TAG. */
	private static final String UNIT_TYPE_TAG = &quot;unitType&quot;;

	/** The Constant VISIBLE_GOODS_COUNT_TAG. */
	private static final String VISIBLE_GOODS_COUNT_TAG = &quot;visibleGoodsCount&quot;;

	/** The Constant WORK_LEFT_TAG. */
	private static final String WORK_LEFT_TAG = &quot;workLeft&quot;;

	/** The Constant WORK_TYPE_TAG. */
	private static final String WORK_TYPE_TAG = &quot;workType&quot;;

	/** The Constant OLD_UNITS_TAG. */
	// @compat 0.10.5
	private static final String OLD_UNITS_TAG = &quot;units&quot;;
	// end @compat
	/** The Constant OLD_HIT_POINTS_TAG. */
	// @compat 0.10.7
	private static final String OLD_HIT_POINTS_TAG = &quot;hitpoints&quot;;

	/** The Constant EQUIPMENT_TAG. */
	private static final String EQUIPMENT_TAG = &quot;equipment&quot;;
	/** The equipment this Unit carries. Now subsumed into roles. */
<span class="fc" id="L4328">	private final TypeCountMap&lt;EquipmentType&gt; equipment = new TypeCountMap&lt;&gt;();</span>
	// end @compat 0.10.x
	/** The Constant OLD_TILE_IMPROVEMENT_TAG. */
	// @compat 0.11.3
	private static final String OLD_TILE_IMPROVEMENT_TAG = &quot;tileimprovement&quot;;
	// end @compat 0.11.3

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L4340">		super.writeAttributes(xw);</span>

<span class="fc" id="L4342">		boolean full = xw.validFor(getOwner());</span>

<span class="fc bfc" id="L4344" title="All 2 branches covered.">		if (name != null) {</span>
<span class="fc" id="L4345">			xw.writeAttribute(NAME_TAG, name);</span>
		}

<span class="fc" id="L4348">		xw.writeAttribute(UNIT_TYPE_TAG, unitType);</span>

<span class="fc" id="L4350">		xw.writeAttribute(MOVES_LEFT_TAG, movesLeft);</span>

<span class="fc" id="L4352">		xw.writeAttribute(STATE_TAG, state);</span>

<span class="fc" id="L4354">		xw.writeAttribute(ROLE_TAG, role);</span>

<span class="fc" id="L4356">		xw.writeAttribute(ROLE_COUNT_TAG, roleCount);</span>

<span class="pc bpc" id="L4358" title="1 of 4 branches missed.">		if (!full &amp;&amp; hasAbility(Ability.PIRACY)) {</span>
			// Pirates do not disclose national characteristics.
<span class="nc" id="L4360">			xw.writeAttribute(OWNER_TAG, getGame().getUnknownEnemy());</span>

		} else {
<span class="fc" id="L4363">			xw.writeAttribute(OWNER_TAG, getOwner());</span>

<span class="fc bfc" id="L4365" title="All 2 branches covered.">			if (isPerson()) {</span>
				// Do not write out nationality and ethnicity for non-persons.
<span class="pc bpc" id="L4367" title="1 of 2 branches missed.">				xw.writeAttribute(NATIONALITY_TAG, (nationality != null) ? nationality : getOwner().getNationId());</span>

<span class="pc bpc" id="L4369" title="1 of 2 branches missed.">				xw.writeAttribute(ETHNICITY_TAG, (ethnicity != null) ? ethnicity : getOwner().getNationId());</span>
			}
		}

<span class="fc bfc" id="L4373" title="All 2 branches covered.">		if (location != null) {</span>
<span class="pc bpc" id="L4374" title="1 of 4 branches missed.">			if (!full &amp;&amp; isInColony()) {</span>
				// Really special case. This happens in attack
				// animations when a defender unit is invisible
				// working inside a colony and has to be specially
				// serialized to the client.
<span class="nc" id="L4379">				xw.writeLocationAttribute(LOCATION_TAG, getColony());</span>

			} else {
<span class="fc" id="L4382">				xw.writeLocationAttribute(LOCATION_TAG, location);</span>
			}
		}

<span class="fc" id="L4386">		xw.writeAttribute(TREASURE_AMOUNT_TAG, treasureAmount);</span>

<span class="fc bfc" id="L4388" title="All 2 branches covered.">		if (full) {</span>
<span class="fc bfc" id="L4389" title="All 2 branches covered.">			if (entryLocation != null) {</span>
<span class="fc" id="L4390">				xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
			}

<span class="fc" id="L4393">			xw.writeAttribute(TURNS_OF_TRAINING_TAG, turnsOfTraining);</span>

<span class="fc bfc" id="L4395" title="All 2 branches covered.">			if (workType != null)</span>
<span class="fc" id="L4396">				xw.writeAttribute(WORK_TYPE_TAG, workType);</span>

<span class="fc bfc" id="L4398" title="All 2 branches covered.">			if (experienceType != null) {</span>
<span class="fc" id="L4399">				xw.writeAttribute(EXPERIENCE_TYPE_TAG, experienceType);</span>
			}

<span class="fc" id="L4402">			xw.writeAttribute(EXPERIENCE_TAG, experience);</span>

<span class="fc" id="L4404">			xw.writeAttribute(INDIAN_SETTLEMENT_TAG, indianSettlement);</span>

<span class="fc" id="L4406">			xw.writeAttribute(WORK_LEFT_TAG, workLeft);</span>

<span class="fc" id="L4408">			xw.writeAttribute(HIT_POINTS_TAG, hitPoints);</span>

<span class="fc" id="L4410">			xw.writeAttribute(ATTRITION_TAG, attrition);</span>

<span class="pc bpc" id="L4412" title="1 of 2 branches missed.">			if (student != null)</span>
<span class="nc" id="L4413">				xw.writeAttribute(STUDENT_TAG, student);</span>

<span class="pc bpc" id="L4415" title="1 of 2 branches missed.">			if (teacher != null)</span>
<span class="nc" id="L4416">				xw.writeAttribute(TEACHER_TAG, teacher);</span>

<span class="fc bfc" id="L4418" title="All 2 branches covered.">			if (destination != null) {</span>
<span class="fc" id="L4419">				xw.writeLocationAttribute(DESTINATION_TAG, destination);</span>
			}

<span class="pc bpc" id="L4422" title="1 of 2 branches missed.">			if (tradeRoute != null) {</span>
<span class="nc" id="L4423">				xw.writeAttribute(TRADE_ROUTE_TAG, tradeRoute);</span>

<span class="nc" id="L4425">				xw.writeAttribute(CURRENT_STOP_TAG, currentStop);</span>
			}
		}
<span class="fc" id="L4428">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc bfc" id="L4435" title="All 2 branches covered.">		if (xw.validFor(getOwner())) {</span>

			// Do not show goods or units carried by this unit.
<span class="fc" id="L4438">			super.writeChildren(xw);</span>

<span class="fc bfc" id="L4440" title="All 2 branches covered.">			if (workImprovement != null)</span>
<span class="fc" id="L4441">				workImprovement.toXML(xw);</span>

<span class="fc bfc" id="L4443" title="All 2 branches covered.">		} else if (getType().canCarryGoods()) {</span>
<span class="fc" id="L4444">			xw.writeAttribute(VISIBLE_GOODS_COUNT_TAG, getVisibleGoodsCount());</span>
		}
<span class="fc" id="L4446">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4453">		super.readAttributes(xr);</span>

<span class="fc" id="L4455">		final Specification spec = getSpecification();</span>
<span class="fc" id="L4456">		final Game game = getGame();</span>

<span class="fc" id="L4458">		name = xr.getAttribute(NAME_TAG, (String) null);</span>

<span class="fc" id="L4460">		Player oldOwner = owner;</span>
<span class="fc" id="L4461">		owner = xr.findFreeColGameObject(game, OWNER_TAG, Player.class, (Player) null, true);</span>
<span class="fc bfc" id="L4462" title="All 2 branches covered.">		if (xr.shouldIntern())</span>
<span class="fc" id="L4463">			game.checkOwners(this, oldOwner);</span>

<span class="fc" id="L4465">		UnitType oldUnitType = unitType;</span>
<span class="fc" id="L4466">		unitType = xr.getType(spec, UNIT_TYPE_TAG, UnitType.class, (UnitType) null);</span>

<span class="fc" id="L4468">		state = xr.getAttribute(STATE_TAG, UnitState.class, UnitState.ACTIVE);</span>

<span class="fc" id="L4470">		role = xr.getRole(spec, ROLE_TAG, Role.class, spec.getDefaultRole());</span>
		// @compat 0.10.x
		// Fix roles
<span class="fc bfc" id="L4473" title="All 2 branches covered.">		if (owner.isIndian()) {</span>
<span class="pc bpc" id="L4474" title="1 of 2 branches missed.">			if (&quot;model.role.scout&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4475">				role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="pc bpc" id="L4476" title="1 of 2 branches missed.">			} else if (&quot;model.role.soldier&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4477">				role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="pc bpc" id="L4478" title="1 of 2 branches missed.">			} else if (&quot;model.role.dragoon&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4479">				role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
			}
<span class="fc bfc" id="L4481" title="All 2 branches covered.">		} else if (owner.isREF()) {</span>
<span class="pc bpc" id="L4482" title="3 of 4 branches missed.">			if (&quot;model.role.soldier&quot;.equals(role.getId()) &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4483">				role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="pc bpc" id="L4484" title="3 of 4 branches missed.">			} else if (&quot;model.role.dragoon&quot;.equals(role.getId()) &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4485">				role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="pc bpc" id="L4486" title="3 of 4 branches missed.">			} else if (&quot;model.role.infantry&quot;.equals(role.getId()) &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4487">				role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="pc bpc" id="L4488" title="2 of 4 branches missed.">			} else if (&quot;model.role.cavalry&quot;.equals(role.getId()) &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4489">				role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
			}
		} else {
<span class="pc bpc" id="L4492" title="1 of 2 branches missed.">			if (&quot;model.role.infantry&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4493">				role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="fc bfc" id="L4494" title="All 2 branches covered.">			} else if (&quot;model.role.cavalry&quot;.equals(role.getId())) {</span>
<span class="fc" id="L4495">				role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
			}
		}
		// end @compat 0.10.x

<span class="fc" id="L4500">		roleCount = xr.getAttribute(ROLE_COUNT_TAG,</span>
				// @compat 0.10.x
				-1
		// Should be role.getMaximumCount()
		// end @compat 0.10.x
		);

<span class="fc" id="L4507">		location = xr.getLocationAttribute(game, LOCATION_TAG, true);</span>

<span class="fc" id="L4509">		entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG, true);</span>

<span class="fc" id="L4511">		movesLeft = xr.getAttribute(MOVES_LEFT_TAG, 0);</span>

<span class="fc" id="L4513">		workLeft = xr.getAttribute(WORK_LEFT_TAG, 0);</span>

<span class="fc" id="L4515">		attrition = xr.getAttribute(ATTRITION_TAG, 0);</span>

<span class="fc" id="L4517">		nationality = xr.getAttribute(NATIONALITY_TAG, (String) null);</span>

<span class="fc" id="L4519">		ethnicity = xr.getAttribute(ETHNICITY_TAG, (String) null);</span>

<span class="fc" id="L4521">		turnsOfTraining = xr.getAttribute(TURNS_OF_TRAINING_TAG, 0);</span>

<span class="fc" id="L4523">		hitPoints = xr.getAttribute(HIT_POINTS_TAG, -1);</span>
		// @compat 0.10.7
<span class="pc bpc" id="L4525" title="1 of 2 branches missed.">		if (hitPoints &lt; 0)</span>
<span class="nc" id="L4526">			hitPoints = xr.getAttribute(OLD_HIT_POINTS_TAG, -1);</span>
		// end @compat

<span class="fc" id="L4529">		teacher = xr.makeFreeColGameObject(game, TEACHER_TAG, Unit.class, false);</span>

<span class="fc" id="L4531">		student = xr.makeFreeColGameObject(game, STUDENT_TAG, Unit.class, false);</span>

<span class="fc" id="L4533">		setHomeIndianSettlement(xr.makeFreeColGameObject(game, INDIAN_SETTLEMENT_TAG, IndianSettlement.class, false));</span>

<span class="fc" id="L4535">		treasureAmount = xr.getAttribute(TREASURE_AMOUNT_TAG, 0);</span>

<span class="fc" id="L4537">		destination = xr.getLocationAttribute(game, DESTINATION_TAG, true);</span>

<span class="fc" id="L4539">		tradeRoute = xr.findFreeColGameObject(game, TRADE_ROUTE_TAG, TradeRoute.class, (TradeRoute) null, false);</span>

<span class="pc bpc" id="L4541" title="1 of 2 branches missed.">		currentStop = (tradeRoute == null) ? -1 : xr.getAttribute(CURRENT_STOP_TAG, 0);</span>

<span class="fc" id="L4543">		experienceType = xr.getType(spec, EXPERIENCE_TYPE_TAG, GoodsType.class, (GoodsType) null);</span>
<span class="pc bpc" id="L4544" title="1 of 4 branches missed.">		if (experienceType == null &amp;&amp; workType != null) {</span>
<span class="nc" id="L4545">			experienceType = workType;</span>
		}

<span class="fc" id="L4548">		experience = xr.getAttribute(EXPERIENCE_TAG, 0);</span>

<span class="fc" id="L4550">		visibleGoodsCount = xr.getAttribute(VISIBLE_GOODS_COUNT_TAG, -1);</span>

		// Make sure you do this after experience and location stuff.
<span class="fc" id="L4553">		changeWorkType(xr.getType(spec, WORK_TYPE_TAG, GoodsType.class, null));</span>
<span class="fc" id="L4554">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// Clear containers.
<span class="pc bpc" id="L4562" title="1 of 2 branches missed.">		if (getGoodsContainer() != null) {</span>
<span class="nc" id="L4563">			getGoodsContainer().removeAll();</span>
		}
<span class="fc" id="L4565">		equipment.clear();</span>
<span class="fc" id="L4566">		workImprovement = null;</span>

<span class="fc" id="L4568">		super.readChildren(xr);</span>

		// @compat 0.10.x
<span class="fc bfc" id="L4571" title="All 2 branches covered.">		if (roleCount &lt; 0) {</span>
			// If roleCount was not present, set it from equipment
<span class="fc" id="L4573">			final Specification spec = getSpecification();</span>
<span class="fc" id="L4574">			Role role = spec.getDefaultRole();</span>
<span class="fc" id="L4575">			boolean horses = false, muskets = false;</span>
<span class="fc" id="L4576">			int count = 1;</span>
<span class="pc bpc" id="L4577" title="1 of 2 branches missed.">			for (EquipmentType type : equipment.keySet()) {</span>
<span class="nc bnc" id="L4578" title="All 2 branches missed.">				if (&quot;model.equipment.horses&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4579" title="All 2 branches missed.">						|| &quot;model.equipment.indian.horses&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4580">					horses = true;</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">				} else if (&quot;model.equipment.muskets&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4582" title="All 2 branches missed.">						|| &quot;model.equipment.indian.muskets&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4583">					muskets = true;</span>
				} else {
<span class="nc" id="L4585">					role = type.getRole();</span>
<span class="nc bnc" id="L4586" title="All 2 branches missed.">					if (&quot;model.equipment.tools&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4587">						count = equipment.getCount(type);</span>
					}
				}
<span class="nc" id="L4590">			}</span>
<span class="pc bpc" id="L4591" title="3 of 4 branches missed.">			if (horses &amp;&amp; muskets) {</span>
<span class="nc bnc" id="L4592" title="All 2 branches missed.">				if (owner.isIndian()) {</span>
<span class="nc" id="L4593">					role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
<span class="nc bnc" id="L4594" title="All 4 branches missed.">				} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4595">					role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
				} else {
<span class="nc" id="L4597">					role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
				}
<span class="pc bpc" id="L4599" title="1 of 2 branches missed.">			} else if (horses) {</span>
<span class="nc bnc" id="L4600" title="All 2 branches missed.">				if (owner.isIndian()) {</span>
<span class="nc" id="L4601">					role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="nc bnc" id="L4602" title="All 4 branches missed.">				} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4603">					logger.warning(&quot;Undefined role: REF Scout&quot;);</span>
				} else {
<span class="nc" id="L4605">					role = spec.getRole(&quot;model.role.scout&quot;);</span>
				}
<span class="pc bpc" id="L4607" title="1 of 2 branches missed.">			} else if (muskets) {</span>
<span class="nc bnc" id="L4608" title="All 2 branches missed.">				if (owner.isIndian()) {</span>
<span class="nc" id="L4609">					role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="nc bnc" id="L4610" title="All 4 branches missed.">				} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4611">					role = spec.getRole(&quot;model.role.infantry&quot;);</span>
				} else {
<span class="nc" id="L4613">					role = spec.getRole(&quot;model.role.soldier&quot;);</span>
				}
			}
<span class="fc" id="L4616">			setRoleCount(Math.min(role.getMaximumCount(), count));</span>
<span class="fc" id="L4617">		} else {</span>
			// If roleCount was present, we are now ignoring equipment.
<span class="fc" id="L4619">			equipment.clear();</span>
		}
		// end @compat 0.10.x

		// @compat 0.10.x
		// There was a bug in 0.10.x that did not clear tile
		// improvements after they were complete, leading to units
		// that still had a tile improvement after they had moved
		// away. Consequently when reading such bogus improvements,
		// there is no guarantee that the tile is defined so
		// compatibility code in TileImprovement.readAttributes
		// tolerates null tile references. These are obviously bogus,
		// so drop them.
<span class="pc bpc" id="L4632" title="3 of 4 branches missed.">		if (workImprovement != null &amp;&amp; workImprovement.getTile() == null) {</span>
<span class="nc" id="L4633">			workImprovement = null;</span>
		}
		// end @compat 0.10.x
<span class="fc" id="L4636">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4643">		final Specification spec = getSpecification();</span>
<span class="fc" id="L4644">		final Game game = getGame();</span>
<span class="fc" id="L4645">		final String tag = xr.getLocalName();</span>

		// @compat 0.10.x
<span class="pc bpc" id="L4648" title="1 of 2 branches missed.">		if (EQUIPMENT_TAG.equals(tag)) {</span>
<span class="nc" id="L4649">			equipment.incrementCount(spec.getEquipmentType(xr.readId()), xr.getAttribute(COUNT_TAG, 0));</span>
<span class="nc" id="L4650">			xr.closeTag(EQUIPMENT_TAG);</span>
			// end @compat 0.10.x

			// @compat 0.10.5
<span class="pc bpc" id="L4654" title="1 of 2 branches missed.">		} else if (OLD_UNITS_TAG.equals(tag)) {</span>
<span class="nc bnc" id="L4655" title="All 2 branches missed.">			while (xr.nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="nc" id="L4656">				super.readChild(xr);</span>
			}
			// end @compat 0.10.5

<span class="pc bpc" id="L4660" title="1 of 2 branches missed.">		} else if (TileImprovement.getXMLElementTagName().equals(tag)</span>
				// @compat 0.11.3
<span class="pc bpc" id="L4662" title="1 of 2 branches missed.">				|| OLD_TILE_IMPROVEMENT_TAG.equals(tag)</span>
		// end @compat 0.11.3
		) {
<span class="nc" id="L4665">			workImprovement = xr.readFreeColGameObject(game, TileImprovement.class);</span>

		} else {
<span class="fc" id="L4668">			super.readChild(xr);</span>
		}
<span class="fc" id="L4670">	}</span>

	/**
	 * Gets a string representation of this unit.
	 *
	 * @param prefix
	 *            A prefix (e.g. &quot;AIUnit&quot;)
	 * @return A string representation of this &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public String toString(String prefix) {
<span class="fc" id="L4680">		StringBuilder sb = new StringBuilder(64);</span>
<span class="fc" id="L4681">		sb.append(&quot;[&quot;).append(prefix).append(getId());</span>
<span class="pc bpc" id="L4682" title="1 of 2 branches missed.">		if (isUninitialized()) {</span>
<span class="nc" id="L4683">			sb.append(&quot; uninitialized&quot;);</span>
<span class="pc bpc" id="L4684" title="1 of 2 branches missed.">		} else if (isDisposed()) {</span>
<span class="nc" id="L4685">			sb.append(&quot; disposed&quot;);</span>
		} else {
<span class="fc" id="L4687">			sb.append(&quot; &quot;).append(lastPart(owner.getNationId(), &quot;.&quot;)).append(&quot; &quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L4688" title="All 2 branches covered.">			if (!hasDefaultRole()) {</span>
<span class="fc" id="L4689">				sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L4690">				int count = getRoleCount();</span>
<span class="pc bpc" id="L4691" title="1 of 2 branches missed.">				if (count &gt; 1)</span>
<span class="nc" id="L4692">					sb.append(&quot;.&quot;).append(count);</span>
			}
<span class="fc" id="L4694">			sb.append(&quot; &quot;).append(getMovesAsString());</span>
		}
<span class="fc" id="L4696">		sb.append(&quot;]&quot;);</span>
<span class="fc" id="L4697">		return sb.toString();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="fc" id="L4705">		return toString(&quot;&quot;);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="fc" id="L4713">		return getXMLElementTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;unit&quot;
	 */
	public static String getXMLElementTagName() {
<span class="fc" id="L4722">		return &quot;unit&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>