<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Map.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Map.java</span></div><h1>Map.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.HashMap;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.util.LogBuilder;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.RandomUtils.*;
// @compat 0.10.x
import net.sf.freecol.server.generator.TerrainGenerator;
// end @compat 0.10.x

/**
 * A rectangular isometric map. The map is represented as a two-dimensional
 * array of tiles. Off-map destinations, such as {@link Europe}, can be reached
 * via the {@link HighSeas}.
 *
 * In theory, a {@link Game} might contain several Map instances connected by
 * the HighSeas.
 */
public class Map extends FreeColGameObject implements Location {

	/** The Constant logger. */
<span class="fc" id="L63">	private static final Logger logger = Logger.getLogger(Map.class.getName());</span>

	/**
	 * Possible actions by the unit travelling along a path in consideration of
	 * the next tile.
	 */
<span class="pc" id="L69">	private static enum MoveStep {</span>
		/** The fail. */
<span class="fc" id="L71">		FAIL,</span>
		/** The byland. */
<span class="fc" id="L73">		BYLAND,</span>
		/** The bywater. */
<span class="fc" id="L75">		BYWATER,</span>
		/** The embark. */
<span class="fc" id="L77">		EMBARK,</span>
		/** The disembark. */
<span class="fc" id="L79">		DISEMBARK</span>
	};

	/**
	 * The number of tiles from the upper edge that are considered polar by
	 * default.
	 */
	public final static int POLAR_HEIGHT = 2;

	/**
	 * The layers included in the map. The RIVERS layer includes all natural
	 * tile improvements that are not resources. The NATIVES layer includes Lost
	 * City Rumours as well as settlements.
	 */
<span class="pc" id="L93">	public static enum Layer {</span>

		/** The none. */
<span class="fc" id="L96">		NONE,</span>
		/** The land. */
<span class="fc" id="L98">		LAND,</span>
		/** The terrain. */
<span class="fc" id="L100">		TERRAIN,</span>
		/** The regions. */
<span class="fc" id="L102">		REGIONS,</span>
		/** The rivers. */
<span class="fc" id="L104">		RIVERS,</span>
		/** The resources. */
<span class="fc" id="L106">		RESOURCES,</span>
		/** The natives. */
<span class="fc" id="L108">		NATIVES,</span>
		/** The all. */
<span class="fc" id="L110">		ALL;</span>
	};

	/** A position on the Map. */
	public static final class Position {

		/** The coordinates of the position. */
		public final int x, y;

		/**
		 * Creates a new &lt;code&gt;Position&lt;/code&gt; object with the given
		 * coordinates.
		 *
		 * @param posX
		 *            The x-coordinate for this position.
		 * @param posY
		 *            The y-coordinate for this position.
		 */
<span class="fc" id="L128">		public Position(int posX, int posY) {</span>
<span class="fc" id="L129">			x = posX;</span>
<span class="fc" id="L130">			y = posY;</span>
<span class="fc" id="L131">		}</span>

		/**
		 * Creates a new &lt;code&gt;Position&lt;/code&gt; object with the coordinates of a
		 * supplied tile.
		 *
		 * @param tile
		 *            The &lt;code&gt;Tile&lt;/code&gt; to extract coordinates from.
		 */
		public Position(Tile tile) {
<span class="fc" id="L141">			this(tile.getX(), tile.getY());</span>
<span class="fc" id="L142">		}</span>

		/**
		 * Creates a new &lt;code&gt;Position&lt;/code&gt; from an existing one with an
		 * optional step in a given direction.
		 *
		 * @param start
		 *            The starting &lt;code&gt;Position&lt;/code&gt;.
		 * @param direction
		 *            An optional &lt;code&gt;Direction&lt;/code&gt; to step.
		 */
<span class="fc" id="L153">		public Position(Position start, Direction direction) {</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">			Position step = (direction == null) ? start : direction.step(start.x, start.y);</span>
<span class="fc" id="L155">			this.x = step.x;</span>
<span class="fc" id="L156">			this.y = step.y;</span>
<span class="fc" id="L157">		}</span>

		/**
		 * Gets the x-coordinate of this Position.
		 *
		 * @return The x-coordinate of this Position.
		 */
		public int getX() {
<span class="fc" id="L165">			return x;</span>
		}

		/**
		 * Gets the y-coordinate of this Position.
		 *
		 * @return The y-coordinate of this Position.
		 */
		public int getY() {
<span class="fc" id="L174">			return y;</span>
		}

		/**
		 * Checks whether a position is valid within a given map size.
		 *
		 * @param width
		 *            The width of the map.
		 * @param height
		 *            The height of the map.
		 * @return True if the given position is within the bounds of the map.
		 */
		public boolean isValid(int width, int height) {
<span class="fc" id="L187">			return Map.isValid(x, y, width, height);</span>
		}

		/**
		 * Gets the distance in tiles between two map positions. With an
		 * isometric map this is a non-trivial task. The formula below has been
		 * developed largely through trial and error. It should cover all cases,
		 * but I wouldn't bet my life on it.
		 *
		 * @param ax
		 *            The x-coordinate of the first position.
		 * @param ay
		 *            The y-coordinate of the first position.
		 * @param bx
		 *            The x-coordinate of the second position.
		 * @param by
		 *            The y-coordinate of the second position.
		 * @return The distance in tiles between the positions.
		 */
		public static int getDistance(int ax, int ay, int bx, int by) {
<span class="fc" id="L207">			int r = (bx - ax) - (ay - by) / 2;</span>

<span class="fc bfc" id="L209" title="All 6 branches covered.">			if (by &gt; ay &amp;&amp; ay % 2 == 0 &amp;&amp; by % 2 != 0) {</span>
<span class="fc" id="L210">				r++;</span>
<span class="fc bfc" id="L211" title="All 6 branches covered.">			} else if (by &lt; ay &amp;&amp; ay % 2 != 0 &amp;&amp; by % 2 == 0) {</span>
<span class="fc" id="L212">				r--;</span>
			}
<span class="fc" id="L214">			return Math.max(Math.abs(ay - by + r), Math.abs(r));</span>
		}

		/**
		 * Gets the distance in tiles between two map positions. With an
		 * isometric map this is a non-trivial task. The formula below has been
		 * developed largely through trial and error. It should cover all cases,
		 * but I wouldn't bet my life on it.
		 *
		 * @param position
		 *            The other &lt;code&gt;Position&lt;/code&gt; to compare.
		 * @return The distance in tiles to the other position.
		 */
		public int getDistance(Position position) {
<span class="nc" id="L228">			return getDistance(getX(), getY(), position.getX(), position.getY());</span>
		}

		/**
		 * Get the direction from this position to an adjacent position.
		 *
		 * @param other
		 *            The adjacent &lt;code&gt;Position&lt;/code&gt;.
		 * @return The &lt;code&gt;Direction&lt;/code&gt;, or null if not adjacent.
		 */
		public Direction getDirection(Position other) {
<span class="fc" id="L239">			return find(Direction.values(), d -&gt; new Position(this, d).equals(other), null);</span>
		}

		// Override Object

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean equals(Object o) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">			if (this == o) {</span>
<span class="nc" id="L250">				return true;</span>
			}
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">			if (o instanceof Position) {</span>
<span class="fc" id="L253">				Position p = (Position) o;</span>
<span class="fc bfc" id="L254" title="All 4 branches covered.">				return x == p.x &amp;&amp; y == p.y;</span>
			}
<span class="nc" id="L256">			return false;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public int hashCode() {
<span class="nc" id="L264">			return x | (y &lt;&lt; 16);</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L272">			return &quot;(&quot; + x + &quot;, &quot; + y + &quot;)&quot;;</span>
		}
	}

	/** The tiles that this map contains. */
	private Tile[][] tiles;

	/** The highest map layer included. */
	private Layer layer;

	/**
	 * The latitude of the northern edge of the map. A negative value indicates
	 * northern latitude, a positive value southern latitude. Thus, -30 equals
	 * 30째N, and 40 equals 40째S.
	 */
<span class="pc" id="L287">	private int minimumLatitude = -90;</span>

	/**
	 * The latitude of the southern edge of the map. A negative value indicates
	 * northern latitude, a positive value southern latitude. Thus, -30 equals
	 * 30째N, and 40 equals 40째S.
	 */
<span class="pc" id="L294">	private int maximumLatitude = 90;</span>

	/** Variable used to convert rows to latitude. */
	private float latitudePerRow;

	/** The regions on the map. */
<span class="pc" id="L300">	private final List&lt;Region&gt; regions = new ArrayList&lt;&gt;();</span>

	/** The search tracing status. Do not serialize. */
<span class="pc" id="L303">	private boolean traceSearch = false;</span>

	/**
	 * Create a new &lt;code&gt;Map&lt;/code&gt; from a collection of tiles.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param width
	 *            The map width.
	 * @param height
	 *            The map height.
	 */
	public Map(Game game, int width, int height) {
<span class="fc" id="L316">		super(game);</span>

<span class="fc" id="L318">		this.tiles = new Tile[width][height];</span>
<span class="fc" id="L319">		setLayer(Layer.RESOURCES);</span>
<span class="fc" id="L320">		calculateLatitudePerRow();</span>
<span class="fc" id="L321">	}</span>

	/**
	 * Create a new &lt;code&gt;Map&lt;/code&gt; from an &lt;code&gt;Element&lt;/code&gt; in a
	 * DOM-parsed XML-tree.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param xr
	 *            The input stream containing the XML.
	 * @throws XMLStreamException
	 *             if a problem was encountered during parsing.
	 */
	public Map(Game game, FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L335">		super(game, null);</span>

<span class="nc" id="L337">		readFromXML(xr);</span>
<span class="nc" id="L338">	}</span>

	/**
	 * Creates a new &lt;code&gt;Map&lt;/code&gt; with the given object identifier. The
	 * object should later be initialized by calling either
	 * {@link #readFromXML(FreeColXMLReader)} or
	 * {@link #readFromXMLElement(Element)}.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param id
	 *            The object identifier.
	 */
	public Map(Game game, String id) {
<span class="fc" id="L352">		super(game, id);</span>
<span class="fc" id="L353">	}</span>

	/**
	 * Checks if an (x,y) coordinate tuple is within a map of specified width
	 * and height.
	 *
	 * @param x
	 *            The x-coordinate of the position.
	 * @param y
	 *            The y-coordinate of the position.
	 * @param width
	 *            The width of the map.
	 * @param height
	 *            The height of the map.
	 * @return True if the given position is within the bounds of the map.
	 */
	public static boolean isValid(int x, int y, int width, int height) {
<span class="fc bfc" id="L370" title="All 8 branches covered.">		return x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height;</span>
	}

	/**
	 * Checks whether a position is valid (within the map limits).
	 *
	 * @param x
	 *            The X coordinate to check.
	 * @param y
	 *            The Y coordinate to check.
	 * @return True if the coordinates are valid.
	 */
	public boolean isValid(int x, int y) {
<span class="fc" id="L383">		return isValid(x, y, getWidth(), getHeight());</span>
	}

	/**
	 * Checks whether a position is valid (within the map limits).
	 *
	 * @param position
	 *            The &lt;code&gt;Position&lt;/code&gt; to check.
	 * @return True if the position is valid.
	 */
	public boolean isValid(Position position) {
<span class="fc" id="L394">		return isValid(position.getX(), position.getY());</span>
	}

	/**
	 * Gets the Tile at position (x, y). 'x' specifies a column and 'y'
	 * specifies a row. (0, 0) is the Tile at the top-left corner of the Map.
	 *
	 * @param x
	 *            The x-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
	 * @param y
	 *            The y-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The &lt;code&gt;Tile&lt;/code&gt; at (x, y), or null if the position is
	 *         invalid.
	 */
	public Tile getTile(int x, int y) {
<span class="fc bfc" id="L409" title="All 2 branches covered.">		return (isValid(x, y)) ? tiles[x][y] : null;</span>
	}

	/**
	 * Gets the Tile at a requested position.
	 *
	 * @param p
	 *            The &lt;code&gt;Position&lt;/code&gt; to query.
	 * @return The &lt;code&gt;Tile&lt;/code&gt; at the given position.
	 */
	public Tile getTile(Position p) {
<span class="fc" id="L420">		return getTile(p.getX(), p.getY());</span>
	}

	/**
	 * Sets the tile at the given coordinates.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to set.
	 * @param x
	 *            The x-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
	 * @param y
	 *            The y-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
	 */
	public void setTile(Tile tile, int x, int y) {
<span class="fc" id="L434">		tiles[x][y] = tile;</span>
<span class="fc" id="L435">	}</span>

	/**
	 * Gets the width of this map.
	 *
	 * @return The width of this map.
	 */
	public int getWidth() {
<span class="fc" id="L443">		return tiles.length;</span>
	}

	/**
	 * Gets the height of this map.
	 *
	 * @return The height of this map.
	 */
	public int getHeight() {
<span class="fc" id="L452">		return tiles[0].length;</span>
	}

	/**
	 * Gets the layer.
	 *
	 * @return the layer
	 */
	public final Layer getLayer() {
<span class="nc" id="L461">		return layer;</span>
	}

	/**
	 * Sets the layer.
	 *
	 * @param newLayer
	 *            the new layer
	 */
	public final void setLayer(final Layer newLayer) {
<span class="fc" id="L471">		this.layer = newLayer;</span>
<span class="fc" id="L472">	}</span>

	/**
	 * Gets the &lt;code&gt;MinimumLatitude&lt;/code&gt; value.
	 *
	 * @return The minimum latitude of this map.
	 */
	public final int getMinimumLatitude() {
<span class="nc" id="L480">		return minimumLatitude;</span>
	}

	/**
	 * Sets the minimum latitude.
	 *
	 * @param newMinimumLatitude
	 *            the new minimum latitude
	 */
	public final void setMinimumLatitude(final int newMinimumLatitude) {
<span class="fc" id="L490">		this.minimumLatitude = newMinimumLatitude;</span>
<span class="fc" id="L491">		calculateLatitudePerRow();</span>
<span class="fc" id="L492">	}</span>

	/**
	 * Gets the &lt;code&gt;MaximumLatitude&lt;/code&gt; value.
	 *
	 * @return The maximum latitude of this map.
	 */
	public final int getMaximumLatitude() {
<span class="nc" id="L500">		return maximumLatitude;</span>
	}

	/**
	 * Sets the maximum latitude.
	 *
	 * @param newMaximumLatitude
	 *            the new maximum latitude
	 */
	public final void setMaximumLatitude(final int newMaximumLatitude) {
<span class="fc" id="L510">		this.maximumLatitude = newMaximumLatitude;</span>
<span class="fc" id="L511">		calculateLatitudePerRow();</span>
<span class="fc" id="L512">	}</span>

	/**
	 * Gets the &lt;code&gt;LatitudePerRow&lt;/code&gt; value.
	 *
	 * @return The latitude change between rows.
	 */
	public final float getLatitudePerRow() {
<span class="fc" id="L520">		return latitudePerRow;</span>
	}

	/**
	 * Calculate latitude per row.
	 */
	private final void calculateLatitudePerRow() {
<span class="fc" id="L527">		this.latitudePerRow = 1f * (maximumLatitude - minimumLatitude) / (getHeight() - 1);</span>
<span class="fc" id="L528">	}</span>

	/**
	 * Gets the latitude of the given map row.
	 *
	 * @param row
	 *            The row to check.
	 * @return The row latitude.
	 */
	public int getLatitude(int row) {
<span class="fc" id="L538">		return minimumLatitude + (int) (row * latitudePerRow);</span>
	}

	/**
	 * Gets the map row with the given latitude.
	 *
	 * @param latitude
	 *            The latitude to find.
	 * @return The row closest to the supplied latitude.
	 */
	public int getRow(int latitude) {
<span class="fc" id="L549">		return (int) ((latitude - minimumLatitude) / latitudePerRow);</span>
	}

	/**
	 * Gets the regions in this map.
	 *
	 * @return All the regions in this map.
	 */
	public Collection&lt;Region&gt; getRegions() {
<span class="fc" id="L558">		return regions;</span>
	}

	/**
	 * Get the fixed regions indexed by key.
	 *
	 * @return A map of the fixed regions.
	 */
	public java.util.Map&lt;String, Region&gt; getFixedRegions() {
<span class="fc" id="L567">		HashMap&lt;String, Region&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">		for (Region r : getRegions()) {</span>
<span class="fc" id="L569">			String n = r.getNameKey();</span>
<span class="fc" id="L570">			result.put(n, r);</span>
<span class="fc" id="L571">		}</span>
<span class="fc" id="L572">		return result;</span>
	}

	/**
	 * Gets a &lt;code&gt;Region&lt;/code&gt; by name key.
	 *
	 * @param key
	 *            The name key to lookup the region with.
	 * @return The region with the given name key, or null if not found.
	 */
	public Region getRegionByKey(final String key) {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">		return (key == null) ? null : find(getRegions(), r -&gt; key.equals(r.getKey()));</span>
	}

	/**
	 * Gets a &lt;code&gt;Region&lt;/code&gt; by name.
	 *
	 * @param name
	 *            The region name.
	 * @return The &lt;code&gt;Region&lt;/code&gt; with the given name, or null if not
	 *         found.
	 */
	public Region getRegionByName(final String name) {
<span class="nc bnc" id="L595" title="All 2 branches missed.">		return (name == null) ? null : find(getRegions(), r -&gt; name.equals(r.getName()));</span>
	}

	/**
	 * Adds a region to this map.
	 *
	 * @param region
	 *            The &lt;code&gt;Region&lt;/code&gt; to add.
	 */
	public void addRegion(final Region region) {
<span class="fc" id="L605">		regions.add(region);</span>
<span class="fc" id="L606">	}</span>

	/**
	 * Are two locations non-null and either the same or at the same tile. This
	 * routine is here because Location is an interface.
	 *
	 * @param l1
	 *            The first &lt;code&gt;Location&lt;/code&gt;.
	 * @param l2
	 *            The second &lt;code&gt;Location&lt;/code&gt;.
	 * @return True if the locations are the same or at the same tile.
	 */
	public static final boolean isSameLocation(Location l1, Location l2) {
<span class="pc bpc" id="L619" title="2 of 6 branches missed.">		return (l1 == null || l2 == null) ? false</span>
<span class="fc bfc" id="L620" title="All 4 branches covered.">				: (l1 == l2) ? true : (l1.getTile() == null) ? false : l1.getTile() == l2.getTile();</span>
	}

	/**
	 * Are two locations at least in the same contiguous land/sea-mass? This
	 * routine is here because Location is an interface.
	 *
	 * @param l1
	 *            The first &lt;code&gt;Location&lt;/code&gt;.
	 * @param l2
	 *            The second &lt;code&gt;Location&lt;/code&gt;.
	 * @return True if the locations are the same or in the same land/sea-mass.
	 */
	public static final boolean isSameContiguity(Location l1, Location l2) {
<span class="pc bpc" id="L634" title="3 of 6 branches missed.">		return (l1 == null || l2 == null) ? false</span>
				: (l1 == l2) ? true
<span class="pc bpc" id="L636" title="2 of 4 branches missed.">						: (l1.getTile() == null || l2.getTile() == null) ? false</span>
<span class="fc" id="L637">								: l1.getTile().isConnectedTo(l2.getTile());</span>
	}

	/**
	 * Is a tile in the map in a polar region?.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to examine.
	 * @return True if the tile is in a polar region.
	 */
	public boolean isPolar(Tile tile) {
<span class="fc bfc" id="L648" title="All 4 branches covered.">		return tile.getY() &lt;= POLAR_HEIGHT || tile.getY() &gt;= getHeight() - POLAR_HEIGHT - 1;</span>
	}

	/**
	 * Gets the direction a unit needs to move in order to get from
	 * &lt;code&gt;t1&lt;/code&gt; to &lt;code&gt;t2&lt;/code&gt;.
	 *
	 * @param t1
	 *            The tile to move from.
	 * @param t2
	 *            The target tile if moving from &lt;code&gt;t1&lt;/code&gt; in the
	 *            direction returned by this method.
	 * @return The direction you need to move from &lt;code&gt;t1&lt;/code&gt; in order to
	 *         reach &lt;code&gt;t2&lt;/code&gt;, or null if the two specified tiles are not
	 *         neighbours.
	 */
	public Direction getDirection(Tile t1, Tile t2) {
<span class="pc bpc" id="L665" title="2 of 4 branches missed.">		return (t1 == null || t2 == null) ? null : new Position(t1).getDirection(new Position(t2));</span>
	}

	/**
	 * Get the approximate direction from one tile to another.
	 *
	 * @param src
	 *            The source &lt;code&gt;Tile&lt;/code&gt;.
	 * @param dst
	 *            The destination &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The approximate direction from source to direction, or null if
	 *         source and destination are the same.
	 */
	public static Direction getRoughDirection(Tile src, Tile dst) {
<span class="fc" id="L679">		int x = dst.getX() - src.getX();</span>
<span class="fc" id="L680">		int y = dst.getY() - src.getY();</span>
<span class="pc bpc" id="L681" title="3 of 4 branches missed.">		if (x == 0 &amp;&amp; y == 0) {</span>
<span class="nc" id="L682">			return null;</span>
		}
<span class="fc" id="L684">		double theta = Math.atan2(y, x) + Math.PI / 2 + Math.PI / 8;</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">		if (theta &lt; 0) {</span>
<span class="nc" id="L686">			theta += 2 * Math.PI;</span>
		}
<span class="fc" id="L688">		return Direction.angleToDirection(theta);</span>
	}

	/**
	 * Gets the adjacent tile in a given direction from the given coordinates.
	 *
	 * @param x
	 *            The x coordinate to work from.
	 * @param y
	 *            The y coordinate to work from.
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; to check.
	 * @return The adjacent &lt;code&gt;Tile&lt;/code&gt; in the specified direction, or
	 *         null if invalid.
	 */
	public Tile getAdjacentTile(int x, int y, Direction direction) {
<span class="fc" id="L704">		return getTile(direction.step(x, y));</span>
	}

	/**
	 * Gets the adjacent tile in a given direction from a given tile.
	 *
	 * @param tile
	 *            The starting &lt;code&gt;Tile&lt;/code&gt;.
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; to check.
	 * @return The adjacent &lt;code&gt;Tile&lt;/code&gt; in the specified direction, or
	 *         null if invalid.
	 */
	public Tile getAdjacentTile(Tile tile, Direction direction) {
<span class="fc" id="L718">		return getAdjacentTile(tile.getX(), tile.getY(), direction);</span>
	}

	/**
	 * Gets the distance between two tiles.
	 *
	 * @param t1
	 *            The first &lt;code&gt;Tile&lt;/code&gt;.
	 * @param t2
	 *            The second &lt;code&gt;Tile&lt;/code&gt;.
	 * @return The distance between the tiles.
	 */
	public int getDistance(Tile t1, Tile t2) {
<span class="fc" id="L731">		return Position.getDistance(t1.getX(), t1.getY(), t2.getX(), t2.getY());</span>
	}

	/**
	 * Get the closest tile to a given one from a list of other tiles.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to start from.
	 * @param tiles
	 *            The list of &lt;code&gt;Tile&lt;/code&gt;s to check.
	 * @return The closest tile found (may be null if the list is empty).
	 */
	public Tile getClosestTile(Tile tile, Collection&lt;Tile&gt; tiles) {
<span class="nc" id="L744">		Tile result = null;</span>
<span class="nc" id="L745">		int minimumDistance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">		for (Tile t : tiles) {</span>
<span class="nc" id="L747">			int distance = getDistance(t, tile);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">			if (distance &lt; minimumDistance) {</span>
<span class="nc" id="L749">				minimumDistance = distance;</span>
<span class="nc" id="L750">				result = t;</span>
			}
<span class="nc" id="L752">		}</span>
<span class="nc" id="L753">		return result;</span>
	}

	/**
	 * Select a random land tile on the map.
	 *
	 * @param random
	 *            A &lt;code&gt;Random&lt;/code&gt; number source.
	 * @return A random land tile, or null if none found.
	 */
	public Tile getRandomLandTile(Random random) {
<span class="fc" id="L764">		final int SLOSH = 10;</span>
<span class="fc" id="L765">		int x = 0, y = 0, width = getWidth(), height = getHeight();</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">		if (width &gt;= SLOSH) {</span>
<span class="fc" id="L767">			width -= SLOSH;</span>
<span class="fc" id="L768">			x += SLOSH / 2;</span>
		}
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">		if (height &gt;= SLOSH) {</span>
<span class="fc" id="L771">			height -= SLOSH;</span>
<span class="fc" id="L772">			y += SLOSH / 2;</span>
		}
<span class="fc" id="L774">		x += randomInt(logger, &quot;W&quot;, random, width);</span>
<span class="fc" id="L775">		y += randomInt(logger, &quot;H&quot;, random, height);</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">		for (Tile t : getCircleTiles(getTile(x, y), true, INFINITY)) {</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">			if (t.isLand()) {</span>
<span class="fc" id="L778">				return t;</span>
			}
<span class="fc" id="L780">		}</span>
<span class="nc" id="L781">		return null;</span>
	}

	// Path-finding/searching infrastructure and routines

	/**
	 * Simple interface to supply a heuristic to the A* routine.
	 */
	private interface SearchHeuristic {

		/**
		 * Gets the value.
		 *
		 * @param tile
		 *            the tile
		 * @return the value
		 */
		int getValue(Tile tile);
	}

	/**
	 * Gets a search heuristic using the Manhatten distance to an end tile.
	 *
	 * @param endTile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to aim for.
	 * @return A new &lt;code&gt;SearchHeuristic&lt;/code&gt; aiming for the end tile.
	 */
	private SearchHeuristic getManhattenHeuristic(Tile endTile) {
<span class="fc" id="L809">		return (Tile tile) -&gt; tile.getDistanceTo(endTile);</span>
	}

	/**
	 * Unified argument tests for full path searches, which then finds the
	 * actual starting location for the path. Deals with special cases like
	 * starting on a carrier and/or high seas.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find the path for.
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; in which the path starts from.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @return The actual starting location.
	 * @throws IllegalArgumentException
	 *             If there are any argument problems.
	 */
	private Location findRealStart(final Unit unit, final Location start, final Unit carrier) {
		// Unit checks.
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">		if (unit == null) {</span>
<span class="nc" id="L830">			throw new IllegalArgumentException(&quot;Null unit.&quot;);</span>
<span class="pc bpc" id="L831" title="1 of 4 branches missed.">		} else if (carrier != null &amp;&amp; !carrier.canCarryUnits()) {</span>
<span class="nc" id="L832">			throw new IllegalArgumentException(&quot;Non-carrier carrier: &quot; + carrier);</span>
<span class="pc bpc" id="L833" title="1 of 4 branches missed.">		} else if (carrier != null &amp;&amp; !carrier.couldCarry(unit)) {</span>
<span class="nc" id="L834">			throw new IllegalArgumentException(&quot;Carrier could not carry unit: &quot; + carrier + &quot;/&quot; + unit);</span>
		}

		Location entry;
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">		if (start == null) {</span>
<span class="nc" id="L839">			throw new IllegalArgumentException(&quot;Null start: &quot; + unit);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">		} else if (start instanceof Unit) {</span>
<span class="fc" id="L841">			Location unitLoc = ((Unit) start).getLocation();</span>
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">			if (unitLoc == null) {</span>
<span class="nc" id="L843">				throw new IllegalArgumentException(&quot;Null on-carrier start: &quot; + unit + &quot;/&quot; + start);</span>
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">			} else if (unitLoc instanceof HighSeas) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">				if (carrier == null) {</span>
<span class="nc" id="L846">					throw new IllegalArgumentException(&quot;Null carrier when&quot; + &quot; starting on high seas: &quot; + unit);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">				} else if (carrier != start) {</span>
<span class="nc" id="L848">					throw new IllegalArgumentException(</span>
							&quot;Wrong carrier when&quot; + &quot; starting on high seas: &quot; + unit + &quot;/&quot; + carrier + &quot; != &quot; + start);
				}
<span class="nc" id="L851">				entry = carrier.resolveDestination();</span>
			} else {
<span class="fc" id="L853">				entry = unitLoc;</span>
			}

<span class="pc bpc" id="L856" title="1 of 2 branches missed.">		} else if (start instanceof HighSeas) {</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">			if (unit.isOnCarrier()) {</span>
<span class="nc" id="L858">				entry = unit.getCarrier().resolveDestination();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">			} else if (unit.isNaval()) {</span>
<span class="nc" id="L860">				entry = unit.resolveDestination();</span>
			} else {
<span class="nc" id="L862">				throw new IllegalArgumentException(</span>
<span class="nc" id="L863">						&quot;No carrier when&quot; + &quot; starting on high seas: &quot; + unit + &quot;/&quot; + unit.getLocation());</span>
			}
<span class="pc bpc" id="L865" title="1 of 4 branches missed.">		} else if (start instanceof Europe || start.getTile() != null) {</span>
<span class="fc" id="L866">			entry = start; // OK</span>
		} else {
<span class="nc" id="L868">			throw new IllegalArgumentException(&quot;Invalid start: &quot; + start);</span>
		}
		// Valid result, reduce to tile if possible.
<span class="fc bfc" id="L871" title="All 2 branches covered.">		return (entry.getTile() != null) ? entry.getTile() : entry;</span>
	}

	/**
	 * Destination argument test for path searches. Find the actual destination
	 * of a path.
	 *
	 * @param end
	 *            The candidate end &lt;code&gt;Location&lt;/code&gt;.
	 * @return The actual end location.
	 * @throws IllegalArgumentException
	 *             If there are any argument problems.
	 */
	private Location findRealEnd(Location end) {
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">		if (end == null) {</span>
<span class="nc" id="L886">			throw new IllegalArgumentException(&quot;Null end.&quot;);</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">		} else if (end instanceof Europe) {</span>
<span class="fc" id="L888">			return end;</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">		} else if (end.getTile() != null) {</span>
<span class="fc" id="L890">			return end.getTile();</span>
		} else {
<span class="nc" id="L892">			throw new IllegalArgumentException(&quot;Invalid end: &quot; + end);</span>
		}
	}

	/**
	 * Gets the best (closest) path location for this unit to reach a given tile
	 * from off the map.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @param tile
	 *            The target &lt;code&gt;Tile&lt;/code&gt;.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt;to use.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; to use.
	 * @return A path to the best entry location tile to arrive on the map at,
	 *         or null if none found.
	 */
	private PathNode getBestEntryPath(Unit unit, Tile tile, Unit carrier, CostDecider costDecider) {
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">		return searchMap(unit, tile, GoalDeciders.getHighSeasGoalDecider(),</span>
<span class="fc" id="L913">				((costDecider != null) ? costDecider : CostDeciders.avoidSettlementsAndBlockingUnits()), INFINITY,</span>
				carrier, null, null);
	}

	/**
	 * Gets the best (closest) entry location for this unit to reach a given
	 * tile from off the map.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @param tile
	 *            The target &lt;code&gt;Tile&lt;/code&gt;.
	 * @param carrier
	 *            An optional carrier &lt;code&gt;Unit&lt;/code&gt;to use.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; to use.
	 * @return The best entry location tile to arrive on the map at, or null if
	 *         none found.
	 */
	public Tile getBestEntryTile(Unit unit, Tile tile, Unit carrier, CostDecider costDecider) {
<span class="nc" id="L933">		PathNode path = getBestEntryPath(unit, tile, carrier, costDecider);</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">		return (path == null) ? null : path.getLastNode().getTile();</span>
	}

	/**
	 * Find the quickest path for a unit (with optional carrier) from a start
	 * tile to an end tile.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find the path for.
	 * @param start
	 *            The &lt;code&gt;Tile&lt;/code&gt; in which the path starts from.
	 * @param end
	 *            The &lt;code&gt;Tile&lt;/code&gt; at the end of the path.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; for determining the
	 *            movement costs (uses default cost deciders for the unit/s if
	 *            not provided).
	 * @param lb
	 *            An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return A path starting at the start tile and ending at the end tile, or
	 *         null if none found.
	 */
	private PathNode findMapPath(Unit unit, Tile start, Tile end, Unit carrier, CostDecider costDecider,
			LogBuilder lb) {
<span class="pc bpc" id="L960" title="1 of 6 branches missed.">		final Unit offMapUnit = (carrier != null) ? carrier : (unit != null &amp;&amp; unit.isNaval()) ? unit : null;</span>
<span class="fc" id="L961">		final GoalDecider gd = GoalDeciders.getLocationGoalDecider(end);</span>
<span class="fc" id="L962">		final SearchHeuristic sh = getManhattenHeuristic(end);</span>
		Unit embarkTo;

		PathNode path;
<span class="fc bfc" id="L966" title="All 2 branches covered.">		if (start.getContiguity() == end.getContiguity()) {</span>
			// If the unit potentially could get to the destination
			// without a carrier, compare both with-carrier and
			// without-carrier paths. The latter will usually be
			// faster, but not always, e.g. mounted units on a good
			// road system.
<span class="fc" id="L972">			path = searchMap(unit, start, gd, costDecider, INFINITY, null, sh, lb);</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">			PathNode carrierPath = (carrier == null) ? null</span>
<span class="fc" id="L974">					: searchMap(unit, start, gd, costDecider, INFINITY, carrier, sh, lb);</span>
<span class="pc bpc" id="L975" title="1 of 4 branches missed.">			if (carrierPath != null</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">					&amp;&amp; (path == null || (path.getLastNode().getCost() &gt; carrierPath.getLastNode().getCost()))) {</span>
<span class="fc" id="L977">				path = carrierPath;</span>
			}

<span class="fc bfc" id="L980" title="All 2 branches covered.">		} else if (offMapUnit != null) {</span>
			// If there is an off-map unit then complex paths which
			// use settlements and inland lakes are possible, but hard
			// to capture with the contiguity test, so just allow the
			// search to proceed.
<span class="fc" id="L985">			path = searchMap(unit, start, gd, costDecider, INFINITY, carrier, sh, lb);</span>

<span class="pc bpc" id="L987" title="6 of 8 branches missed.">		} else if (unit != null &amp;&amp; unit.isOnCarrier() &amp;&amp; !start.isLand() &amp;&amp; end.isLand()</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">				&amp;&amp; !start.getContiguityAdjacent(end.getContiguity()).isEmpty()) {</span>
			// Special case where a land unit is trying to move off a
			// ship to adjacent land.
<span class="nc" id="L991">			path = searchMap(unit, start, gd, costDecider, INFINITY, carrier, sh, lb);</span>

<span class="pc bpc" id="L993" title="3 of 6 branches missed.">		} else if (start.isLand() &amp;&amp; !end.isLand() &amp;&amp; end.getFirstUnit() != null</span>
<span class="pc bpc" id="L994" title="3 of 4 branches missed.">				&amp;&amp; !end.getContiguityAdjacent(start.getContiguity()).isEmpty() &amp;&amp; unit != null</span>
<span class="nc bnc" id="L995" title="All 4 branches missed.">				&amp;&amp; unit.getOwner().owns(end.getFirstUnit()) &amp;&amp; (embarkTo = end.getCarrierForUnit(unit)) != null) {</span>
			// Special case where a land unit is trying to move from
			// land to an adjacent ship.
<span class="nc" id="L998">			path = searchMap(unit, start, GoalDeciders.getAdjacentLocationGoalDecider(end), costDecider, INFINITY, null,</span>
					null, lb);
<span class="nc bnc" id="L1000" title="All 2 branches missed.">			if (path != null) {</span>
<span class="nc" id="L1001">				PathNode last = path.getLastNode();</span>
<span class="nc" id="L1002">				last.next = new PathNode(embarkTo, 0, last.getTurns() + 1, true, last, null);</span>
<span class="nc" id="L1003">			}</span>
		} else { // Otherwise, there is a connectivity failure.
<span class="fc" id="L1005">			path = null;</span>
		}
<span class="fc" id="L1007">		return path;</span>
	}

	/**
	 * Finish processing a path.
	 *
	 * @param path
	 *            The &lt;code&gt;PathNode&lt;/code&gt; to finish.
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is travelling along the path.
	 * @param lb
	 *            An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 */
	private void finishPath(PathNode path, Unit unit, LogBuilder lb) {
<span class="fc bfc" id="L1021" title="All 2 branches covered.">		if (path != null) {</span>
			// Add the turns remaining on the high seas.
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">			final int initialTurns = (!unit.isAtSea()) ? 0</span>
<span class="pc bnc" id="L1024" title="All 2 branches missed.">					: ((unit.isOnCarrier()) ? unit.getCarrier() : unit).getWorkLeft();</span>
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">			if (initialTurns != 0)</span>
<span class="nc" id="L1026">				path.addTurns(initialTurns);</span>

<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">			if (lb != null) {</span>
<span class="nc" id="L1029">				lb.add(&quot;\nSuccess\n&quot;, path.fullPathToString());</span>
			}
		}
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">		if (lb != null) {</span>
<span class="nc" id="L1033">			lb.log(logger, Level.INFO);</span>
		}
<span class="fc" id="L1035">	}</span>

	/**
	 * Find the quickest path for a unit (with optional carrier) from a start
	 * location to an end location.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find the path for.
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; in which the path starts from.
	 * @param end
	 *            The &lt;code&gt;Location&lt;/code&gt; at the end of the path.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; for determining the
	 *            movement costs (uses default cost deciders for the unit/s if
	 *            not provided).
	 * @param lb
	 *            An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return A path starting at the start location and ending at the end
	 *         location, or null if none found.
	 * @throws IllegalArgumentException
	 *             For many reasons, see {@link #findRealStart}.
	 */
	public PathNode findPath(final Unit unit, final Location start, final Location end, final Unit carrier,
			CostDecider costDecider, LogBuilder lb) {
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">		if (traceSearch) {</span>
<span class="nc" id="L1063">			lb = new LogBuilder(1024);</span>
		}

		// Validate the arguments, reducing to either Europe or a Tile.
<span class="fc" id="L1067">		final Location realStart = findRealStart(unit, start, carrier);</span>
		final Location realEnd;
		try {
<span class="fc" id="L1070">			realEnd = findRealEnd(end);</span>
<span class="nc" id="L1071">		} catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L1072">			throw new IllegalArgumentException(</span>
					&quot;Path fail: &quot; + unit + &quot; from &quot; + start + &quot; to &quot; + end + &quot; with &quot; + carrier, iae);
<span class="fc" id="L1074">		}</span>
		// Get the unit that will be used for off-map travel.
<span class="fc bfc" id="L1076" title="All 2 branches covered.">		final Unit offMapUnit = (carrier != null) ? carrier : unit;</span>

		PathNode p, path;
		Tile tile;
<span class="pc bpc" id="L1080" title="1 of 4 branches missed.">		if (realEnd instanceof Tile &amp;&amp; !((Tile) realEnd).isExplored()) {</span>
			// Do not allow finding a path into unexplored territory,
			// as we do not have the terrain type and thus can not
			// calculate costs.
<span class="nc" id="L1084">			path = null;</span>

<span class="fc bfc" id="L1086" title="All 4 branches covered.">		} else if (realStart instanceof Europe &amp;&amp; realEnd instanceof Europe) {</span>
			// 0: Europe-&gt;Europe: Create a trivial path.
<span class="fc" id="L1088">			path = new PathNode(realStart, unit.getMovesLeft(), 0, false, null, null);</span>

<span class="pc bpc" id="L1090" title="1 of 4 branches missed.">		} else if (realStart instanceof Europe &amp;&amp; realEnd instanceof Tile) {</span>
			// 1: Europe-&gt;Tile
			// Fail fast without an off map unit.
<span class="pc bpc" id="L1093" title="2 of 4 branches missed.">			if (offMapUnit == null || !offMapUnit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L1094">				path = null;</span>

				// Find the best place to enter the map from Europe
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">			} else if ((p = getBestEntryPath(unit, (Tile) realEnd, carrier, costDecider)) == null) {</span>
<span class="nc" id="L1098">				path = null;</span>

				// Now search forward from there to get a path in the
				// right order (path costs are not symmetric). There are
				// &quot;expected&quot; failures when rivers block due to foreign
				// ship movement. There are also other failures which we
				// would like to log. Try to filter out the first case.
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">			} else if ((path = findMapPath(unit, (tile = p.getLastNode().getTile()), (Tile) realEnd, carrier,</span>
					costDecider, lb)) == null) {
<span class="nc bnc" id="L1107" title="All 2 branches missed.">				if (!((Tile) realEnd).isOnRiver()) {</span>
<span class="nc" id="L1108">					LogBuilder l2 = new LogBuilder(512);</span>
<span class="nc" id="L1109">					l2.add(&quot;Fail in findPath(&quot;, unit, &quot;, &quot;, tile, &quot;, &quot;, realEnd, &quot;, &quot;, carrier, &quot;)\n&quot;);</span>
<span class="nc" id="L1110">					l2.addStackTrace();</span>
<span class="nc" id="L1111">					l2.add(p.fullPathToString());</span>
<span class="nc" id="L1112">					findMapPath(unit, tile, (Tile) realEnd, carrier, costDecider, l2);</span>
<span class="nc" id="L1113">					l2.log(logger, Level.WARNING);</span>
				}
<span class="nc" id="L1115">				path = null;</span>

				// At the front of the path insert a node for the starting
				// location in Europe, correcting for the turns to sail to
				// the entry location.
			} else {
<span class="fc" id="L1121">				path.addTurns(offMapUnit.getSailTurns());</span>
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">				path.previous = new PathNode(realStart, unit.getMovesLeft(), 0, carrier != null, null, path);</span>
<span class="fc" id="L1123">				path = path.previous;</span>
<span class="pc bpc" id="L1124" title="2 of 4 branches missed.">				if (carrier != null &amp;&amp; unit.getLocation() != carrier) {</span>
<span class="fc" id="L1125">					path.previous = new PathNode(realStart, unit.getMovesLeft(), 0, false, null, path);</span>
<span class="fc" id="L1126">					path = path.previous;</span>
				}
			}

<span class="pc bpc" id="L1130" title="1 of 4 branches missed.">		} else if (realStart instanceof Tile &amp;&amp; realEnd instanceof Europe) {</span>
			// 2: Tile-&gt;Europe
			// Fail fast if Europe is unattainable.
<span class="pc bpc" id="L1133" title="2 of 4 branches missed.">			if (offMapUnit == null || !offMapUnit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L1134">				path = null;</span>

				// Search forwards to the high seas.
<span class="fc bfc" id="L1137" title="All 2 branches covered.">			} else if ((p = searchMap(unit, (Tile) realStart, GoalDeciders.getHighSeasGoalDecider(), costDecider,</span>
					INFINITY, carrier, null, lb)) == null) {
<span class="fc" id="L1139">				path = null;</span>

			} else {
<span class="fc" id="L1142">				PathNode last = p.getLastNode();</span>
<span class="fc" id="L1143">				last.next = new PathNode(realEnd, unit.getInitialMovesLeft(),</span>
<span class="fc" id="L1144">						last.getTurns() + offMapUnit.getSailTurns(), last.isOnCarrier(), last, null);</span>
<span class="fc" id="L1145">				path = p;</span>
<span class="fc" id="L1146">			}</span>

<span class="pc bpc" id="L1148" title="2 of 4 branches missed.">		} else if (realStart instanceof Tile &amp;&amp; realEnd instanceof Tile) {</span>
			// 3: Tile-&gt;Tile
<span class="fc" id="L1150">			path = findMapPath(unit, (Tile) realStart, (Tile) realEnd, carrier, costDecider, lb);</span>

		} else {
<span class="nc" id="L1153">			throw new IllegalStateException(&quot;Can not happen: &quot; + realStart + &quot;, &quot; + realEnd);</span>
		}

<span class="fc" id="L1156">		finishPath(path, unit, lb);</span>
<span class="fc" id="L1157">		return path;</span>
	}

	/**
	 * Searches for a goal. Assumes units in Europe return to their current
	 * entry location, which is not optimal most of the time. Returns the full
	 * path including the start and end locations.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find a path for.
	 * @param start
	 *            The &lt;code&gt;Location&lt;/code&gt; to start the search from.
	 * @param goalDecider
	 *            The object responsible for determining whether a given
	 *            &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; responsible for
	 *            determining the path cost.
	 * @param maxTurns
	 *            The maximum number of turns the given &lt;code&gt;Unit&lt;/code&gt; is
	 *            allowed to move. This is the maximum search range for a goal.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @param lb
	 *            An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return The path to a goal, or null if none can be found.
	 * @throws IllegalArgumentException
	 *             If the unit is null, or the start location does not make
	 *             sense, or the carrier/unit combination is bogus.
	 */
	public PathNode search(final Unit unit, Location start, final GoalDecider goalDecider,
			final CostDecider costDecider, final int maxTurns, final Unit carrier, LogBuilder lb) {
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">		if (traceSearch) {</span>
<span class="nc" id="L1190">			lb = new LogBuilder(1024);</span>
		}

<span class="fc" id="L1193">		final Location realStart = findRealStart(unit, start, carrier);</span>
<span class="fc bfc" id="L1194" title="All 2 branches covered.">		final Unit offMapUnit = (carrier != null) ? carrier : unit;</span>

		PathNode p, path;
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">		if (realStart instanceof Europe) {</span>
			// Fail fast if Europe is unattainable.
<span class="nc bnc" id="L1199" title="All 4 branches missed.">			if (offMapUnit == null || !offMapUnit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L1200">				path = null;</span>

				// This is suboptimal. We do not know where to enter from
				// Europe, so start with the standard entry location...
<span class="nc bnc" id="L1204" title="All 2 branches missed.">			} else if ((p = searchMap(unit, (Tile) offMapUnit.getEntryLocation(), goalDecider, costDecider, maxTurns,</span>
					carrier, null, lb)) == null) {
<span class="nc" id="L1206">				path = null;</span>

				// ...then if we find a path, try to optimize it. This
				// will lose if the initial search fails due to a turn limit.
				// FIXME: do something better.
			} else {
<span class="nc" id="L1212">				path = findPath(unit, realStart, p.getLastNode().getTile(), carrier, costDecider, lb);</span>
			}

		} else {
<span class="fc" id="L1216">			path = searchMap(unit, realStart.getTile(), goalDecider, costDecider, maxTurns, carrier, null, lb);</span>
		}

<span class="fc" id="L1219">		finishPath(path, unit, lb);</span>
<span class="fc" id="L1220">		return path;</span>
	}

	/**
	 * Gets the search tracing status.
	 *
	 * @return The search tracing status.
	 */
	public boolean getSearchTrace() {
<span class="nc" id="L1229">		return traceSearch;</span>
	}

	/**
	 * Sets the search tracing status.
	 *
	 * @param trace
	 *            The new search tracing status.
	 * @return The original search tracing status.
	 */
	public boolean setSearchTrace(boolean trace) {
<span class="nc" id="L1240">		boolean ret = traceSearch;</span>
<span class="nc" id="L1241">		traceSearch = trace;</span>
<span class="nc" id="L1242">		return ret;</span>
	}

	/**
	 * Was a carrier used previously on a path?
	 *
	 * Beware! This is special case code for partially constructed paths that do
	 * not yet have valid .next links, so we can not use the generic PathNode
	 * routines.
	 *
	 * @param path
	 *            The path the search.
	 * @return True if the path includes a previous on-carrier node.
	 */
	private boolean usedCarrier(PathNode path) {
<span class="fc bfc" id="L1257" title="All 2 branches covered.">		while (path != null) {</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">			if (path.isOnCarrier()) {</span>
<span class="nc" id="L1259">				return true;</span>
			}
<span class="fc" id="L1261">			path = path.previous;</span>
		}
<span class="fc" id="L1263">		return false;</span>
	}

	/**
	 * Internal class for evaluating a candidate move.
	 */
	private class MoveCandidate {

		/** The unit. */
		private Unit unit;

		/** The current. */
		private final PathNode current;

		/** The dst. */
		private final Location dst;

		/** The moves left. */
		private int movesLeft;

		/** The turns. */
		private int turns;

		/** The on carrier. */
		private final boolean onCarrier;

		/** The decider. */
		private final CostDecider decider;

		/** The cost. */
		private int cost;

		/** The path. */
		private PathNode path;

		/**
		 * Creates a new move candidate where a cost decider will be used to
		 * work out the new moves and turns left.
		 *
		 * @param unit
		 *            The &lt;code&gt;Unit&lt;/code&gt; to move.
		 * @param current
		 *            The current position on the path.
		 * @param dst
		 *            The &lt;code&gt;Location&lt;/code&gt; to move to.
		 * @param movesLeft
		 *            The initial number of moves left.
		 * @param turns
		 *            The initial number of turns.
		 * @param onCarrier
		 *            Will the new move be on a carrier.
		 * @param decider
		 *            The &lt;code&gt;CostDecider&lt;/code&gt; to use.
		 */
		public MoveCandidate(Unit unit, PathNode current, Location dst, int movesLeft, int turns, boolean onCarrier,
<span class="fc" id="L1318">				CostDecider decider) {</span>
<span class="fc" id="L1319">			this.unit = unit;</span>
<span class="fc" id="L1320">			this.current = current;</span>
<span class="fc" id="L1321">			this.dst = dst;</span>
<span class="fc" id="L1322">			this.movesLeft = movesLeft;</span>
<span class="fc" id="L1323">			this.turns = turns;</span>
<span class="fc" id="L1324">			this.onCarrier = onCarrier;</span>
<span class="fc" id="L1325">			this.decider = decider;</span>
<span class="fc" id="L1326">			this.cost = decider.getCost(unit, current.getLocation(), dst, movesLeft);</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">			if (this.cost != CostDecider.ILLEGAL_MOVE) {</span>
<span class="fc" id="L1328">				this.turns += decider.getNewTurns();</span>
<span class="fc" id="L1329">				this.movesLeft = decider.getMovesLeft();</span>
<span class="fc" id="L1330">				this.cost = PathNode.getCost(this.turns, this.movesLeft);</span>
			}
<span class="fc" id="L1332">			this.path = null;</span>
<span class="fc" id="L1333">		}</span>

		/**
		 * Get the cost.
		 *
		 * @return The current move cost.
		 */
		public int getCost() {
<span class="fc" id="L1341">			return this.cost;</span>
		}

		/**
		 * Handles the change of unit as a result of an embark.
		 *
		 * @param unit
		 *            the unit
		 */
		public void embarkUnit(Unit unit) {
<span class="fc" id="L1351">			this.unit = unit;</span>
<span class="fc" id="L1352">			this.movesLeft = unit.getInitialMovesLeft();</span>
<span class="fc" id="L1353">			this.cost = PathNode.getCost(turns, movesLeft);</span>
<span class="fc" id="L1354">		}</span>

		/**
		 * Resets the path. Required after the parameters change.
		 *
		 * @param goal
		 *            True if this is a goal node.
		 */
		public void resetPath(boolean goal) {
<span class="fc" id="L1363">			path = new PathNode(dst, movesLeft, turns, onCarrier, current, null);</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">			if (goal) {</span>
				// Do not let the CostDecider (which may be
				// conservative) block a final destination. This
				// allows planning routines to compute paths to tiles
				// temporarily occupied by an enemy unit, or for an
				// empty ship to find a compound path to a native
				// settlement where the first step is to collect the
				// cargo it needs to make the final move legal.
<span class="pc bpc" id="L1372" title="5 of 6 branches missed.">				if (cost == CostDecider.ILLEGAL_MOVE &amp;&amp; unit != null &amp;&amp; current.getTile() != null</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">						&amp;&amp; dst.getTile() != null) {</span>
					// Pretend it finishes the move.
<span class="nc" id="L1375">					movesLeft = unit.getInitialMovesLeft();</span>
<span class="nc" id="L1376">					turns++;</span>
<span class="nc" id="L1377">					path = new PathNode(dst, movesLeft, turns, onCarrier, current, null);</span>
				}

				// Add an extra step to disembark from a carrier at a
				// settlement. If this is omitted, then a path that
				// disembarks a unit from its carrier on an adjacent
				// tile looks unfairly expensive.
				Settlement s;
<span class="pc bpc" id="L1385" title="2 of 6 branches missed.">				if (unit != null &amp;&amp; path.isOnCarrier() &amp;&amp; (s = path.getLocation().getSettlement()) != null</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">						&amp;&amp; unit.getOwner().owns(s)) {</span>
<span class="nc" id="L1387">					movesLeft = 0;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">					if (path.embarkedThisTurn(turns)) {</span>
<span class="nc" id="L1389">						turns++;</span>
					}
<span class="nc" id="L1391">					path = new PathNode(s.getTile(), 0, turns, false, path, null);</span>
				}
<span class="fc" id="L1393">				cost = PathNode.getCost(turns, movesLeft);</span>
			}
<span class="fc" id="L1395">		}</span>

		/**
		 * Does this move candidate improve on a specified move.
		 *
		 * @param best
		 *            The &lt;code&gt;PathNode&lt;/code&gt; to compare against.
		 * @return true, if successful
		 */
		public boolean canImprove(PathNode best) {
<span class="pc bpc" id="L1405" title="2 of 6 branches missed.">			return cost != CostDecider.ILLEGAL_MOVE &amp;&amp; (best == null || cost &lt; best.getCost()</span>
<span class="pc bpc" id="L1406" title="1 of 4 branches missed.">					|| (cost == best.getCost() &amp;&amp; best.getLength() &lt; path.getLength()));</span>
		}

		/**
		 * Replace a given path with that of this candidate move.
		 *
		 * @param openMap
		 *            The list of available nodes.
		 * @param openMapQueue
		 *            The queue of available nodes.
		 * @param f
		 *            The heuristic values for A*.
		 * @param sh
		 *            An optional &lt;code&gt;SearchHeuristic&lt;/code&gt; to apply.
		 */
		public void improve(HashMap&lt;String, PathNode&gt; openMap, PriorityQueue&lt;PathNode&gt; openMapQueue,
				HashMap&lt;String, Integer&gt; f, SearchHeuristic sh) {
<span class="fc" id="L1423">			PathNode best = openMap.get(dst.getId());</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">			if (best != null) {</span>
<span class="nc" id="L1425">				openMap.remove(dst.getId());</span>
<span class="nc" id="L1426">				openMapQueue.remove(best);</span>
			}
<span class="fc" id="L1428">			int fcost = cost;</span>
<span class="pc bpc" id="L1429" title="1 of 4 branches missed.">			if (sh != null &amp;&amp; dst.getTile() != null) {</span>
<span class="fc" id="L1430">				fcost += sh.getValue(dst.getTile());</span>
			}
<span class="fc" id="L1432">			f.put(dst.getId(), fcost);</span>
<span class="fc" id="L1433">			openMap.put(dst.getId(), path);</span>
<span class="fc" id="L1434">			openMapQueue.offer(path);</span>
<span class="fc" id="L1435">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1442">			StringBuilder sb = new StringBuilder(128);</span>
<span class="nc" id="L1443">			sb.append(&quot;[candidate unit=&quot;).append(unit).append(&quot; dst=&quot;).append(dst).append(&quot; movesLeft=&quot;)</span>
<span class="nc" id="L1444">					.append(movesLeft).append(&quot; turns=&quot;).append(turns).append(&quot; onCarrier=&quot;).append(onCarrier)</span>
<span class="nc" id="L1445">					.append(&quot; decider=&quot;).append(decider).append(&quot; cost=&quot;).append(cost).append(&quot;]&quot;);</span>
<span class="nc" id="L1446">			return sb.toString();</span>
		}
	};

	/**
	 * Searches for a path to a goal determined by the given
	 * &lt;code&gt;GoalDecider&lt;/code&gt;.
	 *
	 * Using A* with a List (closedMap) for marking the visited nodes and using
	 * a PriorityQueue (openMapQueue) for getting the next edge with the least
	 * cost. This implementation could be improved by having the visited
	 * attribute stored on each Tile in order to avoid both of the HashMaps
	 * currently being used to serve this purpose.
	 *
	 * If the SearchHeuristic is not supplied, then the algorithm degrades
	 * gracefully to Dijkstra's algorithm.
	 *
	 * The data structure for the open list is a combined structure: using a
	 * HashMap for membership tests and a PriorityQueue for getting the node
	 * with the minimal f (cost+heuristics). This gives O(1) on membership test
	 * and O(log N) for remove-best and insertions.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find a path for.
	 * @param start
	 *            The &lt;code&gt;Tile&lt;/code&gt; to start the search from.
	 * @param goalDecider
	 *            The object responsible for determining whether a given
	 *            &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
	 * @param costDecider
	 *            An optional &lt;code&gt;CostDecider&lt;/code&gt; responsible for
	 *            determining the path cost.
	 * @param maxTurns
	 *            The maximum number of turns the given &lt;code&gt;Unit&lt;/code&gt; is
	 *            allowed to move. This is the maximum search range for a goal.
	 * @param carrier
	 *            An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
	 * @param searchHeuristic
	 *            An optional &lt;code&gt;SearchHeuristic&lt;/code&gt;.
	 * @param lb
	 *            An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return A path to a goal determined by the given
	 *         &lt;code&gt;GoalDecider&lt;/code&gt;.
	 */
	private PathNode searchMap(final Unit unit, final Tile start, final GoalDecider goalDecider,
			final CostDecider costDecider, final int maxTurns, final Unit carrier,
			final SearchHeuristic searchHeuristic, final LogBuilder lb) {
<span class="fc" id="L1493">		final HashMap&lt;String, PathNode&gt; openMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1494">		final HashMap&lt;String, PathNode&gt; closedMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1495">		final HashMap&lt;String, Integer&gt; f = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1496">		final PriorityQueue&lt;PathNode&gt; openMapQueue = new PriorityQueue&lt;&gt;(1024, new Comparator&lt;PathNode&gt;() {</span>
			@Override
			public int compare(PathNode p1, PathNode p2) {
<span class="fc" id="L1499">				return (f.get(p1.getLocation().getId()) - f.get(p2.getLocation().getId()));</span>
			}
		});
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">		final Europe europe = (unit == null) ? null : unit.getOwner().getEurope();</span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">		final Unit offMapUnit = (carrier != null) ? carrier : unit;</span>
<span class="pc bpc" id="L1504" title="1 of 8 branches missed.">		Unit currentUnit = (start.isLand()) ? ((start.hasSettlement() &amp;&amp; start.getSettlement().isConnectedPort()</span>
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">				&amp;&amp; unit != null &amp;&amp; unit.getLocation() == carrier) ? carrier : unit) : offMapUnit;</span>
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">		if (lb != null) {</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">			lb.add(&quot;Search trace(unit=&quot;, unit, &quot;, from=&quot;, start, &quot;, max=&quot;,</span>
<span class="nc" id="L1508">					((maxTurns == INFINITY) ? &quot;-&quot; : Integer.toString(maxTurns)), &quot;, carrier=&quot;, carrier, &quot;)&quot;);</span>
		}

		// Create the start node and put it on the open list.
<span class="pc bpc" id="L1512" title="1 of 6 branches missed.">		final PathNode firstNode = new PathNode(start, ((currentUnit != null) ? currentUnit.getMovesLeft() : -1), 0,</span>
				carrier != null &amp;&amp; currentUnit == carrier, null, null);
<span class="fc bfc" id="L1514" title="All 2 branches covered.">		f.put(start.getId(), (searchHeuristic == null) ? 0 : searchHeuristic.getValue(start));</span>
<span class="fc" id="L1515">		openMap.put(start.getId(), firstNode);</span>
<span class="fc" id="L1516">		openMapQueue.offer(firstNode);</span>

<span class="fc" id="L1518">		PathNode best = null;</span>
<span class="fc" id="L1519">		int bestScore = INFINITY;</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">		while (!openMap.isEmpty()) {</span>
			// Choose the node with the lowest f.
<span class="fc" id="L1522">			final PathNode currentNode = openMapQueue.poll();</span>
<span class="fc" id="L1523">			final Location currentLocation = currentNode.getLocation();</span>
<span class="fc" id="L1524">			openMap.remove(currentLocation.getId());</span>
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">			if (lb != null) {</span>
<span class="nc" id="L1526">				lb.add(&quot;\n  &quot;, currentNode);</span>
			}

			// Reset current unit to that of this node.
<span class="fc bfc" id="L1530" title="All 2 branches covered.">			currentUnit = (currentNode.isOnCarrier()) ? carrier : unit;</span>

			// Check for success.
<span class="fc bfc" id="L1533" title="All 2 branches covered.">			if (goalDecider.check(currentUnit, currentNode)) {</span>
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">				if (lb != null) {</span>
<span class="nc" id="L1535">					lb.add(&quot; ***goal(&quot;, currentNode.getCost(), &quot;)***&quot;);</span>
				}
<span class="fc" id="L1537">				best = goalDecider.getGoal();</span>
<span class="fc" id="L1538">				bestScore = best.getCost();</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">				if (!goalDecider.hasSubGoals()) {</span>
<span class="fc" id="L1540">					break;</span>
				}
				continue;
			}

			// Skip nodes that can not beat the current best path.
<span class="fc bfc" id="L1546" title="All 2 branches covered.">			if (bestScore &lt; currentNode.getCost()) {</span>
<span class="fc" id="L1547">				closedMap.put(currentLocation.getId(), currentNode);</span>
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">				if (lb != null) {</span>
<span class="nc" id="L1549">					lb.add(&quot; ...goal cost wins(&quot;, bestScore, &quot; &lt; &quot;, currentNode.getCost(), &quot;)...&quot;);</span>
				}
				continue;
			}

			// Ignore nodes over the turn limit.
<span class="fc bfc" id="L1555" title="All 2 branches covered.">			if (currentNode.getTurns() &gt; maxTurns) {</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">				if (lb != null) {</span>
<span class="nc" id="L1557">					lb.add(&quot;...out-of-range&quot;);</span>
				}
				continue;
			}

			// Valid candidate for the closed list.
<span class="fc" id="L1563">			closedMap.put(currentLocation.getId(), currentNode);</span>
<span class="pc bpc" id="L1564" title="1 of 2 branches missed.">			if (lb != null) {</span>
<span class="nc" id="L1565">				lb.add(&quot;...close&quot;);</span>
			}

			// Collect the parameters for the current node.
<span class="fc" id="L1569">			final int currentMovesLeft = currentNode.getMovesLeft();</span>
<span class="fc" id="L1570">			final int currentTurns = currentNode.getTurns();</span>
<span class="fc" id="L1571">			final boolean currentOnCarrier = currentNode.isOnCarrier();</span>

<span class="fc" id="L1573">			final Tile currentTile = currentNode.getTile();</span>
<span class="pc bpc" id="L1574" title="1 of 2 branches missed.">			if (currentTile == null) { // Must be in Europe.</span>
				// FIXME: Do not consider tiles &quot;adjacent&quot; to Europe, yet.
				// There may indeed be cases where going to Europe and
				// coming back on the other side of the map is faster.
<span class="nc bnc" id="L1578" title="All 2 branches missed.">				if (lb != null) {</span>
<span class="nc" id="L1579">					lb.add(&quot;...skip Europe&quot;);</span>
				}
				continue;
			}

			// Try the tiles in each direction
			PathNode closed;
<span class="fc bfc" id="L1586" title="All 2 branches covered.">			for (Tile moveTile : currentTile.getSurroundingTiles(1)) {</span>
				// If the new tile is the tile we just visited, skip it.
<span class="pc bpc" id="L1588" title="1 of 2 branches missed.">				if (lb != null) {</span>
<span class="nc" id="L1589">					lb.add(&quot;\n    &quot;, moveTile);</span>
				}
<span class="fc bfc" id="L1591" title="All 4 branches covered.">				if (currentNode.previous != null &amp;&amp; currentNode.previous.getTile() == moveTile) {</span>
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">					if (lb != null) {</span>
<span class="nc" id="L1593">						lb.add(&quot; prev&quot;);</span>
					}
					continue;
				}

				// Skip neighbouring tiles already too expensive.
				int cc;
<span class="fc bfc" id="L1600" title="All 2 branches covered.">				if ((closed = closedMap.get(moveTile.getId())) != null</span>
<span class="pc bpc" id="L1601" title="1 of 2 branches missed.">						&amp;&amp; (cc = closed.getCost()) &lt;= currentNode.getCost()) {</span>
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">					if (lb != null) {</span>
<span class="nc" id="L1603">						lb.add(&quot; &quot;, cc);</span>
					}
					continue;
				}

				// Is this move to the goal? Use fake high cost so
				// this does not become cached inside the goal decider
				// as the preferred path.
<span class="fc" id="L1611">				boolean isGoal = goalDecider.check(unit,</span>
						new PathNode(moveTile, 0, INFINITY / 2, false, currentNode, null));
<span class="pc bpc" id="L1613" title="1 of 4 branches missed.">				if (isGoal &amp;&amp; lb != null) {</span>
<span class="nc" id="L1614">					lb.add(&quot; *goal*&quot;);</span>
				}

				// Is this move possible for the base unit?
				// Allow some seemingly impossible moves if it is to
				// the goal (see the comment to recoverMove).
<span class="fc" id="L1620">				Unit.MoveType umt = unit.getSimpleMoveType(currentTile, moveTile);</span>
<span class="fc bfc" id="L1621" title="All 4 branches covered.">				boolean carrierMove = carrier != null &amp;&amp; carrier.isTileAccessible(moveTile);</span>
<span class="fc" id="L1622">				boolean unitMove = umt.isProgress();</span>
<span class="fc bfc" id="L1623" title="All 2 branches covered.">				if (isGoal) {</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">					if (!unitMove) {</span>
<span class="pc bpc" id="L1625" title="2 of 4 branches missed.">						switch (umt) {</span>
						case ATTACK_UNIT:
						case ATTACK_SETTLEMENT:
						case ENTER_FOREIGN_COLONY_WITH_SCOUT:
						case ENTER_INDIAN_SETTLEMENT_WITH_SCOUT:
						case ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST:
						case ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY:
						case ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS:
							// Can not move to the tile, but there is
							// a valid interaction with the unit or
							// settlement that is there.
<span class="fc" id="L1636">							unitMove = true;</span>
<span class="fc" id="L1637">							break;</span>
						case MOVE_NO_ATTACK_MARINE:
						case MOVE_NO_ATTACK_CIVILIAN:
<span class="nc bnc" id="L1640" title="All 2 branches missed.">							if (moveTile.hasSettlement()) {</span>
<span class="nc" id="L1641">								break;</span>
							}
							// There is a unit in the way. Unless this
							// unit can arrive there this turn, assume the
							// condition is transient as long as the tile
							// is not in a constrained position such as a
							// small island or river.
<span class="nc bnc" id="L1648" title="All 4 branches missed.">							unitMove = currentNode.getTurns() &gt; 0 &amp;&amp; moveTile.getAvailableAdjacentCount() &gt;= 3;</span>
<span class="nc" id="L1649">							break;</span>
						case MOVE_NO_ACCESS_WATER:
							// The unit can not disembark directly to the
							// goal along this path, but the goal is still
							// available by other paths.
<span class="nc bnc" id="L1654" title="All 2 branches missed.">							if (lb != null) {</span>
<span class="nc" id="L1655">								lb.add(&quot; !disembark&quot;);</span>
							}
							continue;
						default:
							break;
						}
<span class="pc bpc" id="L1661" title="1 of 4 branches missed.">						if (!unitMove &amp;&amp; unit == currentUnit) {</span>
							// This search can never succeed if the unit
							// can not reach the goal, except if there is
							// a carrier involved that might still succeed.
<span class="nc bnc" id="L1665" title="All 2 branches missed.">							if (lb != null) {</span>
<span class="nc" id="L1666">								lb.add(&quot; fail-at-GOAL(&quot;, umt, &quot;)&quot;);</span>
							}
							continue;
						}
					}
					// Special case where the carrier is adjacent to
					// an accessible goal settlement but out of moves,
					// in which case we let the unit finish the job
					// if it can move.
<span class="pc bpc" id="L1675" title="3 of 6 branches missed.">					if (unitMove &amp;&amp; carrierMove &amp;&amp; currentOnCarrier) {</span>
<span class="nc bnc" id="L1676" title="All 4 branches missed.">						carrierMove = currentNode.getMovesLeft() &gt; 0 || currentNode.embarkedThisTurn(currentTurns);</span>
					}
				}
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">				if (lb != null) {</span>
<span class="nc bnc" id="L1680" title="All 4 branches missed.">					lb.add(&quot; &quot;, umt, &quot;/&quot;, ((unitMove) ? &quot;U&quot; : &quot;&quot;), ((carrierMove) ? &quot;C&quot; : &quot;&quot;));</span>
				}

				// Check for a carrier change at the new tile,
				// creating a MoveCandidate for each case.
				//
				// Do *not* allow units to re-embark on the carrier.
				// Note that embarking can actually increase the moves
				// left because the carrier might be not have spent
				// any moves yet that turn.
				//
				// Note that we always favour using the carrier if
				// both carrier and non-carrier moves are possible,
				// which can only be true moving into a settlement.
				// Usually when moving into a settlement it will be
				// useful to dock the carrier so it can collect new
				// cargo. OTOH if the carrier is just passing through
				// the right thing is to keep the passenger on board.
				// However, see the goal settlement exception above.
<span class="fc bfc" id="L1699" title="All 8 branches covered.">				MoveStep step = (currentOnCarrier)</span>
						? ((carrierMove) ? MoveStep.BYWATER : (unitMove) ? MoveStep.DISEMBARK : MoveStep.FAIL)
<span class="pc bpc" id="L1701" title="2 of 6 branches missed.">						: ((carrierMove &amp;&amp; !usedCarrier(currentNode)) ? MoveStep.EMBARK</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">								: (unitMove || isGoal) ? ((unit.isNaval()) ? MoveStep.BYWATER : MoveStep.BYLAND)</span>
										: MoveStep.FAIL);
				MoveCandidate move;
<span class="pc bfc" id="L1705" title="All 5 branches covered.">				switch (step) {</span>
				case BYLAND:
<span class="fc bfc" id="L1707" title="All 2 branches covered.">					move = new MoveCandidate(unit, currentNode, moveTile, currentMovesLeft, currentTurns, false,</span>
<span class="fc" id="L1708">							((costDecider != null) ? costDecider : CostDeciders.defaultCostDeciderFor(unit)));</span>
<span class="fc" id="L1709">					break;</span>
				case BYWATER:
<span class="fc bfc" id="L1711" title="All 2 branches covered.">					move = new MoveCandidate(offMapUnit, currentNode, moveTile, currentMovesLeft, currentTurns,</span>
							currentOnCarrier,
<span class="fc" id="L1713">							((costDecider != null) ? costDecider : CostDeciders.defaultCostDeciderFor(offMapUnit)));</span>
<span class="fc" id="L1714">					break;</span>
				case EMBARK:
<span class="fc bfc" id="L1716" title="All 2 branches covered.">					move = new MoveCandidate(unit, currentNode, moveTile, currentMovesLeft, currentTurns, true,</span>
<span class="fc" id="L1717">							((costDecider != null) ? costDecider : CostDeciders.defaultCostDeciderFor(unit)));</span>
<span class="fc" id="L1718">					move.embarkUnit(carrier);</span>
<span class="fc" id="L1719">					break;</span>
				case DISEMBARK:
<span class="fc bfc" id="L1721" title="All 2 branches covered.">					move = new MoveCandidate(unit, currentNode, moveTile, 0, currentTurns, false,</span>
<span class="fc" id="L1722">							((costDecider != null) ? costDecider : CostDeciders.defaultCostDeciderFor(unit)));</span>
<span class="fc" id="L1723">					break;</span>
				case FAIL:
				default: // Loop on failure.
<span class="fc" id="L1726">					move = null;</span>
					break;
				}

				String stepLog;
<span class="fc bfc" id="L1731" title="All 2 branches covered.">				if (move == null) {</span>
<span class="fc" id="L1732">					stepLog = &quot;!&quot;;</span>
				} else {
<span class="fc" id="L1734">					move.resetPath(isGoal);</span>
					// Tighten the bounds on a previously seen case if possible
<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">					if (closed != null) {</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">						if (move.canImprove(closed)) {</span>
<span class="nc" id="L1738">							closedMap.remove(moveTile.getId());</span>
<span class="nc" id="L1739">							move.improve(openMap, openMapQueue, f, searchHeuristic);</span>
<span class="nc" id="L1740">							stepLog = &quot;^&quot; + Integer.toString(move.getCost());</span>
						} else {
<span class="nc" id="L1742">							stepLog = &quot;.&quot;;</span>
						}
<span class="fc bfc" id="L1744" title="All 2 branches covered.">					} else if (move.canImprove(openMap.get(moveTile.getId()))) {</span>
<span class="fc" id="L1745">						move.improve(openMap, openMapQueue, f, searchHeuristic);</span>
<span class="fc" id="L1746">						stepLog = &quot;+&quot; + Integer.toString(move.getCost());</span>
					} else {
<span class="fc" id="L1748">						stepLog = &quot;-&quot;;</span>
					}
				}
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">				if (lb != null) {</span>
<span class="nc" id="L1752">					lb.add(&quot; &quot;, step, stepLog);</span>
				}
<span class="fc" id="L1754">			}</span>
<span class="fc" id="L1755">		}</span>

		// Relink the path. We omitted the .next link while constructing it.
<span class="fc" id="L1758">		best = goalDecider.getGoal();</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">		if (best != null) {</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">			while (best.previous != null) {</span>
<span class="fc" id="L1761">				best.previous.next = best;</span>
<span class="fc" id="L1762">				best = best.previous;</span>
			}
		}
<span class="fc" id="L1765">		return best;</span>
	}

	/**
	 * Searches for a tile within a radius of a starting tile.
	 *
	 * Does not use a unit, and thus does not consider movement validity.
	 *
	 * @param start
	 *            The starting &lt;code&gt;Tile&lt;/code&gt;.
	 * @param goalDecider
	 *            A &lt;code&gt;GoalDecider&lt;/code&gt; that chooses the goal, which must
	 *            be capable of tolerating a null unit.
	 * @param radius
	 *            The maximum radius of tiles to search from the start.
	 * @return The goal tile as determined by the, or null if none found.
	 */
	public Tile searchCircle(final Tile start, final GoalDecider goalDecider, final int radius) {
<span class="pc bpc" id="L1783" title="3 of 6 branches missed.">		if (start == null || goalDecider == null || radius &lt;= 0) {</span>
<span class="nc" id="L1784">			return null;</span>
		}

<span class="fc bfc" id="L1787" title="All 2 branches covered.">		for (Tile t : getCircleTiles(start, true, radius)) {</span>
<span class="fc" id="L1788">			PathNode path = new PathNode(t, 0, start.getDistanceTo(t), false, null, null);</span>
<span class="pc bpc" id="L1789" title="3 of 4 branches missed.">			if (goalDecider.check(null, path) &amp;&amp; !goalDecider.hasSubGoals()) {</span>
<span class="nc" id="L1790">				break;</span>
			}
<span class="fc" id="L1792">		}</span>

<span class="fc" id="L1794">		PathNode best = goalDecider.getGoal();</span>
<span class="pc bpc" id="L1795" title="1 of 2 branches missed.">		return (best == null) ? null : best.getTile();</span>
	}

	// Support for various kinds of map iteration.

	/**
	 * An iterator returning positions in a spiral starting at a given center
	 * tile. The center tile is never included in the returned tiles, and all
	 * returned tiles are valid.
	 */
	private final class CircleIterator implements Iterator&lt;Tile&gt; {

		/** The maximum radius. */
		private final int radius;
		/** The current radius of the iteration. */
		private int currentRadius;

		/** The current index in the circle with the current radius:. */
		private int n;
		/** The current position in the circle. */
		private int x, y;

		/**
		 * Create a new Circle Iterator.
		 *
		 * @param center
		 *            The center &lt;code&gt;Tile&lt;/code&gt; of the circle.
		 * @param isFilled
		 *            True to get all of the positions within the circle.
		 * @param radius
		 *            The radius of the circle.
		 */
<span class="fc" id="L1827">		public CircleIterator(Tile center, boolean isFilled, int radius) {</span>
<span class="pc bpc" id="L1828" title="1 of 2 branches missed.">			if (center == null) {</span>
<span class="nc" id="L1829">				throw new IllegalArgumentException(&quot;center must not be null.&quot;);</span>
			}
<span class="fc" id="L1831">			this.radius = radius;</span>
<span class="fc" id="L1832">			n = 0;</span>

			Position step;
<span class="pc bpc" id="L1835" title="3 of 4 branches missed.">			if (isFilled || radius == 1) {</span>
<span class="fc" id="L1836">				step = Direction.NE.step(center.getX(), center.getY());</span>
<span class="fc" id="L1837">				x = step.x;</span>
<span class="fc" id="L1838">				y = step.y;</span>
<span class="fc" id="L1839">				currentRadius = 1;</span>
			} else {
<span class="nc" id="L1841">				this.currentRadius = radius;</span>
<span class="nc" id="L1842">				x = center.getX();</span>
<span class="nc" id="L1843">				y = center.getY();</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">				for (int i = 1; i &lt; radius; i++) {</span>
<span class="nc" id="L1845">					step = Direction.N.step(x, y);</span>
<span class="nc" id="L1846">					x = step.x;</span>
<span class="nc" id="L1847">					y = step.y;</span>
				}
<span class="nc" id="L1849">				step = Direction.NE.step(x, y);</span>
<span class="nc" id="L1850">				x = step.x;</span>
<span class="nc" id="L1851">				y = step.y;</span>
			}
<span class="fc bfc" id="L1853" title="All 2 branches covered.">			if (!isValid(x, y)) {</span>
<span class="fc" id="L1854">				nextTile();</span>
			}
<span class="fc" id="L1856">		}</span>

		/**
		 * Gets the current radius of the circle.
		 *
		 * @return The distance from the center tile this
		 *         &lt;code&gt;CircleIterator&lt;/code&gt; was initialized with.
		 */
		public int getCurrentRadius() {
<span class="nc" id="L1865">			return currentRadius;</span>
		}

		/**
		 * Finds the next position.
		 */
		private void nextTile() {
<span class="fc bfc" id="L1872" title="All 2 branches covered.">			boolean started = n != 0;</span>
			do {
<span class="fc" id="L1874">				n++;</span>
<span class="fc" id="L1875">				final int width = currentRadius * 2;</span>
<span class="fc bfc" id="L1876" title="All 2 branches covered.">				if (n &gt;= width * 4) {</span>
<span class="fc" id="L1877">					currentRadius++;</span>
<span class="fc bfc" id="L1878" title="All 2 branches covered.">					if (currentRadius &gt; radius) {</span>
<span class="fc" id="L1879">						x = y = UNDEFINED;</span>
<span class="fc" id="L1880">						break;</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">					} else if (!started) {</span>
<span class="fc" id="L1882">						x = y = UNDEFINED;</span>
<span class="fc" id="L1883">						break;</span>
					} else {
<span class="fc" id="L1885">						n = 0;</span>
<span class="fc" id="L1886">						started = false;</span>
<span class="fc" id="L1887">						Position step = Direction.NE.step(x, y);</span>
<span class="fc" id="L1888">						x = step.x;</span>
<span class="fc" id="L1889">						y = step.y;</span>
<span class="fc" id="L1890">					}</span>
				} else {
<span class="fc" id="L1892">					int i = n / width;</span>
					Direction direction;
<span class="pc bpc" id="L1894" title="1 of 5 branches missed.">					switch (i) {</span>
					case 0:
<span class="fc" id="L1896">						direction = Direction.SE;</span>
<span class="fc" id="L1897">						break;</span>
					case 1:
<span class="fc" id="L1899">						direction = Direction.SW;</span>
<span class="fc" id="L1900">						break;</span>
					case 2:
<span class="fc" id="L1902">						direction = Direction.NW;</span>
<span class="fc" id="L1903">						break;</span>
					case 3:
<span class="fc" id="L1905">						direction = Direction.NE;</span>
<span class="fc" id="L1906">						break;</span>
					default:
<span class="nc" id="L1908">						throw new IllegalStateException(&quot;i=&quot; + i + &quot;, n=&quot; + n + &quot;, width=&quot; + width);</span>
					}
<span class="fc" id="L1910">					Position step = direction.step(x, y);</span>
<span class="fc" id="L1911">					x = step.x;</span>
<span class="fc" id="L1912">					y = step.y;</span>
				}
<span class="fc bfc" id="L1914" title="All 2 branches covered.">			} while (!isValid(x, y));</span>
<span class="fc" id="L1915">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasNext() {
<span class="pc bpc" id="L1922" title="1 of 4 branches missed.">			return x != UNDEFINED &amp;&amp; y != UNDEFINED;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Tile next() throws NoSuchElementException {
<span class="pc bpc" id="L1930" title="1 of 2 branches missed.">			if (!hasNext()) {</span>
<span class="nc" id="L1931">				throw new NoSuchElementException(&quot;CircleIterator exhausted&quot;);</span>
			}
<span class="fc" id="L1933">			Tile result = getTile(x, y);</span>
<span class="fc" id="L1934">			nextTile();</span>
<span class="fc" id="L1935">			return result;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void remove() {
<span class="nc" id="L1943">			throw new UnsupportedOperationException();</span>
		}
	}

	/**
	 * Gets a circle iterator.
	 *
	 * @param center
	 *            The center &lt;code&gt;Tile&lt;/code&gt; to iterate around.
	 * @param isFilled
	 *            True to get all of the positions in the circle.
	 * @param radius
	 *            The radius of circle.
	 * @return The circle iterator.
	 */
	public Iterator&lt;Tile&gt; getCircleIterator(Tile center, boolean isFilled, int radius) {
<span class="fc" id="L1959">		return new CircleIterator(center, isFilled, radius);</span>
	}

	/**
	 * Gets an iterable for all the tiles in a circle using an underlying
	 * CircleIterator.
	 *
	 * @param center
	 *            The center &lt;code&gt;Tile&lt;/code&gt; to iterate around.
	 * @param isFilled
	 *            True to get all of the positions in the circle.
	 * @param radius
	 *            The radius of circle.
	 * @return An &lt;code&gt;Iterable&lt;/code&gt; for a circle of tiles.
	 */
	public Iterable&lt;Tile&gt; getCircleTiles(final Tile center, final boolean isFilled, final int radius) {
<span class="fc" id="L1975">		return new Iterable&lt;Tile&gt;() {</span>
			@Override
			public Iterator&lt;Tile&gt; iterator() {
<span class="fc" id="L1978">				return getCircleIterator(center, isFilled, radius);</span>
			}
		};
	}

	/**
	 * An iterator for the whole map.
	 */
	private class WholeMapIterator implements Iterator&lt;Tile&gt; {

		/** The current coordinate position in the iteration. */
		private int x, y;

		/**
		 * Default constructor.
		 */
<span class="fc" id="L1994">		public WholeMapIterator() {</span>
<span class="fc" id="L1995">			x = y = 0;</span>
<span class="fc" id="L1996">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L2003" title="All 2 branches covered.">			return y &lt; getHeight();</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Tile next() throws NoSuchElementException {
<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">			if (!hasNext()) {</span>
<span class="nc" id="L2012">				throw new NoSuchElementException(&quot;WholeMapIterator exhausted&quot;);</span>
			}
<span class="fc" id="L2014">			Tile result = getTile(x, y);</span>
<span class="fc" id="L2015">			x++;</span>
<span class="fc bfc" id="L2016" title="All 2 branches covered.">			if (x &gt;= getWidth()) {</span>
<span class="fc" id="L2017">				x = 0;</span>
<span class="fc" id="L2018">				y++;</span>
			}
<span class="fc" id="L2020">			return result;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void remove() {
<span class="nc" id="L2028">			throw new UnsupportedOperationException();</span>
		}
	}

	/**
	 * Gets an &lt;code&gt;Iterator&lt;/code&gt; of every &lt;code&gt;Tile&lt;/code&gt; on the map.
	 *
	 * @return An &lt;code&gt;Iterator&lt;/code&gt; for the whole map.
	 */
	public Iterator&lt;Tile&gt; getWholeMapIterator() {
<span class="nc" id="L2038">		return new WholeMapIterator();</span>
	}

	/**
	 * Gets an iterable for all the tiles in the map using an underlying
	 * WholeMapIterator.
	 *
	 * @return An &lt;code&gt;Iterable&lt;/code&gt; for all tiles of the map.
	 */
	public Iterable&lt;Tile&gt; getAllTiles() {
<span class="fc" id="L2048">		return new Iterable&lt;Tile&gt;() {</span>
			@Override
			public Iterator&lt;Tile&gt; iterator() {
<span class="fc" id="L2051">				return new WholeMapIterator();</span>
			}
		};
	}

	// Useful customers for tile iteration.

	/**
	 * Searches for land within the given radius.
	 *
	 * @param x
	 *            X-component of the position to search from.
	 * @param y
	 *            Y-component of the position to search from.
	 * @param distance
	 *            The radius in tiles that should be searched for land.
	 * @return The first land tile found within the radius, or null if none
	 *         found.
	 */
	public Tile getLandWithinDistance(int x, int y, int distance) {
<span class="fc bfc" id="L2071" title="All 2 branches covered.">		for (Tile t : getCircleTiles(getTile(x, y), true, distance)) {</span>
<span class="fc bfc" id="L2072" title="All 2 branches covered.">			if (t.isLand()) {</span>
<span class="fc" id="L2073">				return t;</span>
			}
<span class="fc" id="L2075">		}</span>
<span class="fc" id="L2076">		return null;</span>
	}

	/**
	 * Iterates through a rectangular subpart of the Map. Intentionally avoids
	 * calling methods doing redundant checks, which would slow down map
	 * display.
	 * 
	 * @param x
	 *            X-component of the position of first tile.
	 * @param y
	 *            Y-component of the position of first tile.
	 * @param w
	 *            Width of the rectangle.
	 * @param h
	 *            Height of the rectangle.
	 * @param consumer
	 *            Provides a function to call for each tile.
	 */
	public void forSubMap(int x, int y, int w, int h, java.util.function.Consumer&lt;Tile&gt; consumer) {
<span class="nc bnc" id="L2096" title="All 2 branches missed.">		if (x &lt; 0) {</span>
<span class="nc" id="L2097">			w += x;</span>
<span class="nc" id="L2098">			x = 0;</span>
		}
<span class="nc bnc" id="L2100" title="All 2 branches missed.">		if (y &lt; 0) {</span>
<span class="nc" id="L2101">			h += y;</span>
<span class="nc" id="L2102">			y = 0;</span>
		}
<span class="nc bnc" id="L2104" title="All 4 branches missed.">		if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L2105">			return;</span>
		}
<span class="nc" id="L2107">		int width = getWidth();</span>
<span class="nc" id="L2108">		int height = getHeight();</span>
<span class="nc bnc" id="L2109" title="All 4 branches missed.">		if (x &gt; width || y &gt; height) {</span>
<span class="nc" id="L2110">			return;</span>
		}
<span class="nc bnc" id="L2112" title="All 2 branches missed.">		if (x + w &gt; width) {</span>
<span class="nc" id="L2113">			w = width - x;</span>
		}
<span class="nc bnc" id="L2115" title="All 2 branches missed.">		if (y + h &gt; height) {</span>
<span class="nc" id="L2116">			h = height - y;</span>
		}
<span class="nc bnc" id="L2118" title="All 2 branches missed.">		for (int yi = y; yi &lt; y + h; ++yi) {</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">			for (int xi = x; xi &lt; x + w; ++xi) {</span>
<span class="nc" id="L2120">				consumer.accept(tiles[xi][yi]);</span>
			}
		}
<span class="nc" id="L2123">	}</span>

	/**
	 * Flood fills from a given &lt;code&gt;Position&lt;/code&gt; p, based on connectivity
	 * information encoded in boolmap.
	 *
	 * @param boolmap
	 *            The connectivity information for this floodfill.
	 * @param x
	 *            The starting x coordinate.
	 * @param y
	 *            The starting y coordinate.
	 * @return A boolean[][] of the same size as boolmap, where &quot;true&quot; means the
	 *         fill succeeded at that location.
	 */
	public static boolean[][] floodFill(boolean[][] boolmap, int x, int y) {
<span class="fc" id="L2139">		return floodFill(boolmap, x, y, Integer.MAX_VALUE);</span>
	}

	/**
	 * Flood fills from a given &lt;code&gt;Position&lt;/code&gt; p, based on connectivity
	 * information encoded in boolmap.
	 *
	 * @param boolmap
	 *            The connectivity information for this floodfill.
	 * @param x
	 *            The starting x coordinate.
	 * @param y
	 *            The starting y coordinate.
	 * @param limit
	 *            Limit to stop flood fill at.
	 * @return A boolean[][] of the same size as boolmap, where &quot;true&quot; means the
	 *         fill succeeded at that location.
	 */
	public static boolean[][] floodFill(boolean[][] boolmap, int x, int y, int limit) {
<span class="fc" id="L2158">		Position p = new Position(x, y);</span>
<span class="fc" id="L2159">		Queue&lt;Position&gt; q = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L2160">		boolean[][] visited = new boolean[boolmap.length][boolmap[0].length];</span>
<span class="fc" id="L2161">		visited[p.getX()][p.getY()] = true;</span>
<span class="fc" id="L2162">		limit--;</span>
		do {
<span class="fc bfc" id="L2164" title="All 2 branches covered.">			for (Direction direction : Direction.values()) {</span>
<span class="fc" id="L2165">				Position n = new Position(p, direction);</span>
<span class="fc bfc" id="L2166" title="All 4 branches covered.">				if (n.isValid(boolmap.length, boolmap[0].length) &amp;&amp; boolmap[n.getX()][n.getY()]</span>
<span class="fc bfc" id="L2167" title="All 4 branches covered.">						&amp;&amp; !visited[n.getX()][n.getY()] &amp;&amp; limit &gt; 0) {</span>
<span class="fc" id="L2168">					visited[n.getX()][n.getY()] = true;</span>
<span class="fc" id="L2169">					limit--;</span>
<span class="fc" id="L2170">					q.add(n);</span>
				}
			}

<span class="fc" id="L2174">			p = q.poll();</span>
<span class="fc bfc" id="L2175" title="All 4 branches covered.">		} while (p != null &amp;&amp; limit &gt; 0);</span>
<span class="fc" id="L2176">		return visited;</span>
	}

	/**
	 * Sets the contiguity identifier for all tiles.
	 */
	public void resetContiguity() {
		// Create the water map. It is an error for any tile not to
		// have a region at this point.
<span class="fc" id="L2185">		boolean[][] waterMap = new boolean[getWidth()][getHeight()];</span>
<span class="fc bfc" id="L2186" title="All 2 branches covered.">		for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">			for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="pc bpc" id="L2188" title="1 of 2 branches missed.">				if (isValid(x, y)) {</span>
<span class="fc bfc" id="L2189" title="All 2 branches covered.">					waterMap[x][y] = !getTile(x, y).isLand();</span>
<span class="fc" id="L2190">					Tile tile = getTile(x, y);</span>
<span class="fc" id="L2191">					tile.setContiguity(-1);</span>
				}
			}
		}

		// Flood fill each contiguous water region, setting the
		// contiguity number.
<span class="fc" id="L2198">		int contig = 0;</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">		for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2200" title="All 2 branches covered.">			for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="fc bfc" id="L2201" title="All 2 branches covered.">				if (waterMap[x][y]) {</span>
<span class="fc" id="L2202">					Tile tile = getTile(x, y);</span>
<span class="fc bfc" id="L2203" title="All 2 branches covered.">					if (tile.getContiguity() &gt;= 0) {</span>
<span class="fc" id="L2204">						continue;</span>
					}

<span class="fc" id="L2207">					boolean[][] found = floodFill(waterMap, x, y);</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">					for (int yy = 0; yy &lt; getHeight(); yy++) {</span>
<span class="fc bfc" id="L2209" title="All 2 branches covered.">						for (int xx = 0; xx &lt; getWidth(); xx++) {</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">							if (found[xx][yy]) {</span>
<span class="fc" id="L2211">								Tile t = getTile(xx, yy);</span>
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">								if (t.getContiguity() &lt; 0) {</span>
<span class="fc" id="L2213">									t.setContiguity(contig);</span>
								}
							}
						}
					}
<span class="fc" id="L2218">					contig++;</span>
				}
			}
		}

		// Complement the waterMap, it is now the land map.
<span class="fc bfc" id="L2224" title="All 2 branches covered.">		for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2225" title="All 2 branches covered.">			for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">				if (isValid(x, y)) {</span>
<span class="fc bfc" id="L2227" title="All 2 branches covered.">					waterMap[x][y] = !waterMap[x][y];</span>
				}
			}
		}

		// Flood fill again for each contiguous land region.
<span class="fc bfc" id="L2233" title="All 2 branches covered.">		for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2234" title="All 2 branches covered.">			for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="fc bfc" id="L2235" title="All 2 branches covered.">				if (waterMap[x][y]) {</span>
<span class="fc" id="L2236">					Tile tile = getTile(x, y);</span>
<span class="fc bfc" id="L2237" title="All 2 branches covered.">					if (tile.getContiguity() &gt;= 0) {</span>
<span class="fc" id="L2238">						continue;</span>
					}

<span class="fc" id="L2241">					boolean[][] found = floodFill(waterMap, x, y);</span>
<span class="fc bfc" id="L2242" title="All 2 branches covered.">					for (int yy = 0; yy &lt; getHeight(); yy++) {</span>
<span class="fc bfc" id="L2243" title="All 2 branches covered.">						for (int xx = 0; xx &lt; getWidth(); xx++) {</span>
<span class="fc bfc" id="L2244" title="All 2 branches covered.">							if (found[xx][yy]) {</span>
<span class="fc" id="L2245">								Tile t = getTile(xx, yy);</span>
<span class="pc bpc" id="L2246" title="1 of 2 branches missed.">								if (t.getContiguity() &lt; 0) {</span>
<span class="fc" id="L2247">									t.setContiguity(contig);</span>
								}
							}
						}
					}
<span class="fc" id="L2252">					contig++;</span>
				}
			}
		}
<span class="fc" id="L2256">	}</span>

	/**
	 * Places the &quot;high seas&quot;-tiles on the border of this map.
	 *
	 * All other tiles previously of type High Seas will be set to Ocean.
	 *
	 * @param distToLandFromHighSeas
	 *            The distance between the land and the high seas (given in
	 *            tiles).
	 * @param maxDistanceToEdge
	 *            The maximum distance a high sea tile can have from the edge of
	 *            the map.
	 */
	public void resetHighSeas(int distToLandFromHighSeas, int maxDistanceToEdge) {
<span class="fc" id="L2271">		final Specification spec = getSpecification();</span>
<span class="fc" id="L2272">		final TileType ocean = spec.getTileType(&quot;model.tile.ocean&quot;);</span>
<span class="fc" id="L2273">		final TileType highSeas = spec.getTileType(&quot;model.tile.highSeas&quot;);</span>
<span class="pc bpc" id="L2274" title="1 of 2 branches missed.">		if (highSeas == null) {</span>
<span class="nc" id="L2275">			throw new RuntimeException(&quot;HighSeas TileType must exist&quot;);</span>
		}
<span class="pc bpc" id="L2277" title="1 of 2 branches missed.">		if (ocean == null) {</span>
<span class="nc" id="L2278">			throw new RuntimeException(&quot;Ocean TileType must exist&quot;);</span>
		}
<span class="pc bpc" id="L2280" title="1 of 2 branches missed.">		if (distToLandFromHighSeas &lt; 0) {</span>
<span class="nc" id="L2281">			throw new RuntimeException(&quot;Land&lt;-&gt;HighSeas distance can not be negative&quot;);</span>
		}
<span class="pc bpc" id="L2283" title="1 of 2 branches missed.">		if (maxDistanceToEdge &lt; 0) {</span>
<span class="nc" id="L2284">			throw new RuntimeException(&quot;Distance to edge can not be negative&quot;);</span>
		}

		// Reset all highSeas tiles to the default ocean type.
<span class="fc bfc" id="L2288" title="All 2 branches covered.">		for (Tile t : getAllTiles()) {</span>
<span class="pc bpc" id="L2289" title="1 of 2 branches missed.">			if (t.getType() == highSeas) {</span>
<span class="nc" id="L2290">				t.setType(ocean);</span>
			}
<span class="fc" id="L2292">		}</span>

<span class="fc" id="L2294">		final int width = getWidth(), height = getHeight();</span>
<span class="fc" id="L2295">		Tile t, seaL = null, seaR = null;</span>
<span class="fc" id="L2296">		int totalL = 0, totalR = 0, distanceL = -1, distanceR = -1;</span>
<span class="fc bfc" id="L2297" title="All 2 branches covered.">		for (int y = 0; y &lt; height; y++) {</span>
<span class="pc bpc" id="L2298" title="1 of 2 branches missed.">			for (int x = 0; x &lt; maxDistanceToEdge &amp;&amp; x &lt; width &amp;&amp; isValid(x, y)</span>
<span class="pc bpc" id="L2299" title="1 of 6 branches missed.">					&amp;&amp; (t = getTile(x, y)).getType() == ocean; x++) {</span>
<span class="fc" id="L2300">				Tile other = getLandWithinDistance(x, y, distToLandFromHighSeas);</span>
<span class="fc bfc" id="L2301" title="All 2 branches covered.">				if (other == null) {</span>
<span class="fc" id="L2302">					t.setType(highSeas);</span>
<span class="fc" id="L2303">					totalL++;</span>
				} else {
<span class="fc" id="L2305">					int distance = t.getDistanceTo(other);</span>
<span class="fc bfc" id="L2306" title="All 2 branches covered.">					if (distanceL &lt; distance) {</span>
<span class="fc" id="L2307">						distanceL = distance;</span>
<span class="fc" id="L2308">						seaL = t;</span>
					}
				}
			}
<span class="pc bpc" id="L2312" title="1 of 2 branches missed.">			for (int x = 0; x &lt; maxDistanceToEdge &amp;&amp; x &lt; width &amp;&amp; isValid(width - 1 - x, y)</span>
<span class="pc bpc" id="L2313" title="1 of 6 branches missed.">					&amp;&amp; (t = getTile(width - 1 - x, y)).getType() == ocean; x++) {</span>
<span class="fc" id="L2314">				Tile other = getLandWithinDistance(width - 1 - x, y, distToLandFromHighSeas);</span>
<span class="fc bfc" id="L2315" title="All 2 branches covered.">				if (other == null) {</span>
<span class="fc" id="L2316">					t.setType(highSeas);</span>
<span class="fc" id="L2317">					totalR++;</span>
				} else {
<span class="fc" id="L2319">					int distance = t.getDistanceTo(other);</span>
<span class="fc bfc" id="L2320" title="All 2 branches covered.">					if (distanceR &lt; distance) {</span>
<span class="fc" id="L2321">						distanceR = distance;</span>
<span class="fc" id="L2322">						seaR = t;</span>
					}
				}
			}
		}
<span class="pc bpc" id="L2327" title="3 of 4 branches missed.">		if (totalL &lt;= 0 &amp;&amp; seaL != null) {</span>
<span class="nc" id="L2328">			seaL.setType(highSeas);</span>
<span class="nc" id="L2329">			totalL++;</span>
		}
<span class="pc bpc" id="L2331" title="3 of 4 branches missed.">		if (totalR &lt;= 0 &amp;&amp; seaR != null) {</span>
<span class="nc" id="L2332">			seaR.setType(highSeas);</span>
<span class="nc" id="L2333">			totalR++;</span>
		}
<span class="pc bpc" id="L2335" title="2 of 4 branches missed.">		if (totalL &lt;= 0 || totalR &lt;= 0) {</span>
<span class="nc bnc" id="L2336" title="All 8 branches missed.">			logger.warning(&quot;No high seas on &quot;</span>
					+ ((totalL &lt;= 0 &amp;&amp; totalR &lt;= 0) ? &quot;either&quot;
							: (totalL &lt;= 0) ? &quot;left&quot; : (totalR &lt;= 0) ? &quot;right&quot; : &quot;BOGUS&quot;)
					+ &quot; side of the map.&quot; + &quot;  This can cause failures on small test maps.&quot;);
		}
<span class="fc" id="L2341">	}</span>

	/**
	 * Sets the high seas count for all tiles connected to the high seas. Any
	 * ocean tiles on the map vertical edges that do not have an explicit false
	 * moveToEurope attribute are given a true one.
	 *
	 * Set all high seas counts negative, then start with a count of zero for
	 * tiles with the moveToEurope attribute or of a type with that ability.
	 * Iterate outward by neighbouring tile, incrementing the count on each
	 * pass, stopping at land. Thus, only the coastal land tiles will have a
	 * non-negative high seas count. This significantly speeds up the colony
	 * site evaluator, as it does not have to try to find a path to Europe for
	 * each tile.
	 */
	public void resetHighSeasCount() {
<span class="fc" id="L2357">		List&lt;Tile&gt; curr = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2358">		List&lt;Tile&gt; next = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2359">		int hsc = 0;</span>
<span class="fc bfc" id="L2360" title="All 2 branches covered.">		for (Tile t : getAllTiles()) {</span>
<span class="fc" id="L2361">			t.setHighSeasCount(-1);</span>
<span class="fc bfc" id="L2362" title="All 2 branches covered.">			if (!t.isLand()) {</span>
<span class="pc bpc" id="L2363" title="1 of 6 branches missed.">				if ((t.getX() == 0 || t.getX() == getWidth() - 1) &amp;&amp; t.getType() != null</span>
<span class="pc bpc" id="L2364" title="1 of 4 branches missed.">						&amp;&amp; t.getType().isHighSeasConnected() &amp;&amp; !t.getType().isDirectlyHighSeasConnected()</span>
<span class="fc bfc" id="L2365" title="All 2 branches covered.">						&amp;&amp; t.getMoveToEurope() == null) {</span>
<span class="fc" id="L2366">					t.setMoveToEurope(Boolean.TRUE);</span>
				}
<span class="fc bfc" id="L2368" title="All 2 branches covered.">				if (t.isDirectlyHighSeasConnected()) {</span>
<span class="fc" id="L2369">					t.setHighSeasCount(hsc);</span>
<span class="fc" id="L2370">					next.add(t);</span>
				}
			}
<span class="fc" id="L2373">		}</span>
<span class="fc bfc" id="L2374" title="All 2 branches covered.">		while (!next.isEmpty()) {</span>
<span class="fc" id="L2375">			hsc++;</span>
<span class="fc" id="L2376">			curr.addAll(next);</span>
<span class="fc" id="L2377">			next.clear();</span>
<span class="fc bfc" id="L2378" title="All 2 branches covered.">			while (!curr.isEmpty()) {</span>
<span class="fc" id="L2379">				Tile tile = curr.remove(0);</span>
				// Deliberately using low level access to neighbours
				// rather than Tile.getSurroundingTiles() because that
				// relies on the map being attached to the game, which
				// is not necessarily true in the test suite.
<span class="fc" id="L2384">				Position position = new Position(tile.getX(), tile.getY());</span>
<span class="fc bfc" id="L2385" title="All 2 branches covered.">				for (Direction d : Direction.values()) {</span>
<span class="fc" id="L2386">					Position p = new Position(position, d);</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">					if (isValid(p)) {</span>
<span class="fc" id="L2388">						Tile t = getTile(p);</span>
<span class="fc bfc" id="L2389" title="All 2 branches covered.">						if (t.getHighSeasCount() &lt; 0) {</span>
<span class="fc" id="L2390">							t.setHighSeasCount(hsc);</span>
<span class="fc bfc" id="L2391" title="All 2 branches covered.">							if (!t.isLand())</span>
<span class="fc" id="L2392">								next.add(t);</span>
						}
					}
				}
<span class="fc" id="L2396">			}</span>
		}
<span class="fc" id="L2398">	}</span>

	/**
	 * Reset layer to reflect what is actually there.
	 */
	public void resetLayers() {
<span class="nc" id="L2404">		boolean regions = false, rivers = false, lostCityRumours = false, resources = false, nativeSettlements = false;</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">		for (Tile t : getAllTiles()) {</span>
<span class="nc bnc" id="L2406" title="All 2 branches missed.">			regions |= t.getRegion() != null;</span>
<span class="nc" id="L2407">			rivers |= t.hasRiver();</span>
<span class="nc" id="L2408">			lostCityRumours |= t.hasLostCityRumour();</span>
<span class="nc" id="L2409">			resources |= t.hasResource();</span>
<span class="nc" id="L2410">			nativeSettlements |= t.getSettlement() instanceof IndianSettlement;</span>
<span class="nc" id="L2411">		}</span>
<span class="nc bnc" id="L2412" title="All 18 branches missed.">		setLayer((rivers &amp;&amp; lostCityRumours &amp;&amp; resources &amp;&amp; nativeSettlements) ? Layer.ALL</span>
				: (nativeSettlements || lostCityRumours) ? Layer.NATIVES
						: (resources) ? Layer.RESOURCES
								: (rivers) ? Layer.RIVERS : (regions) ? Layer.REGIONS : Layer.TERRAIN);
<span class="nc" id="L2416">	}</span>

	/**
	 * Fix the region parent/child relationships.
	 */
	public void fixupRegions() {
<span class="fc bfc" id="L2422" title="All 2 branches covered.">		for (Region r : regions) {</span>
<span class="fc bfc" id="L2423" title="All 2 branches covered.">			if (r.isPacific()) {</span>
<span class="fc" id="L2424">				continue;</span>
			}
<span class="fc" id="L2426">			Region p = r.getParent();</span>
			// Mountains and Rivers were setting their parent to the
			// discoverable land region they are created within. Move them
			// up to being children of the geographic region.
<span class="pc bpc" id="L2430" title="1 of 6 branches missed.">			if (r.getDiscoverable() &amp;&amp; p != null &amp;&amp; p.getDiscoverable()) {</span>
<span class="nc" id="L2431">				p = p.getParent();</span>
<span class="nc" id="L2432">				r.setParent(p);</span>
			}
<span class="fc bfc" id="L2434" title="All 4 branches covered.">			if (p != null &amp;&amp; !p.getChildren().contains(r)) {</span>
<span class="fc" id="L2435">				p.addChild(r);</span>
			}
<span class="fc" id="L2437">		}</span>
<span class="fc" id="L2438">	}</span>

	// Interface Location
	// getId() inherited.

	/**
	 * Gets the location tile. Obviously not applicable to a Map.
	 *
	 * @return Null.
	 */
	@Override
	public Tile getTile() {
<span class="nc" id="L2450">		return null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabel() {
<span class="nc" id="L2458">		return StringTemplate.key(&quot;newWorld&quot;);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabelFor(Player player) {
<span class="nc" id="L2466">		String name = player.getNewLandName();</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">		return (name == null) ? getLocationLabel() : StringTemplate.name(name);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean add(Locatable locatable) {
		// Used to add units to their entry location. Dropped as this
		// is handled explicitly in the server.
<span class="nc bnc" id="L2477" title="All 2 branches missed.">		if (locatable instanceof Unit) {</span>
<span class="nc" id="L2478">			throw new RuntimeException(&quot;Disabled Map.add(Unit)&quot;);</span>
		}
<span class="nc" id="L2480">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean remove(Locatable locatable) {
<span class="nc bnc" id="L2488" title="All 2 branches missed.">		if (locatable instanceof Unit) {</span>
<span class="nc" id="L2489">			Tile tile = locatable.getTile();</span>
<span class="nc bnc" id="L2490" title="All 2 branches missed.">			if (tile != null) {</span>
<span class="nc" id="L2491">				return tile.remove(locatable);</span>
			}
		}
<span class="nc" id="L2494">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean contains(Locatable locatable) {
<span class="nc bnc" id="L2502" title="All 4 branches missed.">		return locatable instanceof Unit &amp;&amp; locatable.getLocation() != null</span>
<span class="nc bnc" id="L2503" title="All 2 branches missed.">				&amp;&amp; locatable.getLocation().getTile() != null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean canAdd(Locatable locatable) {
<span class="nc" id="L2511">		return locatable instanceof Unit;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getUnitCount() {
<span class="nc" id="L2519">		return -1;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List&lt;Unit&gt; getUnitList() {
<span class="nc" id="L2527">		return Collections.&lt;Unit&gt;emptyList();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Iterator&lt;Unit&gt; getUnitIterator() {
<span class="nc" id="L2535">		return getUnitList().iterator();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public GoodsContainer getGoodsContainer() {
<span class="nc" id="L2543">		return null; // Obviously irrelevant for a Map.</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Settlement getSettlement() {
<span class="nc" id="L2551">		return null; // Obviously irrelevant for a Map.</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Colony getColony() {
<span class="nc" id="L2559">		return null; // Obviously irrelevant for a Map.</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public IndianSettlement getIndianSettlement() {
<span class="nc" id="L2567">		return null; // Obviously irrelevant for a Map.</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location up() {
<span class="nc" id="L2575">		return this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getRank() {
<span class="nc" id="L2583">		return Location.LOCATION_RANK_NOWHERE;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toShortString() {
<span class="nc" id="L2591">		return &quot;Map&quot;;</span>
	}

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int checkIntegrity(boolean fix) {
<span class="fc" id="L2601">		int result = super.checkIntegrity(fix);</span>
<span class="fc bfc" id="L2602" title="All 2 branches covered.">		for (Tile t : getAllTiles()) {</span>
<span class="fc" id="L2603">			result = Math.min(result, t.checkIntegrity(fix));</span>
<span class="fc" id="L2604">		}</span>
<span class="fc" id="L2605">		return result;</span>
	}

	// Serialization

	/** The Constant HEIGHT_TAG. */
	private static final String HEIGHT_TAG = &quot;height&quot;;

	/** The Constant LAYER_TAG. */
	private static final String LAYER_TAG = &quot;layer&quot;;

	/** The Constant MAXIMUM_LATITUDE_TAG. */
	private static final String MAXIMUM_LATITUDE_TAG = &quot;maximumLatitude&quot;;

	/** The Constant MINIMUM_LATITUDE_TAG. */
	private static final String MINIMUM_LATITUDE_TAG = &quot;minimumLatitude&quot;;

	/** The Constant WIDTH_TAG. */
	private static final String WIDTH_TAG = &quot;width&quot;;

	/** The missing regions. */
	// @compat 0.10.x, region remediation
<span class="pc" id="L2627">	private final List&lt;Tile&gt; missingRegions = new ArrayList&lt;&gt;();</span>
	// end @compat
	/** The fixup high seas. */
	// @compat 0.10.5, nasty I/O hack
<span class="pc" id="L2631">	private boolean fixupHighSeas = false;</span>
	// end @compat

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2639">		super.writeAttributes(xw);</span>

<span class="fc" id="L2641">		xw.writeAttribute(WIDTH_TAG, getWidth());</span>

<span class="fc" id="L2643">		xw.writeAttribute(HEIGHT_TAG, getHeight());</span>

<span class="fc" id="L2645">		xw.writeAttribute(LAYER_TAG, layer);</span>

<span class="fc" id="L2647">		xw.writeAttribute(MINIMUM_LATITUDE_TAG, minimumLatitude);</span>

<span class="fc" id="L2649">		xw.writeAttribute(MAXIMUM_LATITUDE_TAG, maximumLatitude);</span>
<span class="fc" id="L2650">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2657">		super.writeChildren(xw);</span>

<span class="fc bfc" id="L2659" title="All 2 branches covered.">		for (Region region : getSortedCopy(regions)) {</span>
<span class="fc" id="L2660">			region.toXML(xw);</span>
<span class="fc" id="L2661">		}</span>

<span class="fc bfc" id="L2663" title="All 2 branches covered.">		for (Tile tile : getAllTiles()) {</span>
<span class="fc" id="L2664">			tile.toXML(xw);</span>
<span class="fc" id="L2665">		}</span>
<span class="fc" id="L2666">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L2673">		super.readAttributes(xr);</span>

<span class="fc" id="L2675">		setLayer(xr.getAttribute(LAYER_TAG, Layer.class, Layer.ALL));</span>

<span class="pc bpc" id="L2677" title="1 of 2 branches missed.">		if (tiles == null) {</span>
<span class="fc" id="L2678">			int width = xr.getAttribute(WIDTH_TAG, -1);</span>
<span class="pc bpc" id="L2679" title="1 of 2 branches missed.">			if (width &lt; 0) {</span>
<span class="nc" id="L2680">				throw new XMLStreamException(&quot;Bogus width: &quot; + width);</span>
			}

<span class="fc" id="L2683">			int height = xr.getAttribute(HEIGHT_TAG, -1);</span>
<span class="pc bpc" id="L2684" title="1 of 2 branches missed.">			if (height &lt; 0) {</span>
<span class="nc" id="L2685">				throw new XMLStreamException(&quot;Bogus height: &quot; + height);</span>
			}

<span class="fc" id="L2688">			tiles = new Tile[width][height];</span>
		}

<span class="fc" id="L2691">		minimumLatitude = xr.getAttribute(MINIMUM_LATITUDE_TAG, -90);</span>

<span class="fc" id="L2693">		maximumLatitude = xr.getAttribute(MAXIMUM_LATITUDE_TAG, 90);</span>

<span class="fc" id="L2695">		calculateLatitudePerRow();</span>
<span class="fc" id="L2696">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// The tiles structure is large, and individually
		// overwriteable, so we do not clear it unlike most other containers.

		// @compat 0.10.5
<span class="fc" id="L2707">		fixupHighSeas = false;</span>
		// end @compat

		// @compat 0.10.x
<span class="fc" id="L2711">		missingRegions.clear();</span>
		// end @compat

<span class="fc" id="L2714">		super.readChildren(xr);</span>

		// @compat 0.10.x
<span class="pc bpc" id="L2717" title="2 of 4 branches missed.">		if (getGame().isInServer() &amp;&amp; !missingRegions.isEmpty()) {</span>
<span class="nc" id="L2718">			TerrainGenerator.makeLakes(this, missingRegions);</span>
		}
		// end @compat

		// @compat 0.10.5
<span class="fc bfc" id="L2723" title="All 2 branches covered.">		if (fixupHighSeas) {</span>
<span class="fc" id="L2724">			resetHighSeasCount();</span>
		}
		// end @compat

		// Fix up settlement tile ownership in one hit here, avoiding
		// complications with cached tiles within the Tile serialization.
<span class="fc bfc" id="L2730" title="All 2 branches covered.">		for (Tile t : getAllTiles()) {</span>
<span class="fc" id="L2731">			Settlement s = t.getOwningSettlement();</span>
<span class="fc bfc" id="L2732" title="All 2 branches covered.">			if (s != null) {</span>
<span class="fc" id="L2733">				s.addTile(t);</span>
			}
<span class="fc" id="L2735">		}</span>

		// @compat 0.11.3
		// Maps with incorrect parent/child chains were occurring.
<span class="fc" id="L2739">		fixupRegions();</span>
		// end @compat 0.11.3
<span class="fc" id="L2741">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L2748">		final Game game = getGame();</span>
<span class="fc" id="L2749">		final String tag = xr.getLocalName();</span>

<span class="fc bfc" id="L2751" title="All 2 branches covered.">		if (Region.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L2752">			addRegion(xr.readFreeColGameObject(game, Region.class));</span>

<span class="pc bpc" id="L2754" title="1 of 2 branches missed.">		} else if (Tile.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L2755">			Tile t = xr.readFreeColGameObject(game, Tile.class);</span>
<span class="fc" id="L2756">			setTile(t, t.getX(), t.getY());</span>

			// @compat 0.10.x
<span class="pc bpc" id="L2759" title="2 of 6 branches missed.">			if (t.getType() != null &amp;&amp; &quot;model.tile.lake&quot;.equals(t.getType().getId()) &amp;&amp; t.getRegion() == null) {</span>
<span class="nc" id="L2760">				missingRegions.add(t);</span>
			}
			// end @compat

			// @compat 0.10.5
<span class="fc bfc" id="L2765" title="All 2 branches covered.">			if (t.getHighSeasCount() == Tile.FLAG_RECALCULATE) {</span>
<span class="fc" id="L2766">				fixupHighSeas = true;</span>
			}
			// end @compat

<span class="fc" id="L2770">		} else {</span>
<span class="nc" id="L2771">			super.readChild(xr);</span>
		}
<span class="fc" id="L2773">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="fc" id="L2780">		return getXMLElementTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;map&quot;.
	 */
	public static String getXMLElementTagName() {
<span class="fc" id="L2789">		return &quot;map&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>