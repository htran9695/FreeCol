<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Colony.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Colony.java</span></div><h1>Colony.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.Occupation;
import net.sf.freecol.common.model.Stance;

import static net.sf.freecol.common.util.CollectionUtils.*;

import net.sf.freecol.common.util.LogBuilder;
import net.sf.freecol.common.util.RandomChoice;

/**
 * Represents a colony. A colony contains {@link Building}s and
 * {@link ColonyTile}s. The latter represents the tiles around the
 * &lt;code&gt;Colony&lt;/code&gt; where working is possible.
 */
public class Colony extends Settlement implements Nameable, TradeLocation {

	/** The Constant logger. */
<span class="fc" id="L56">	private static final Logger logger = Logger.getLogger(Colony.class.getName());</span>

	/** The Constant REARRANGE_WORKERS. */
	public static final String REARRANGE_WORKERS = &quot;rearrangeWorkers&quot;;

	/** The Constant LIBERTY_PER_REBEL. */
	public static final int LIBERTY_PER_REBEL = 200;
	/** The number of turns of advanced warning of starvation. */
	public static final int FAMINE_TURNS = 3;

	/**
	 * The Enum ColonyChangeEvent.
	 */
<span class="nc" id="L69">	public static enum ColonyChangeEvent {</span>

		/** The population change. */
<span class="nc" id="L72">		POPULATION_CHANGE,</span>

		/** The production change. */
<span class="nc" id="L75">		PRODUCTION_CHANGE,</span>

		/** The bonus change. */
<span class="nc" id="L78">		BONUS_CHANGE,</span>

		/** The warehouse change. */
<span class="nc" id="L81">		WAREHOUSE_CHANGE,</span>

		/** The build queue change. */
<span class="nc" id="L84">		BUILD_QUEUE_CHANGE,</span>

		/** The unit type change. */
<span class="nc" id="L87">		UNIT_TYPE_CHANGE</span>
	}

	/** Reasons for not building a buildable. */
<span class="pc" id="L91">	public static enum NoBuildReason {</span>

		/** The none. */
<span class="fc" id="L94">		NONE,</span>

		/** The not building. */
<span class="fc" id="L97">		NOT_BUILDING,</span>

		/** The not buildable. */
<span class="fc" id="L100">		NOT_BUILDABLE,</span>

		/** The population too small. */
<span class="fc" id="L103">		POPULATION_TOO_SMALL,</span>

		/** The missing build ability. */
<span class="fc" id="L106">		MISSING_BUILD_ABILITY,</span>

		/** The missing ability. */
<span class="fc" id="L109">		MISSING_ABILITY,</span>

		/** The wrong upgrade. */
<span class="fc" id="L112">		WRONG_UPGRADE,</span>

		/** The coastal. */
<span class="fc" id="L115">		COASTAL,</span>

		/** The limit exceeded. */
<span class="fc" id="L118">		LIMIT_EXCEEDED</span>
	}

	/** A map of Buildings, indexed by the id of their basic type. */
<span class="fc" id="L122">	protected final java.util.Map&lt;String, Building&gt; buildingMap = new HashMap&lt;&gt;();</span>

	/** A list of the ColonyTiles. */
<span class="fc" id="L125">	protected final List&lt;ColonyTile&gt; colonyTiles = new ArrayList&lt;&gt;();</span>

	/** A map of ExportData, indexed by the ids of GoodsTypes. */
<span class="fc" id="L128">	protected final java.util.Map&lt;String, ExportData&gt; exportData = new HashMap&lt;&gt;();</span>

	/**
	 * The number of liberty points. Liberty points are an abstract game
	 * concept. They are generated by but are not identical to bells, and
	 * subject to further modification.
	 */
	protected int liberty;

	/** The SoL membership this turn. */
	protected int sonsOfLiberty;

	/** The SoL membership last turn. */
	protected int oldSonsOfLiberty;

	/** The number of tories this turn. */
	protected int tories;

	/** The number of tories last turn. */
	protected int oldTories;

	/** The current production bonus. */
	protected int productionBonus;

	/**
	 * The number of immigration points. Immigration points are an abstract game
	 * concept. They are generated by but are not identical to crosses.
	 */
	protected int immigration;

	/** The turn in which this colony was established. */
<span class="fc" id="L159">	protected Turn established = new Turn(0);</span>

	/** A list of items to be built. */
<span class="fc" id="L162">	protected final BuildQueue&lt;BuildableType&gt; buildQueue = new BuildQueue&lt;&gt;(this,</span>
			BuildQueue.CompletionAction.REMOVE_EXCEPT_LAST, Consumer.COLONY_PRIORITY);

	/** The colonists that may be born. */
<span class="fc" id="L166">	protected final BuildQueue&lt;UnitType&gt; populationQueue = new BuildQueue&lt;&gt;(this, BuildQueue.CompletionAction.SHUFFLE,</span>
			Consumer.POPULATION_PRIORITY);

	/** The display unit count. */
	// Will only be used on enemy colonies:
<span class="fc" id="L171">	protected int displayUnitCount = -1;</span>

	// Do not serialize below.

	/** Contains information about production and consumption. */
<span class="fc" id="L176">	private final ProductionCache productionCache = new ProductionCache(this);</span>

	/** The occupation tracing status. Do not serialize. */
<span class="fc" id="L179">	private boolean traceOccupation = false;</span>

	/**
	 * Constructor for ServerColony.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param owner
	 *            The &lt;code&gt;Player&lt;/code&gt; owning this &lt;code&gt;Colony&lt;/code&gt;.
	 * @param name
	 *            The name of the new &lt;code&gt;Colony&lt;/code&gt;.
	 * @param tile
	 *            The containing &lt;code&gt;Tile&lt;/code&gt;.
	 */
	protected Colony(Game game, Player owner, String name, Tile tile) {
<span class="fc" id="L194">		super(game, owner, name, tile);</span>
<span class="fc" id="L195">	}</span>

	/**
	 * Create a new &lt;code&gt;Colony&lt;/code&gt; with the given identifier. The object
	 * should later be initialized by calling either
	 * {@link #readFromXML(FreeColXMLReader)}.
	 *
	 * @param game
	 *            The enclosing &lt;code&gt;Game&lt;/code&gt;.
	 * @param id
	 *            The object identifier.
	 */
	public Colony(Game game, String id) {
<span class="fc" id="L208">		super(game, id);</span>
<span class="fc" id="L209">	}</span>

	// Primitive accessors.

	/**
	 * Gets a &lt;code&gt;List&lt;/code&gt; of every {@link Building} in this
	 * &lt;code&gt;Colony&lt;/code&gt;.
	 *
	 * @return A list of &lt;code&gt;Building&lt;/code&gt;s.
	 * @see Building
	 */
	public List&lt;Building&gt; getBuildings() {
<span class="fc" id="L221">		return new ArrayList&lt;&gt;(buildingMap.values());</span>
	}

	/**
	 * Get building of the specified general type (note: *not* necessarily the
	 * exact building type supplied, but the building present in the colony that
	 * is a descendant of the ultimate ancestor of the specified type).
	 *
	 * @param type
	 *            The type of the building to get.
	 * @return The &lt;code&gt;Building&lt;/code&gt; found.
	 */
	public Building getBuilding(BuildingType type) {
<span class="fc" id="L234">		return buildingMap.get(type.getFirstLevel().getId());</span>
	}

	/**
	 * Gets a &lt;code&gt;List&lt;/code&gt; of every {@link ColonyTile} in this
	 * &lt;code&gt;Colony&lt;/code&gt;.
	 *
	 * @return A list of &lt;code&gt;ColonyTile&lt;/code&gt;s.
	 * @see ColonyTile
	 */
	public List&lt;ColonyTile&gt; getColonyTiles() {
<span class="fc" id="L245">		return colonyTiles;</span>
	}

	/**
	 * Get the &lt;code&gt;ColonyTile&lt;/code&gt; matching the given &lt;code&gt;Tile&lt;/code&gt;.
	 *
	 * @param t
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return The corresponding &lt;code&gt;ColonyTile&lt;/code&gt;, or null if not found.
	 */
	public ColonyTile getColonyTile(Tile t) {
<span class="fc bfc" id="L256" title="All 2 branches covered.">		return find(colonyTiles, ct -&gt; ct.getWorkTile() == t);</span>
	}

	/**
	 * Get the export date for a goods type.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return The required &lt;code&gt;ExportData&lt;/code&gt;.
	 */
	public ExportData getExportData(final GoodsType goodsType) {
<span class="fc" id="L267">		ExportData result = exportData.get(goodsType.getId());</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">		if (result == null) {</span>
<span class="fc" id="L269">			result = new ExportData(goodsType);</span>
<span class="fc" id="L270">			setExportData(result);</span>
		}
<span class="fc" id="L272">		return result;</span>
	}

	/**
	 * Set some export data.
	 *
	 * @param newExportData
	 *            A new &lt;code&gt;ExportData&lt;/code&gt; value.
	 */
	public final void setExportData(final ExportData newExportData) {
<span class="fc" id="L282">		exportData.put(newExportData.getId(), newExportData);</span>
<span class="fc" id="L283">	}</span>

	/**
	 * Gets the liberty points.
	 *
	 * @return The current liberty.
	 */
	public int getLiberty() {
<span class="fc" id="L291">		return liberty;</span>
	}

	/**
	 * Gets the production bonus of the colony.
	 *
	 * @return The current production bonus of the colony.
	 */
	public int getProductionBonus() {
<span class="fc" id="L300">		return productionBonus;</span>
	}

	/**
	 * Gets the immigration points.
	 *
	 * @return The current immigration.
	 */
	public int getImmigration() {
<span class="fc" id="L309">		return immigration;</span>
	}

	/**
	 * Modify the immigration points by amount given.
	 *
	 * @param amount
	 *            An amount of immigration.
	 */
	public void modifyImmigration(int amount) {
<span class="fc" id="L319">		immigration += amount;</span>
<span class="fc" id="L320">	}</span>

	/**
	 * Get the turn this colony was established.
	 *
	 * @return The establishment &lt;code&gt;Turn&lt;/code&gt;.
	 */
	public Turn getEstablished() {
<span class="nc" id="L328">		return established;</span>
	}

	/**
	 * Set the turn of establishment.
	 *
	 * @param newEstablished
	 *            The new &lt;code&gt;Turn&lt;/code&gt; of establishment.
	 */
	public void setEstablished(final Turn newEstablished) {
<span class="nc" id="L338">		this.established = newEstablished;</span>
<span class="nc" id="L339">	}</span>

	/**
	 * Get the &lt;code&gt;BuildQueue&lt;/code&gt; contents.
	 *
	 * @return A list of &lt;code&gt;Buildable&lt;/code&gt;s.
	 */
	public List&lt;BuildableType&gt; getBuildQueue() {
<span class="fc" id="L347">		return buildQueue.getValues();</span>
	}

	/**
	 * Set the build queue value.
	 *
	 * @param newBuildQueue
	 *            A list of new values for the build queue.
	 */
	public void setBuildQueue(final List&lt;BuildableType&gt; newBuildQueue) {
<span class="fc" id="L357">		buildQueue.setValues(newBuildQueue);</span>
<span class="fc" id="L358">	}</span>

	// Occupation routines

	/**
	 * Gets the occupation tracing status.
	 *
	 * @return The occupation tracing status.
	 */
	public boolean getOccupationTrace() {
<span class="fc" id="L368">		return this.traceOccupation;</span>
	}

	/**
	 * Sets the occupation tracing status.
	 *
	 * @param trace
	 *            The new occupation tracing status.
	 * @return The original occupation tracing status.
	 */
	public boolean setOccupationTrace(boolean trace) {
<span class="nc" id="L379">		boolean ret = this.traceOccupation;</span>
<span class="nc" id="L380">		this.traceOccupation = trace;</span>
<span class="nc" id="L381">		return ret;</span>
	}

	/**
	 * Accumulate choices.
	 *
	 * @param workTypes
	 *            the work types
	 * @param tried
	 *            the tried
	 * @param result
	 *            the result
	 */
	private void accumulateChoices(Collection&lt;GoodsType&gt; workTypes, Collection&lt;GoodsType&gt; tried,
			List&lt;Collection&lt;GoodsType&gt;&gt; result) {
<span class="fc" id="L396">		workTypes.removeAll(tried);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">		if (!workTypes.isEmpty()) {</span>
<span class="fc" id="L398">			result.add(workTypes);</span>
<span class="fc" id="L399">			tried.addAll(workTypes);</span>
		}
<span class="fc" id="L401">	}</span>

	/**
	 * Accumulate choice.
	 *
	 * @param workType
	 *            the work type
	 * @param tried
	 *            the tried
	 * @param result
	 *            the result
	 */
	private void accumulateChoice(GoodsType workType, Collection&lt;GoodsType&gt; tried, List&lt;Collection&lt;GoodsType&gt;&gt; result) {
<span class="fc bfc" id="L414" title="All 2 branches covered.">		if (workType == null)</span>
<span class="fc" id="L415">			return;</span>
<span class="fc" id="L416">		accumulateChoices(workType.getEquivalentTypes(), tried, result);</span>
<span class="fc" id="L417">	}</span>

	/**
	 * Get a list of collections of goods types, in order of priority to try to
	 * produce in this colony by a given unit.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @param userMode
	 *            If a user requested this, favour the current work type, if not
	 *            favour goods that the unit requires.
	 * @return The list of collections of &lt;code&gt;GoodsType&lt;/code&gt;s.
	 */
	public List&lt;Collection&lt;GoodsType&gt;&gt; getWorkTypeChoices(Unit unit, boolean userMode) {
<span class="fc" id="L431">		final Specification spec = getSpecification();</span>
<span class="fc" id="L432">		List&lt;Collection&lt;GoodsType&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L433">		Set&lt;GoodsType&gt; tried = new HashSet&lt;&gt;();</span>

		// Find the food and non-food goods types required by the unit.
<span class="fc" id="L436">		Set&lt;GoodsType&gt; food = new HashSet&lt;&gt;();</span>
<span class="fc" id="L437">		Set&lt;GoodsType&gt; nonFood = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">		for (AbstractGoods ag : unit.getType().getConsumedGoods()) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">			if (productionCache.getNetProductionOf(ag.getType()) &lt; ag.getAmount()) {</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">				if (ag.getType().isFoodType()) {</span>
<span class="fc" id="L441">					food.addAll(ag.getType().getEquivalentTypes());</span>
				} else {
<span class="fc" id="L443">					nonFood.addAll(ag.getType().getEquivalentTypes());</span>
				}
			}
<span class="fc" id="L446">		}</span>

<span class="pc bpc" id="L448" title="1 of 2 branches missed.">		if (userMode) { // Favour current and expert types in user mode</span>
<span class="nc" id="L449">			accumulateChoice(unit.getWorkType(), tried, result);</span>
<span class="nc" id="L450">			accumulateChoice(unit.getType().getExpertProduction(), tried, result);</span>
<span class="nc" id="L451">			accumulateChoice(unit.getExperienceType(), tried, result);</span>
<span class="nc" id="L452">			accumulateChoices(food, tried, result);</span>
<span class="nc" id="L453">			accumulateChoices(nonFood, tried, result);</span>
		} else { // Otherwise favour the required goods types
<span class="fc" id="L455">			accumulateChoices(food, tried, result);</span>
<span class="fc" id="L456">			accumulateChoices(nonFood, tried, result);</span>
<span class="fc" id="L457">			accumulateChoice(unit.getWorkType(), tried, result);</span>
<span class="fc" id="L458">			accumulateChoice(unit.getType().getExpertProduction(), tried, result);</span>
<span class="fc" id="L459">			accumulateChoice(unit.getExperienceType(), tried, result);</span>
		}
<span class="fc" id="L461">		accumulateChoices(spec.getFoodGoodsTypeList(), tried, result);</span>
<span class="fc" id="L462">		accumulateChoices(spec.getNewWorldLuxuryGoodsTypeList(), tried, result);</span>
<span class="fc" id="L463">		accumulateChoices(spec.getGoodsTypeList(), tried, result);</span>
<span class="fc" id="L464">		return result;</span>
	}

	/**
	 * Gets the best occupation for a given unit to produce one of a given set
	 * of goods types.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find an &lt;code&gt;Occupation&lt;/code&gt; for.
	 * @param workTypes
	 *            A collection of &lt;code&gt;GoodsType&lt;/code&gt; to consider producing.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null if none
	 *         found.
	 */
	private Occupation getOccupationFor(Unit unit, Collection&lt;GoodsType&gt; workTypes, LogBuilder lb) {
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">		if (workTypes.isEmpty())</span>
<span class="nc" id="L482">			return null;</span>

<span class="fc" id="L484">		Occupation best = new Occupation(null, null, null);</span>
<span class="fc" id="L485">		int bestAmount = 0;</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">		for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="fc" id="L487">			bestAmount = best.improve(unit, wl, bestAmount, workTypes, lb);</span>
<span class="fc" id="L488">		}</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">		if (best.workLocation != null) {</span>
<span class="fc" id="L491">			lb.add(&quot;\n  =&gt; &quot;, best, &quot; = &quot;, bestAmount);</span>
		}
<span class="fc bfc" id="L493" title="All 2 branches covered.">		return (best.workLocation == null) ? null : best;</span>
	}

	/**
	 * Gets the best occupation for a given unit.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find an &lt;code&gt;Occupation&lt;/code&gt; for.
	 * @param userMode
	 *            If a user requested this, favour the current work type, if not
	 *            favour goods that the unit requires.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null if none
	 *         found.
	 */
	private Occupation getOccupationFor(Unit unit, boolean userMode, LogBuilder lb) {
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">		for (Collection&lt;GoodsType&gt; types : getWorkTypeChoices(unit, userMode)) {</span>
<span class="fc" id="L511">			lb.add(&quot;\n  &quot;);</span>
<span class="fc" id="L512">			FreeColObject.logFreeColObjects(types, lb);</span>
<span class="fc" id="L513">			Occupation occupation = getOccupationFor(unit, types, lb);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">			if (occupation != null)</span>
<span class="fc" id="L515">				return occupation;</span>
<span class="fc" id="L516">		}</span>
<span class="nc" id="L517">		lb.add(&quot;\n  =&gt; FAILED&quot;);</span>
<span class="nc" id="L518">		return null;</span>
	}

	/**
	 * Gets the best occupation for a given unit to produce one of a given set
	 * of goods types.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find an &lt;code&gt;Occupation&lt;/code&gt; for.
	 * @param workTypes
	 *            A collection of &lt;code&gt;GoodsType&lt;/code&gt; to consider producing.
	 * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null if none
	 *         found.
	 */
	private Occupation getOccupationFor(Unit unit, Collection&lt;GoodsType&gt; workTypes) {
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">		LogBuilder lb = new LogBuilder((getOccupationTrace()) ? 64 : 0);</span>
<span class="fc" id="L534">		lb.add(getName(), &quot;.getOccupationFor(&quot;, unit, &quot;, &quot;);</span>
<span class="fc" id="L535">		FreeColObject.logFreeColObjects(workTypes, lb);</span>
<span class="fc" id="L536">		lb.add(&quot;)&quot;);</span>

<span class="fc" id="L538">		Occupation occupation = getOccupationFor(unit, workTypes, lb);</span>
<span class="fc" id="L539">		lb.log(logger, Level.WARNING);</span>
<span class="fc" id="L540">		return occupation;</span>
	}

	/**
	 * Gets the best occupation for a given unit.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to find an &lt;code&gt;Occupation&lt;/code&gt; for.
	 * @param userMode
	 *            If a user requested this, favour the current work type, if not
	 *            favour goods that the unit requires.
	 * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null if none
	 *         found.
	 */
	private Occupation getOccupationFor(Unit unit, boolean userMode) {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">		LogBuilder lb = new LogBuilder((getOccupationTrace()) ? 64 : 0);</span>
<span class="fc" id="L556">		lb.add(getName(), &quot;.getOccupationFor(&quot;, unit, &quot;)&quot;);</span>

<span class="fc" id="L558">		Occupation occupation = getOccupationFor(unit, userMode, lb);</span>
<span class="fc" id="L559">		lb.log(logger, Level.WARNING);</span>
<span class="fc" id="L560">		return occupation;</span>
	}

	// WorkLocations, Buildings, ColonyTiles

	/**
	 * Get a stream of all the possible work locations for this colony.
	 *
	 * @return A suitable &lt;code&gt;Stream&lt;/code&gt;.
	 */
	private Stream&lt;WorkLocation&gt; getAllWorkLocationsStream() {
<span class="fc" id="L571">		return Stream.concat(colonyTiles.stream(), buildingMap.values().stream());</span>
	}

	/**
	 * Gets a list of every work location in this colony.
	 *
	 * @return The list of work locations.
	 */
	public List&lt;WorkLocation&gt; getAllWorkLocations() {
<span class="fc" id="L580">		return getAllWorkLocationsStream().collect(Collectors.toList());</span>
	}

	/**
	 * Gets a list of all freely available work locations in this colony.
	 *
	 * @return The list of available &lt;code&gt;WorkLocation&lt;/code&gt;s.
	 */
	public List&lt;WorkLocation&gt; getAvailableWorkLocations() {
<span class="fc" id="L589">		return getAllWorkLocationsStream().filter(WorkLocation::isAvailable).collect(Collectors.toList());</span>
	}

	/**
	 * Gets a list of all current work locations in this colony.
	 *
	 * @return The list of current &lt;code&gt;WorkLocation&lt;/code&gt;s.
	 */
	public List&lt;WorkLocation&gt; getCurrentWorkLocations() {
<span class="fc" id="L598">		return getAllWorkLocationsStream().filter(WorkLocation::isCurrent).collect(Collectors.toList());</span>
	}

	/**
	 * Add a Building to this Colony.
	 *
	 * Lower level routine, do not use directly in-game (use buildBuilding).
	 * Used for serialization and public for the test suite.
	 *
	 * -til: Could change the tile appearance if the building is stockade-type
	 *
	 * @param building
	 *            The &lt;code&gt;Building&lt;/code&gt; to build.
	 * @return True if the building was added.
	 */
	public boolean addBuilding(final Building building) {
<span class="pc bpc" id="L614" title="2 of 4 branches missed.">		if (building == null || building.getType() == null)</span>
<span class="nc" id="L615">			return false;</span>
<span class="fc" id="L616">		final BuildingType buildingType = building.getType().getFirstLevel();</span>
<span class="pc bpc" id="L617" title="2 of 4 branches missed.">		if (buildingType == null || buildingType.getId() == null)</span>
<span class="nc" id="L618">			return false;</span>
<span class="fc" id="L619">		buildingMap.put(buildingType.getId(), building);</span>
<span class="fc" id="L620">		addFeatures(building.getType());</span>
<span class="fc" id="L621">		return true;</span>
	}

	/**
	 * Remove a building from this Colony.
	 *
	 * -til: Could change the tile appearance if the building is stockade-type
	 *
	 * @param building
	 *            The &lt;code&gt;Building&lt;/code&gt; to remove.
	 * @return True if the building was removed.
	 */
	protected boolean removeBuilding(final Building building) {
<span class="fc" id="L634">		final BuildingType buildingType = building.getType().getFirstLevel();</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">		if (buildingMap.remove(buildingType.getId()) == null)</span>
<span class="nc" id="L636">			return false;</span>
<span class="fc" id="L637">		removeFeatures(building.getType());</span>
<span class="fc" id="L638">		return true;</span>
	}

	/**
	 * Gets a building for producing a given type of goods.
	 * 
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @return A &lt;code&gt;Building&lt;/code&gt; which produces the given type of goods,
	 *         or null if not found.
	 */
	public Building getBuildingForProducing(final GoodsType goodsType) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">		for (Building b : buildingMap.values()) {</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">			if (AbstractGoods.findByType(goodsType, b.getOutputs()) != null)</span>
<span class="nc" id="L652">				return b;</span>
<span class="nc" id="L653">		}</span>
<span class="nc" id="L654">		return null;</span>
	}

	/**
	 * Gets a work location with a given ability.
	 *
	 * @param ability
	 *            An ability key.
	 * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
	 *         &lt;code&gt;Ability&lt;/code&gt;, or null if not found.
	 */
	public WorkLocation getWorkLocationWithAbility(String ability) {
<span class="nc bnc" id="L666" title="All 2 branches missed.">		for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">			if (wl.hasAbility(ability))</span>
<span class="nc" id="L668">				return wl;</span>
<span class="nc" id="L669">		}</span>
<span class="nc" id="L670">		return null;</span>
	}

	/**
	 * Gets a work location of a specific class with a given ability.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param ability
	 *            An ability key.
	 * @param returnClass
	 *            The expected subclass.
	 * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
	 *         &lt;code&gt;Ability&lt;/code&gt;, or null if not found.
	 */
	public &lt;T extends WorkLocation&gt; T getWorkLocationWithAbility(String ability, Class&lt;T&gt; returnClass) {
<span class="nc" id="L686">		WorkLocation wl = getWorkLocationWithAbility(ability);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">		if (wl != null)</span>
			try {
<span class="nc" id="L689">				return returnClass.cast(wl);</span>
<span class="nc" id="L690">			} catch (ClassCastException cce) {</span>
			}
		;
<span class="nc" id="L693">		return null;</span>
	}

	/**
	 * Gets a work location with a given modifier.
	 *
	 * @param modifier
	 *            A modifier key.
	 * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
	 *         &lt;code&gt;Modifier&lt;/code&gt;, or null if not found.
	 */
	public WorkLocation getWorkLocationWithModifier(String modifier) {
<span class="fc bfc" id="L705" title="All 2 branches covered.">		for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">			if (wl.hasModifier(modifier))</span>
<span class="fc" id="L707">				return wl;</span>
<span class="fc" id="L708">		}</span>
<span class="fc" id="L709">		return null;</span>
	}

	/**
	 * Gets a work location of a specific class with a given modifier.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param modifier
	 *            A modifier key.
	 * @param returnClass
	 *            The expected subclass.
	 * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
	 *         &lt;code&gt;Modifier&lt;/code&gt;, or null if not found.
	 */
	public &lt;T extends WorkLocation&gt; T getWorkLocationWithModifier(String modifier, Class&lt;T&gt; returnClass) {
<span class="fc" id="L725">		WorkLocation wl = getWorkLocationWithModifier(modifier);</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">		if (wl != null)</span>
			try {
<span class="fc" id="L728">				return returnClass.cast(wl);</span>
<span class="nc" id="L729">			} catch (ClassCastException cce) {</span>
			}
<span class="fc" id="L731">		return null;</span>
	}

	/**
	 * Collect the work locations for consuming a given type of goods.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to consume.
	 * @return A list of &lt;code&gt;WorkLocation&lt;/code&gt;s which consume the given type
	 *         of goods.
	 */
	public List&lt;WorkLocation&gt; getWorkLocationsForConsuming(GoodsType goodsType) {
<span class="nc bnc" id="L743" title="All 2 branches missed.">		return getCurrentWorkLocations().stream().filter(wl -&gt; any(wl.getInputs(), ag -&gt; ag.getType() == goodsType))</span>
<span class="nc" id="L744">				.collect(Collectors.toList());</span>
	}

	/**
	 * Collect the work locations for producing a given type of goods.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @return A list of &lt;code&gt;WorkLocation&lt;/code&gt;s which produce the given type
	 *         of goods.
	 */
	public List&lt;WorkLocation&gt; getWorkLocationsForProducing(GoodsType goodsType) {
<span class="fc bfc" id="L756" title="All 2 branches covered.">		return getCurrentWorkLocations().stream().filter(wl -&gt; any(wl.getOutputs(), ag -&gt; ag.getType() == goodsType))</span>
<span class="fc" id="L757">				.collect(Collectors.toList());</span>
	}

	/**
	 * Find a work location for producing a given type of goods. Beware that
	 * this may not be the optimal location for the production, for which
	 * {@link #getWorkLocationFor} is better.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @return A &lt;code&gt;WorkLocation&lt;/code&gt;s which produces the given type of
	 *         goods, or null if not found.
	 */
	public WorkLocation getWorkLocationForProducing(GoodsType goodsType) {
<span class="fc" id="L771">		List&lt;WorkLocation&gt; wls = getWorkLocationsForProducing(goodsType);</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">		return (wls.isEmpty()) ? null : wls.get(0);</span>
	}

	/**
	 * Gets the work location best suited for the given unit to produce a type
	 * of goods.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to get the building for.
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @return The best &lt;code&gt;WorkLocation&lt;/code&gt; found.
	 */
	public WorkLocation getWorkLocationFor(Unit unit, GoodsType goodsType) {
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">		if (goodsType == null)</span>
<span class="nc" id="L787">			return getWorkLocationFor(unit);</span>
<span class="fc" id="L788">		Occupation occupation = getOccupationFor(unit, goodsType.getEquivalentTypes());</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">		return (occupation == null) ? null : occupation.workLocation;</span>
	}

	/**
	 * Gets the work location best suited for the given unit.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check for.
	 * @return The best &lt;code&gt;WorkLocation&lt;/code&gt; found.
	 */
	public WorkLocation getWorkLocationFor(Unit unit) {
<span class="fc" id="L800">		Occupation occupation = getOccupationFor(unit, false);</span>
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">		return (occupation == null) ? null : occupation.workLocation;</span>
	}

	/**
	 * Is a tile actually in use by this colony?.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to test.
	 * @return True if this tile is actively in use by this colony.
	 */
	public boolean isTileInUse(Tile tile) {
<span class="fc" id="L812">		ColonyTile colonyTile = getColonyTile(tile);</span>
<span class="pc bpc" id="L813" title="1 of 4 branches missed.">		return colonyTile != null &amp;&amp; !colonyTile.isEmpty();</span>
	}

	/**
	 * Get the warehouse-type building in this colony.
	 *
	 * @return The warehouse &lt;code&gt;Building&lt;/code&gt;.
	 */
	public Building getWarehouse() {
<span class="fc" id="L822">		return getWorkLocationWithModifier(Modifier.WAREHOUSE_STORAGE, Building.class);</span>
	}

	/**
	 * Does this colony have a stockade?.
	 *
	 * @return True if the colony has a stockade.
	 */
	public boolean hasStockade() {
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">		return getStockade() != null;</span>
	}

	/**
	 * Gets the stockade building in this colony.
	 *
	 * @return The stockade &lt;code&gt;Building&lt;/code&gt;.
	 */
	public Building getStockade() {
<span class="fc" id="L840">		return getWorkLocationWithModifier(Modifier.DEFENCE, Building.class);</span>
	}

	/**
	 * Gets the stockade key, as should be visible to the owner or a player that
	 * can see this colony.
	 *
	 * @return The stockade key, or null if no stockade-building is present.
	 */
	public String getStockadeKey() {
<span class="nc" id="L850">		Building stockade = getStockade();</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">		return (stockade == null) ? null : stockade.getType().getSuffix();</span>
	}

	/**
	 * Get a weighted list of natural disasters than can strike this colony.
	 * This list comprises all natural disasters that can strike the colony's
	 * tiles.
	 *
	 * @return A weighted list of &lt;code&gt;Disaster&lt;/code&gt;s.
	 */
	public List&lt;RandomChoice&lt;Disaster&gt;&gt; getDisasters() {
<span class="nc" id="L862">		List&lt;RandomChoice&lt;Disaster&gt;&gt; disasters = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">		for (ColonyTile tile : colonyTiles) {</span>
<span class="nc" id="L864">			disasters.addAll(tile.getWorkTile().getDisasters());</span>
<span class="nc" id="L865">		}</span>
<span class="nc" id="L866">		return disasters;</span>
	}

	// What are we building? What can we build?

	/**
	 * Is a building type able to be automatically built at no cost. True when
	 * the player has a modifier that collapses the cost to zero.
	 *
	 * @param buildingType
	 *            a &lt;code&gt;BuildingType&lt;/code&gt; value
	 * @return True if the building is available at zero cost.
	 */
	public boolean isAutomaticBuild(BuildingType buildingType) {
<span class="fc" id="L880">		float value = owner.applyModifiers(100f, getGame().getTurn(), Modifier.BUILDING_PRICE_BONUS, buildingType);</span>
<span class="fc bfc" id="L881" title="All 4 branches covered.">		return value == 0f &amp;&amp; canBuild(buildingType);</span>
	}

	/**
	 * Gets a list of every unit type this colony may build.
	 *
	 * @return A list of buildable &lt;code&gt;UnitType&lt;/code&gt;s.
	 */
	public List&lt;UnitType&gt; getBuildableUnits() {
<span class="nc bnc" id="L890" title="All 4 branches missed.">		return getSpecification().getUnitTypeList().stream().filter(ut -&gt; ut.needsGoodsToBuild() &amp;&amp; canBuild(ut))</span>
<span class="nc" id="L891">				.collect(Collectors.toList());</span>
	}

	/**
	 * Returns how many turns it would take to build the given
	 * &lt;code&gt;BuildableType&lt;/code&gt;.
	 *
	 * @param buildable
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to build.
	 * @return The number of turns to build the buildable, negative if some
	 *         goods are not being built, UNDEFINED if none is.
	 */
	public int getTurnsToComplete(BuildableType buildable) {
<span class="nc" id="L904">		return getTurnsToComplete(buildable, null);</span>
	}

	/**
	 * Returns how many turns it would take to build the given
	 * &lt;code&gt;BuildableType&lt;/code&gt;.
	 *
	 * @param buildable
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to build.
	 * @param needed
	 *            The &lt;code&gt;AbstractGoods&lt;/code&gt; needed to continue the build.
	 * @return The number of turns to build the buildable (which may be zero,
	 *         UNDEFINED if no useful work is being done, negative if some
	 *         requirement is or will block completion (value is the negation of
	 *         (turns-to-blockage + 1), and if the needed argument is supplied
	 *         it is set to the goods deficit).
	 */
	public int getTurnsToComplete(BuildableType buildable, AbstractGoods needed) {
<span class="fc" id="L922">		final List&lt;AbstractGoods&gt; required = buildable.getRequiredGoods();</span>
<span class="fc" id="L923">		int turns = 0, satisfied = 0, failing = 0, underway = 0;</span>

<span class="fc" id="L925">		ProductionInfo info = productionCache.getProductionInfo(buildQueue);</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">		for (AbstractGoods ag : required) {</span>
<span class="fc" id="L927">			final GoodsType type = ag.getType();</span>
<span class="fc" id="L928">			final int amountNeeded = ag.getAmount();</span>
<span class="fc" id="L929">			final int amountAvailable = getGoodsCount(type);</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">			if (amountAvailable &gt;= amountNeeded) {</span>
<span class="fc" id="L931">				satisfied++;</span>
<span class="fc" id="L932">				continue;</span>
			}
<span class="fc" id="L934">			int production = productionCache.getNetProductionOf(type);</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">			if (info != null) {</span>
<span class="fc" id="L936">				AbstractGoods consumption = AbstractGoods.findByType(type, info.getConsumption());</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">				if (consumption != null) {</span>
					// add the amount the build queue itself will consume
<span class="nc" id="L939">					production += consumption.getAmount();</span>
				}
			}
<span class="fc bfc" id="L942" title="All 2 branches covered.">			if (production &lt;= 0) {</span>
<span class="fc" id="L943">				failing++;</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">				if (needed != null) {</span>
<span class="fc" id="L945">					needed.setType(type);</span>
<span class="fc" id="L946">					needed.setAmount(amountNeeded - amountAvailable);</span>
				}
				continue;
			}

<span class="fc" id="L951">			underway++;</span>
<span class="fc" id="L952">			int amountRemaining = amountNeeded - amountAvailable;</span>
<span class="fc" id="L953">			int eta = amountRemaining / production;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">			if (amountRemaining % production != 0)</span>
<span class="fc" id="L955">				eta++;</span>
<span class="fc" id="L956">			turns = Math.max(turns, eta);</span>
<span class="fc" id="L957">		}</span>

<span class="fc bfc" id="L959" title="All 2 branches covered.">		return (satisfied + underway == required.size()) ? turns // Will finish</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">				: (failing == required.size()) ? UNDEFINED // Not even trying</span>
						: -(turns + 1); // Blocked by something
	}

	/**
	 * Returns &lt;code&gt;true&lt;/code&gt; if this Colony can breed the given type of
	 * Goods. Only animals (such as horses) are expected to be breedable.
	 *
	 * @param goodsType
	 *            a &lt;code&gt;GoodsType&lt;/code&gt; value
	 * @return a &lt;code&gt;boolean&lt;/code&gt; value
	 */
	public boolean canBreed(GoodsType goodsType) {
<span class="nc" id="L973">		int breedingNumber = goodsType.getBreedingNumber();</span>
<span class="nc bnc" id="L974" title="All 4 branches missed.">		return (breedingNumber &lt; GoodsType.INFINITY &amp;&amp; breedingNumber &lt;= getGoodsCount(goodsType));</span>
	}

	/**
	 * Gets the type of building currently being built.
	 *
	 * @return The type of building currently being built.
	 */
	public BuildableType getCurrentlyBuilding() {
<span class="fc" id="L983">		return buildQueue.getCurrentlyBuilding();</span>
	}

	/**
	 * Sets the current type of buildable to be built and if it is a building
	 * insist that there is only one in the queue.
	 *
	 * @param buildable
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to build.
	 */
	public void setCurrentlyBuilding(BuildableType buildable) {
<span class="fc" id="L994">		buildQueue.setCurrentlyBuilding(buildable);</span>
<span class="fc" id="L995">	}</span>

	/**
	 * Can build.
	 *
	 * @return true, if successful
	 */
	public boolean canBuild() {
<span class="nc" id="L1003">		return canBuild(getCurrentlyBuilding());</span>
	}

	/**
	 * Returns true if this Colony can build the given BuildableType.
	 *
	 * @param buildableType
	 *            a &lt;code&gt;BuildableType&lt;/code&gt; value
	 * @return a &lt;code&gt;boolean&lt;/code&gt; value
	 */
	public boolean canBuild(BuildableType buildableType) {
<span class="fc bfc" id="L1014" title="All 2 branches covered.">		return getNoBuildReason(buildableType, null) == NoBuildReason.NONE;</span>
	}

	/**
	 * Return the reason why the give &lt;code&gt;BuildableType&lt;/code&gt; can not be
	 * built.
	 *
	 * @param buildableType
	 *            A &lt;code&gt;BuildableType&lt;/code&gt; to build.
	 * @param assumeBuilt
	 *            An optional list of other buildable types which can be assumed
	 *            to be built, for the benefit of build queue checks.
	 * @return A &lt;code&gt;NoBuildReason&lt;/code&gt; value decribing the failure,
	 *         including &lt;code&gt;NoBuildReason.NONE&lt;/code&gt; on success.
	 */
	public NoBuildReason getNoBuildReason(BuildableType buildableType, List&lt;BuildableType&gt; assumeBuilt) {
<span class="fc bfc" id="L1030" title="All 2 branches covered.">		if (buildableType == null) {</span>
<span class="fc" id="L1031">			return NoBuildReason.NOT_BUILDING;</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">		} else if (!buildableType.needsGoodsToBuild()) {</span>
<span class="fc" id="L1033">			return NoBuildReason.NOT_BUILDABLE;</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">		} else if (buildableType.getRequiredPopulation() &gt; getUnitCount()) {</span>
<span class="fc" id="L1035">			return NoBuildReason.POPULATION_TOO_SMALL;</span>
<span class="pc bpc" id="L1036" title="3 of 4 branches missed.">		} else if (buildableType.hasAbility(Ability.COASTAL_ONLY) &amp;&amp; !getTile().isCoastland()) {</span>
<span class="nc" id="L1037">			return NoBuildReason.COASTAL;</span>
		} else {
<span class="fc bfc" id="L1039" title="All 4 branches covered.">			if (!all(buildableType.getRequiredAbilities().entrySet(), e -&gt; e.getValue() == hasAbility(e.getKey()))) {</span>
<span class="fc" id="L1040">				return NoBuildReason.MISSING_ABILITY;</span>
			}
<span class="fc bfc" id="L1042" title="All 2 branches covered.">			if (!all(buildableType.getLimits(), l -&gt; l.evaluate(this))) {</span>
<span class="fc" id="L1043">				return NoBuildReason.LIMIT_EXCEEDED;</span>
			}
		}
<span class="fc bfc" id="L1046" title="All 2 branches covered.">		if (assumeBuilt == null) {</span>
<span class="fc" id="L1047">			assumeBuilt = Collections.&lt;BuildableType&gt;emptyList();</span>
		}
<span class="fc bfc" id="L1049" title="All 2 branches covered.">		if (buildableType instanceof BuildingType) {</span>
<span class="fc" id="L1050">			BuildingType newBuildingType = (BuildingType) buildableType;</span>
<span class="fc" id="L1051">			Building colonyBuilding = this.getBuilding(newBuildingType);</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">			if (colonyBuilding == null) {</span>
				// the colony has no similar building yet
<span class="fc" id="L1054">				BuildingType from = newBuildingType.getUpgradesFrom();</span>
<span class="pc bpc" id="L1055" title="1 of 4 branches missed.">				if (from != null &amp;&amp; !assumeBuilt.contains(from)) {</span>
					// we are trying to build an advanced factory, we
					// should build lower level shop first
<span class="fc" id="L1058">					return NoBuildReason.WRONG_UPGRADE;</span>
				}
<span class="fc" id="L1060">			} else {</span>
				// a building of the same family already exists
<span class="fc" id="L1062">				BuildingType from = colonyBuilding.getType().getUpgradesTo();</span>
<span class="pc bpc" id="L1063" title="1 of 4 branches missed.">				if (from != newBuildingType &amp;&amp; !assumeBuilt.contains(from)) {</span>
					// the existing building's next upgrade is not the
					// new one we want to build
<span class="fc" id="L1066">					return NoBuildReason.WRONG_UPGRADE;</span>
				}
			}
<span class="pc bpc" id="L1069" title="1 of 6 branches missed.">		} else if (buildableType instanceof UnitType &amp;&amp;(!buildableType.hasAbility(Ability.PERSON)) &amp;&amp; (!hasAbility(Ability.BUILD, buildableType)</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">				&amp;&amp; none(assumeBuilt, bt -&gt; bt.hasAbility(Ability.BUILD, buildableType)))) {</span>
			// Non-person units need a BUILD ability, present or assumed.
<span class="fc" id="L1072">				return NoBuildReason.MISSING_BUILD_ABILITY;</span>
		}
<span class="fc" id="L1074">		return NoBuildReason.NONE;</span>
	}

	/**
	 * Returns the price for the remaining hammers and tools for the
	 * {@link Building} that is currently being built.
	 *
	 * @return The price.
	 * @see net.sf.freecol.client.control.InGameController#payForBuilding
	 */
	public int getPriceForBuilding() {
<span class="nc" id="L1085">		return getPriceForBuilding(getCurrentlyBuilding());</span>
	}

	/**
	 * Gets the price for the remaining resources to build a given buildable.
	 *
	 * @param type
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to build.
	 * @return The price.
	 * @see net.sf.freecol.client.control.InGameController#payForBuilding
	 */
	public int getPriceForBuilding(BuildableType type) {
<span class="nc" id="L1097">		return priceGoodsForBuilding(getRequiredGoods(type));</span>
	}

	/**
	 * Gets a price for a map of resources to build a given buildable.
	 *
	 * @param required
	 *            A list of required &lt;code&gt;AbstractGoods&lt;/code&gt;.
	 * @return The price.
	 * @see net.sf.freecol.client.control.InGameController#payForBuilding
	 */
	public int priceGoodsForBuilding(List&lt;AbstractGoods&gt; required) {
<span class="nc" id="L1109">		final Market market = getOwner().getMarket();</span>
		// FIXME: magic number!
<span class="nc" id="L1111">		return required.stream()</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">				.mapToInt(ag -&gt; (ag.getType().isStorable())</span>
<span class="nc" id="L1113">						? (market.getBidPrice(ag.getType(), ag.getAmount()) * 110) / 100</span>
<span class="nc" id="L1114">						: ag.getType().getPrice() * ag.getAmount())</span>
<span class="nc" id="L1115">				.sum();</span>
	}

	/**
	 * Gets a map of the types of goods and amount thereof required to finish a
	 * buildable in this colony.
	 *
	 * @param type
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to build.
	 * @return The map to completion.
	 */
	public List&lt;AbstractGoods&gt; getRequiredGoods(BuildableType type) {
<span class="nc" id="L1127">		List&lt;AbstractGoods&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">		for (AbstractGoods goods : type.getRequiredGoods()) {</span>
<span class="nc" id="L1129">			GoodsType goodsType = goods.getType();</span>
<span class="nc" id="L1130">			int remaining = goods.getAmount() - getGoodsCount(goodsType);</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">			if (remaining &gt; 0) {</span>
<span class="nc" id="L1132">				result.add(new AbstractGoods(goodsType, remaining));</span>
			}
<span class="nc" id="L1134">		}</span>
<span class="nc" id="L1135">		return result;</span>
	}

	/**
	 * Gets all the goods required to complete a build. The list includes the
	 * prerequisite raw materials as well as the direct requirements (i.e.
	 * hammers, tools). If enough of a required goods is present in the colony,
	 * then that type is not returned. Take care to order types with raw
	 * materials first so that we can prioritize gathering what is required
	 * before manufacturing.
	 *
	 * Public for the benefit of AI planning and the test suite.
	 *
	 * @param buildable
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; to consider.
	 * @return A list of required abstract goods.
	 */
	public List&lt;AbstractGoods&gt; getFullRequiredGoods(BuildableType buildable) {
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">		if (buildable == null)</span>
<span class="nc" id="L1154">			return Collections.&lt;AbstractGoods&gt;emptyList();</span>

<span class="fc" id="L1156">		List&lt;AbstractGoods&gt; required = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">		for (AbstractGoods ag : buildable.getRequiredGoods()) {</span>
<span class="fc" id="L1158">			int amount = ag.getAmount();</span>
<span class="fc" id="L1159">			GoodsType type = ag.getType();</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">			while (type != null) {</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">				if (amount &lt;= this.getGoodsCount(type))</span>
<span class="fc" id="L1162">					break; // Shortcut</span>
<span class="fc" id="L1163">				required.add(0, new AbstractGoods(type, amount - this.getGoodsCount(type)));</span>
<span class="fc" id="L1164">				type = type.getInputType();</span>
			}
<span class="fc" id="L1166">		}</span>
<span class="fc" id="L1167">		return required;</span>
	}

	/**
	 * Check if the owner can buy the remaining hammers and tools for the
	 * {@link Building} that is currently being built.
	 *
	 * @return true, if successful
	 * @see #getPriceForBuilding
	 * @exception IllegalStateException
	 *                If the owner of this &lt;code&gt;Colony&lt;/code&gt; has an
	 *                insufficient amount of gold.
	 */
	public boolean canPayToFinishBuilding() {
<span class="nc" id="L1181">		return canPayToFinishBuilding(getCurrentlyBuilding());</span>
	}

	/**
	 * Check if the owner can buy the remaining hammers and tools for the
	 * {@link Building} given.
	 *
	 * @param buildableType
	 *            a &lt;code&gt;BuildableType&lt;/code&gt; value
	 * @return a &lt;code&gt;boolean&lt;/code&gt; value
	 * @see #getPriceForBuilding
	 * @exception IllegalStateException
	 *                If the owner of this &lt;code&gt;Colony&lt;/code&gt; has an
	 *                insufficient amount of gold.
	 */
	public boolean canPayToFinishBuilding(BuildableType buildableType) {
<span class="nc bnc" id="L1197" title="All 4 branches missed.">		return buildableType != null &amp;&amp; getOwner().checkGold(getPriceForBuilding(buildableType));</span>
	}

	// Liberty and the consequences

	/**
	 * Adds to the liberty points by increasing the liberty goods present. Used
	 * only by DebugMenu.
	 *
	 * @param amount
	 *            The number of liberty to add.
	 */
	public void addLiberty(int amount) {
<span class="fc" id="L1210">		List&lt;GoodsType&gt; libertyTypeList = getSpecification().getLibertyGoodsTypeList();</span>
<span class="fc" id="L1211">		final int uc = getUnitCount();</span>
<span class="pc bpc" id="L1212" title="2 of 6 branches missed.">		if (calculateRebels(uc, sonsOfLiberty) &lt;= uc + 1 &amp;&amp; amount &gt; 0 &amp;&amp; !libertyTypeList.isEmpty()) {</span>
<span class="fc" id="L1213">			addGoods(libertyTypeList.get(0), amount);</span>
		}
<span class="fc" id="L1215">		updateSoL();</span>
<span class="fc" id="L1216">		updateProductionBonus();</span>
<span class="fc" id="L1217">	}</span>

	/**
	 * Modify the liberty points by amount given.
	 *
	 * @param amount
	 *            An amount of liberty.
	 */
	public void modifyLiberty(int amount) {
		// Produced liberty always applies to the player (for FFs etc)
<span class="fc" id="L1227">		getOwner().modifyLiberty(amount);</span>

<span class="fc" id="L1229">		liberty += amount;</span>
		// Liberty can not meaningfully go negative.
<span class="fc" id="L1231">		liberty = Math.max(0, liberty);</span>

<span class="fc" id="L1233">		updateSoL();</span>
<span class="fc" id="L1234">		updateProductionBonus();</span>

		// If the bell accumulation cap option is set, and the colony
		// has reached 100%, liberty can not rise higher.
<span class="fc" id="L1238">		boolean capped = getSpecification().getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);</span>
<span class="pc bpc" id="L1239" title="3 of 4 branches missed.">		if (capped &amp;&amp; sonsOfLiberty &gt;= 100) {</span>
<span class="nc" id="L1240">			liberty = LIBERTY_PER_REBEL * getUnitCount();</span>
		}
<span class="fc" id="L1242">	}</span>

	/**
	 * Calculates the current SoL membership of the colony based on the liberty
	 * value and colonists.
	 */
	public void updateSoL() {
<span class="fc" id="L1249">		int uc = getUnitCount();</span>
<span class="fc" id="L1250">		oldSonsOfLiberty = sonsOfLiberty;</span>
<span class="fc" id="L1251">		oldTories = tories;</span>
<span class="fc" id="L1252">		sonsOfLiberty = calculateSoLPercentage(uc, getLiberty());</span>
<span class="fc" id="L1253">		tories = uc - calculateRebels(uc, sonsOfLiberty);</span>
<span class="fc" id="L1254">	}</span>

	/**
	 * Calculate the SoL membership percentage of the colony based on the number
	 * of colonists and liberty.
	 *
	 * @param uc
	 *            The proposed number of units in the colony.
	 * @param liberty
	 *            The amount of liberty.
	 * @return The percentage of SoLs, negative if not calculable.
	 */
	private int calculateSoLPercentage(int uc, int liberty) {
<span class="fc bfc" id="L1267" title="All 2 branches covered.">		if (uc &lt;= 0)</span>
<span class="fc" id="L1268">			return -1;</span>

<span class="fc" id="L1270">		float membership = (liberty * 100.0f) / (LIBERTY_PER_REBEL * uc);</span>
<span class="fc" id="L1271">		membership = applyModifiers(membership, getGame().getTurn(), getOwner().getModifiers(Modifier.SOL));</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">		if (membership &lt; 0.0f) {</span>
<span class="nc" id="L1273">			membership = 0.0f;</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">		} else if (membership &gt; 100.0f) {</span>
<span class="fc" id="L1275">			membership = 100.0f;</span>
		}
<span class="fc" id="L1277">		return (int) membership;</span>
	}

	/**
	 * Calculate the SoL membership percentage of a colony.
	 *
	 * @return The percentage of SoLs, negative if not calculable.
	 */
	public int getSoLPercentage() {
<span class="nc" id="L1286">		return calculateSoLPercentage(getUnitCount(), getLiberty());</span>
	}

	/**
	 * Calculate the number of rebels given a SoL percentage and unit count.
	 *
	 * @param uc
	 *            The number of units in the colony.
	 * @param solPercent
	 *            The percentage of SoLs.
	 * @return the int
	 */
	public static int calculateRebels(int uc, int solPercent) {
<span class="fc" id="L1299">		return (int) Math.floor(0.01 * solPercent * uc);</span>
	}

	/**
	 * Gets the Tory membership percentage of the colony.
	 *
	 * @return The current Tory membership of the colony.
	 */
	public int getTory() {
<span class="fc" id="L1308">		return 100 - getSoL();</span>
	}

	/**
	 * Update the colony's production bonus.
	 *
	 * @return True if the bonus changed.
	 */
	protected boolean updateProductionBonus() {
<span class="fc" id="L1317">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1318">		final int veryBadGovernment = spec.getInteger(&quot;model.option.veryBadGovernmentLimit&quot;);</span>
<span class="fc" id="L1319">		final int badGovernment = spec.getInteger(&quot;model.option.badGovernmentLimit&quot;);</span>
<span class="fc" id="L1320">		final int veryGoodGovernment = spec.getInteger(&quot;model.option.veryGoodGovernmentLimit&quot;);</span>
<span class="fc" id="L1321">		final int goodGovernment = spec.getInteger(&quot;model.option.goodGovernmentLimit&quot;);</span>
<span class="pc bpc" id="L1322" title="1 of 8 branches missed.">		int newBonus = (sonsOfLiberty &gt;= veryGoodGovernment) ? 2</span>
				: (sonsOfLiberty &gt;= goodGovernment) ? 1
						: (tories &gt; veryBadGovernment) ? -2 : (tories &gt; badGovernment) ? -1 : 0;
<span class="fc bfc" id="L1325" title="All 2 branches covered.">		if (productionBonus != newBonus) {</span>
<span class="fc" id="L1326">			invalidateCache();</span>
<span class="fc" id="L1327">			productionBonus = newBonus;</span>
<span class="fc" id="L1328">			return true;</span>
		}
<span class="fc" id="L1330">		return false;</span>
	}

	/**
	 * Gets the number of units that would be good to add/remove from this
	 * colony. That is the number of extra units that can be added without
	 * damaging the production bonus, or the number of units to remove to
	 * improve it.
	 *
	 * @return The number of units to add to the colony, or if negative the
	 *         negation of the number of units to remove.
	 */
	public int getPreferredSizeChange() {
<span class="nc" id="L1343">		int i, limit, pop = getUnitCount();</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">		if (productionBonus &lt; 0) {</span>
<span class="nc" id="L1345">			limit = pop;</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">			for (i = 1; i &lt; limit; i++) {</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">				if (governmentChange(pop - i) == 1)</span>
<span class="nc" id="L1348">					break;</span>
			}
<span class="nc" id="L1350">			return -i;</span>
		} else {
<span class="nc" id="L1352">			final Specification spec = getSpecification();</span>
<span class="nc" id="L1353">			limit = spec.getInteger(&quot;model.option.badGovernmentLimit&quot;);</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">			for (i = 1; i &lt; limit; i++) {</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">				if (governmentChange(pop + i) == -1)</span>
<span class="nc" id="L1356">					break;</span>
			}
<span class="nc" id="L1358">			return i - 1;</span>
		}
	}

	// Unit manipulation and population

	/**
	 * Special routine to handle non-specific add of unit to colony.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to add.
	 * @return True if the add succeeds.
	 */
	public boolean joinColony(Unit unit) {
<span class="fc" id="L1372">		Occupation occupation = getOccupationFor(unit, false);</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">		if (occupation == null) {</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">			if (!traceOccupation) {</span>
<span class="nc" id="L1375">				LogBuilder lb = new LogBuilder(64);</span>
<span class="nc" id="L1376">				getOccupationFor(unit, false, lb);</span>
<span class="nc" id="L1377">				lb.log(logger, Level.WARNING);</span>
			}
<span class="nc" id="L1379">			return false;</span>
		}
<span class="fc" id="L1381">		return occupation.install(unit);</span>
	}

	/**
	 * Can this colony reduce its population voluntarily?
	 *
	 * This is generally the case, but can be prevented by buildings such as the
	 * stockade in classic mode.
	 *
	 * @return True if the population can be reduced.
	 */
	public boolean canReducePopulation() {
<span class="nc bnc" id="L1393" title="All 2 branches missed.">		return getUnitCount() &gt; applyModifiers(0f, getGame().getTurn(), Modifier.MINIMUM_COLONY_SIZE);</span>
	}

	/**
	 * Gets the message to display if the colony can not reduce its population.
	 *
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing why a colony can not
	 *         reduce its population, or null if it can.
	 */
	public StringTemplate getReducePopulationMessage() {
<span class="nc bnc" id="L1403" title="All 2 branches missed.">		if (canReducePopulation())</span>
<span class="nc" id="L1404">			return null;</span>
<span class="nc" id="L1405">		Set&lt;Modifier&gt; modifierSet = getModifiers(Modifier.MINIMUM_COLONY_SIZE);</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">		if (modifierSet.isEmpty())</span>
<span class="nc" id="L1407">			return null;</span>
<span class="nc" id="L1408">		Modifier modifier = modifierSet.iterator().next();</span>
<span class="nc" id="L1409">		FreeColObject source = modifier.getSource();</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">		if (source instanceof BuildingType) {</span>
			// If the modifier source is a building type, use the
			// building in the colony, which may be of a different
			// level to the modifier source.
			// This prevents the stockade modifier from matching a
			// colony-fort, and thus the message attributing the
			// failure to reduce population to a non-existing
			// stockade, BR#3522055.
<span class="nc" id="L1418">			source = getBuilding((BuildingType) source).getType();</span>
		}
<span class="nc" id="L1420">		return StringTemplate.template(&quot;model.colony.minimumColonySize&quot;).addName(&quot;%object%&quot;, source);</span>
	}

	/**
	 * Gets the message to display if a colony can not build something.
	 *
	 * @param buildable
	 *            The &lt;code&gt;BuildableType&lt;/code&gt; that can not be built.
	 * @return A &lt;code&gt;ModelMessage&lt;/code&gt; describing the build failure.
	 */
	public ModelMessage getUnbuildableMessage(BuildableType buildable) {
<span class="nc" id="L1431">		return new ModelMessage(ModelMessage.MessageType.WARNING, &quot;model.colony.unbuildable&quot;, this, buildable)</span>
<span class="nc" id="L1432">				.addName(&quot;%colony%&quot;, getName()).addNamed(&quot;%object%&quot;, buildable);</span>
	}

	/**
	 * Returns 1, 0, or -1 to indicate that government would improve, remain the
	 * same, or deteriorate if the colony had the given population.
	 *
	 * @param unitCount
	 *            The proposed population for the colony.
	 * @return 1, 0 or -1.
	 */
	public int governmentChange(int unitCount) {
<span class="nc" id="L1444">		final Specification spec = getSpecification();</span>
<span class="nc" id="L1445">		final int veryBadGovernment = spec.getInteger(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1446">		final int badGovernment = spec.getInteger(GameOptions.BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1447">		final int veryGoodGovernment = spec.getInteger(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1448">		final int goodGovernment = spec.getInteger(GameOptions.GOOD_GOVERNMENT_LIMIT);</span>

<span class="nc" id="L1450">		int rebelPercent = calculateSoLPercentage(unitCount, getLiberty());</span>
<span class="nc" id="L1451">		int rebelCount = calculateRebels(unitCount, rebelPercent);</span>
<span class="nc" id="L1452">		int loyalistCount = unitCount - rebelCount;</span>

<span class="nc" id="L1454">		int result = 0;</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">		if (rebelPercent &gt;= veryGoodGovernment) { // There are no tories left.</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">			if (sonsOfLiberty &lt; veryGoodGovernment) {</span>
<span class="nc" id="L1457">				result = 1;</span>
			}
<span class="nc bnc" id="L1459" title="All 2 branches missed.">		} else if (rebelPercent &gt;= goodGovernment) {</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">			if (sonsOfLiberty &gt;= veryGoodGovernment) {</span>
<span class="nc" id="L1461">				result = -1;</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">			} else if (sonsOfLiberty &lt; goodGovernment) {</span>
<span class="nc" id="L1463">				result = 1;</span>
			}
		} else {
<span class="nc bnc" id="L1466" title="All 2 branches missed.">			if (sonsOfLiberty &gt;= goodGovernment) {</span>
<span class="nc" id="L1467">				result = -1;</span>
			} else { // Now that no bonus is applied, penalties may.
<span class="nc bnc" id="L1469" title="All 2 branches missed.">				if (loyalistCount &gt; veryBadGovernment) {</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">					if (tories &lt;= veryBadGovernment) {</span>
<span class="nc" id="L1471">						result = -1;</span>
					}
<span class="nc bnc" id="L1473" title="All 2 branches missed.">				} else if (loyalistCount &gt; badGovernment) {</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">					if (tories &lt;= badGovernment) {</span>
<span class="nc" id="L1475">						result = -1;</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">					} else if (tories &gt; veryBadGovernment) {</span>
<span class="nc" id="L1477">						result = 1;</span>
					}
				} else {
<span class="nc bnc" id="L1480" title="All 2 branches missed.">					if (tories &gt; badGovernment) {</span>
<span class="nc" id="L1481">						result = 1;</span>
					}
				}
			}
		}
<span class="nc" id="L1486">		return result;</span>
	}

	/**
	 * Check for gov mgt change message.
	 *
	 * @return the model message
	 */
	public ModelMessage checkForGovMgtChangeMessage() {
<span class="nc" id="L1495">		final Specification spec = getSpecification();</span>
<span class="nc" id="L1496">		final int veryBadGovernment = spec.getInteger(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1497">		final int badGovernment = spec.getInteger(GameOptions.BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1498">		final int veryGoodGovernment = spec.getInteger(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1499">		final int goodGovernment = spec.getInteger(GameOptions.GOOD_GOVERNMENT_LIMIT);</span>

<span class="nc" id="L1501">		String msgId = null;</span>
<span class="nc" id="L1502">		int number = 0;</span>
<span class="nc" id="L1503">		ModelMessage.MessageType msgType = ModelMessage.MessageType.GOVERNMENT_EFFICIENCY;</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">		if (sonsOfLiberty &gt;= veryGoodGovernment) {</span>
			// there are no tories left
<span class="nc bnc" id="L1506" title="All 2 branches missed.">			if (oldSonsOfLiberty &lt; veryGoodGovernment) {</span>
<span class="nc" id="L1507">				msgId = &quot;model.colony.veryGoodGovernment&quot;;</span>
<span class="nc" id="L1508">				msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1509">				number = veryGoodGovernment;</span>
			}
<span class="nc bnc" id="L1511" title="All 2 branches missed.">		} else if (sonsOfLiberty &gt;= goodGovernment) {</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">			if (oldSonsOfLiberty == veryGoodGovernment) {</span>
<span class="nc" id="L1513">				msgId = &quot;model.colony.lostVeryGoodGovernment&quot;;</span>
<span class="nc" id="L1514">				msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1515">				number = veryGoodGovernment;</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">			} else if (oldSonsOfLiberty &lt; goodGovernment) {</span>
<span class="nc" id="L1517">				msgId = &quot;model.colony.goodGovernment&quot;;</span>
<span class="nc" id="L1518">				msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1519">				number = goodGovernment;</span>
			}
		} else {
<span class="nc bnc" id="L1522" title="All 2 branches missed.">			if (oldSonsOfLiberty &gt;= goodGovernment) {</span>
<span class="nc" id="L1523">				msgId = &quot;model.colony.lostGoodGovernment&quot;;</span>
<span class="nc" id="L1524">				msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1525">				number = goodGovernment;</span>
			}

			// Now that no bonus is applied, penalties may.
<span class="nc bnc" id="L1529" title="All 2 branches missed.">			if (tories &gt; veryBadGovernment) {</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">				if (oldTories &lt;= veryBadGovernment) {</span>
					// government has become very bad
<span class="nc" id="L1532">					msgId = &quot;model.colony.veryBadGovernment&quot;;</span>
				}
<span class="nc bnc" id="L1534" title="All 2 branches missed.">			} else if (tories &gt; badGovernment) {</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">				if (oldTories &lt;= badGovernment) {</span>
					// government has become bad
<span class="nc" id="L1537">					msgId = &quot;model.colony.badGovernment&quot;;</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">				} else if (oldTories &gt; veryBadGovernment) {</span>
					// government has improved, but is still bad
<span class="nc" id="L1540">					msgId = &quot;model.colony.governmentImproved1&quot;;</span>
				}
<span class="nc bnc" id="L1542" title="All 2 branches missed.">			} else if (oldTories &gt; badGovernment) {</span>
				// government was bad, but has improved
<span class="nc" id="L1544">				msgId = &quot;model.colony.governmentImproved2&quot;;</span>
			}
		}

<span class="nc" id="L1548">		GoodsType bells = getSpecification().getGoodsType(&quot;model.goods.bells&quot;);</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">		return (msgId == null) ? null</span>
<span class="nc" id="L1550">				: new ModelMessage(msgType, msgId, this, bells).addName(&quot;%colony%&quot;, getName()).addAmount(&quot;%number%&quot;,</span>
<span class="nc" id="L1551">						number);</span>
	}

	/**
	 * Signal to the colony that its population is changing. Called from
	 * Unit.setLocation when a unit moves into or out of this colony, but *not*
	 * if it is moving within the colony.
	 */
	public void updatePopulation() {
<span class="fc" id="L1560">		updateSoL();</span>
<span class="fc" id="L1561">		updateProductionBonus();</span>
<span class="fc bfc" id="L1562" title="All 2 branches covered.">		if (getOwner().isAI()) {</span>
<span class="fc" id="L1563">			firePropertyChange(Colony.REARRANGE_WORKERS, true, false);</span>
		}
<span class="fc" id="L1565">	}</span>

	/**
	 * Signal to the colony that a unit is moving in or out or changing its
	 * internal work location to one with a different teaching ability. This
	 * requires either checking for a new teacher or student, or clearing any
	 * existing education relationships.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is changing its education state.
	 * @param enable
	 *            If true, check for new education opportunities, otherwise
	 *            clear existing ones.
	 */
	public void updateEducation(Unit unit, boolean enable) {
<span class="fc" id="L1580">		WorkLocation wl = unit.getWorkLocation();</span>
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">		if (wl == null) {</span>
<span class="nc" id="L1582">			throw new RuntimeException(&quot;updateEducation(&quot; + unit + &quot;) unit not at work location.&quot;);</span>
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">		} else if (wl.getColony() != this) {</span>
<span class="nc" id="L1584">			throw new RuntimeException(&quot;updateEducation(&quot; + unit + &quot;) unit not at work location in this colony.&quot;);</span>
		}
<span class="fc bfc" id="L1586" title="All 2 branches covered.">		if (enable) {</span>
<span class="fc bfc" id="L1587" title="All 2 branches covered.">			if (wl.canTeach()) {</span>
<span class="fc" id="L1588">				Unit student = unit.getStudent();</span>
<span class="pc bpc" id="L1589" title="1 of 4 branches missed.">				if (student == null &amp;&amp; (student = findStudent(unit)) != null) {</span>
<span class="fc" id="L1590">					unit.setStudent(student);</span>
<span class="fc" id="L1591">					student.setTeacher(unit);</span>
<span class="fc" id="L1592">					unit.setTurnsOfTraining(0);// Teacher starts teaching</span>
<span class="fc" id="L1593">					unit.changeWorkType(null);</span>
				}
<span class="fc" id="L1595">			} else {</span>
<span class="fc" id="L1596">				Unit teacher = unit.getTeacher();</span>
<span class="pc bpc" id="L1597" title="1 of 4 branches missed.">				if (teacher == null &amp;&amp; (teacher = findTeacher(unit)) != null) {</span>
<span class="fc" id="L1598">					unit.setTeacher(teacher);</span>
<span class="fc" id="L1599">					teacher.setStudent(unit);</span>
				}
<span class="fc" id="L1601">			}</span>
		} else {
<span class="fc bfc" id="L1603" title="All 2 branches covered.">			if (wl.canTeach()) {</span>
<span class="fc" id="L1604">				Unit student = unit.getStudent();</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">				if (student != null) {</span>
<span class="fc" id="L1606">					student.setTeacher(null);</span>
<span class="fc" id="L1607">					unit.setStudent(null);</span>
<span class="fc" id="L1608">					unit.setTurnsOfTraining(0);// Teacher stops teaching</span>
				}
<span class="fc" id="L1610">			} else {</span>
<span class="fc" id="L1611">				Unit teacher = unit.getTeacher();</span>
<span class="fc bfc" id="L1612" title="All 2 branches covered.">				if (teacher != null) {</span>
<span class="fc" id="L1613">					teacher.setStudent(null);</span>
<span class="fc" id="L1614">					unit.setTeacher(null);</span>
				}
			}
		}
<span class="fc" id="L1618">	}</span>

	/**
	 * Does this colony have undead units?.
	 *
	 * @return True if this colony has undead units.
	 */
	public boolean isUndead() {
<span class="nc" id="L1626">		Unit u = getFirstUnit();</span>
<span class="nc bnc" id="L1627" title="All 4 branches missed.">		return u != null &amp;&amp; u.isUndead();</span>
	}

	/**
	 * Gets the apparent number of units at this colony. Used in client enemy
	 * colonies
	 *
	 * @return The apparent number of &lt;code&gt;Unit&lt;/code&gt;s at this colony.
	 */
	public int getDisplayUnitCount() {
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">		return (displayUnitCount &gt; 0) ? displayUnitCount : getUnitCount();</span>
	}

	/**
	 * Sets the apparent number of units at this colony. Used in client enemy
	 * colonies
	 *
	 * @param count
	 *            The new apparent number of &lt;code&gt;Unit&lt;/code&gt;s at this colony.
	 */
	public void setDisplayUnitCount(int count) {
<span class="fc" id="L1648">		this.displayUnitCount = count;</span>
<span class="fc" id="L1649">	}</span>

	// Defence, offense and trade response

	/**
	 * Gets the best defender type available to this colony.
	 *
	 * @return The best available defender type.
	 */
	public UnitType getBestDefenderType() {
<span class="fc" id="L1659">		UnitType bestDefender = null;</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">		for (UnitType unitType : getSpecification().getUnitTypeList()) {</span>
<span class="fc bfc" id="L1661" title="All 6 branches covered.">			if (unitType.getDefence() &gt; 0 &amp;&amp; (bestDefender == null || bestDefender.getDefence() &lt; unitType.getDefence())</span>
<span class="fc bfc" id="L1662" title="All 4 branches covered.">					&amp;&amp; !unitType.hasAbility(Ability.NAVAL_UNIT) &amp;&amp; unitType.isAvailableTo(getOwner())) {</span>
<span class="fc" id="L1663">				bestDefender = unitType;</span>
			}
<span class="fc" id="L1665">		}</span>
<span class="fc" id="L1666">		return bestDefender;</span>
	}

	/**
	 * Gets the total defence power.
	 *
	 * @return The total defence power.
	 */
	public double getTotalDefencePower() {
<span class="fc" id="L1675">		final CombatModel cm = getGame().getCombatModel();</span>
<span class="fc" id="L1676">		return getTile().getUnitList().stream().filter(Unit::isDefensiveUnit)</span>
<span class="pc" id="L1677">				.mapToDouble(u -&gt; cm.getDefencePower(null, u)).sum();</span>
	}

	/**
	 * Determines whether this colony is sufficiently unprotected and contains
	 * something worth pillaging. To be called by CombatModels when the attacker
	 * has defeated an unarmed colony defender.
	 *
	 * @param attacker
	 *            The &lt;code&gt;Unit&lt;/code&gt; that has defeated the defender.
	 * @return True if the attacker can pillage this colony.
	 */
	public boolean canBePillaged(Unit attacker) {
<span class="pc bpc" id="L1690" title="2 of 4 branches missed.">		return !hasStockade() &amp;&amp; attacker.hasAbility(Ability.PILLAGE_UNPROTECTED_COLONY)</span>
<span class="fc bfc" id="L1691" title="All 2 branches covered.">				&amp;&amp; !(getBurnableBuildings().isEmpty()</span>
<span class="fc bfc" id="L1692" title="All 4 branches covered.">						&amp;&amp; getTile().getNavalUnits().isEmpty() &amp;&amp; (getLootableGoodsList().isEmpty()</span>
<span class="pc bpc" id="L1693" title="2 of 4 branches missed.">								|| !attacker.getType().canCarryGoods() || !attacker.hasSpaceLeft())</span>
<span class="fc bfc" id="L1694" title="All 2 branches covered.">						&amp;&amp; !canBePlundered());</span>
	}

	/**
	 * Checks if this colony can be plundered. That is, can it yield non-zero
	 * gold.
	 *
	 * @return True if at least one piece of gold can be plundered from this
	 *         colony.
	 */
	public boolean canBePlundered() {
<span class="fc" id="L1705">		return owner.checkGold(1);</span>
	}

	/**
	 * Gets the buildings in this colony that could be burned by a raid.
	 *
	 * @return A list of burnable buildings.
	 */
	public List&lt;Building&gt; getBurnableBuildings() {
<span class="fc" id="L1714">		return getBuildings().stream().filter(Building::canBeDamaged).collect(Collectors.toList());</span>
	}

	/**
	 * Gets a list of all stored goods in this colony, suitable for being
	 * looted.
	 *
	 * @return A list of lootable goods in this colony.
	 */
	public List&lt;Goods&gt; getLootableGoodsList() {
<span class="fc" id="L1724">		return getGoodsContainer().getGoods().stream().filter(g -&gt; g.getType().isStorable())</span>
<span class="fc" id="L1725">				.collect(Collectors.toList());</span>
	}

	/**
	 * Returns &lt;code&gt;true&lt;/code&gt; if the number of enemy combat units on all
	 * tiles that belong to the colony exceeds the number of friendly combat
	 * units. At the moment, only the colony owner's own units are considered
	 * friendly, but that could be extended to include the units of allied
	 * players.
	 *
	 * FIXME: if a colony is under siege, it should not be possible to put units
	 * outside the colony, unless those units are armed.
	 *
	 * @return a &lt;code&gt;boolean&lt;/code&gt; value
	 */
	public boolean isUnderSiege() {
<span class="fc" id="L1741">		int friendlyUnits = 0;</span>
<span class="fc" id="L1742">		int enemyUnits = 0;</span>
<span class="fc bfc" id="L1743" title="All 2 branches covered.">		for (ColonyTile colonyTile : colonyTiles) {</span>
<span class="fc bfc" id="L1744" title="All 2 branches covered.">			for (Unit unit : colonyTile.getWorkTile().getUnitList()) {</span>
<span class="fc bfc" id="L1745" title="All 2 branches covered.">				if (unit.getOwner() == getOwner()) {</span>
<span class="fc bfc" id="L1746" title="All 2 branches covered.">					if (unit.isDefensiveUnit()) {</span>
<span class="fc" id="L1747">						friendlyUnits++;</span>
					}
<span class="pc bpc" id="L1749" title="1 of 4 branches missed.">				} else if (getOwner().atWarWith(unit.getOwner()) &amp;&amp; unit.isOffensiveUnit()) {</span>
<span class="fc" id="L1750">						enemyUnits++;</span>
					}
<span class="fc" id="L1752">				}</span>
<span class="fc" id="L1753">			}</span>
<span class="fc bfc" id="L1754" title="All 2 branches covered.">		return enemyUnits &gt; friendlyUnits;</span>
	}

	/**
	 * Evaluate this colony for a given player.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
	 * @return A value for the player.
	 */
	public int evaluateFor(Player player) {
<span class="nc bnc" id="L1765" title="All 4 branches missed.">		if (player.isAI() &amp;&amp; player.getNumberOfSettlements() &lt; 5) {// FIXME:</span>
																	// magic#
<span class="nc" id="L1767">			return Integer.MIN_VALUE;</span>
		}
		int result;
<span class="nc bnc" id="L1770" title="All 2 branches missed.">		if (player.owns(this)) {</span>
<span class="nc" id="L1771">			result = getAvailableWorkLocations().stream().mapToInt(wl -&gt; wl.evaluateFor(player)).sum()</span>
<span class="nc" id="L1772">					+ getTile().getUnitList().stream().mapToInt(u -&gt; u.evaluateFor(player)).sum()</span>
<span class="nc" id="L1773">					+ getCompactGoods().stream().mapToInt(g -&gt; g.evaluateFor(player)).sum();</span>
		} else { // Much guesswork
<span class="nc" id="L1775">			result = getDisplayUnitCount() * 1000 + 500 // Some useful goods?</span>
<span class="nc" id="L1776">					+ 200 * (int) getTile().getSurroundingTiles(0, 1).stream()</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">							.filter(t -&gt; t.getOwningSettlement() == this).count();</span>
<span class="nc" id="L1778">			Building stockade = getStockade();</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">			if (stockade != null)</span>
<span class="nc" id="L1780">				result *= stockade.getLevel();</span>
		}
<span class="nc" id="L1782">		return result;</span>
	}

	// Education

	/**
	 * Returns true if this colony has a schoolhouse and the unit type is a
	 * skilled unit type with a skill level not exceeding the level of the
	 * schoolhouse. @see Building#canAdd
	 *
	 * @param unit
	 *            The unit to add as a teacher.
	 * @return &lt;code&gt;true&lt;/code&gt; if this unit type could be added.
	 */
	public boolean canTrain(Unit unit) {
<span class="fc" id="L1797">		return canTrain(unit.getType());</span>
	}

	/**
	 * Returns true if this colony has a schoolhouse and the unit type is a
	 * skilled unit type with a skill level not exceeding the level of the
	 * schoolhouse. The number of units already in the schoolhouse and the
	 * availability of pupils are not taken into account. @see Building#canAdd
	 *
	 * @param unitType
	 *            The unit type to add as a teacher.
	 * @return &lt;code&gt;true&lt;/code&gt; if this unit type could be added.
	 */
	public boolean canTrain(UnitType unitType) {
<span class="pc bpc" id="L1811" title="3 of 8 branches missed.">		return hasAbility(Ability.TEACH) &amp;&amp; any(buildingMap.values(), b -&gt; b.canTeach() &amp;&amp; b.canAddType(unitType));</span>
	}

	/**
	 * Gets a list of all teachers currently present in the school building.
	 *
	 * @return A list of teacher &lt;code&gt;Unit&lt;/code&gt;s.
	 */
	public List&lt;Unit&gt; getTeachers() {
<span class="nc" id="L1820">		List&lt;Unit&gt; teachers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">		for (Building building : buildingMap.values()) {</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">			if (building.canTeach()) {</span>
<span class="nc" id="L1823">				teachers.addAll(building.getUnitList());</span>
			}
<span class="nc" id="L1825">		}</span>
<span class="nc" id="L1826">		return teachers;</span>
	}

	/**
	 * Find a teacher for the specified student. Do not search if
	 * ALLOW_STUDENT_SELECTION is true--- it is the player's job then.
	 *
	 * @param student
	 *            The student &lt;code&gt;Unit&lt;/code&gt; that needs a teacher.
	 * @return A potential teacher, or null of none found.
	 */
	public Unit findTeacher(Unit student) {
<span class="fc bfc" id="L1838" title="All 2 branches covered.">		if (getSpecification().getBoolean(GameOptions.ALLOW_STUDENT_SELECTION))</span>
<span class="fc" id="L1839">			return null; // No automatic assignment</span>
<span class="fc bfc" id="L1840" title="All 2 branches covered.">		for (Building building : getBuildings()) {</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">			if (building.canTeach()) {</span>
<span class="fc bfc" id="L1842" title="All 2 branches covered.">				for (Unit unit : building.getUnitList()) {</span>
<span class="pc bpc" id="L1843" title="1 of 4 branches missed.">					if (unit.getStudent() == null &amp;&amp; student.canBeStudent(unit))</span>
<span class="fc" id="L1844">						return unit;</span>
<span class="fc" id="L1845">				}</span>
			}
<span class="fc" id="L1847">		}</span>
<span class="fc" id="L1848">		return null;</span>
	}

	/**
	 * Find a student for the specified teacher. Do not search if
	 * ALLOW_STUDENT_SELECTION is true--- its the player's job then.
	 *
	 * @param teacher
	 *            The teacher &lt;code&gt;Unit&lt;/code&gt; that needs a student.
	 * @return A potential student, or null of none found.
	 */
	public Unit findStudent(final Unit teacher) {
<span class="fc bfc" id="L1860" title="All 2 branches covered.">		if (getSpecification().getBoolean(GameOptions.ALLOW_STUDENT_SELECTION))</span>
<span class="fc" id="L1861">			return null; // No automatic assignment</span>
<span class="fc" id="L1862">		Unit student = null;</span>
<span class="fc" id="L1863">		GoodsType expertProduction = teacher.getType().getExpertProduction();</span>
<span class="fc" id="L1864">		int skillLevel = INFINITY;</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">		for (Unit potentialStudent : getUnitList()) {</span>
			/**
			 * Always pick the student with the least skill first. Break ties by
			 * favouring the one working in the teacher's trade, otherwise first
			 * applicant wins.
			 */
<span class="fc bfc" id="L1871" title="All 6 branches covered.">			if (potentialStudent.getTeacher() == null &amp;&amp; potentialStudent.canBeStudent(teacher)</span>
<span class="fc bfc" id="L1872" title="All 2 branches covered.">					&amp;&amp; (student == null || potentialStudent.getSkillLevel() &lt; skillLevel</span>
<span class="fc bfc" id="L1873" title="All 2 branches covered.">							|| (potentialStudent.getSkillLevel() == skillLevel</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">									&amp;&amp; potentialStudent.getWorkType() == expertProduction))) {</span>
<span class="fc" id="L1875">				student = potentialStudent;</span>
<span class="fc" id="L1876">				skillLevel = student.getSkillLevel();</span>
			}
<span class="fc" id="L1878">		}</span>
<span class="fc" id="L1879">		return student;</span>
	}

	// Production and consumption

	/**
	 * Does this colony produce a goods type?
	 *
	 * This is more reliable than checking net or total production, either of
	 * which might be cancelling to zero.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return True if goods type is produced.
	 */
	public boolean isProducing(GoodsType goodsType) {
<span class="nc" id="L1895">		return productionCache.isProducing(goodsType);</span>
	}

	/**
	 * Does this colony consume a goods type?
	 *
	 * This is more reliable than checking net or total consumption, either of
	 * which might be cancelling to zero.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return True if goods type is consumed.
	 */
	public boolean isConsuming(GoodsType goodsType) {
<span class="nc" id="L1909">		return productionCache.isConsuming(goodsType);</span>
	}

	/**
	 * Get a list of all {@link Consumer}s in the colony sorted by priority.
	 * Consumers include all object that consume goods, e.g. Units, Buildings
	 * and BuildQueues.
	 *
	 * @return a list of consumers
	 */
	public List&lt;Consumer&gt; getConsumers() {
<span class="fc" id="L1920">		List&lt;Consumer&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1921">		result.addAll(getUnitList());</span>
<span class="fc" id="L1922">		result.addAll(buildingMap.values());</span>
<span class="fc" id="L1923">		result.add(buildQueue);</span>
<span class="fc" id="L1924">		result.add(populationQueue);</span>

<span class="fc" id="L1926">		Collections.sort(result, Consumer.COMPARATOR);</span>
<span class="fc" id="L1927">		return result;</span>
	}

	/**
	 * Returns the number of goods of a given type used by the settlement each
	 * turn.
	 *
	 * @param goodsType
	 *            &lt;code&gt;GoodsType&lt;/code&gt; values
	 * @return an &lt;code&gt;int&lt;/code&gt; value
	 */
	@Override
	public int getConsumptionOf(GoodsType goodsType) {
<span class="fc" id="L1940">		final Specification spec = getSpecification();</span>
<span class="fc" id="L1941">		int result = super.getConsumptionOf(goodsType);</span>
<span class="fc bfc" id="L1942" title="All 2 branches covered.">		if (spec.getGoodsType(&quot;model.goods.bells&quot;).equals(goodsType)) {</span>
<span class="fc" id="L1943">			result -= spec.getInteger(&quot;model.option.unitsThatUseNoBells&quot;);</span>
		}
<span class="fc" id="L1945">		return Math.max(0, result);</span>
	}

	/**
	 * Gets the combined production of all food types.
	 *
	 * @return an &lt;code&gt;int&lt;/code&gt; value
	 */
	public int getFoodProduction() {
<span class="fc" id="L1954">		return getSpecification().getFoodGoodsTypeList().stream().mapToInt(ft -&gt; getTotalProductionOf(ft)).sum();</span>
	}

	/**
	 * Get the number of turns before starvation occurs at this colony with
	 * current production levels.
	 *
	 * @return The number of turns before starvation occurs, or negative if it
	 *         will not.
	 */
	public int getStarvationTurns() {
<span class="nc" id="L1965">		final GoodsType foodType = getSpecification().getPrimaryFoodType();</span>
<span class="nc" id="L1966">		final int food = getGoodsCount(foodType);</span>
<span class="nc" id="L1967">		final int newFood = getAdjustedNetProductionOf(foodType);</span>
<span class="nc bnc" id="L1968" title="All 2 branches missed.">		return (newFood &gt;= 0) ? -1 : food / -newFood;</span>
	}

	/**
	 * Get the number of turns before a new colonist will be born in this colony
	 * with current production levels.
	 *
	 * @return A number of turns, or negative if no colonist will be born.
	 */
	public int getNewColonistTurns() {
<span class="nc" id="L1978">		final GoodsType foodType = getSpecification().getPrimaryFoodType();</span>
<span class="nc" id="L1979">		final int food = getGoodsCount(foodType);</span>
<span class="nc" id="L1980">		final int newFood = getAdjustedNetProductionOf(foodType);</span>
<span class="nc bnc" id="L1981" title="All 4 branches missed.">		return (food + newFood &gt;= Settlement.FOOD_PER_COLONIST) ? 1</span>
				: (newFood &lt;= 0) ? -1 : (Settlement.FOOD_PER_COLONIST - food) / newFood + 1;
	}

	/**
	 * Get the current production &lt;code&gt;Modifier&lt;/code&gt;, which is generated from
	 * the current production bonus.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
	 * @return A list of suitable &lt;code&gt;Modifier&lt;/code&gt;s.
	 */
	public List&lt;Modifier&gt; getProductionModifiers(GoodsType goodsType) {
<span class="fc bfc" id="L1994" title="All 2 branches covered.">		if (productionBonus == 0)</span>
<span class="fc" id="L1995">			return Collections.&lt;Modifier&gt;emptyList();</span>
<span class="fc" id="L1996">		Modifier mod = new Modifier(goodsType.getId(), productionBonus, Modifier.ModifierType.ADDITIVE,</span>
				Specification.SOL_MODIFIER_SOURCE);
<span class="fc" id="L1998">		mod.setModifierIndex(Modifier.COLONY_PRODUCTION_INDEX);</span>
<span class="fc" id="L1999">		List&lt;Modifier&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2000">		result.add(mod);</span>
<span class="fc" id="L2001">		return result;</span>
	}

	/**
	 * Get the net production of the given goods type.
	 *
	 * (Also part of interface TradeLocation)
	 *
	 * @param goodsType
	 *            a &lt;code&gt;GoodsType&lt;/code&gt; value
	 * @return an &lt;code&gt;int&lt;/code&gt; value
	 */
	public int getNetProductionOf(GoodsType goodsType) {
<span class="fc" id="L2014">		return productionCache.getNetProductionOf(goodsType);</span>
	}

	/**
	 * Is a work location productive?.
	 *
	 * @param workLocation
	 *            The &lt;code&gt;WorkLocation&lt;/code&gt; to check.
	 * @return True if something is being produced at the
	 *         &lt;code&gt;WorkLocation&lt;/code&gt;.
	 */
	public boolean isProductive(WorkLocation workLocation) {
<span class="nc" id="L2026">		ProductionInfo info = productionCache.getProductionInfo(workLocation);</span>
<span class="nc bnc" id="L2027" title="All 6 branches missed.">		return info != null &amp;&amp; info.getProduction() != null &amp;&amp; !info.getProduction().isEmpty()</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">				&amp;&amp; info.getProduction().get(0).getAmount() &gt; 0;</span>
	}

	/**
	 * Returns the net production of the given GoodsType adjusted by the
	 * possible consumption of BuildQueues.
	 *
	 * @param goodsType
	 *            a &lt;code&gt;GoodsType&lt;/code&gt; value
	 * @return an &lt;code&gt;int&lt;/code&gt; value
	 */
	public int getAdjustedNetProductionOf(GoodsType goodsType) {
<span class="fc" id="L2040">		int result = productionCache.getNetProductionOf(goodsType);</span>
<span class="fc bfc" id="L2041" title="All 2 branches covered.">		for (BuildQueue&lt;?&gt; queue : new BuildQueue&lt;?&gt;[] { buildQueue, populationQueue }) {</span>
<span class="fc" id="L2042">			ProductionInfo info = productionCache.getProductionInfo(queue);</span>
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">			if (info != null) {</span>
<span class="fc" id="L2044">				result += AbstractGoods.getCount(goodsType, info.getConsumption());</span>
			}
		}
<span class="fc" id="L2047">		return result;</span>
	}

	/**
	 * Gets a copy of the current production map. Useful in the server at the
	 * point net production is applied to a colony.
	 *
	 * @return A copy of the current production map.
	 */
	protected TypeCountMap&lt;GoodsType&gt; getProductionMap() {
<span class="fc" id="L2057">		return productionCache.getProductionMap();</span>
	}

	/**
	 * Returns the ProductionInfo for the given Object.
	 *
	 * @param object
	 *            an &lt;code&gt;Object&lt;/code&gt; value
	 * @return a &lt;code&gt;ProductionInfo&lt;/code&gt; value
	 */
	public ProductionInfo getProductionInfo(Object object) {
<span class="fc" id="L2068">		return productionCache.getProductionInfo(object);</span>
	}

	/**
	 * Invalidates the production cache.
	 */
	public void invalidateCache() {
<span class="fc" id="L2075">		productionCache.invalidate();</span>
<span class="fc" id="L2076">	}</span>

	/**
	 * Can this colony produce certain goods?.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check production of.
	 * @return True if the goods can be produced.
	 */
	public boolean canProduce(GoodsType goodsType) {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">		return (getNetProductionOf(goodsType) &gt; 0) ? true // Obviously:-)</span>

				// Breeding requires the breedable number to be present
<span class="nc bnc" id="L2089" title="All 4 branches missed.">				: (goodsType.isBreedable()) ? getGoodsCount(goodsType) &gt;= goodsType.getBreedingNumber()</span>

						// Is there a work location that can produce the goods,
						// with
						// positive generic production potential and all inputs
						// satisfied?
<span class="nc bnc" id="L2095" title="All 2 branches missed.">						: any(getWorkLocationsForProducing(goodsType), wl -&gt; wl.getGenericPotential(goodsType) &gt; 0</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">								&amp;&amp; all(wl.getInputs(), ag -&gt; canProduce(ag.getType())));</span>
	}

	// Planning support

	/** Container class for tile exploration or improvement suggestions. */
	public static class TileImprovementSuggestion {

		/**
		 * Comparator to order suggestions by descending improvement amount.
		 */
<span class="nc" id="L2107">		public static final Comparator&lt;TileImprovementSuggestion&gt; descendingAmountComparator = new Comparator&lt;TileImprovementSuggestion&gt;() {</span>
			@Override
			public int compare(TileImprovementSuggestion tis1, TileImprovementSuggestion tis2) {
<span class="nc" id="L2110">				int cmp = tis2.amount - tis1.amount;</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">				if (cmp == 0)</span>
<span class="nc" id="L2112">					cmp = tis2.tile.compareTo(tis1.tile);</span>
<span class="nc" id="L2113">				return cmp;</span>
			}
		};

		/** The tile to explore or improve. */
		public Tile tile;
		/** The tile improvement to make, or if null to explore an LCR. */
		public TileImprovementType tileImprovementType;
		/** The expected improvement. INFINITY for LCRs. */
		public int amount;

		/**
		 * Instantiates a new tile improvement suggestion.
		 *
		 * @param tile
		 *            the tile
		 * @param t
		 *            the t
		 * @param amount
		 *            the amount
		 */
<span class="nc" id="L2134">		public TileImprovementSuggestion(Tile tile, TileImprovementType t, int amount) {</span>
<span class="nc" id="L2135">			this.tile = tile;</span>
<span class="nc" id="L2136">			this.tileImprovementType = t;</span>
<span class="nc" id="L2137">			this.amount = amount;</span>
<span class="nc" id="L2138">		}</span>

		/**
		 * Checks if is exploration.
		 *
		 * @return true, if is exploration
		 */
		public boolean isExploration() {
<span class="nc bnc" id="L2146" title="All 2 branches missed.">			return this.tileImprovementType == null;</span>
		}
	};

	/**
	 * Collect suggestions for tiles that need exploration or improvement (which
	 * may depend on current use within the colony).
	 *
	 * @return A list of &lt;code&gt;TileImprovementSuggestion&lt;/code&gt;s.
	 */
	public List&lt;TileImprovementSuggestion&gt; getTileImprovementSuggestions() {
<span class="nc" id="L2157">		final Specification spec = getSpecification();</span>
<span class="nc" id="L2158">		List&lt;TileImprovementSuggestion&gt; result = new ArrayList&lt;&gt;();</span>

		// Encourage exploration of neighbouring rumours.
<span class="nc bnc" id="L2161" title="All 2 branches missed.">		for (Tile tile : getTile().getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2162" title="All 2 branches missed.">			if (tile.hasLostCityRumour()) {</span>
<span class="nc" id="L2163">				result.add(new TileImprovementSuggestion(tile, null, INFINITY));</span>
			}
<span class="nc" id="L2165">		}</span>

		// Consider improvements for all colony tiles
<span class="nc bnc" id="L2168" title="All 2 branches missed.">		for (ColonyTile ct : getColonyTiles()) {</span>
<span class="nc" id="L2169">			final Tile tile = ct.getWorkTile();</span>
<span class="nc bnc" id="L2170" title="All 4 branches missed.">			if (tile == null || tile.getOwningSettlement() != this)</span>
<span class="nc" id="L2171">				continue;</span>

<span class="nc bnc" id="L2173" title="All 2 branches missed.">			for (TileImprovementType t : spec.getTileImprovementTypeList()) {</span>
<span class="nc bnc" id="L2174" title="All 2 branches missed.">				if (t.isNatural())</span>
<span class="nc" id="L2175">					continue;</span>
<span class="nc" id="L2176">				int improvement = ct.improvedBy(t);</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">				if (improvement &gt; 0) {</span>
<span class="nc" id="L2178">					result.add(new TileImprovementSuggestion(tile, t, improvement));</span>
				}
<span class="nc" id="L2180">			}</span>
<span class="nc" id="L2181">		}</span>
<span class="nc" id="L2182">		Collections.sort(result, TileImprovementSuggestion.descendingAmountComparator);</span>
<span class="nc" id="L2183">		return result;</span>
	}

	/**
	 * Finds another unit in this colony that would be better at doing the job
	 * of the specified unit.
	 *
	 * @param expert
	 *            The &lt;code&gt;Unit&lt;/code&gt; to consider.
	 * @return A better expert, or null if none available.
	 */
	public Unit getBetterExpert(Unit expert) {
<span class="nc" id="L2195">		GoodsType production = expert.getWorkType();</span>
<span class="nc" id="L2196">		UnitType expertType = expert.getType();</span>
<span class="nc" id="L2197">		GoodsType expertise = expertType.getExpertProduction();</span>
<span class="nc" id="L2198">		Unit bestExpert = null;</span>
<span class="nc" id="L2199">		int bestImprovement = 0;</span>

<span class="nc bnc" id="L2201" title="All 6 branches missed.">		if (production == null || expertise == null || production == expertise)</span>
<span class="nc" id="L2202">			return null;</span>

		// We have an expert not doing the job of their expertise.
		// Check if there is a non-expert doing the job instead.
<span class="nc bnc" id="L2206" title="All 2 branches missed.">		for (Unit nonExpert : getUnitList()) {</span>
<span class="nc bnc" id="L2207" title="All 4 branches missed.">			if (nonExpert.getWorkType() != expertise || nonExpert.getType() == expertType)</span>
<span class="nc" id="L2208">				continue;</span>

			// We have found a unit of a different type doing the
			// job of this expert's expertise now check if the
			// production would be better if the units swapped
			// positions.
<span class="nc" id="L2214">			int expertProductionNow = 0;</span>
<span class="nc" id="L2215">			int nonExpertProductionNow = 0;</span>
<span class="nc" id="L2216">			int expertProductionPotential = 0;</span>
<span class="nc" id="L2217">			int nonExpertProductionPotential = 0;</span>

			// Get the current and potential productions for the
			// work location of the expert.
<span class="nc" id="L2221">			WorkLocation ewl = expert.getWorkLocation();</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">			if (ewl != null) {</span>
<span class="nc" id="L2223">				expertProductionNow = ewl.getPotentialProduction(expertise, expert.getType());</span>
<span class="nc" id="L2224">				nonExpertProductionPotential = ewl.getPotentialProduction(expertise, nonExpert.getType());</span>
			}

			// Get the current and potential productions for the
			// work location of the non-expert.
<span class="nc" id="L2229">			WorkLocation nwl = nonExpert.getWorkTile();</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">			if (nwl != null) {</span>
<span class="nc" id="L2231">				nonExpertProductionNow = nwl.getPotentialProduction(expertise, nonExpert.getType());</span>
<span class="nc" id="L2232">				expertProductionPotential = nwl.getPotentialProduction(expertise, expertType);</span>
			}

			// Find the unit that achieves the best improvement.
<span class="nc" id="L2236">			int improvement = expertProductionPotential + nonExpertProductionPotential - expertProductionNow</span>
					- nonExpertProductionNow;
<span class="nc bnc" id="L2238" title="All 2 branches missed.">			if (improvement &gt; bestImprovement) {</span>
<span class="nc" id="L2239">				bestImprovement = improvement;</span>
<span class="nc" id="L2240">				bestExpert = nonExpert;</span>
			}
<span class="nc" id="L2242">		}</span>
<span class="nc" id="L2243">		return bestExpert;</span>
	}

	/**
	 * Determine if there is a problem with the production of a given goods
	 * type.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return A collection of warning messages.
	 */
	public Collection&lt;StringTemplate&gt; getProductionWarnings(GoodsType goodsType) {
<span class="nc" id="L2255">		List&lt;StringTemplate&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2256">		final int amount = getGoodsCount(goodsType);</span>
<span class="nc" id="L2257">		final int production = getNetProductionOf(goodsType);</span>
		int waste;

<span class="nc bnc" id="L2260" title="All 2 branches missed.">		if (goodsType.isStorable()) {</span>
<span class="nc bnc" id="L2261" title="All 4 branches missed.">			if (goodsType.limitIgnored() &amp;&amp; goodsType.isFoodType()) {</span>
<span class="nc" id="L2262">					int starve = getStarvationTurns();</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">					if (starve == 0) {</span>
<span class="nc" id="L2264">						result.add(StringTemplate.template(&quot;model.colony.starving&quot;).addName(&quot;%colony%&quot;, getName()));</span>
<span class="nc bnc" id="L2265" title="All 2 branches missed.">					} else if (starve &lt;= Colony.FAMINE_TURNS) {</span>
<span class="nc" id="L2266">						result.add(StringTemplate.template(&quot;model.colony.famineFeared&quot;).addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L2267">								.addAmount(&quot;%number%&quot;, starve));</span>
					}
<span class="nc" id="L2269">				}</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">			} else if (!getExportData(goodsType).getExported()</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">					&amp;&amp; (waste = amount + production - getWarehouseCapacity()) &gt; 0) {</span>
<span class="nc" id="L2272">				result.add(StringTemplate.template(&quot;model.building.warehouseSoonFull&quot;).addNamed(&quot;%goods%&quot;, goodsType)</span>
<span class="nc" id="L2273">						.addName(&quot;%colony%&quot;, getName()).addAmount(&quot;%amount%&quot;, waste));</span>
			}
		

<span class="nc" id="L2277">		BuildableType currentlyBuilding = getCurrentlyBuilding();</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">		if (currentlyBuilding != null) {</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">			for (AbstractGoods goods : currentlyBuilding.getRequiredGoods()) {</span>
<span class="nc bnc" id="L2280" title="All 4 branches missed.">				if (goods.getType().equals(goodsType) &amp;&amp; amount &lt; goods.getAmount()) {</span>
<span class="nc" id="L2281">					int needsAmount = goods.getAmount() - amount;</span>
<span class="nc" id="L2282">					result.add(StringTemplate.template(&quot;model.colony.buildableNeedsGoods&quot;)</span>
<span class="nc" id="L2283">							.addName(&quot;%colony%&quot;, getName()).addNamed(&quot;%buildable%&quot;, currentlyBuilding)</span>
<span class="nc" id="L2284">							.addAmount(&quot;%amount%&quot;, needsAmount).addNamed(&quot;%goodsType%&quot;, goodsType));</span>
				}
<span class="nc" id="L2286">			}</span>
		}

<span class="nc bnc" id="L2289" title="All 2 branches missed.">		for (WorkLocation wl : getWorkLocationsForProducing(goodsType)) {</span>
<span class="nc" id="L2290">			ProductionInfo info = getProductionInfo(wl);</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">			if (info == null)</span>
<span class="nc" id="L2292">				continue;</span>
<span class="nc" id="L2293">			StringTemplate t = getInsufficientProductionMessage(info,</span>
<span class="nc" id="L2294">					AbstractGoods.findByType(goodsType, info.getProductionDeficit()));</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">			if (t != null)</span>
<span class="nc" id="L2296">				result.add(t);</span>
<span class="nc" id="L2297">		}</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">		for (WorkLocation wl : getWorkLocationsForConsuming(goodsType)) {</span>
<span class="nc" id="L2299">			ProductionInfo info = getProductionInfo(wl);</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">			if (info == null)</span>
<span class="nc" id="L2301">				continue;</span>
<span class="nc" id="L2302">			List&lt;AbstractGoods&gt; deficit = info.getProductionDeficit();</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">			if (deficit.isEmpty())</span>
<span class="nc" id="L2304">				continue;</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">			for (AbstractGoods ag : wl.getOutputs()) {</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">				if (ag.getType().isStorable())</span>
<span class="nc" id="L2307">					continue;</span>
<span class="nc" id="L2308">				StringTemplate t = getInsufficientProductionMessage(info,</span>
<span class="nc" id="L2309">						AbstractGoods.findByType(ag.getType(), deficit));</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">				if (t != null)</span>
<span class="nc" id="L2311">					result.add(t);</span>
<span class="nc" id="L2312">			}</span>
<span class="nc" id="L2313">		}</span>

<span class="nc" id="L2315">		return result;</span>
	}

	/**
	 * Get a message about insufficient production for a building.
	 *
	 * @param info
	 *            The &lt;code&gt;ProductionInfo&lt;/code&gt; for the work location.
	 * @param deficit
	 *            The &lt;code&gt;AbstractGoods&lt;/code&gt; in deficit.
	 * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt; or null if none required.
	 */
	private StringTemplate getInsufficientProductionMessage(ProductionInfo info, AbstractGoods deficit) {
<span class="nc bnc" id="L2328" title="All 4 branches missed.">		if (info == null || deficit == null)</span>
<span class="nc" id="L2329">			return null;</span>

<span class="nc" id="L2331">		List&lt;AbstractGoods&gt; input = info.getConsumptionDeficit();</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">		if (input.isEmpty())</span>
<span class="nc" id="L2333">			return null;</span>
<span class="nc" id="L2334">		StringTemplate label = StringTemplate.label(&quot;, &quot;);</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">		for (AbstractGoods ag : input)</span>
<span class="nc" id="L2336">			label.addStringTemplate(ag.getLabel());</span>

<span class="nc" id="L2338">		return StringTemplate.template(&quot;model.colony.insufficientProduction&quot;).addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L2339">				.addNamed(&quot;%outputType%&quot;, deficit.getType()).addAmount(&quot;%outputAmount%&quot;, deficit.getAmount())</span>
<span class="nc" id="L2340">				.addStringTemplate(&quot;%consumptionDeficit%&quot;, label);</span>
	}

	/**
	 * Check if a goods type is still useful to this colony.
	 * 
	 * In general, all goods are useful. However post-independence there is no
	 * need for more liberty once Sol% reaches 100, nor immigration. Note the
	 * latter may change when we implement sailing to other European ports.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to check.
	 * @return true, if successful
	 */
	public boolean goodsUseful(GoodsType goodsType) {
<span class="nc bnc" id="L2355" title="All 2 branches missed.">		if (getOwner().getPlayerType() == Player.PlayerType.INDEPENDENT) {</span>
<span class="nc bnc" id="L2356" title="All 6 branches missed.">			if ((goodsType.isLibertyType() &amp;&amp; getSoLPercentage() &gt;= 100) || goodsType.isImmigrationType())</span>
<span class="nc" id="L2357">				return false;</span>
		}
<span class="nc" id="L2359">		return true;</span>
	}

	/**
	 * Special goods need modifiers applied when changed, and immigration
	 * accumulates to the owner.
	 *
	 * @param goodsType
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
	 * @param amount
	 *            The amount of modification.
	 */
	private void modifySpecialGoods(GoodsType goodsType, int amount) {
<span class="fc" id="L2372">		final Turn turn = getGame().getTurn();</span>
		Set&lt;Modifier&gt; mods;

<span class="fc" id="L2375">		mods = goodsType.getModifiers(Modifier.LIBERTY);</span>
<span class="fc bfc" id="L2376" title="All 2 branches covered.">		if (!mods.isEmpty()) {</span>
<span class="fc" id="L2377">			int liberty = (int) applyModifiers(amount, turn, mods);</span>
<span class="fc" id="L2378">			modifyLiberty(liberty);</span>
		}

<span class="fc" id="L2381">		mods = goodsType.getModifiers(Modifier.IMMIGRATION);</span>
<span class="fc bfc" id="L2382" title="All 2 branches covered.">		if (!mods.isEmpty()) {</span>
<span class="fc" id="L2383">			int migration = (int) applyModifiers(amount, turn, mods);</span>
<span class="fc" id="L2384">			modifyImmigration(migration);</span>
<span class="fc" id="L2385">			getOwner().modifyImmigration(migration);</span>
		}
<span class="fc" id="L2387">	}</span>

	/**
	 * Creates a temporary copy of this colony for planning purposes.
	 *
	 * A simple colony.copy() can not work because all the colony tiles will be
	 * left referring to uncopied work tiles which the colony-copy does not own,
	 * which prevents them being used as valid work locations. We have to copy
	 * the colony tile (which includes the colony), and fix up all the colony
	 * tile work tiles to point to copies of the original tile, and fix the
	 * ownership of those tiles.
	 *
	 * @return A scratch version of this colony.
	 */
	public Colony copyColony() {
<span class="fc" id="L2402">		final Game game = getGame();</span>
<span class="fc" id="L2403">		Tile tile = getTile();</span>
<span class="fc" id="L2404">		Tile tileCopy = tile.copy(game, tile.getClass());</span>
<span class="fc" id="L2405">		Colony colony = tileCopy.getColony();</span>
<span class="fc bfc" id="L2406" title="All 2 branches covered.">		for (ColonyTile ct : colony.getColonyTiles()) {</span>
			Tile wt;
<span class="fc bfc" id="L2408" title="All 2 branches covered.">			if (ct.isColonyCenterTile()) {</span>
<span class="fc" id="L2409">				wt = tileCopy;</span>
			} else {
<span class="fc" id="L2411">				wt = ct.getWorkTile();</span>
<span class="fc" id="L2412">				wt = wt.copy(game, wt.getClass());</span>
<span class="pc bpc" id="L2413" title="1 of 2 branches missed.">				if (wt.getOwningSettlement() == this) {</span>
<span class="fc" id="L2414">					wt.setOwningSettlement(colony);</span>
				}
			}
<span class="fc" id="L2417">			ct.setWorkTile(wt);</span>
<span class="fc" id="L2418">		}</span>
<span class="fc" id="L2419">		return colony;</span>
	}

	/**
	 * Finds the corresponding FreeColObject from another copy of this colony.
	 *
	 * @param &lt;T&gt;
	 *            the generic type
	 * @param fco
	 *            The &lt;code&gt;FreeColObject&lt;/code&gt; in the other colony.
	 * @return The corresponding &lt;code&gt;FreeColObject&lt;/code&gt; in this colony, or
	 *         null if not found.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends FreeColObject&gt; T getCorresponding(T fco) {
<span class="fc" id="L2434">		final String id = fco.getId();</span>
<span class="fc bfc" id="L2435" title="All 2 branches covered.">		if (fco instanceof WorkLocation) {</span>
<span class="pc bpc" id="L2436" title="1 of 2 branches missed.">			for (WorkLocation t : getAllWorkLocations()) {</span>
<span class="fc bfc" id="L2437" title="All 2 branches covered.">				if (t.getId().equals(id))</span>
<span class="fc" id="L2438">					return (T) t;</span>
<span class="pc" id="L2439">			}</span>
<span class="pc bpc" id="L2440" title="1 of 2 branches missed.">		} else if (fco instanceof Tile) {</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">			if (getTile().getId().equals(id))</span>
<span class="nc" id="L2442">				return (T) getTile();</span>
<span class="nc bnc" id="L2443" title="All 2 branches missed.">			for (ColonyTile ct : getColonyTiles()) {</span>
<span class="nc bnc" id="L2444" title="All 2 branches missed.">				if (ct.getWorkTile().getId().equals(id))</span>
<span class="nc" id="L2445">					return (T) ct.getWorkTile();</span>
<span class="nc" id="L2446">			}</span>
<span class="pc bpc" id="L2447" title="1 of 2 branches missed.">		} else if (fco instanceof Unit) {</span>
<span class="pc bpc" id="L2448" title="1 of 2 branches missed.">			for (Unit t : getUnitList()) {</span>
<span class="fc bfc" id="L2449" title="All 2 branches covered.">				if (t.getId().equals(id))</span>
<span class="fc" id="L2450">					return (T) t;</span>
<span class="fc" id="L2451">			}</span>
<span class="nc bnc" id="L2452" title="All 2 branches missed.">			for (Unit t : getTile().getUnitList()) {</span>
<span class="nc bnc" id="L2453" title="All 2 branches missed.">				if (t.getId().equals(id))</span>
<span class="nc" id="L2454">					return (T) t;</span>
<span class="nc" id="L2455">			}</span>
		}
<span class="nc" id="L2457">		return null;</span>
	}

	// Override FreeColObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Set&lt;Ability&gt; getAbilities(String id, FreeColGameObjectType type, Turn turn) {
<span class="pc bpc" id="L2467" title="1 of 2 branches missed.">		if (turn == null)</span>
<span class="fc" id="L2468">			turn = getGame().getTurn();</span>
<span class="fc" id="L2469">		Set&lt;Ability&gt; result = super.getAbilities(id, type, turn);</span>
		// Owner abilities also apply to colonies
<span class="pc bpc" id="L2471" title="1 of 2 branches missed.">		if (owner != null)</span>
<span class="fc" id="L2472">			result.addAll(owner.getAbilities(id, type, turn));</span>
<span class="fc" id="L2473">		return result;</span>
	}

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List&lt;FreeColGameObject&gt; getDisposeList() {
<span class="fc" id="L2483">		List&lt;FreeColGameObject&gt; objects = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2484" title="All 2 branches covered.">		for (WorkLocation workLocation : getAllWorkLocations()) {</span>
<span class="fc" id="L2485">			objects.addAll(workLocation.getDisposeList());</span>
<span class="fc" id="L2486">		}</span>
<span class="fc" id="L2487">		objects.addAll(super.getDisposeList());</span>
<span class="fc" id="L2488">		return objects;</span>
	}

	// Interface Location (from Settlement via GoodsLocation
	// via UnitLocation)
	// The unit list in UnitLocation is replaced in Colonies.
	// Inherits
	// FreeColObject.getId
	// Settlement.getTile
	// Settlement.getLocationLabel
	// GoodsLocation.canAdd
	// GoodsLocation.getGoodsContainer
	// Settlement.getSettlement

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getLocationLabelFor(Player player) {
		// Everyone can always work out a colony name.
<span class="fc" id="L2508">		return StringTemplate.name(getName());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean add(Locatable locatable) {
<span class="nc bnc" id="L2516" title="All 2 branches missed.">		if (locatable instanceof Unit) {</span>
<span class="nc" id="L2517">			return joinColony((Unit) locatable);</span>
		}
<span class="nc" id="L2519">		return super.add(locatable);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean remove(Locatable locatable) {
<span class="nc bnc" id="L2527" title="All 2 branches missed.">		if (locatable instanceof Unit) {</span>
<span class="nc" id="L2528">			Location loc = locatable.getLocation();</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">			if (loc instanceof WorkLocation) {</span>
<span class="nc" id="L2530">				WorkLocation wl = (WorkLocation) loc;</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">				if (wl.getColony() == this) {</span>
<span class="nc" id="L2532">					return wl.remove(locatable);</span>
				}
			}
<span class="nc" id="L2535">			return false;</span>
		}
<span class="nc" id="L2537">		return super.remove(locatable);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean contains(Locatable locatable) {
<span class="nc bnc" id="L2545" title="All 2 branches missed.">		if (locatable instanceof Unit) {</span>
<span class="nc" id="L2546">			return any(getAvailableWorkLocations(), wl -&gt; wl.contains(locatable));</span>
		}
<span class="nc" id="L2548">		return super.contains(locatable);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getUnitCount() {
<span class="fc" id="L2556">		return getCurrentWorkLocations().stream().mapToInt(wl -&gt; wl.getUnitCount()).sum();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List&lt;Unit&gt; getUnitList() {
<span class="fc" id="L2564">		ArrayList&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2565" title="All 2 branches covered.">		for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="fc" id="L2566">			units.addAll(wl.getUnitList());</span>
<span class="fc" id="L2567">		}</span>
<span class="fc" id="L2568">		return units;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location up() {
<span class="fc" id="L2576">		return this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toShortString() {
<span class="fc" id="L2584">		return getName();</span>
	}

	// Interface UnitLocation
	// Inherits
	// UnitLocation.getSpaceTaken [Irrelevant!]
	// UnitLocation.moveToFront [Irrelevant!]
	// UnitLocation.clearUnitList [Irrelevant!]
	// Settlement.equipForRole
	// Settlement.getNoAddReason

	// Interface GoodsLocation

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getGoodsCapacity() {
<span class="fc" id="L2602">		return (int) applyModifiers(0f, getGame().getTurn(), Modifier.WAREHOUSE_STORAGE);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean addGoods(GoodsType type, int amount) {
<span class="fc" id="L2610">		super.addGoods(type, amount);</span>
<span class="fc" id="L2611">		productionCache.invalidate(type);</span>
<span class="fc" id="L2612">		modifySpecialGoods(type, amount);</span>
<span class="fc" id="L2613">		return true;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Goods removeGoods(GoodsType type, int amount) {
<span class="fc" id="L2621">		Goods removed = super.removeGoods(type, amount);</span>
<span class="fc" id="L2622">		productionCache.invalidate(type);</span>
<span class="fc bfc" id="L2623" title="All 2 branches covered.">		if (removed != null)</span>
<span class="fc" id="L2624">			modifySpecialGoods(type, -removed.getAmount());</span>
<span class="fc" id="L2625">		return removed;</span>
	}

	// Settlement

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getImageKey() {
		String key;
<span class="nc bnc" id="L2636" title="All 2 branches missed.">		if (isUndead()) {</span>
<span class="nc" id="L2637">			key = &quot;.undead&quot;;</span>
		} else {
<span class="nc" id="L2639">			int count = getDisplayUnitCount();</span>
<span class="nc bnc" id="L2640" title="All 4 branches missed.">			key = (count &lt;= 3) ? &quot;.small&quot; : (count &lt;= 7) ? &quot;.medium&quot; : &quot;.large&quot;;</span>
<span class="nc" id="L2641">			String stockade = getStockadeKey();</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">			if (stockade != null)</span>
<span class="nc" id="L2643">				key += &quot;.&quot; + stockade;</span>
		}
<span class="nc" id="L2645">		return &quot;image.tileitem.&quot; + getType().getId() + key;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Unit getDefendingUnit(Unit attacker) {
<span class="pc bpc" id="L2653" title="1 of 2 branches missed.">		if (displayUnitCount &gt; 0) {</span>
			// There are units, but we don't see them
<span class="nc" id="L2655">			return null;</span>
		}

		// Note that this function will only return a unit working
		// inside the colony. Typically, colonies are also defended
		// by units outside the colony on the same tile. To consider
		// units outside the colony as well, use
		// @see Tile#getDefendingUnit instead.
		//
		// Returns an arbitrary unarmed land unit unless Paul Revere
		// is present as founding father, in which case the unit can
		// be armed as well.
<span class="fc" id="L2667">		List&lt;Unit&gt; unitList = getUnitList();</span>

<span class="fc" id="L2669">		Unit defender = null;</span>
<span class="fc" id="L2670">		double defencePower = -1.0;</span>
<span class="fc bfc" id="L2671" title="All 2 branches covered.">		for (Unit nextUnit : unitList) {</span>
<span class="fc" id="L2672">			double unitPower = getGame().getCombatModel().getDefencePower(attacker, nextUnit);</span>
<span class="pc bpc" id="L2673" title="1 of 2 branches missed.">			if (Unit.betterDefender(defender, defencePower, nextUnit, unitPower)) {</span>
<span class="fc" id="L2674">				defender = nextUnit;</span>
<span class="fc" id="L2675">				defencePower = unitPower;</span>
			}
<span class="fc" id="L2677">		}</span>
<span class="pc bpc" id="L2678" title="1 of 2 branches missed.">		if (defender == null) {</span>
<span class="nc" id="L2679">			throw new IllegalStateException(&quot;Colony &quot; + getName() + &quot; contains no units!&quot;);</span>
		}
<span class="fc" id="L2681">		return defender;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public double getDefenceRatio() {
<span class="nc" id="L2689">		return getTotalDefencePower() / (1 + getUnitCount());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isBadlyDefended() {
<span class="fc bfc" id="L2697" title="All 2 branches covered.">		return getTotalDefencePower() &lt; 0.95 * getUnitCount() - 2.5;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public RandomRange getPlunderRange(Unit attacker) {
<span class="fc bfc" id="L2705" title="All 2 branches covered.">		if (canBePlundered()) {</span>
<span class="fc" id="L2706">			int upper = (owner.getGold() * (getUnitCount() + 1)) / (owner.getColoniesPopulation() + 1);</span>
<span class="pc bpc" id="L2707" title="1 of 2 branches missed.">			if (upper &gt; 0)</span>
<span class="fc" id="L2708">				return new RandomRange(100, 1, upper + 1, 1);</span>
		}
<span class="fc" id="L2710">		return null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getSoL() {
<span class="fc" id="L2718">		return sonsOfLiberty;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getUpkeep() {
<span class="fc" id="L2726">		return buildingMap.values().stream().mapToInt(b -&gt; b.getType().getUpkeep()).sum();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getTotalProductionOf(GoodsType goodsType) {
<span class="fc" id="L2734">		return getCurrentWorkLocations().stream().mapToInt(wl -&gt; wl.getTotalProductionOf(goodsType)).sum();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean canProvideGoods(List&lt;AbstractGoods&gt; requiredGoods) {
		// Unlike priceGoods, this takes goods &quot;reserved&quot; for other
		// purposes into account.
<span class="fc" id="L2744">		BuildableType buildable = getCurrentlyBuilding();</span>
<span class="fc bfc" id="L2745" title="All 2 branches covered.">		for (AbstractGoods goods : requiredGoods) {</span>
<span class="fc" id="L2746">			int available = getGoodsCount(goods.getType());</span>

<span class="fc" id="L2748">			int breedingNumber = goods.getType().getBreedingNumber();</span>
<span class="fc bfc" id="L2749" title="All 2 branches covered.">			if (breedingNumber != GoodsType.INFINITY) {</span>
<span class="fc" id="L2750">				available -= breedingNumber;</span>
			}

<span class="pc bpc" id="L2753" title="1 of 2 branches missed.">			if (buildable != null) {</span>
<span class="fc" id="L2754">				available -= AbstractGoods.getCount(goods.getType(), buildable.getRequiredGoods());</span>
			}

<span class="fc bfc" id="L2757" title="All 2 branches covered.">			if (available &lt; goods.getAmount())</span>
<span class="fc" id="L2758">				return false;</span>
<span class="fc" id="L2759">		}</span>
<span class="fc" id="L2760">		return true;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	public boolean hasContacted(Player player) {
<span class="pc bpc" id="L2767" title="2 of 6 branches missed.">		return player != null &amp;&amp; (player.isEuropean() || getOwner().getStance(player) != Stance.UNCONTACTED);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public StringTemplate getAlarmLevelLabel(Player player) {
<span class="nc" id="L2775">		Stance stance = getOwner().getStance(player);</span>
<span class="nc" id="L2776">		return StringTemplate.template(&quot;model.colony.&quot; + stance.getKey()).addStringTemplate(&quot;%nation%&quot;,</span>
<span class="nc" id="L2777">				getOwner().getNationLabel());</span>
	}

	// Interface TradeLocation
	// getGoodsCount provided in GoodsContainer

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getExportAmount(GoodsType goodsType, int turns) {
<span class="fc" id="L2788">		final int present = Math.max(0, getGoodsCount(goodsType) + turns * getNetProductionOf(goodsType));</span>
<span class="fc" id="L2789">		final ExportData ed = getExportData(goodsType);</span>
<span class="fc" id="L2790">		return Math.max(0, present - ed.getExportLevel());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getImportAmount(GoodsType goodsType, int turns) {
<span class="pc bpc" id="L2798" title="1 of 2 branches missed.">		if (goodsType.limitIgnored())</span>
<span class="nc" id="L2799">			return GoodsContainer.HUGE_CARGO_SIZE;</span>

<span class="fc" id="L2801">		final int present = Math.max(0, getGoodsCount(goodsType) + turns * getNetProductionOf(goodsType));</span>
<span class="fc" id="L2802">		int capacity = getWarehouseCapacity();</span>
<span class="fc" id="L2803">		return Math.max(0, capacity - present);</span>
	}

	//
	// Miscellaneous low level
	//

	/**
	 * Add port ability to non-landlocked colonies.
	 */
	protected void addPortAbility() {
<span class="fc" id="L2814">		addAbility(new Ability(Ability.HAS_PORT));</span>
<span class="fc" id="L2815">	}</span>

	/**
	 * Check the integrity of the build queues. Catches build fails due to
	 * broken requirements.
	 *
	 * @param fix
	 *            Fix problems if possible.
	 * @return Negative if there are problems remaining, zero if problems were
	 *         fixed, positive if no problems found at all.
	 */
	public int checkBuildQueueIntegrity(boolean fix) {
<span class="fc" id="L2827">		int result = 1;</span>
<span class="fc" id="L2828">		List&lt;BuildableType&gt; buildables = buildQueue.getValues();</span>
<span class="fc" id="L2829">		List&lt;BuildableType&gt; assumeBuilt = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2830" title="All 2 branches covered.">		for (int i = 0; i &lt; buildables.size(); i++) {</span>
<span class="fc" id="L2831">			BuildableType bt = buildables.get(i);</span>
<span class="fc" id="L2832">			NoBuildReason reason = getNoBuildReason(bt, assumeBuilt);</span>
<span class="pc bpc" id="L2833" title="1 of 2 branches missed.">			if (reason == NoBuildReason.NONE) {</span>
<span class="fc" id="L2834">				assumeBuilt.add(bt);</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">			} else if (fix) {</span>
<span class="nc" id="L2836">				buildQueue.remove(i);</span>
<span class="nc" id="L2837">				result = Math.min(result, 0);</span>
			} else {
<span class="nc" id="L2839">				result = -1;</span>
			}
		}
<span class="fc" id="L2842">		List&lt;UnitType&gt; unitTypes = populationQueue.getValues();</span>
<span class="fc" id="L2843">		assumeBuilt.clear();</span>
<span class="fc bfc" id="L2844" title="All 2 branches covered.">		for (int i = 0; i &lt; unitTypes.size(); i++) {</span>
<span class="fc" id="L2845">			UnitType ut = unitTypes.get(i);</span>
<span class="fc" id="L2846">			NoBuildReason reason = getNoBuildReason(ut, assumeBuilt);</span>
<span class="pc bpc" id="L2847" title="1 of 2 branches missed.">			if (reason == NoBuildReason.NONE) {</span>
<span class="fc" id="L2848">				assumeBuilt.add(ut);</span>
<span class="nc bnc" id="L2849" title="All 2 branches missed.">			} else if (fix) {</span>
<span class="nc" id="L2850">				populationQueue.remove(i);</span>
<span class="nc" id="L2851">				result = Math.min(result, 0);</span>
			} else {
<span class="nc" id="L2853">				result = -1;</span>
			}
		}
<span class="fc" id="L2856">		return result;</span>
	}

	// Override FreeColGameObject

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int checkIntegrity(boolean fix) {
<span class="nc" id="L2866">		int result = super.checkIntegrity(fix);</span>

		// @compat 0.10.x
<span class="nc bnc" id="L2869" title="All 4 branches missed.">		if (!isLandLocked() &amp;&amp; !hasAbility(Ability.HAS_PORT)) {</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">			if (fix) {</span>
<span class="nc" id="L2871">				addPortAbility();</span>
<span class="nc" id="L2872">				result = Math.min(result, 0);</span>
			} else {
<span class="nc" id="L2874">				result = -1;</span>
			}
		}
		// end @compat 0.10.x

<span class="nc" id="L2879">		return Math.min(result, checkBuildQueueIntegrity(fix));</span>
	}

	// Serialization

	/** The Constant BUILD_QUEUE_TAG. */
	private static final String BUILD_QUEUE_TAG = &quot;buildQueueItem&quot;;

	/** The Constant ESTABLISHED_TAG. */
	private static final String ESTABLISHED_TAG = &quot;established&quot;;

	/** The Constant IMMIGRATION_TAG. */
	private static final String IMMIGRATION_TAG = &quot;immigration&quot;;

	/** The Constant LIBERTY_TAG. */
	private static final String LIBERTY_TAG = &quot;liberty&quot;;

	/** The Constant PRODUCTION_BONUS_TAG. */
	private static final String PRODUCTION_BONUS_TAG = &quot;productionBonus&quot;;

	/** The Constant NAME_TAG. */
	private static final String NAME_TAG = &quot;name&quot;;

	/** The Constant OLD_SONS_OF_LIBERTY_TAG. */
	private static final String OLD_SONS_OF_LIBERTY_TAG = &quot;oldSonsOfLiberty&quot;;

	/** The Constant OLD_TORIES_TAG. */
	private static final String OLD_TORIES_TAG = &quot;oldTories&quot;;

	/** The Constant POPULATION_QUEUE_TAG. */
	private static final String POPULATION_QUEUE_TAG = &quot;populationQueueItem&quot;;

	/** The Constant SONS_OF_LIBERTY_TAG. */
	private static final String SONS_OF_LIBERTY_TAG = &quot;sonsOfLiberty&quot;;

	/** The Constant TORIES_TAG. */
	private static final String TORIES_TAG = &quot;tories&quot;;

	/** The Constant UNIT_COUNT_TAG. */
	private static final String UNIT_COUNT_TAG = &quot;unitCount&quot;;

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2925">		super.writeAttributes(xw);</span>

		// Delegated from Settlement
<span class="fc" id="L2928">		xw.writeAttribute(NAME_TAG, getName());</span>

<span class="fc" id="L2930">		xw.writeAttribute(ESTABLISHED_TAG, established.getNumber());</span>

		// SoL has to be visible for the popular support bonus to be
		// visible to an attacking rebel player.
<span class="fc" id="L2934">		xw.writeAttribute(SONS_OF_LIBERTY_TAG, sonsOfLiberty);</span>

<span class="fc bfc" id="L2936" title="All 2 branches covered.">		if (xw.validFor(getOwner())) {</span>

<span class="fc" id="L2938">			xw.writeAttribute(OLD_SONS_OF_LIBERTY_TAG, oldSonsOfLiberty);</span>

<span class="fc" id="L2940">			xw.writeAttribute(TORIES_TAG, tories);</span>

<span class="fc" id="L2942">			xw.writeAttribute(OLD_TORIES_TAG, oldTories);</span>

<span class="fc" id="L2944">			xw.writeAttribute(LIBERTY_TAG, liberty);</span>

<span class="fc" id="L2946">			xw.writeAttribute(IMMIGRATION_TAG, immigration);</span>

<span class="fc" id="L2948">			xw.writeAttribute(PRODUCTION_BONUS_TAG, productionBonus);</span>

		} else {

<span class="fc" id="L2952">			int uc = getDisplayUnitCount();</span>
<span class="pc bpc" id="L2953" title="1 of 2 branches missed.">			if (uc &lt;= 0) {</span>
<span class="nc" id="L2954">				logger.warning(&quot;Unit count fail: &quot; + uc + &quot; id=&quot; + getId() + &quot; unitCount=&quot; + getUnitCount() + &quot; scope=&quot;</span>
<span class="nc" id="L2955">						+ xw.getWriteScope() + &quot; player=&quot; + xw.getWriteScope().getClient() + &quot;\n&quot;</span>
<span class="nc" id="L2956">						+ net.sf.freecol.common.debug.FreeColDebugger.stackTraceToString());</span>
			}
<span class="fc" id="L2958">			xw.writeAttribute(UNIT_COUNT_TAG, uc);</span>
		}
<span class="fc" id="L2960">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2967">		super.writeChildren(xw);</span>

<span class="fc bfc" id="L2969" title="All 2 branches covered.">		if (xw.validFor(getOwner())) {</span>

<span class="fc bfc" id="L2971" title="All 2 branches covered.">			for (Entry&lt;String, ExportData&gt; e : mapEntriesByKey(exportData)) {</span>
<span class="fc" id="L2972">				e.getValue().toXML(xw);</span>
<span class="fc" id="L2973">			}</span>

<span class="fc bfc" id="L2975" title="All 2 branches covered.">			for (WorkLocation workLocation : getSortedCopy(getAllWorkLocations())) {</span>
<span class="fc" id="L2976">				workLocation.toXML(xw);</span>
<span class="fc" id="L2977">			}</span>

<span class="fc bfc" id="L2979" title="All 2 branches covered.">			for (BuildableType item : buildQueue.getValues()) { // In order!</span>
<span class="fc" id="L2980">				xw.writeStartElement(BUILD_QUEUE_TAG);</span>

<span class="fc" id="L2982">				xw.writeAttribute(ID_ATTRIBUTE_TAG, item);</span>

<span class="fc" id="L2984">				xw.writeEndElement();</span>
<span class="fc" id="L2985">			}</span>

<span class="fc bfc" id="L2987" title="All 2 branches covered.">			for (BuildableType item : populationQueue.getValues()) { // In order</span>
<span class="fc" id="L2988">				xw.writeStartElement(POPULATION_QUEUE_TAG);</span>

<span class="fc" id="L2990">				xw.writeAttribute(ID_ATTRIBUTE_TAG, item);</span>

<span class="fc" id="L2992">				xw.writeEndElement();</span>
<span class="fc" id="L2993">			}</span>

		} else {
			// Special case. Serialize stockade-class buildings to
			// otherwise unprivileged clients as the stockade level is
			// visible to anyone who can see the colony. This should
			// have no other information leaks because stockade
			// buildings have no production or units inside.
<span class="fc" id="L3001">			Building stockade = getStockade();</span>
<span class="pc bpc" id="L3002" title="1 of 2 branches missed.">			if (stockade != null)</span>
<span class="nc" id="L3003">				stockade.toXML(xw);</span>
		}
<span class="fc" id="L3005">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L3012">		super.readAttributes(xr);</span>

<span class="fc" id="L3014">		established = new Turn(xr.getAttribute(ESTABLISHED_TAG, 0));</span>

<span class="fc" id="L3016">		sonsOfLiberty = xr.getAttribute(SONS_OF_LIBERTY_TAG, 0);</span>

<span class="fc" id="L3018">		oldSonsOfLiberty = xr.getAttribute(OLD_SONS_OF_LIBERTY_TAG, 0);</span>

<span class="fc" id="L3020">		tories = xr.getAttribute(TORIES_TAG, 0);</span>

<span class="fc" id="L3022">		oldTories = xr.getAttribute(OLD_TORIES_TAG, 0);</span>

<span class="fc" id="L3024">		liberty = xr.getAttribute(LIBERTY_TAG, 0);</span>

<span class="fc" id="L3026">		immigration = xr.getAttribute(IMMIGRATION_TAG, 0);</span>

<span class="fc" id="L3028">		productionBonus = xr.getAttribute(PRODUCTION_BONUS_TAG, 0);</span>

<span class="fc" id="L3030">		displayUnitCount = xr.getAttribute(UNIT_COUNT_TAG, -1);</span>
<span class="fc" id="L3031">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// Clear containers.
<span class="fc" id="L3039">		colonyTiles.clear();</span>
<span class="fc" id="L3040">		buildingMap.clear();</span>
<span class="fc" id="L3041">		exportData.clear();</span>
<span class="fc" id="L3042">		buildQueue.clear();</span>
<span class="fc" id="L3043">		populationQueue.clear();</span>

<span class="fc" id="L3045">		super.readChildren(xr);</span>

<span class="fc" id="L3047">		invalidateCache();</span>
<span class="fc" id="L3048">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L3055">		final Specification spec = getSpecification();</span>
<span class="fc" id="L3056">		final Game game = getGame();</span>
<span class="fc" id="L3057">		final String tag = xr.getLocalName();</span>

<span class="fc bfc" id="L3059" title="All 2 branches covered.">		if (BUILD_QUEUE_TAG.equals(tag)) {</span>
<span class="fc" id="L3060">			BuildableType bt = xr.getType(spec, ID_ATTRIBUTE_TAG, BuildableType.class, (BuildableType) null);</span>
<span class="pc bpc" id="L3061" title="1 of 2 branches missed.">			if (bt != null)</span>
<span class="fc" id="L3062">				buildQueue.add(bt);</span>
<span class="fc" id="L3063">			xr.closeTag(BUILD_QUEUE_TAG);</span>

<span class="fc bfc" id="L3065" title="All 2 branches covered.">		} else if (POPULATION_QUEUE_TAG.equals(xr.getLocalName())) {</span>
<span class="fc" id="L3066">			UnitType ut = xr.getType(spec, ID_ATTRIBUTE_TAG, UnitType.class, (UnitType) null);</span>
<span class="pc bpc" id="L3067" title="1 of 2 branches missed.">			if (ut != null)</span>
<span class="fc" id="L3068">				populationQueue.add(ut);</span>
<span class="fc" id="L3069">			xr.closeTag(POPULATION_QUEUE_TAG);</span>

<span class="fc bfc" id="L3071" title="All 2 branches covered.">		} else if (Building.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L3072">			addBuilding(xr.readFreeColGameObject(game, Building.class));</span>

<span class="fc bfc" id="L3074" title="All 2 branches covered.">		} else if (ColonyTile.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L3075">			colonyTiles.add(xr.readFreeColGameObject(game, ColonyTile.class));</span>

<span class="fc bfc" id="L3077" title="All 2 branches covered.">		} else if (ExportData.getXMLElementTagName().equals(tag)) {</span>
<span class="fc" id="L3078">			ExportData data = new ExportData(xr);</span>
<span class="fc" id="L3079">			exportData.put(data.getId(), data);</span>

<span class="fc" id="L3081">		} else {</span>
<span class="fc" id="L3082">			super.readChild(xr);</span>
		}
<span class="fc" id="L3084">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="fc" id="L3091">		return getName();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="fc" id="L3099">		return getXMLElementTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;colony&quot;.
	 */
	public static String getXMLElementTagName() {
<span class="fc" id="L3108">		return &quot;colony&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>