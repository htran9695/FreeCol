<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapViewer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.client.gui</a> &gt; <span class="el_source">MapViewer.java</span></div><h1>MapViewer.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.client.gui;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;

import net.sf.freecol.client.ClientOptions;
import net.sf.freecol.client.FreeColClient;
import net.sf.freecol.common.debug.FreeColDebugger;
import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.BuildableType;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.FreeColGameObject;
import net.sf.freecol.common.model.Game;
import net.sf.freecol.common.model.IndianSettlement;
import net.sf.freecol.common.model.Map;
import net.sf.freecol.common.model.PathNode;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Region;
import net.sf.freecol.common.model.Settlement;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Turn;
import net.sf.freecol.common.model.Unit;

import static net.sf.freecol.common.util.StringUtils.*;

/**
 * MapViewer is a private helper class of Canvas and SwingGUI.
 * 
 * This class is responsible for drawing the map/background on the
 * &lt;code&gt;Canvas&lt;/code&gt;. In addition, the graphical state of the map (focus,
 * active unit..) is currently handled by this class.
 */
public final class MapViewer {

	/** The Constant logger. */
<span class="nc" id="L82">	private static final Logger logger = Logger.getLogger(MapViewer.class.getName());</span>

	/**
	 * The Enum BorderType.
	 */
<span class="nc" id="L87">	private static enum BorderType {</span>
		/** The country. */
<span class="nc" id="L89">		COUNTRY,</span>
		/** The region. */
<span class="nc" id="L91">		REGION</span>
	}

	/**
	 * The Class TextSpecification.
	 */
	private static class TextSpecification {

		/** The text. */
		public final String text;

		/** The font. */
		public final Font font;

		/**
		 * Instantiates a new text specification.
		 *
		 * @param newText
		 *            the new text
		 * @param newFont
		 *            the new font
		 */
<span class="nc" id="L113">		public TextSpecification(String newText, Font newFont) {</span>
<span class="nc" id="L114">			text = newText;</span>
<span class="nc" id="L115">			font = newFont;</span>
<span class="nc" id="L116">		}</span>
	}

	/** The free col client. */
	private final FreeColClient freeColClient;

	/** The gui. */
	private final SwingGUI gui;

	/** The size. */
	private Dimension size;

	/** Scaled ImageLibrary only used for map painting. */
	private ImageLibrary lib;

	/** The tv. */
	private final TileViewer tv;

	/** The cursor. */
	private TerrainCursor cursor;

	/** The selected tile. */
	private Tile selectedTile;

	/** The focus. */
<span class="nc" id="L141">	private Tile focus = null;</span>

	/** The active unit. */
	private Unit activeUnit;

	/** The view mode in use. */
<span class="nc" id="L147">	private int viewMode = 0;</span>

	/** A path to be displayed on the map. */
	private PathNode currentPath;

	/** A path for a current goto order. */
<span class="nc" id="L153">	private PathNode gotoPath = null;</span>

	/** The goto started. */
<span class="nc" id="L156">	private boolean gotoStarted = false;</span>

	/** The right space. */
	// Helper variables for displaying the map.
	private int tileHeight, tileWidth, halfHeight, halfWidth, topSpace, topRows, /* bottomSpace, */ bottomRows,
			leftSpace, rightSpace;

	/** The bottom row. */
	// The y-coordinate of the Tiles that will be drawn at the bottom
<span class="nc" id="L165">	private int bottomRow = -1;</span>

	/** The top row. */
	// The y-coordinate of the Tiles that will be drawn at the top
	private int topRow;

	// The y-coordinate on the screen (in pixels) of the images of the
	/** The bottom row Y. */
	// Tiles that will be drawn at the bottom
	private int bottomRowY;

	// The y-coordinate on the screen (in pixels) of the images of the
	/** The top row Y. */
	// Tiles that will be drawn at the top
	private int topRowY;

	/** The left column. */
	// The x-coordinate of the Tiles that will be drawn at the left side
	private int leftColumn;

	/** The right column. */
	// The x-coordinate of the Tiles that will be drawn at the right side
	private int rightColumn;

	// The x-coordinate on the screen (in pixels) of the images of the
	/** The left column X. */
	// Tiles that will be drawn at the left (can be less than 0)
	private int leftColumnX;

	/** The aligned right. */
	// Whether the map is currently aligned with the edge.
<span class="nc" id="L196">	private boolean alignedTop = false, alignedBottom = false, alignedLeft = false, alignedRight = false;</span>

	/** The Constant MAP_SCALE_MIN. */
	// How the map can be scaled
	private static final float MAP_SCALE_MIN = 0.25f;

	/** The Constant MAP_SCALE_MAX. */
	private static final float MAP_SCALE_MAX = 2.0f;

	/** The Constant MAP_SCALE_STEP. */
	private static final float MAP_SCALE_STEP = 0.25f;

	/** The Constant MAX_OTHER_UNITS. */
	// The height offset to paint a Unit at (in pixels).
	private static final int UNIT_OFFSET = 20, OTHER_UNITS_OFFSET_X = -5, // Relative
																			// to
																			// the
																			// state
																			// indicator.
			OTHER_UNITS_OFFSET_Y = 1, OTHER_UNITS_WIDTH = 3, MAX_OTHER_UNITS = 10;

	/** The units out for animation. */
	private final java.util.Map&lt;Unit, Integer&gt; unitsOutForAnimation;

	/** The units out for animation labels. */
	private final java.util.Map&lt;Unit, JLabel&gt; unitsOutForAnimationLabels;

	/** The border points. */
	// borders
<span class="nc" id="L225">	private final EnumMap&lt;Direction, Point2D.Float&gt; borderPoints = new EnumMap&lt;&gt;(Direction.class);</span>

	/** The control points. */
<span class="nc" id="L228">	private final EnumMap&lt;Direction, Point2D.Float&gt; controlPoints = new EnumMap&lt;&gt;(Direction.class);</span>

	/** The border stroke. */
<span class="nc" id="L231">	private Stroke borderStroke = new BasicStroke(4);</span>

	/** The grid stroke. */
<span class="nc" id="L234">	private Stroke gridStroke = new BasicStroke(1);</span>

	/**
	 * The constructor to use.
	 *
	 * @param freeColClient
	 *            The &lt;code&gt;FreeColClient&lt;/code&gt; for the game.
	 */
<span class="nc" id="L242">	MapViewer(FreeColClient freeColClient) {</span>
<span class="nc" id="L243">		this.freeColClient = freeColClient;</span>
<span class="nc" id="L244">		this.gui = (SwingGUI) freeColClient.getGUI();</span>
<span class="nc" id="L245">		this.size = null;</span>

<span class="nc" id="L247">		tv = new TileViewer(freeColClient);</span>
<span class="nc" id="L248">		setImageLibraryAndUpdateData(new ImageLibrary());</span>

<span class="nc" id="L250">		cursor = null;</span>

<span class="nc" id="L252">		unitsOutForAnimation = new HashMap&lt;&gt;();</span>
<span class="nc" id="L253">		unitsOutForAnimationLabels = new HashMap&lt;&gt;();</span>
<span class="nc" id="L254">	}</span>

	/**
	 * Gets the contained &lt;code&gt;ImageLibrary&lt;/code&gt;.
	 * 
	 * @return The image library;
	 */
	ImageLibrary getImageLibrary() {
<span class="nc" id="L262">		return lib;</span>
	}

	/**
	 * Get the view mode.
	 *
	 * @return The view mode.
	 */
	int getViewMode() {
<span class="nc" id="L271">		return viewMode;</span>
	}

	/**
	 * Toggle the current view mode.
	 */
	void toggleViewMode() {
<span class="nc" id="L278">		changeViewMode(1 - viewMode);</span>
<span class="nc" id="L279">	}</span>

	/**
	 * Change the view mode to a new one.
	 *
	 * @param newViewMode
	 *            The new view mode.
	 */
	void changeViewMode(int newViewMode) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">		if (newViewMode != viewMode) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">			logger.fine(</span>
					&quot;Changed to &quot; + ((newViewMode == GUI.MOVE_UNITS_MODE) ? &quot;Move Units&quot; : &quot;View Terrain&quot;) + &quot; mode&quot;);
<span class="nc" id="L291">			viewMode = newViewMode;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">			if (viewMode == GUI.MOVE_UNITS_MODE)</span>
<span class="nc" id="L293">				restartBlinking();</span>
			else
<span class="nc" id="L295">				stopBlinking();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			if (activeUnit != null) {</span>
<span class="nc" id="L297">				Tile tile = activeUnit.getTile();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">				if (isTileVisible(tile))</span>
<span class="nc" id="L299">					gui.refreshTile(tile);</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">				if (selectedTile != tile &amp;&amp; isTileVisible(selectedTile))</span>
<span class="nc" id="L301">					gui.refreshTile(selectedTile);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">			} else if (isTileVisible(selectedTile))</span>
<span class="nc" id="L303">				gui.refreshTile(selectedTile);</span>
<span class="nc" id="L304">			gui.updateMapControls();</span>
		}
<span class="nc" id="L306">	}</span>

	/**
	 * Centers the map on the selected unit.
	 */
	void centerActiveUnit() {
<span class="nc bnc" id="L312" title="All 4 branches missed.">		if (activeUnit != null &amp;&amp; activeUnit.getTile() != null) {</span>
<span class="nc" id="L313">			gui.setFocus(activeUnit.getTile());</span>
		}
<span class="nc" id="L315">	}</span>

	/**
	 * Converts the given screen coordinates to Map coordinates. It checks to
	 * see to which Tile the given pixel 'belongs'.
	 *
	 * @param x
	 *            The x-coordinate in pixels.
	 * @param y
	 *            The y-coordinate in pixels.
	 * @return The Tile that is located at the given position on the screen.
	 */
	Tile convertToMapTile(int x, int y) {
<span class="nc" id="L328">		final Game game = freeColClient.getGame();</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">		if (game == null || game.getMap() == null)</span>
<span class="nc" id="L330">			return null;</span>

		int leftOffset;
<span class="nc bnc" id="L333" title="All 2 branches missed.">		if (focus.getX() &lt; getLeftColumns()) {</span>
			// we are at the left side of the map
<span class="nc bnc" id="L335" title="All 2 branches missed.">			if ((focus.getY() &amp; 1) == 0) {</span>
<span class="nc" id="L336">				leftOffset = tileWidth * focus.getX() + halfWidth;</span>
			} else {
<span class="nc" id="L338">				leftOffset = tileWidth * (focus.getX() + 1);</span>
			}
<span class="nc bnc" id="L340" title="All 2 branches missed.">		} else if (focus.getX() &gt;= (game.getMap().getWidth() - getRightColumns())) {</span>
			// we are at the right side of the map
<span class="nc bnc" id="L342" title="All 2 branches missed.">			if ((focus.getY() &amp; 1) == 0) {</span>
<span class="nc" id="L343">				leftOffset = size.width - (game.getMap().getWidth() - focus.getX()) * tileWidth;</span>
			} else {
<span class="nc" id="L345">				leftOffset = size.width - (game.getMap().getWidth() - focus.getX() - 1) * tileWidth - halfWidth;</span>
			}
		} else {
<span class="nc bnc" id="L348" title="All 2 branches missed.">			if ((focus.getY() &amp; 1) == 0) {</span>
<span class="nc" id="L349">				leftOffset = (size.width / 2);</span>
			} else {
<span class="nc" id="L351">				leftOffset = (size.width / 2) + halfWidth;</span>
			}
		}

		int topOffset;
<span class="nc bnc" id="L356" title="All 2 branches missed.">		if (focus.getY() &lt; topRows) {</span>
			// we are at the top of the map
<span class="nc" id="L358">			topOffset = (focus.getY() + 1) * (halfHeight);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">		} else if (focus.getY() &gt;= (game.getMap().getHeight() - bottomRows)) {</span>
			// we are at the bottom of the map
<span class="nc" id="L361">			topOffset = size.height - (game.getMap().getHeight() - focus.getY()) * (halfHeight);</span>
		} else {
<span class="nc" id="L363">			topOffset = (size.height / 2);</span>
		}

		// At this point (leftOffset, topOffset) is the center pixel
		// of the Tile that was on focus (= the Tile that should have
		// been drawn at the center of the screen if possible).

		// Next, we can calculate the center pixel of the tile-sized
		// rectangle that was clicked. First, we calculate the
		// difference in units of rows and columns.
<span class="nc bnc" id="L373" title="All 2 branches missed.">		int dcol = (x - leftOffset + (x &gt; leftOffset ? halfWidth : -halfWidth)) / tileWidth;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		int drow = (y - topOffset + (y &gt; topOffset ? halfHeight : -halfHeight)) / tileHeight;</span>
<span class="nc" id="L375">		int px = leftOffset + dcol * tileWidth;</span>
<span class="nc" id="L376">		int py = topOffset + drow * tileHeight;</span>
		// Since rows are shifted, we need to correct.
<span class="nc" id="L378">		int newCol = focus.getX() + dcol;</span>
<span class="nc" id="L379">		int newRow = focus.getY() + drow * 2;</span>
<span class="nc" id="L380">		logger.finest(&quot;Old focus was &quot; + focus.getX() + &quot;, &quot; + focus.getY() + &quot;. Preliminary focus is &quot; + newCol + &quot;, &quot;</span>
				+ newRow + &quot;.&quot;);
		// Now, we check whether the central diamond of the calculated
		// rectangle was clicked, and adjust rows and columns
		// accordingly. See Direction.
<span class="nc" id="L385">		Direction direction = null;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">		if (x &gt; px) {</span>
			// right half of the rectangle
<span class="nc bnc" id="L388" title="All 2 branches missed.">			if (y &gt; py) {</span>
				// bottom right
<span class="nc bnc" id="L390" title="All 2 branches missed.">				if ((y - py) &gt; halfHeight - (x - px) / 2) {</span>
<span class="nc" id="L391">					direction = Direction.SE;</span>
				}
			} else {
				// top right
<span class="nc bnc" id="L395" title="All 2 branches missed.">				if ((y - py) &lt; (x - px) / 2 - halfHeight) {</span>
<span class="nc" id="L396">					direction = Direction.NE;</span>
				}

			}
		} else {
			// left half of the rectangle
<span class="nc bnc" id="L402" title="All 2 branches missed.">			if (y &gt; py) {</span>
				// bottom left
<span class="nc bnc" id="L404" title="All 2 branches missed.">				if ((y - py) &gt; (x - px) / 2 + halfHeight) {</span>
<span class="nc" id="L405">					direction = Direction.SW;</span>
				}
			} else {
				// top left
<span class="nc bnc" id="L409" title="All 2 branches missed.">				if ((y - py) &lt; (px - x) / 2 - halfHeight) {</span>
<span class="nc" id="L410">					direction = Direction.NW;</span>
				}
			}
		}
<span class="nc" id="L414">		int col = newCol;</span>
<span class="nc" id="L415">		int row = newRow;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">		if (direction != null) {</span>
<span class="nc" id="L417">			Map.Position step = direction.step(newCol, newRow);</span>
<span class="nc" id="L418">			col = step.x;</span>
<span class="nc" id="L419">			row = step.y;</span>
		}
<span class="nc" id="L421">		logger.finest(&quot;Direction is &quot; + direction + &quot;, new focus is &quot; + col + &quot;, &quot; + row);</span>
<span class="nc" id="L422">		return freeColClient.getGame().getMap().getTile(col, row);</span>

	}

	/**
	 * Run some code with the given unit made invisible. You can nest several of
	 * these method calls in order to hide multiple units. There are no problems
	 * related to nested calls with the same unit.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to be hidden.
	 * @param sourceTile
	 *            The source &lt;code&gt;Tile&lt;/code&gt;.
	 * @param r
	 *            The code to be executed.
	 */
	void executeWithUnitOutForAnimation(final Unit unit, final Tile sourceTile, final OutForAnimationCallback r) {
<span class="nc" id="L439">		final JLabel unitLabel = enterUnitOutForAnimation(unit, sourceTile);</span>
		try {
<span class="nc" id="L441">			r.executeWithUnitOutForAnimation(unitLabel);</span>
		} finally {
<span class="nc" id="L443">			releaseUnitOutForAnimation(unit);</span>
<span class="nc" id="L444">		}</span>
<span class="nc" id="L445">	}</span>

	/**
	 * Enter unit out for animation.
	 *
	 * @param unit
	 *            the unit
	 * @param sourceTile
	 *            the source tile
	 * @return the j label
	 */
	private JLabel enterUnitOutForAnimation(final Unit unit, final Tile sourceTile) {
<span class="nc" id="L457">		Integer i = unitsOutForAnimation.get(unit);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">		if (i == null) {</span>
<span class="nc" id="L459">			final JLabel unitLabel = createUnitLabel(unit);</span>

<span class="nc" id="L461">			i = 1;</span>
<span class="nc" id="L462">			unitLabel.setLocation(calculateUnitLabelPositionInTile(unitLabel.getWidth(), unitLabel.getHeight(),</span>
<span class="nc" id="L463">					calculateTilePosition(sourceTile)));</span>
<span class="nc" id="L464">			unitsOutForAnimationLabels.put(unit, unitLabel);</span>
<span class="nc" id="L465">			gui.getCanvas().add(unitLabel, JLayeredPane.DEFAULT_LAYER);</span>
<span class="nc" id="L466">		} else {</span>
<span class="nc" id="L467">			i++;</span>
		}
<span class="nc" id="L469">		unitsOutForAnimation.put(unit, i);</span>
<span class="nc" id="L470">		return unitsOutForAnimationLabels.get(unit);</span>
	}

	/**
	 * Release unit out for animation.
	 *
	 * @param unit
	 *            the unit
	 */
	private void releaseUnitOutForAnimation(final Unit unit) {
<span class="nc" id="L480">		Integer i = unitsOutForAnimation.get(unit);</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">		if (i == null) {</span>
<span class="nc" id="L482">			throw new IllegalStateException(&quot;Tried to release unit that was not out for animation&quot;);</span>
		}
<span class="nc bnc" id="L484" title="All 2 branches missed.">		if (i == 1) {</span>
<span class="nc" id="L485">			unitsOutForAnimation.remove(unit);</span>
<span class="nc" id="L486">			gui.getCanvas().removeFromCanvas(unitsOutForAnimationLabels.remove(unit));</span>
		} else {
<span class="nc" id="L488">			i--;</span>
<span class="nc" id="L489">			unitsOutForAnimation.put(unit, i);</span>
		}
<span class="nc" id="L491">	}</span>

	/**
	 * Returns true if the given Unit is being animated.
	 *
	 * @param unit
	 *            an &lt;code&gt;Unit&lt;/code&gt;
	 * @return a &lt;code&gt;boolean&lt;/code&gt;
	 */
	private boolean isOutForAnimation(final Unit unit) {
<span class="nc" id="L501">		return unitsOutForAnimation.containsKey(unit);</span>
	}

	/**
	 * Draw the unit's image and occupation indicator in one JLabel object.
	 *
	 * @param unit
	 *            The unit to be drawn
	 * @return A JLabel object with the unit's image.
	 */
	private JLabel createUnitLabel(Unit unit) {
<span class="nc" id="L512">		final BufferedImage unitImg = lib.getUnitImage(unit);</span>
<span class="nc" id="L513">		final int width = halfWidth + unitImg.getWidth() / 2;</span>
<span class="nc" id="L514">		final int height = unitImg.getHeight();</span>

<span class="nc" id="L516">		BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L517">		Graphics2D g = img.createGraphics();</span>

<span class="nc" id="L519">		final int unitX = (width - unitImg.getWidth()) / 2;</span>
<span class="nc" id="L520">		g.drawImage(unitImg, unitX, 0, null);</span>

<span class="nc" id="L522">		Player player = freeColClient.getMyPlayer();</span>
<span class="nc" id="L523">		String text = Messages.message(unit.getOccupationLabel(player, false));</span>
<span class="nc" id="L524">		g.drawImage(lib.getOccupationIndicatorChip(g, unit, text), 0, 0, null);</span>

<span class="nc" id="L526">		final JLabel label = new JLabel(new ImageIcon(img));</span>
<span class="nc" id="L527">		label.setSize(width, height);</span>

<span class="nc" id="L529">		g.dispose();</span>
<span class="nc" id="L530">		return label;</span>
	}

	/**
	 * Calculate the bounds of the rectangle containing a Tile on the screen,
	 * and return it. If the Tile is not on-screen a maximal rectangle is
	 * returned. The bounds includes a one-tile padding area above the Tile, to
	 * include the space needed by any units in the Tile.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; on the screen.
	 * @return The bounds &lt;code&gt;Rectangle&lt;/code&gt;.
	 */
	Rectangle calculateTileBounds(Tile tile) {
<span class="nc" id="L544">		Rectangle result = new Rectangle(0, 0, size.width, size.height);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">		if (isTileVisible(tile)) {</span>
<span class="nc" id="L546">			result.x = ((tile.getX() - leftColumn) * tileWidth) + leftColumnX;</span>
<span class="nc" id="L547">			result.y = ((tile.getY() - topRow) * halfHeight) + topRowY - tileHeight;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">			if ((tile.getY() &amp; 1) != 0) {</span>
<span class="nc" id="L549">				result.x += halfWidth;</span>
			}
<span class="nc" id="L551">			result.width = tileWidth;</span>
<span class="nc" id="L552">			result.height = tileHeight * 2;</span>
		}
<span class="nc" id="L554">		return result;</span>
	}

	/**
	 * Gets the position of the given &lt;code&gt;Tile&lt;/code&gt; on the drawn map.
	 *
	 * @param t
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return The position of the given &lt;code&gt;Tile&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
	 *         if the &lt;code&gt;Tile&lt;/code&gt; is not drawn on the mapboard.
	 */
	Point calculateTilePosition(Tile t) {
<span class="nc" id="L566">		repositionMapIfNeeded();</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">		if (!isTileVisible(t))</span>
<span class="nc" id="L568">			return null;</span>

<span class="nc" id="L570">		int x = ((t.getX() - leftColumn) * tileWidth) + leftColumnX;</span>
<span class="nc" id="L571">		int y = ((t.getY() - topRow) * halfHeight) + topRowY;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">		if ((t.getY() &amp; 1) != 0)</span>
<span class="nc" id="L573">			x += halfWidth;</span>
<span class="nc" id="L574">		return new Point(x, y);</span>
	}

	/**
	 * Gets the tile width.
	 *
	 * @return the tile width
	 */
	int getTileWidth() {
<span class="nc" id="L583">		return tileWidth;</span>
	}

	/**
	 * Gets the position where a unitLabel located at tile should be drawn.
	 *
	 * @param labelWidth
	 *            The width of the unit label.
	 * @param labelHeight
	 *            The width of the unit label.
	 * @param tileP
	 *            The position of the Tile on the screen.
	 * @return The position where to put the label, null if tileP is null.
	 */
	Point calculateUnitLabelPositionInTile(int labelWidth, int labelHeight, Point tileP) {
<span class="nc bnc" id="L598" title="All 2 branches missed.">		if (tileP != null) {</span>
<span class="nc" id="L599">			int labelX = tileP.x + tileWidth / 2 - labelWidth / 2;</span>
<span class="nc" id="L600">			int labelY = tileP.y + tileHeight / 2 - labelHeight / 2 - (int) (UNIT_OFFSET * lib.getScaleFactor());</span>
<span class="nc" id="L601">			return new Point(labelX, labelY);</span>
		} else {
<span class="nc" id="L603">			return null;</span>
		}
	}

	/**
	 * Checks if the Tile/Units at the given coordinates are displayed on the
	 * screen (or, if the map is already displayed and the focus has been
	 * changed, whether they will be displayed on the screen the next time it'll
	 * be redrawn).
	 *
	 * @param tileToCheck
	 *            The position of the Tile in question.
	 * @return &lt;i&gt;true&lt;/i&gt; if the Tile will be drawn on the screen, &lt;i&gt;false&lt;/i&gt;
	 *         otherwise.
	 */
	boolean onScreen(Tile tileToCheck) {
<span class="nc bnc" id="L619" title="All 2 branches missed.">		if (tileToCheck == null)</span>
<span class="nc" id="L620">			return false;</span>
<span class="nc" id="L621">		repositionMapIfNeeded();</span>
<span class="nc bnc" id="L622" title="All 8 branches missed.">		return (tileToCheck.getY() - 2 &gt; topRow || alignedTop) &amp;&amp; (tileToCheck.getY() + 4 &lt; bottomRow || alignedBottom)</span>
<span class="nc bnc" id="L623" title="All 4 branches missed.">				&amp;&amp; (tileToCheck.getX() - 1 &gt; leftColumn || alignedLeft)</span>
<span class="nc bnc" id="L624" title="All 4 branches missed.">				&amp;&amp; (tileToCheck.getX() + 2 &lt; rightColumn || alignedRight);</span>
	}

	/**
	 * Starts the unit-selection-cursor blinking animation.
	 */
	void startCursorBlinking() {
<span class="nc" id="L631">		cursor = new TerrainCursor();</span>
<span class="nc" id="L632">		cursor.addActionListener((ActionEvent ae) -&gt; {</span>
<span class="nc" id="L633">			Unit unit = activeUnit;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">			if (unit != null) {</span>
<span class="nc" id="L635">				Tile tile = unit.getTile();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">				if (isTileVisible(tile))</span>
<span class="nc" id="L637">					gui.refreshTile(tile);</span>
			}
<span class="nc" id="L639">		});</span>
<span class="nc" id="L640">		cursor.startBlinking();</span>
<span class="nc" id="L641">	}</span>

	/**
	 * Stop blinking.
	 */
	void stopBlinking() {
<span class="nc" id="L647">		cursor.stopBlinking();</span>
<span class="nc" id="L648">	}</span>

	/**
	 * Restart blinking.
	 */
	void restartBlinking() {
<span class="nc" id="L654">		cursor.startBlinking();</span>
<span class="nc" id="L655">	}</span>

	/**
	 * Gets the focus of the map. That is the center tile of the displayed map.
	 *
	 * @return The center tile of the displayed map
	 * @see #setFocus(Tile)
	 */
	Tile getFocus() {
<span class="nc" id="L664">		return focus;</span>
	}

	/**
	 * Sets the focus of the map.
	 *
	 * @param focus
	 *            The &lt;code&gt;Position&lt;/code&gt; of the center tile of the displayed
	 *            map.
	 * @see #getFocus
	 */
	void setFocus(Tile focus) {
<span class="nc" id="L676">		this.focus = focus;</span>
<span class="nc" id="L677">		forceReposition();</span>
<span class="nc" id="L678">	}</span>

	/**
	 * Sets the focus of the map but offset to the left or right so that the
	 * focus position can still be visible when a popup is raised. If
	 * successful, the supplied position will either be at the center of the
	 * left or right half of the map.
	 *
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to display.
	 * @return Positive if the focus is on the right hand side, negative if on
	 *         the left, zero on failure.
	 * @see #getFocus
	 */
	int setOffsetFocus(Tile tile) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">		if (tile == null)</span>
<span class="nc" id="L694">			return 0;</span>
		int where;
<span class="nc" id="L696">		final Map map = freeColClient.getGame().getMap();</span>
<span class="nc" id="L697">		final int tx = tile.getX(), ty = tile.getY(), width = rightColumn - leftColumn;</span>
<span class="nc" id="L698">		int moveX = -1;</span>
<span class="nc" id="L699">		gui.setFocus(tile);</span>
<span class="nc" id="L700">		positionMap(tile);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">		if (leftColumn &lt;= 0) { // At left edge already</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">			if (tx &lt;= width / 4) {</span>
<span class="nc" id="L703">				where = -1;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">			} else if (tx &gt;= 3 * width / 4) {</span>
<span class="nc" id="L705">				where = 1;</span>
			} else {
<span class="nc" id="L707">				moveX = tx + width / 4;</span>
<span class="nc" id="L708">				where = -1;</span>
			}
<span class="nc bnc" id="L710" title="All 2 branches missed.">		} else if (rightColumn &gt;= width - 1) { // At right edge</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">			if (tx &gt;= rightColumn - width / 4) {</span>
<span class="nc" id="L712">				where = 1;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">			} else if (tx &lt;= rightColumn - 3 * width / 4) {</span>
<span class="nc" id="L714">				where = -1;</span>
			} else {
<span class="nc" id="L716">				moveX = tx - width / 4;</span>
<span class="nc" id="L717">				where = 1;</span>
			}
		} else { // Move focus left 1/4 screen
<span class="nc" id="L720">			moveX = tx - width / 4;</span>
<span class="nc" id="L721">			where = 1;</span>
		}
<span class="nc bnc" id="L723" title="All 2 branches missed.">		if (moveX &gt;= 0) {</span>
<span class="nc" id="L724">			Tile other = map.getTile(moveX, ty);</span>
<span class="nc" id="L725">			gui.setFocus(other);</span>
<span class="nc" id="L726">			positionMap(other);</span>
		}
<span class="nc" id="L728">		return where;</span>
	}

	/**
	 * Force the next screen repaint to reposition the tiles on the window.
	 */
	void forceReposition() {
<span class="nc" id="L735">		bottomRow = -1;</span>
<span class="nc" id="L736">	}</span>

	/**
	 * Reposition map if needed.
	 */
	private void repositionMapIfNeeded() {
<span class="nc bnc" id="L742" title="All 4 branches missed.">		if (bottomRow &lt; 0 &amp;&amp; focus != null)</span>
<span class="nc" id="L743">			positionMap(focus);</span>
<span class="nc" id="L744">	}</span>

	/**
	 * Position the map so that the supplied tile is displayed at the center.
	 *
	 * @param pos
	 *            The &lt;code&gt;Tile&lt;/code&gt; to center at.
	 */
	private void positionMap(Tile pos) {
<span class="nc" id="L753">		final Game game = freeColClient.getGame();</span>
<span class="nc" id="L754">		int x = pos.getX(), y = pos.getY();</span>
<span class="nc" id="L755">		int leftColumns = getLeftColumns(), rightColumns = getRightColumns();</span>

		/*
		 * PART 1 ====== Calculate: bottomRow, topRow, bottomRowY, topRowY This
		 * will tell us which rows need to be drawn on the screen (from
		 * bottomRow until and including topRow). bottomRowY will tell us at
		 * which height the bottom row needs to be drawn.
		 */
<span class="nc" id="L763">		alignedTop = false;</span>
<span class="nc" id="L764">		alignedBottom = false;</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">		if (y &lt; topRows) {</span>
<span class="nc" id="L766">			alignedTop = true;</span>
			// We are at the top of the map
<span class="nc" id="L768">			bottomRow = (size.height / (halfHeight)) - 1;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">			if ((size.height % (halfHeight)) != 0) {</span>
<span class="nc" id="L770">				bottomRow++;</span>
			}
<span class="nc" id="L772">			topRow = 0;</span>
<span class="nc" id="L773">			bottomRowY = bottomRow * (halfHeight);</span>
<span class="nc" id="L774">			topRowY = 0;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">		} else if (y &gt;= (game.getMap().getHeight() - bottomRows)) {</span>
<span class="nc" id="L776">			alignedBottom = true;</span>
			// We are at the bottom of the map
<span class="nc" id="L778">			bottomRow = game.getMap().getHeight() - 1;</span>

<span class="nc" id="L780">			topRow = size.height / (halfHeight);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">			if ((size.height % (halfHeight)) &gt; 0) {</span>
<span class="nc" id="L782">				topRow++;</span>
			}
<span class="nc" id="L784">			topRow = game.getMap().getHeight() - topRow;</span>

<span class="nc" id="L786">			bottomRowY = size.height - tileHeight;</span>
<span class="nc" id="L787">			topRowY = bottomRowY - (bottomRow - topRow) * (halfHeight);</span>
		} else {
			// We are not at the top of the map and not at the bottom
<span class="nc" id="L790">			bottomRow = y + bottomRows - 1;</span>
<span class="nc" id="L791">			topRow = y - topRows;</span>
<span class="nc" id="L792">			bottomRowY = topSpace + (halfHeight) * bottomRows;</span>
<span class="nc" id="L793">			topRowY = topSpace - topRows * (halfHeight);</span>
		}

		/*
		 * PART 2 ====== Calculate: leftColumn, rightColumn, leftColumnX This
		 * will tell us which columns need to be drawn on the screen (from
		 * leftColumn until and including rightColumn). leftColumnX will tell us
		 * at which x-coordinate the left column needs to be drawn (this is for
		 * the Tiles where y&amp;1 == 0; the others should be halfWidth more to the
		 * right).
		 */

<span class="nc" id="L805">		alignedLeft = false;</span>
<span class="nc" id="L806">		alignedRight = false;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">		if (x &lt; leftColumns) {</span>
			// We are at the left side of the map
<span class="nc" id="L809">			leftColumn = 0;</span>

<span class="nc" id="L811">			rightColumn = size.width / tileWidth - 1;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">			if ((size.width % tileWidth) &gt; 0) {</span>
<span class="nc" id="L813">				rightColumn++;</span>
			}

<span class="nc" id="L816">			leftColumnX = 0;</span>
<span class="nc" id="L817">			alignedLeft = true;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">		} else if (x &gt;= (game.getMap().getWidth() - rightColumns)) {</span>
			// We are at the right side of the map
<span class="nc" id="L820">			rightColumn = game.getMap().getWidth() - 1;</span>

<span class="nc" id="L822">			leftColumn = size.width / tileWidth;</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			if ((size.width % tileWidth) &gt; 0) {</span>
<span class="nc" id="L824">				leftColumn++;</span>
			}

<span class="nc" id="L827">			leftColumnX = size.width - tileWidth - halfWidth - leftColumn * tileWidth;</span>
<span class="nc" id="L828">			leftColumn = rightColumn - leftColumn;</span>
<span class="nc" id="L829">			alignedRight = true;</span>
		} else {
			// We are not at the left side of the map and not at the right side
<span class="nc" id="L832">			leftColumn = x - leftColumns;</span>
<span class="nc" id="L833">			rightColumn = x + rightColumns;</span>
<span class="nc" id="L834">			leftColumnX = (size.width - tileWidth) / 2 - leftColumns * tileWidth;</span>
		}
<span class="nc" id="L836">	}</span>

	/**
	 * Scroll the map in the given direction.
	 *
	 * @param direction
	 *            The &lt;code&gt;Direction&lt;/code&gt; to scroll in.
	 * @return True if scrolling occurred.
	 */
	boolean scrollMap(Direction direction) {
<span class="nc" id="L846">		Tile t = focus;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">		if (t == null)</span>
<span class="nc" id="L848">			return false;</span>
<span class="nc" id="L849">		int fx = t.getX(), fy = t.getY();</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">		if ((t = t.getNeighbourOrNull(direction)) == null)</span>
<span class="nc" id="L851">			return false;</span>
<span class="nc" id="L852">		int tx = t.getX(), ty = t.getY();</span>
		int x, y;

		// When already close to an edge, resist moving the focus closer,
		// but if moving away immediately jump out of the `nearTo' area.
<span class="nc bnc" id="L857" title="All 4 branches missed.">		if (isMapNearTop(ty) &amp;&amp; isMapNearTop(fy)) {</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">			y = (ty &lt;= fy) ? fy : topRows;</span>
<span class="nc bnc" id="L859" title="All 4 branches missed.">		} else if (isMapNearBottom(ty) &amp;&amp; isMapNearBottom(fy)) {</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">			y = (ty &gt;= fy) ? fy : freeColClient.getGame().getMap().getWidth() - bottomRows;</span>
		} else {
<span class="nc" id="L862">			y = ty;</span>
		}
<span class="nc bnc" id="L864" title="All 4 branches missed.">		if (isMapNearLeft(tx, ty) &amp;&amp; isMapNearLeft(fx, fy)) {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">			x = (tx &lt;= fx) ? fx : getLeftColumns(ty);</span>
<span class="nc bnc" id="L866" title="All 4 branches missed.">		} else if (isMapNearRight(tx, ty) &amp;&amp; isMapNearRight(fx, fy)) {</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">			x = (tx &gt;= fx) ? fx : freeColClient.getGame().getMap().getWidth() - getRightColumns(ty);</span>
		} else {
<span class="nc" id="L869">			x = tx;</span>
		}

<span class="nc bnc" id="L872" title="All 4 branches missed.">		if (x == fx &amp;&amp; y == fy)</span>
<span class="nc" id="L873">			return false;</span>
<span class="nc" id="L874">		gui.setFocus(freeColClient.getGame().getMap().getTile(x, y));</span>
<span class="nc" id="L875">		return true;</span>
	}

	/**
	 * Is a y-coordinate near the bottom?.
	 *
	 * @param y
	 *            The y-coordinate.
	 * @return True if near the bottom.
	 */
	private boolean isMapNearBottom(int y) {
<span class="nc bnc" id="L886" title="All 2 branches missed.">		return y &gt;= freeColClient.getGame().getMap().getHeight() - bottomRows;</span>
	}

	/**
	 * Is an x,y coordinate near the left?.
	 *
	 * @param x
	 *            The x-coordinate.
	 * @param y
	 *            The y-coordinate.
	 * @return True if near the left.
	 */
	private boolean isMapNearLeft(int x, int y) {
<span class="nc bnc" id="L899" title="All 2 branches missed.">		return x &lt; getLeftColumns(y);</span>
	}

	/**
	 * Is an x,y coordinate near the right?.
	 *
	 * @param x
	 *            The x-coordinate.
	 * @param y
	 *            The y-coordinate.
	 * @return True if near the right.
	 */
	private boolean isMapNearRight(int x, int y) {
<span class="nc bnc" id="L912" title="All 2 branches missed.">		return x &gt;= freeColClient.getGame().getMap().getWidth() - getRightColumns(y);</span>
	}

	/**
	 * Returns the amount of columns that are to the left of the Tile that is
	 * displayed in the center of the Map.
	 *
	 * @return The amount of columns that are to the left of the Tile that is
	 *         displayed in the center of the Map.
	 */
	private int getLeftColumns() {
<span class="nc" id="L923">		return getLeftColumns(focus.getY());</span>
	}

	/**
	 * Returns the amount of columns that are to the left of the Tile with the
	 * given y-coordinate.
	 *
	 * @param y
	 *            The y-coordinate of the Tile in question.
	 * @return The amount of columns that are to the left of the Tile with the
	 *         given y-coordinate.
	 */
	private int getLeftColumns(int y) {
<span class="nc" id="L936">		int leftColumns = leftSpace / tileWidth + 1;</span>

<span class="nc bnc" id="L938" title="All 2 branches missed.">		if ((y &amp; 1) == 0) {</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">			if ((leftSpace % tileWidth) &gt; 32) {</span>
<span class="nc" id="L940">				leftColumns++;</span>
			}
		} else {
<span class="nc bnc" id="L943" title="All 2 branches missed.">			if ((leftSpace % tileWidth) == 0) {</span>
<span class="nc" id="L944">				leftColumns--;</span>
			}
		}

<span class="nc" id="L948">		return leftColumns;</span>
	}

	/**
	 * Returns the amount of columns that are to the right of the Tile that is
	 * displayed in the center of the Map.
	 *
	 * @return The amount of columns that are to the right of the Tile that is
	 *         displayed in the center of the Map.
	 */
	private int getRightColumns() {
<span class="nc" id="L959">		return getRightColumns(focus.getY());</span>
	}

	/**
	 * Returns the amount of columns that are to the right of the Tile with the
	 * given y-coordinate.
	 *
	 * @param y
	 *            The y-coordinate of the Tile in question.
	 * @return The amount of columns that are to the right of the Tile with the
	 *         given y-coordinate.
	 */
	private int getRightColumns(int y) {
<span class="nc" id="L972">		int rightColumns = rightSpace / tileWidth + 1;</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">		if ((y &amp; 1) == 0) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">			if ((rightSpace % tileWidth) == 0) {</span>
<span class="nc" id="L976">				rightColumns--;</span>
			}
		} else {
<span class="nc bnc" id="L979" title="All 2 branches missed.">			if ((rightSpace % tileWidth) &gt; 32) {</span>
<span class="nc" id="L980">				rightColumns++;</span>
			}
		}

<span class="nc" id="L984">		return rightColumns;</span>
	}

	/**
	 * Is a y-coordinate near the top?.
	 *
	 * @param y
	 *            The y-coordinate.
	 * @return True if near the top.
	 */
	private boolean isMapNearTop(int y) {
<span class="nc bnc" id="L995" title="All 2 branches missed.">		return y &lt; topRows;</span>
	}

	/**
	 * Checks if is tile visible.
	 *
	 * @param tile
	 *            the tile
	 * @return true, if is tile visible
	 */
	private boolean isTileVisible(Tile tile) {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">		if (tile == null)</span>
<span class="nc" id="L1007">			return false;</span>
<span class="nc bnc" id="L1008" title="All 6 branches missed.">		return tile.getY() &gt;= topRow &amp;&amp; tile.getY() &lt;= bottomRow &amp;&amp; tile.getX() &gt;= leftColumn</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">				&amp;&amp; tile.getX() &lt;= rightColumn;</span>
	}

	/**
	 * Gets the selected tile.
	 *
	 * @return The &lt;code&gt;Tile&lt;/code&gt; selected.
	 */
	Tile getSelectedTile() {
<span class="nc" id="L1018">		return selectedTile;</span>
	}

	/**
	 * Selects the tile at the specified position. There are two possible cases:
	 *
	 * &lt;ol&gt;
	 * &lt;li&gt;If the tile contains a unit that can become active, then that unit
	 * will be set as the active unit.
	 * &lt;li&gt;If not, the &lt;code&gt;selectedTile&lt;/code&gt; will become the map focus.
	 * &lt;/ol&gt;
	 *
	 * If a unit is active and is located on the selected tile, then nothing
	 * (except perhaps a map reposition) will happen.
	 *
	 * @param newTile
	 *            The &lt;code&gt;Tile&lt;/code&gt;, the tile to be selected
	 * @return True if the focus was set.
	 * @see #getSelectedTile
	 * @see #setActiveUnit
	 * @see #setFocus(Tile)
	 */
	boolean setSelectedTile(Tile newTile) {
<span class="nc" id="L1041">		Tile oldTile = this.selectedTile;</span>
<span class="nc" id="L1042">		boolean ret = false;</span>
<span class="nc" id="L1043">		selectedTile = newTile;</span>

<span class="nc bnc" id="L1045" title="All 2 branches missed.">		if (viewMode == GUI.MOVE_UNITS_MODE) {</span>
<span class="nc bnc" id="L1046" title="All 4 branches missed.">			if (activeUnit == null || activeUnit.getTile() != newTile) {</span>
				// select a unit on the selected tile
<span class="nc" id="L1048">				Unit unitInFront = findUnitInFront(newTile);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">				if (unitInFront != null) {</span>
<span class="nc" id="L1050">					ret = gui.setActiveUnit(unitInFront);</span>
<span class="nc" id="L1051">					updateCurrentPathForActiveUnit();</span>
				} else {
<span class="nc" id="L1053">					gui.setFocus(newTile);</span>
<span class="nc" id="L1054">					ret = true;</span>
				}
			}
		}

		// Check for refocus
<span class="nc bnc" id="L1060" title="All 4 branches missed.">		if (!onScreen(newTile) || freeColClient.getClientOptions().getBoolean(ClientOptions.ALWAYS_CENTER)) {</span>
<span class="nc" id="L1061">			gui.setFocus(newTile);</span>
<span class="nc" id="L1062">			ret = true;</span>
		} else {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">			if (oldTile != null) {</span>
<span class="nc" id="L1065">				gui.refreshTile(oldTile);</span>
			}

<span class="nc bnc" id="L1068" title="All 2 branches missed.">			if (newTile != null) {</span>
<span class="nc" id="L1069">				gui.refreshTile(newTile);</span>
			}
		}
<span class="nc" id="L1072">		return ret;</span>
	}

	/**
	 * Gets the unit that should be displayed on the given tile.
	 *
	 * @param unitTile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to check.
	 * @return The &lt;code&gt;Unit&lt;/code&gt; to display or null if none found.
	 */
	private Unit findUnitInFront(Tile unitTile) {
		Unit result;

<span class="nc bnc" id="L1085" title="All 4 branches missed.">		if (unitTile == null || unitTile.isEmpty()) {</span>
<span class="nc" id="L1086">			result = null;</span>

<span class="nc bnc" id="L1088" title="All 4 branches missed.">		} else if (activeUnit != null &amp;&amp; activeUnit.getTile() == unitTile) {</span>
<span class="nc" id="L1089">			result = activeUnit;</span>

<span class="nc bnc" id="L1091" title="All 2 branches missed.">		} else if (unitTile.hasSettlement()) {</span>
<span class="nc" id="L1092">			result = null;</span>

<span class="nc bnc" id="L1094" title="All 4 branches missed.">		} else if (activeUnit != null &amp;&amp; activeUnit.isOffensiveUnit()) {</span>
<span class="nc" id="L1095">			result = unitTile.getDefendingUnit(activeUnit);</span>

		} else {
			// Find the unit with the most moves left, preferring
			// active units.
<span class="nc" id="L1100">			List&lt;Unit&gt; units = unitTile.getUnitList();</span>
<span class="nc" id="L1101">			result = units.remove(0);</span>
<span class="nc" id="L1102">			int best = result.getMovesLeft();</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">			boolean carrier, active = result.getState() == Unit.UnitState.ACTIVE;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">			for (Unit u : units) {</span>
<span class="nc" id="L1105">				carrier = false;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">				if (active) {</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">					if (u.getState() == Unit.UnitState.ACTIVE) {</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">						if (best &lt; u.getMovesLeft()) {</span>
<span class="nc" id="L1109">							best = u.getMovesLeft();</span>
<span class="nc" id="L1110">							result = u;</span>
						}
					} else {
<span class="nc bnc" id="L1113" title="All 2 branches missed.">						carrier = !u.isEmpty();</span>
					}
<span class="nc bnc" id="L1115" title="All 2 branches missed.">				} else if (u.getState() == Unit.UnitState.ACTIVE) {</span>
<span class="nc" id="L1116">					active = true;</span>
<span class="nc" id="L1117">					best = u.getMovesLeft();</span>
<span class="nc" id="L1118">					result = u;</span>
				} else {
<span class="nc bnc" id="L1120" title="All 2 branches missed.">					if (best &lt; u.getMovesLeft()) {</span>
<span class="nc" id="L1121">						best = u.getMovesLeft();</span>
<span class="nc" id="L1122">						result = u;</span>
					}
<span class="nc bnc" id="L1124" title="All 2 branches missed.">					carrier = !u.isEmpty();</span>
				}
<span class="nc bnc" id="L1126" title="All 2 branches missed.">				if (carrier) {</span>
					// Check for active units on carriers. Usually the
					// carrier takes precedence.
<span class="nc bnc" id="L1129" title="All 2 branches missed.">					for (Unit c : u.getUnitList()) {</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">						if (active) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">							if (best &lt; c.getMovesLeft()) {</span>
<span class="nc" id="L1132">								best = c.getMovesLeft();</span>
<span class="nc" id="L1133">								result = c;</span>
							}
<span class="nc bnc" id="L1135" title="All 2 branches missed.">						} else if (c.getState() == Unit.UnitState.ACTIVE) {</span>
<span class="nc" id="L1136">							active = true;</span>
<span class="nc" id="L1137">							best = c.getMovesLeft();</span>
<span class="nc" id="L1138">							result = c;</span>
						}
<span class="nc" id="L1140">					}</span>
				}
<span class="nc" id="L1142">			}</span>
		}
<span class="nc" id="L1144">		return result;</span>
	}

	/**
	 * Gets the active unit.
	 *
	 * @return The &lt;code&gt;Unit&lt;/code&gt;.
	 * @see #setActiveUnit
	 */
	Unit getActiveUnit() {
<span class="nc" id="L1154">		return activeUnit;</span>
	}

	/**
	 * Sets the active unit.
	 *
	 * @param activeUnit
	 *            The new active &lt;code&gt;Unit&lt;/code&gt;.
	 * @return True if the focus was set.
	 */
	boolean setActiveUnit(Unit activeUnit) {
		// Don't select a unit with zero moves left. -sjm
		// The user might what to check the status of a unit - SG
<span class="nc bnc" id="L1167" title="All 2 branches missed.">		Tile tile = (activeUnit == null) ? null : activeUnit.getTile();</span>
<span class="nc" id="L1168">		this.activeUnit = activeUnit;</span>

		// The user activated a unit
<span class="nc bnc" id="L1171" title="All 4 branches missed.">		if (viewMode == GUI.VIEW_TERRAIN_MODE &amp;&amp; activeUnit != null) {</span>
<span class="nc" id="L1172">			changeViewMode(GUI.MOVE_UNITS_MODE);</span>
		}

<span class="nc bnc" id="L1175" title="All 4 branches missed.">		if (activeUnit == null || tile == null) {</span>
<span class="nc" id="L1176">			gui.getCanvas().stopGoto();</span>
		} else {
<span class="nc" id="L1178">			updateCurrentPathForActiveUnit();</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">			if (!gui.setSelectedTile(tile)</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">					|| freeColClient.getClientOptions().getBoolean(ClientOptions.JUMP_TO_ACTIVE_UNIT)) {</span>
<span class="nc" id="L1181">				gui.setFocus(tile);</span>
<span class="nc" id="L1182">				return true;</span>
			}
		}
<span class="nc" id="L1185">		return false;</span>
	}

	/**
	 * Checks if there is currently a goto operation on the mapboard.
	 *
	 * @return True if a goto operation is in progress.
	 */
	boolean isGotoStarted() {
<span class="nc" id="L1194">		return gotoStarted;</span>
	}

	/**
	 * Starts a goto operation on the mapboard.
	 * 
	 * Dont use this directly, call the method in canvas!
	 */
	void startGoto() {
<span class="nc" id="L1203">		gotoStarted = true;</span>
<span class="nc" id="L1204">		setGotoPath(null);</span>
<span class="nc" id="L1205">	}</span>

	/**
	 * Stops any ongoing goto operation on the mapboard.
	 * 
	 * Dont use this directly, call the method in canvas!
	 */
	void stopGoto() {
<span class="nc" id="L1213">		setGotoPath(null);</span>
<span class="nc" id="L1214">		updateCurrentPathForActiveUnit();</span>
<span class="nc" id="L1215">		gotoStarted = false;</span>
<span class="nc" id="L1216">	}</span>

	/**
	 * Gets the path to be drawn on the map.
	 *
	 * @return The path that should be drawn on the map or &lt;code&gt;null&lt;/code&gt; if
	 *         no path should be drawn.
	 */
	PathNode getGotoPath() {
<span class="nc" id="L1225">		return gotoPath;</span>
	}

	/**
	 * Sets the path to be drawn on the map.
	 * 
	 * Dont use this directly, call the method in canvas!
	 *
	 * @param gotoPath
	 *            The path that should be drawn on the map or &lt;code&gt;null&lt;/code&gt;
	 *            if no path should be drawn.
	 */
	void setGotoPath(PathNode gotoPath) {
<span class="nc" id="L1238">		this.gotoPath = gotoPath;</span>
<span class="nc" id="L1239">		forceReposition();</span>
<span class="nc" id="L1240">	}</span>

	/**
	 * Sets the path of the active unit to display it.
	 */
	void updateCurrentPathForActiveUnit() {
		PathNode path;
<span class="nc bnc" id="L1247" title="All 4 branches missed.">		if (activeUnit == null || activeUnit.getDestination() == null</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">				|| ((FreeColGameObject) activeUnit.getDestination()).isDisposed()</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">				|| Map.isSameLocation(activeUnit.getLocation(), activeUnit.getDestination())) {</span>
<span class="nc" id="L1250">			path = null;</span>
		} else {
			try {
<span class="nc" id="L1253">				path = activeUnit.findPath(activeUnit.getDestination());</span>
<span class="nc" id="L1254">			} catch (Exception e) {</span>
<span class="nc" id="L1255">				logger.log(Level.WARNING, &quot;Path fail&quot;, e);</span>
<span class="nc" id="L1256">				path = null;</span>
<span class="nc" id="L1257">				activeUnit.setDestination(null);</span>
<span class="nc" id="L1258">			}</span>
		}
<span class="nc" id="L1260">		setCurrentPath(path);</span>
<span class="nc" id="L1261">	}</span>

	/**
	 * Set the current active unit path.
	 *
	 * @param path
	 *            The current &lt;code&gt;PathNode&lt;/code&gt;.
	 */
	void setCurrentPath(PathNode path) {
<span class="nc" id="L1270">		this.currentPath = path;</span>
<span class="nc" id="L1271">	}</span>

	/**
	 * Sets the size.
	 *
	 * @param size
	 *            the new size
	 */
	void setSize(Dimension size) {
<span class="nc" id="L1280">		this.size = size;</span>
<span class="nc" id="L1281">		updateMapDisplayVariables();</span>
<span class="nc" id="L1282">	}</span>

	/**
	 * Reset the scale of the map to the default.
	 */
	void resetMapScale() {
<span class="nc" id="L1288">		setImageLibraryAndUpdateData(new ImageLibrary());</span>
<span class="nc" id="L1289">		updateMapDisplayVariables();</span>
<span class="nc" id="L1290">	}</span>

	/**
	 * Checks if is at max map scale.
	 *
	 * @return true, if is at max map scale
	 */
	boolean isAtMaxMapScale() {
<span class="nc bnc" id="L1298" title="All 2 branches missed.">		return lib.getScaleFactor() == MAP_SCALE_MAX;</span>
	}

	/**
	 * Checks if is at min map scale.
	 *
	 * @return true, if is at min map scale
	 */
	boolean isAtMinMapScale() {
<span class="nc bnc" id="L1307" title="All 2 branches missed.">		return lib.getScaleFactor() == MAP_SCALE_MIN;</span>
	}

	/**
	 * Increase map scale.
	 */
	void increaseMapScale() {
<span class="nc" id="L1314">		float newScale = lib.getScaleFactor() + MAP_SCALE_STEP;</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">		if (newScale &gt;= MAP_SCALE_MAX)</span>
<span class="nc" id="L1316">			newScale = MAP_SCALE_MAX;</span>
<span class="nc" id="L1317">		setImageLibraryAndUpdateData(new ImageLibrary(newScale));</span>
<span class="nc" id="L1318">		updateMapDisplayVariables();</span>
<span class="nc" id="L1319">	}</span>

	/**
	 * Decrease map scale.
	 */
	void decreaseMapScale() {
<span class="nc" id="L1325">		float newScale = lib.getScaleFactor() - MAP_SCALE_STEP;</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">		if (newScale &lt;= MAP_SCALE_MIN)</span>
<span class="nc" id="L1327">			newScale = MAP_SCALE_MIN;</span>
<span class="nc" id="L1328">		setImageLibraryAndUpdateData(new ImageLibrary(newScale));</span>
<span class="nc" id="L1329">		updateMapDisplayVariables();</span>
<span class="nc" id="L1330">	}</span>

	/**
	 * Update map display variables.
	 */
	private void updateMapDisplayVariables() {
		// Calculate the amount of rows that will be drawn above the
		// central Tile
<span class="nc" id="L1338">		topSpace = (size.height - tileHeight) / 2;</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">		if ((topSpace % (halfHeight)) != 0) {</span>
<span class="nc" id="L1340">			topRows = topSpace / (halfHeight) + 2;</span>
		} else {
<span class="nc" id="L1342">			topRows = topSpace / (halfHeight) + 1;</span>
		}
<span class="nc" id="L1344">		bottomRows = topRows;</span>
<span class="nc" id="L1345">		leftSpace = (size.width - tileWidth) / 2;</span>
<span class="nc" id="L1346">		rightSpace = leftSpace;</span>
<span class="nc" id="L1347">	}</span>

	/**
	 * Sets the ImageLibrary and calculates various items that depend on tile
	 * size.
	 *
	 * @param lib
	 *            an &lt;code&gt;ImageLibrary&lt;/code&gt; value
	 */
	private void setImageLibraryAndUpdateData(ImageLibrary lib) {
<span class="nc" id="L1357">		this.lib = lib;</span>
<span class="nc" id="L1358">		tv.setImageLibraryAndUpdateData(lib);</span>
		// ATTENTION: we assume that all base tiles have the same size
<span class="nc" id="L1360">		Dimension tileSize = lib.tileSize;</span>
<span class="nc" id="L1361">		tileHeight = tileSize.height;</span>
<span class="nc" id="L1362">		tileWidth = tileSize.width;</span>
<span class="nc" id="L1363">		halfHeight = tileHeight / 2;</span>
<span class="nc" id="L1364">		halfWidth = tileWidth / 2;</span>

<span class="nc" id="L1366">		int dx = tileWidth / 16;</span>
<span class="nc" id="L1367">		int dy = tileHeight / 16;</span>
<span class="nc" id="L1368">		int ddx = dx + dx / 2;</span>
<span class="nc" id="L1369">		int ddy = dy + dy / 2;</span>

		// small corners
<span class="nc" id="L1372">		controlPoints.put(Direction.N, new Point2D.Float(halfWidth, dy));</span>
<span class="nc" id="L1373">		controlPoints.put(Direction.E, new Point2D.Float(tileWidth - dx, halfHeight));</span>
<span class="nc" id="L1374">		controlPoints.put(Direction.S, new Point2D.Float(halfWidth, tileHeight - dy));</span>
<span class="nc" id="L1375">		controlPoints.put(Direction.W, new Point2D.Float(dx, halfHeight));</span>
		// big corners
<span class="nc" id="L1377">		controlPoints.put(Direction.SE, new Point2D.Float(halfWidth, tileHeight));</span>
<span class="nc" id="L1378">		controlPoints.put(Direction.NE, new Point2D.Float(tileWidth, halfHeight));</span>
<span class="nc" id="L1379">		controlPoints.put(Direction.SW, new Point2D.Float(0, halfHeight));</span>
<span class="nc" id="L1380">		controlPoints.put(Direction.NW, new Point2D.Float(halfWidth, 0));</span>
		// small corners
<span class="nc" id="L1382">		borderPoints.put(Direction.NW, new Point2D.Float(dx + ddx, halfHeight - ddy));</span>
<span class="nc" id="L1383">		borderPoints.put(Direction.N, new Point2D.Float(halfWidth - ddx, dy + ddy));</span>
<span class="nc" id="L1384">		borderPoints.put(Direction.NE, new Point2D.Float(halfWidth + ddx, dy + ddy));</span>
<span class="nc" id="L1385">		borderPoints.put(Direction.E, new Point2D.Float(tileWidth - dx - ddx, halfHeight - ddy));</span>
<span class="nc" id="L1386">		borderPoints.put(Direction.SE, new Point2D.Float(tileWidth - dx - ddx, halfHeight + ddy));</span>
<span class="nc" id="L1387">		borderPoints.put(Direction.S, new Point2D.Float(halfWidth + ddx, tileHeight - dy - ddy));</span>
<span class="nc" id="L1388">		borderPoints.put(Direction.SW, new Point2D.Float(halfWidth - ddx, tileHeight - dy - ddy));</span>
<span class="nc" id="L1389">		borderPoints.put(Direction.W, new Point2D.Float(dx + ddx, halfHeight + ddy));</span>

<span class="nc" id="L1391">		borderStroke = new BasicStroke(dy);</span>
<span class="nc" id="L1392">		gridStroke = new BasicStroke(lib.getScaleFactor());</span>
<span class="nc" id="L1393">	}</span>

	/**
	 * Displays the Map.
	 *
	 * @param g
	 *            The Graphics2D object on which to draw the Map.
	 */
	void displayMap(Graphics2D g) {
<span class="nc" id="L1402">		final ClientOptions options = freeColClient.getClientOptions();</span>
<span class="nc" id="L1403">		Game game = freeColClient.getGame();</span>
<span class="nc" id="L1404">		Map map = game.getMap();</span>

		// Remember transform
<span class="nc" id="L1407">		AffineTransform originTransform = g.getTransform();</span>
<span class="nc" id="L1408">		Rectangle clipBounds = g.getClipBounds();</span>

		// Position the map if it is not positioned yet
<span class="nc" id="L1411">		repositionMapIfNeeded();</span>

		// Determine which tiles need to be redrawn
<span class="nc" id="L1414">		int firstRow = (clipBounds.y - topRowY) / (halfHeight) - 1;</span>
<span class="nc" id="L1415">		int clipTopY = topRowY + firstRow * (halfHeight);</span>
<span class="nc" id="L1416">		firstRow = topRow + firstRow;</span>

<span class="nc" id="L1418">		int firstColumn = (clipBounds.x - leftColumnX) / tileWidth - 1;</span>
<span class="nc" id="L1419">		int clipLeftX = leftColumnX + firstColumn * tileWidth;</span>
<span class="nc" id="L1420">		firstColumn = leftColumn + firstColumn;</span>

<span class="nc" id="L1422">		int lastRow = (clipBounds.y + clipBounds.height - topRowY) / (halfHeight);</span>
<span class="nc" id="L1423">		lastRow = topRow + lastRow;</span>

<span class="nc" id="L1425">		int lastColumn = (clipBounds.x + clipBounds.width - leftColumnX) / tileWidth;</span>
<span class="nc" id="L1426">		lastColumn = leftColumn + lastColumn;</span>

		// Clear background
<span class="nc" id="L1429">		g.setColor(Color.black);</span>
<span class="nc" id="L1430">		g.fillRect(clipBounds.x, clipBounds.y, clipBounds.width, clipBounds.height);</span>

		// Set and remember transform for upper left corner
<span class="nc" id="L1433">		g.translate(clipLeftX, clipTopY);</span>
<span class="nc" id="L1434">		AffineTransform baseTransform = g.getTransform();</span>

<span class="nc" id="L1436">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>

		// Display the base Tiles
<span class="nc" id="L1439">		final int x0 = firstColumn;</span>
<span class="nc" id="L1440">		final int y0 = firstRow;</span>
<span class="nc" id="L1441">		map.forSubMap(x0, y0, lastColumn - firstColumn + 1, lastRow - firstRow + 1, (Tile tile) -&gt; {</span>
<span class="nc" id="L1442">			final int x = tile.getX();</span>
<span class="nc" id="L1443">			final int y = tile.getY();</span>
<span class="nc" id="L1444">			final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1445">			final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1446">			g.translate(xt, yt);</span>

<span class="nc" id="L1448">			tv.displayTileWithBeachAndBorder(g, tile);</span>
<span class="nc" id="L1449">			tv.displayUnknownTileBorder(g, tile);</span>

<span class="nc" id="L1451">			g.translate(-xt, -yt);</span>
<span class="nc" id="L1452">		});</span>

		// Draw the grid, if needed
<span class="nc bnc" id="L1455" title="All 2 branches missed.">		if (options.getBoolean(ClientOptions.DISPLAY_GRID)) {</span>
			// Generate a zigzag GeneralPath
<span class="nc" id="L1457">			GeneralPath gridPath = new GeneralPath();</span>
<span class="nc" id="L1458">			gridPath.moveTo(0, 0);</span>
<span class="nc" id="L1459">			int nextX = halfWidth;</span>
<span class="nc" id="L1460">			int nextY = -halfHeight;</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">			for (int i = 0; i &lt;= ((lastColumn - firstColumn) * 2 + 1); i++) {</span>
<span class="nc" id="L1462">				gridPath.lineTo(nextX, nextY);</span>
<span class="nc" id="L1463">				nextX += halfWidth;</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">				nextY = (nextY == 0 ? -halfHeight : 0);</span>
			}

			// Display the grid
<span class="nc" id="L1468">			g.setStroke(gridStroke);</span>
<span class="nc" id="L1469">			g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">			for (int row = firstRow; row &lt;= lastRow; row++) {</span>
<span class="nc" id="L1471">				g.translate(0, halfHeight);</span>
<span class="nc" id="L1472">				AffineTransform rowTransform = g.getTransform();</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">				if ((row &amp; 1) == 1) {</span>
<span class="nc" id="L1474">					g.translate(halfWidth, 0);</span>
				}
<span class="nc" id="L1476">				g.draw(gridPath);</span>
<span class="nc" id="L1477">				g.setTransform(rowTransform);</span>
			}
<span class="nc" id="L1479">			g.setTransform(baseTransform);</span>
		}

		// Paint full region borders
<span class="nc bnc" id="L1483" title="All 2 branches missed.">		if (options.getInteger(ClientOptions.DISPLAY_TILE_TEXT) == ClientOptions.DISPLAY_TILE_TEXT_REGIONS) {</span>
<span class="nc" id="L1484">			map.forSubMap(x0, y0 - 1, lastColumn - firstColumn + 1, lastRow - firstRow + 1 + 1, (Tile tile) -&gt; {</span>
<span class="nc" id="L1485">				final int x = tile.getX();</span>
<span class="nc" id="L1486">				final int y = tile.getY();</span>
<span class="nc" id="L1487">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1488">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1489">				g.translate(xt, yt);</span>
<span class="nc" id="L1490">				displayTerritorialBorders(g, tile, BorderType.REGION, true);</span>
<span class="nc" id="L1491">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1492">			});</span>
		}

		// Paint full country borders
<span class="nc bnc" id="L1496" title="All 2 branches missed.">		if (options.getBoolean(ClientOptions.DISPLAY_BORDERS)) {</span>
<span class="nc" id="L1497">			map.forSubMap(x0, y0 - 1, lastColumn - firstColumn + 1, lastRow - firstRow + 1 + 1, (Tile tile) -&gt; {</span>
<span class="nc" id="L1498">				final int x = tile.getX();</span>
<span class="nc" id="L1499">				final int y = tile.getY();</span>
<span class="nc" id="L1500">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1501">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1502">				g.translate(xt, yt);</span>
<span class="nc" id="L1503">				displayTerritorialBorders(g, tile, BorderType.COUNTRY, true);</span>
<span class="nc" id="L1504">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1505">			});</span>
		}

		// Display the Tile overlays
<span class="nc" id="L1509">		Set&lt;String&gt; overlayCache = ImageLibrary.createOverlayCache();</span>
<span class="nc" id="L1510">		int colonyLabels = options.getInteger(ClientOptions.COLONY_LABELS);</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">		boolean withNumbers = colonyLabels == ClientOptions.COLONY_LABELS_CLASSIC;</span>
<span class="nc" id="L1512">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);</span>
<span class="nc" id="L1513">		map.forSubMap(x0, y0, lastColumn - firstColumn + 1, lastRow - firstRow + 1, (Tile tile) -&gt; {</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">			if (!tile.isExplored())</span>
<span class="nc" id="L1515">				return;</span>

<span class="nc" id="L1517">			final int x = tile.getX();</span>
<span class="nc" id="L1518">			final int y = tile.getY();</span>
<span class="nc" id="L1519">			final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1520">			final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1521">			g.translate(xt, yt);</span>

<span class="nc" id="L1523">			BufferedImage overlayImage = lib.getOverlayImage(tile, overlayCache);</span>
<span class="nc" id="L1524">			tv.displayTileItems(g, tile, overlayImage);</span>
<span class="nc" id="L1525">			tv.displaySettlementWithChipsOrPopulationNumber(g, tile, withNumbers);</span>
<span class="nc" id="L1526">			tv.displayFogOfWar(g, tile);</span>
<span class="nc" id="L1527">			tv.displayOptionalTileText(g, tile);</span>

<span class="nc" id="L1529">			g.translate(-xt, -yt);</span>
<span class="nc" id="L1530">		});</span>
<span class="nc" id="L1531">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>

		// Paint transparent region borders
<span class="nc bnc" id="L1534" title="All 2 branches missed.">		if (options.getInteger(ClientOptions.DISPLAY_TILE_TEXT) == ClientOptions.DISPLAY_TILE_TEXT_REGIONS) {</span>
<span class="nc" id="L1535">			map.forSubMap(x0, y0 - 1, lastColumn - firstColumn + 1, lastRow - firstRow + 1 + 1, (Tile tile) -&gt; {</span>
<span class="nc" id="L1536">				final int x = tile.getX();</span>
<span class="nc" id="L1537">				final int y = tile.getY();</span>
<span class="nc" id="L1538">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1539">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1540">				g.translate(xt, yt);</span>
<span class="nc" id="L1541">				displayTerritorialBorders(g, tile, BorderType.REGION, false);</span>
<span class="nc" id="L1542">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1543">			});</span>
		}

		// Paint transparent country borders
<span class="nc bnc" id="L1547" title="All 2 branches missed.">		if (options.getBoolean(ClientOptions.DISPLAY_BORDERS)) {</span>
<span class="nc" id="L1548">			map.forSubMap(x0, y0 - 1, lastColumn - firstColumn + 1, lastRow - firstRow + 1 + 1, (Tile tile) -&gt; {</span>
<span class="nc" id="L1549">				final int x = tile.getX();</span>
<span class="nc" id="L1550">				final int y = tile.getY();</span>
<span class="nc" id="L1551">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1552">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1553">				g.translate(xt, yt);</span>
<span class="nc" id="L1554">				displayTerritorialBorders(g, tile, BorderType.COUNTRY, false);</span>
<span class="nc" id="L1555">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1556">			});</span>
		}

		// Display cursor for selected tile or active unit
<span class="nc" id="L1560">		Tile cursorTile = null;</span>
<span class="nc bnc" id="L1561" title="All 3 branches missed.">		switch (viewMode) {</span>
		case GUI.MOVE_UNITS_MODE:
<span class="nc bnc" id="L1563" title="All 6 branches missed.">			if (activeUnit != null &amp;&amp; (cursor.isActive() || activeUnit.getMovesLeft() &lt;= 0))</span>
<span class="nc" id="L1564">				cursorTile = activeUnit.getTile();</span>
			break;
		case GUI.VIEW_TERRAIN_MODE:
<span class="nc bnc" id="L1567" title="All 2 branches missed.">			if (selectedTile != null)</span>
<span class="nc" id="L1568">				cursorTile = selectedTile;</span>
		}
<span class="nc bnc" id="L1570" title="All 2 branches missed.">		if (cursorTile != null) {</span>
<span class="nc" id="L1571">			final int x = cursorTile.getX();</span>
<span class="nc" id="L1572">			final int y = cursorTile.getY();</span>
<span class="nc bnc" id="L1573" title="All 8 branches missed.">			if (x &gt;= x0 &amp;&amp; y &gt;= y0 &amp;&amp; x &lt;= lastColumn &amp;&amp; y &lt;= lastRow) {</span>
<span class="nc" id="L1574">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1575">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1576">				g.translate(xt, yt);</span>
<span class="nc" id="L1577">				displayCursor(g);</span>
<span class="nc" id="L1578">				g.translate(-xt, -yt);</span>
			}
		}

		// Display units
<span class="nc" id="L1583">		g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">		if (!game.isInRevengeMode()) {</span>
<span class="nc" id="L1585">			map.forSubMap(x0, y0, lastColumn - firstColumn + 1, lastRow - firstRow + 1, (Tile tile) -&gt; {</span>
				// check for units
<span class="nc" id="L1587">				Unit unit = findUnitInFront(tile);</span>
<span class="nc bnc" id="L1588" title="All 4 branches missed.">				if (unit == null || isOutForAnimation(unit))</span>
<span class="nc" id="L1589">					return;</span>

<span class="nc" id="L1591">				final int x = tile.getX();</span>
<span class="nc" id="L1592">				final int y = tile.getY();</span>
<span class="nc" id="L1593">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1594">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1595">				g.translate(xt, yt);</span>

<span class="nc" id="L1597">				displayUnit(g, unit);</span>

<span class="nc" id="L1599">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1600">			});</span>
		} else {
			/*
			 * Add extra rows and colums, as the dark halo is huge to enable a
			 * very slow fade into transparency, see BR#2580
			 */
<span class="nc" id="L1606">			map.forSubMap(x0 - 2, y0 - 4, lastColumn - firstColumn + 1 + 4, lastRow - firstRow + 1 + 8, (Tile tile) -&gt; {</span>
				// check for units
<span class="nc" id="L1608">				Unit unit = findUnitInFront(tile);</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">				if (unit == null)</span>
<span class="nc" id="L1610">					return;</span>

<span class="nc" id="L1612">				final int x = tile.getX();</span>
<span class="nc" id="L1613">				final int y = tile.getY();</span>
<span class="nc" id="L1614">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1615">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1616">				g.translate(xt, yt);</span>

<span class="nc bnc" id="L1618" title="All 2 branches missed.">				if (unit.isUndead()) {</span>
					// Rescale dark halo only in rare case its needed!
<span class="nc" id="L1620">					BufferedImage darkness = lib.getMiscImage(ImageLibrary.DARKNESS);</span>
<span class="nc" id="L1621">					tv.displayCenteredImage(g, darkness);</span>
				}
<span class="nc bnc" id="L1623" title="All 2 branches missed.">				if (!isOutForAnimation(unit))</span>
<span class="nc" id="L1624">					displayUnit(g, unit);</span>

<span class="nc" id="L1626">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1627">			});</span>
		}

		// Display the colony names, if needed
<span class="nc bnc" id="L1631" title="All 2 branches missed.">		if (colonyLabels != ClientOptions.COLONY_LABELS_NONE) {</span>
<span class="nc" id="L1632">			final Player player = freeColClient.getMyPlayer();</span>
<span class="nc" id="L1633">			FontLibrary fontLibrary = new FontLibrary(lib.getScaleFactor());</span>
<span class="nc" id="L1634">			Font font = fontLibrary.createScaledFont(FontLibrary.FontType.NORMAL, FontLibrary.FontSize.SMALLER,</span>
					Font.BOLD);
<span class="nc" id="L1636">			Font italicFont = fontLibrary.createScaledFont(FontLibrary.FontType.NORMAL, FontLibrary.FontSize.SMALLER,</span>
					Font.BOLD | Font.ITALIC);
<span class="nc" id="L1638">			Font productionFont = fontLibrary.createScaledFont(FontLibrary.FontType.NORMAL, FontLibrary.FontSize.TINY,</span>
					Font.BOLD);

			/*
			 * For settlement names and territorial borders 1 extra row needs to
			 * be drawn in north to prevent missing parts on partial redraws, as
			 * they can reach below their tiles, see BR#2580
			 */
<span class="nc" id="L1646">			map.forSubMap(x0, y0 - 1, lastColumn - firstColumn + 1, lastRow - firstRow + 1 + 1, (Tile tile) -&gt; {</span>
<span class="nc" id="L1647">				Settlement settlement = tile.getSettlement();</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">				if (settlement == null)</span>
<span class="nc" id="L1649">					return;</span>

<span class="nc" id="L1651">				final int x = tile.getX();</span>
<span class="nc" id="L1652">				final int y = tile.getY();</span>
<span class="nc" id="L1653">				final int xt = (x - x0) * tileWidth + (y &amp; 1) * halfWidth;</span>
<span class="nc" id="L1654">				final int yt = (y - y0) * halfHeight;</span>
<span class="nc" id="L1655">				g.translate(xt, yt);</span>

<span class="nc" id="L1657">				displaySettlementLabels(g, settlement, player, colonyLabels, font, italicFont, productionFont);</span>

<span class="nc" id="L1659">				g.translate(-xt, -yt);</span>
<span class="nc" id="L1660">			});</span>
		}

		// Restore original transform to allow for more drawing
<span class="nc" id="L1664">		g.setTransform(originTransform);</span>

		// Display goto path
<span class="nc bnc" id="L1667" title="All 2 branches missed.">		if (currentPath != null) {</span>
<span class="nc" id="L1668">			displayPath(g, currentPath);</span>
		}
<span class="nc bnc" id="L1670" title="All 2 branches missed.">		if (gotoPath != null) {</span>
<span class="nc" id="L1671">			displayPath(g, gotoPath);</span>
		}
<span class="nc" id="L1673">	}</span>

	/**
	 * Display settlement labels.
	 *
	 * @param g
	 *            the g
	 * @param settlement
	 *            the settlement
	 * @param player
	 *            the player
	 * @param colonyLabels
	 *            the colony labels
	 * @param font
	 *            the font
	 * @param italicFont
	 *            the italic font
	 * @param productionFont
	 *            the production font
	 */
	private void displaySettlementLabels(Graphics2D g, Settlement settlement, Player player, int colonyLabels,
			Font font, Font italicFont, Font productionFont) {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">		if (settlement.isDisposed()) {</span>
<span class="nc" id="L1696">			logger.warning(&quot;Settlement display race detected: &quot; + settlement.getName());</span>
<span class="nc" id="L1697">			return;</span>
		}
<span class="nc" id="L1699">		String name = Messages.message(settlement.getLocationLabelFor(player));</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">		if (name == null)</span>
<span class="nc" id="L1701">			return;</span>

<span class="nc" id="L1703">		Color backgroundColor = settlement.getOwner().getNationColor();</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">		if (backgroundColor == null)</span>
<span class="nc" id="L1705">			backgroundColor = Color.WHITE;</span>
		// int yOffset = lib.getSettlementImage(settlement).getHeight() + 1;
<span class="nc" id="L1707">		int yOffset = tileHeight;</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">		switch (colonyLabels) {</span>
		case ClientOptions.COLONY_LABELS_CLASSIC:
<span class="nc" id="L1710">			BufferedImage img = lib.getStringImage(g, name, backgroundColor, font);</span>
<span class="nc" id="L1711">			g.drawImage(img, (tileWidth - img.getWidth()) / 2 + 1, yOffset, null);</span>
<span class="nc" id="L1712">			break;</span>

		case ClientOptions.COLONY_LABELS_MODERN:
		default:
<span class="nc" id="L1716">			backgroundColor = new Color(backgroundColor.getRed(), backgroundColor.getGreen(), backgroundColor.getBlue(),</span>
					128);
<span class="nc" id="L1718">			TextSpecification[] specs = new TextSpecification[1];</span>
<span class="nc bnc" id="L1719" title="All 4 branches missed.">			if (settlement instanceof Colony &amp;&amp; settlement.getOwner() == player) {</span>
<span class="nc" id="L1720">				Colony colony = (Colony) settlement;</span>
<span class="nc" id="L1721">				BuildableType buildable = colony.getCurrentlyBuilding();</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">				if (buildable != null) {</span>
<span class="nc" id="L1723">					specs = new TextSpecification[2];</span>
<span class="nc" id="L1724">					String t = Messages.getName(buildable) + &quot; &quot;</span>
<span class="nc" id="L1725">							+ Turn.getTurnsText(colony.getTurnsToComplete(buildable));</span>
<span class="nc" id="L1726">					specs[1] = new TextSpecification(t, productionFont);</span>
				}
			}
<span class="nc" id="L1729">			specs[0] = new TextSpecification(name, font);</span>

<span class="nc" id="L1731">			BufferedImage nameImage = createLabel(g, specs, backgroundColor);</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">			if (nameImage != null) {</span>
<span class="nc" id="L1733">				int spacing = 3;</span>
<span class="nc" id="L1734">				BufferedImage leftImage = null;</span>
<span class="nc" id="L1735">				BufferedImage rightImage = null;</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">				if (settlement instanceof Colony) {</span>
<span class="nc" id="L1737">					Colony colony = (Colony) settlement;</span>
<span class="nc" id="L1738">					String string = Integer.toString(colony.getDisplayUnitCount());</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">					leftImage = createLabel(g, string, ((colony.getPreferredSizeChange() &gt; 0) ? italicFont : font),</span>
							backgroundColor);
<span class="nc bnc" id="L1741" title="All 2 branches missed.">					if (player.owns(settlement)) {</span>
<span class="nc" id="L1742">						int bonusProduction = colony.getProductionBonus();</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">						if (bonusProduction != 0) {</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">							String bonus = (bonusProduction &gt; 0) ? &quot;+&quot; + bonusProduction</span>
<span class="nc" id="L1745">									: Integer.toString(bonusProduction);</span>
<span class="nc" id="L1746">							rightImage = createLabel(g, bonus, font, backgroundColor);</span>
						}
					}
<span class="nc bnc" id="L1749" title="All 2 branches missed.">				} else if (settlement instanceof IndianSettlement) {</span>
<span class="nc" id="L1750">					IndianSettlement is = (IndianSettlement) settlement;</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">					if (is.getType().isCapital()) {</span>
<span class="nc" id="L1752">						leftImage = createCapitalLabel(nameImage.getHeight(), 5, backgroundColor);</span>
					}

<span class="nc" id="L1755">					Unit missionary = is.getMissionary();</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">					if (missionary != null) {</span>
<span class="nc" id="L1757">						boolean expert = missionary.hasAbility(Ability.EXPERT_MISSIONARY);</span>
<span class="nc" id="L1758">						backgroundColor = missionary.getOwner().getNationColor();</span>
<span class="nc" id="L1759">						backgroundColor = new Color(backgroundColor.getRed(), backgroundColor.getGreen(),</span>
<span class="nc" id="L1760">								backgroundColor.getBlue(), 128);</span>
<span class="nc" id="L1761">						rightImage = createReligiousMissionLabel(nameImage.getHeight(), 5, backgroundColor, expert);</span>
					}
				}

<span class="nc bnc" id="L1765" title="All 2 branches missed.">				int width = (int) ((nameImage.getWidth() * lib.getScaleFactor())</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">						+ ((leftImage != null) ? (leftImage.getWidth() * lib.getScaleFactor()) + spacing : 0)</span>
<span class="nc" id="L1767">						+ ((rightImage != null) ? (rightImage.getWidth() * lib.getScaleFactor()) + spacing : 0));</span>
<span class="nc" id="L1768">				int labelOffset = (tileWidth - width) / 2;</span>
<span class="nc" id="L1769">				yOffset -= (nameImage.getHeight() * lib.getScaleFactor()) / 2;</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">				if (leftImage != null) {</span>
<span class="nc" id="L1771">					g.drawImage(leftImage, labelOffset, yOffset, null);</span>
<span class="nc" id="L1772">					labelOffset += (leftImage.getWidth() * lib.getScaleFactor()) + spacing;</span>
				}
<span class="nc" id="L1774">				g.drawImage(nameImage, labelOffset, yOffset, null);</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">				if (rightImage != null) {</span>
<span class="nc" id="L1776">					labelOffset += (nameImage.getWidth() * lib.getScaleFactor()) + spacing;</span>
<span class="nc" id="L1777">					g.drawImage(rightImage, labelOffset, yOffset, null);</span>
				}
				break;
			}
		}
<span class="nc" id="L1782">	}</span>

	/**
	 * Draws the pentagram indicating a native capital.
	 *
	 * @param extent
	 *            the extent
	 * @param padding
	 *            the padding
	 * @param backgroundColor
	 *            the background color
	 * @return the buffered image
	 */
	private static BufferedImage createCapitalLabel(int extent, int padding, Color backgroundColor) {
		// create path
<span class="nc" id="L1797">		double deg2rad = Math.PI / 180.0;</span>
<span class="nc" id="L1798">		double angle = -90.0 * deg2rad;</span>
<span class="nc" id="L1799">		double offset = extent * 0.5;</span>
<span class="nc" id="L1800">		double size1 = (extent - padding - padding) * 0.5;</span>

<span class="nc" id="L1802">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L1803">		path.moveTo(Math.cos(angle) * size1 + offset, Math.sin(angle) * size1 + offset);</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">		for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L1805">			angle += 144 * deg2rad;</span>
<span class="nc" id="L1806">			path.lineTo(Math.cos(angle) * size1 + offset, Math.sin(angle) * size1 + offset);</span>
		}
<span class="nc" id="L1808">		path.closePath();</span>

		// draw everything
<span class="nc" id="L1811">		BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L1812">		Graphics2D g = bi.createGraphics();</span>
<span class="nc" id="L1813">		g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);</span>
<span class="nc" id="L1814">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L1815">		g.setColor(backgroundColor);</span>
<span class="nc" id="L1816">		g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));</span>
<span class="nc" id="L1817">		g.setColor(Color.BLACK);</span>
<span class="nc" id="L1818">		g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
<span class="nc" id="L1819">		g.draw(path);</span>
<span class="nc" id="L1820">		g.setColor(Color.WHITE);</span>
<span class="nc" id="L1821">		g.fill(path);</span>
<span class="nc" id="L1822">		g.dispose();</span>
<span class="nc" id="L1823">		return bi;</span>
	}

	/**
	 * Creates an BufferedImage that shows the given text centred on a
	 * translucent rounded rectangle with the given color.
	 *
	 * @param g
	 *            a &lt;code&gt;Graphics2D&lt;/code&gt;
	 * @param text
	 *            a &lt;code&gt;String&lt;/code&gt;
	 * @param font
	 *            a &lt;code&gt;Font&lt;/code&gt;
	 * @param backgroundColor
	 *            a &lt;code&gt;Color&lt;/code&gt;
	 * @return an &lt;code&gt;BufferedImage&lt;/code&gt;
	 */
	private static BufferedImage createLabel(Graphics2D g, String text, Font font, Color backgroundColor) {
<span class="nc" id="L1841">		TextSpecification[] specs = new TextSpecification[1];</span>
<span class="nc" id="L1842">		specs[0] = new TextSpecification(text, font);</span>
<span class="nc" id="L1843">		return createLabel(g, specs, backgroundColor);</span>
	}

	/**
	 * Creates an BufferedImage that shows the given text centred on a
	 * translucent rounded rectangle with the given color.
	 *
	 * @param g
	 *            a &lt;code&gt;Graphics2D&lt;/code&gt;
	 * @param textSpecs
	 *            a &lt;code&gt;TextSpecification&lt;/code&gt; array
	 * @param backgroundColor
	 *            a &lt;code&gt;Color&lt;/code&gt;
	 * @return a &lt;code&gt;BufferedImage&lt;/code&gt;
	 */
	private static BufferedImage createLabel(Graphics2D g, TextSpecification[] textSpecs, Color backgroundColor) {
<span class="nc" id="L1859">		int hPadding = 15;</span>
<span class="nc" id="L1860">		int vPadding = 10;</span>
<span class="nc" id="L1861">		int linePadding = 5;</span>
<span class="nc" id="L1862">		int width = 0;</span>
<span class="nc" id="L1863">		int height = vPadding;</span>
		int i;

		TextSpecification spec;
<span class="nc" id="L1867">		TextLayout[] labels = new TextLayout[textSpecs.length];</span>
		TextLayout label;

<span class="nc bnc" id="L1870" title="All 2 branches missed.">		for (i = 0; i &lt; textSpecs.length; i++) {</span>
<span class="nc" id="L1871">			spec = textSpecs[i];</span>
<span class="nc" id="L1872">			label = new TextLayout(spec.text, spec.font, g.getFontRenderContext());</span>
<span class="nc" id="L1873">			labels[i] = label;</span>
<span class="nc" id="L1874">			Rectangle textRectangle = label.getPixelBounds(null, 0, 0);</span>
<span class="nc" id="L1875">			width = Math.max(width, textRectangle.width + hPadding);</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">			if (i &gt; 0)</span>
<span class="nc" id="L1877">				height += linePadding;</span>
<span class="nc" id="L1878">			height += (int) (label.getAscent() + label.getDescent());</span>
		}

<span class="nc" id="L1881">		int radius = Math.min(hPadding, vPadding);</span>

<span class="nc" id="L1883">		BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L1884">		Graphics2D g2 = bi.createGraphics();</span>
<span class="nc" id="L1885">		g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);</span>
<span class="nc" id="L1886">		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L1887">		g2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);</span>

<span class="nc" id="L1889">		g2.setColor(backgroundColor);</span>
<span class="nc" id="L1890">		g2.fill(new RoundRectangle2D.Float(0, 0, width, height, radius, radius));</span>
<span class="nc" id="L1891">		g2.setColor(ImageLibrary.getForegroundColor(backgroundColor));</span>
<span class="nc" id="L1892">		float y = vPadding / 2;</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">		for (i = 0; i &lt; labels.length; i++) {</span>
<span class="nc" id="L1894">			Rectangle textRectangle = labels[i].getPixelBounds(null, 0, 0);</span>
<span class="nc" id="L1895">			float x = (width - textRectangle.width) / 2;</span>
<span class="nc" id="L1896">			y += labels[i].getAscent();</span>
<span class="nc" id="L1897">			labels[i].draw(g2, x, y);</span>
<span class="nc" id="L1898">			y += labels[i].getDescent() + linePadding;</span>
		}
<span class="nc" id="L1900">		g2.dispose();</span>
<span class="nc" id="L1901">		return bi;</span>
	}

	/**
	 * Draws a cross indicating a religious mission is present in the native
	 * village.
	 *
	 * @param extent
	 *            the extent
	 * @param padding
	 *            the padding
	 * @param backgroundColor
	 *            the background color
	 * @param expertMissionary
	 *            the expert missionary
	 * @return the buffered image
	 */
	private static BufferedImage createReligiousMissionLabel(int extent, int padding, Color backgroundColor,
			boolean expertMissionary) {
		// create path
<span class="nc" id="L1921">		double offset = extent * 0.5;</span>
<span class="nc" id="L1922">		double size1 = extent - padding - padding;</span>
<span class="nc" id="L1923">		double bar = size1 / 3.0;</span>
<span class="nc" id="L1924">		double inset = 0.0;</span>
<span class="nc" id="L1925">		double kludge = 0.0;</span>

<span class="nc" id="L1927">		GeneralPath circle = new GeneralPath();</span>
<span class="nc" id="L1928">		GeneralPath cross = new GeneralPath();</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">		if (expertMissionary) {</span>
			// this is meant to represent the eucharist (the -1, +1 thing is a
			// nasty kludge)
<span class="nc" id="L1932">			circle.append(new Ellipse2D.Double(padding - 1, padding - 1, size1 + 1, size1 + 1), false);</span>
<span class="nc" id="L1933">			inset = 4.0;</span>
<span class="nc" id="L1934">			bar = (size1 - inset - inset) / 3.0;</span>
			// more nasty -1, +1 kludges
<span class="nc" id="L1936">			kludge = 1.0;</span>
		}
<span class="nc" id="L1938">		offset -= 1.0;</span>
<span class="nc" id="L1939">		cross.moveTo(offset, padding + inset - kludge);</span>
<span class="nc" id="L1940">		cross.lineTo(offset, extent - padding - inset);</span>
<span class="nc" id="L1941">		cross.moveTo(offset - bar, padding + bar + inset);</span>
<span class="nc" id="L1942">		cross.lineTo(offset + bar + 1, padding + bar + inset);</span>

		// draw everything
<span class="nc" id="L1945">		BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L1946">		Graphics2D g = bi.createGraphics();</span>
<span class="nc" id="L1947">		g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);</span>
<span class="nc" id="L1948">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L1949">		g.setColor(backgroundColor);</span>
<span class="nc" id="L1950">		g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));</span>
<span class="nc" id="L1951">		g.setColor(ImageLibrary.getForegroundColor(backgroundColor));</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">		if (expertMissionary) {</span>
<span class="nc" id="L1953">			g.setStroke(new BasicStroke(2.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
<span class="nc" id="L1954">			g.draw(circle);</span>
<span class="nc" id="L1955">			g.setStroke(new BasicStroke(1.6f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
		} else {
<span class="nc" id="L1957">			g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
		}
<span class="nc" id="L1959">		g.draw(cross);</span>
<span class="nc" id="L1960">		g.dispose();</span>
<span class="nc" id="L1961">		return bi;</span>
	}

	/**
	 * Display a path.
	 *
	 * @param g
	 *            The &lt;code&gt;Graphics2D&lt;/code&gt; to display on.
	 * @param path
	 *            The &lt;code&gt;PathNode&lt;/code&gt; to display.
	 */
	private void displayPath(Graphics2D g, PathNode path) {
<span class="nc" id="L1973">		final Font font = FontLibrary.createFont(FontLibrary.FontType.NORMAL, FontLibrary.FontSize.TINY,</span>
<span class="nc" id="L1974">				lib.getScaleFactor());</span>
<span class="nc" id="L1975">		final boolean debug = FreeColDebugger.isInDebugMode(FreeColDebugger.DebugMode.PATHS);</span>

<span class="nc bnc" id="L1977" title="All 2 branches missed.">		for (PathNode p = path; p != null; p = p.next) {</span>
<span class="nc" id="L1978">			Tile tile = p.getTile();</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">			if (tile == null)</span>
<span class="nc" id="L1980">				continue;</span>
<span class="nc" id="L1981">			Point point = calculateTilePosition(tile);</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">			if (point == null)</span>
<span class="nc" id="L1983">				continue;</span>

<span class="nc bnc" id="L1985" title="All 4 branches missed.">			BufferedImage image = (p.isOnCarrier()) ? ImageLibrary.getPathImage(ImageLibrary.PathType.NAVAL)</span>
<span class="nc" id="L1986">					: (activeUnit != null) ? ImageLibrary.getPathImage(activeUnit) : null;</span>

<span class="nc bnc" id="L1988" title="All 2 branches missed.">			BufferedImage turns = (p.getTurns() &lt;= 0) ? null</span>
<span class="nc" id="L1989">					: lib.getStringImage(g, Integer.toString(p.getTurns()), Color.WHITE, font);</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">			g.setColor((turns == null) ? Color.GREEN : Color.RED);</span>

<span class="nc bnc" id="L1992" title="All 2 branches missed.">			if (debug) { // More detailed display</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">				if (activeUnit != null) {</span>
<span class="nc" id="L1994">					image = ImageLibrary.getPathNextTurnImage(activeUnit);</span>
				}
<span class="nc" id="L1996">				turns = lib.getStringImage(g, Integer.toString(p.getTurns()) + &quot;/&quot; + Integer.toString(p.getMovesLeft()),</span>
						Color.WHITE, font);
			}

<span class="nc" id="L2000">			g.translate(point.x, point.y);</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">			if (image == null) {</span>
<span class="nc" id="L2002">				g.fillOval(halfWidth, halfHeight, 10, 10);</span>
<span class="nc" id="L2003">				g.setColor(Color.BLACK);</span>
<span class="nc" id="L2004">				g.drawOval(halfWidth, halfHeight, 10, 10);</span>
			} else {
<span class="nc" id="L2006">				tv.displayCenteredImage(g, image);</span>
<span class="nc bnc" id="L2007" title="All 2 branches missed.">				if (turns != null) {</span>
<span class="nc" id="L2008">					tv.displayCenteredImage(g, turns);</span>
				}
			}
<span class="nc" id="L2011">			g.translate(-point.x, -point.y);</span>
		}
<span class="nc" id="L2013">	}</span>

	/**
	 * Displays the given Unit onto the given Graphics2D object at the location
	 * specified by the coordinates.
	 *
	 * @param g
	 *            The Graphics2D object on which to draw the Unit.
	 * @param unit
	 *            The Unit to draw.
	 */
	private void displayUnit(Graphics2D g, Unit unit) {
<span class="nc" id="L2025">		final Player player = freeColClient.getMyPlayer();</span>

		// Draw the unit.
		// If unit is sentry, draw in grayscale
<span class="nc bnc" id="L2029" title="All 2 branches missed.">		boolean fade = (unit.getState() == Unit.UnitState.SENTRY)</span>
<span class="nc bnc" id="L2030" title="All 6 branches missed.">				|| (unit.hasTile() &amp;&amp; player != null &amp;&amp; !player.canSee(unit.getTile()));</span>
<span class="nc" id="L2031">		BufferedImage image = lib.getUnitImage(unit, fade);</span>
<span class="nc" id="L2032">		Point p = calculateUnitImagePositionInTile(image);</span>
<span class="nc" id="L2033">		g.drawImage(image, p.x, p.y, null);</span>

		// Draw an occupation and nation indicator.
<span class="nc" id="L2036">		String text = Messages.message(unit.getOccupationLabel(player, false));</span>
<span class="nc" id="L2037">		g.drawImage(lib.getOccupationIndicatorChip(g, unit, text),</span>
<span class="nc" id="L2038">				(int) (TileViewer.STATE_OFFSET_X * lib.getScaleFactor()), 0, null);</span>

		// Draw one small line for each additional unit (like in civ3).
<span class="nc" id="L2041">		int unitsOnTile = 0;</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">		if (unit.hasTile()) {</span>
			// When a unit is moving from tile to tile, it is
			// removed from the source tile. So the unit stack
			// indicator cannot be drawn during the movement see
			// UnitMoveAnimation.animate() for details
<span class="nc" id="L2047">			unitsOnTile = unit.getTile().getTotalUnitCount();</span>
		}
<span class="nc bnc" id="L2049" title="All 2 branches missed.">		if (unitsOnTile &gt; 1) {</span>
<span class="nc" id="L2050">			g.setColor(Color.WHITE);</span>
<span class="nc" id="L2051">			int unitLinesY = OTHER_UNITS_OFFSET_Y;</span>
<span class="nc" id="L2052">			int x1 = (int) ((TileViewer.STATE_OFFSET_X + OTHER_UNITS_OFFSET_X) * lib.getScaleFactor());</span>
<span class="nc" id="L2053">			int x2 = (int) ((TileViewer.STATE_OFFSET_X + OTHER_UNITS_OFFSET_X + OTHER_UNITS_WIDTH)</span>
<span class="nc" id="L2054">					* lib.getScaleFactor());</span>
<span class="nc bnc" id="L2055" title="All 4 branches missed.">			for (int i = 0; i &lt; unitsOnTile &amp;&amp; i &lt; MAX_OTHER_UNITS; i++) {</span>
<span class="nc" id="L2056">				g.drawLine(x1, unitLinesY, x2, unitLinesY);</span>
<span class="nc" id="L2057">				unitLinesY += 2;</span>
			}
		}

		// FOR DEBUGGING
		net.sf.freecol.server.ai.AIUnit au;
<span class="nc bnc" id="L2063" title="All 6 branches missed.">		if (FreeColDebugger.isInDebugMode(FreeColDebugger.DebugMode.MENUS) &amp;&amp; player != null &amp;&amp; !player.owns(unit)</span>
<span class="nc bnc" id="L2064" title="All 4 branches missed.">				&amp;&amp; unit.getOwner().isAI() &amp;&amp; freeColClient.getFreeColServer() != null</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">				&amp;&amp; (au = freeColClient.getFreeColServer().getAIMain().getAIUnit(unit)) != null) {</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">			if (FreeColDebugger.debugShowMission()) {</span>
<span class="nc" id="L2067">				g.setColor(Color.WHITE);</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">				g.drawString((!au.hasMission()) ? &quot;No mission&quot; : lastPart(au.getMission().getClass().toString(), &quot;.&quot;),</span>
						0, 0);
			}
<span class="nc bnc" id="L2071" title="All 4 branches missed.">			if (FreeColDebugger.debugShowMissionInfo() &amp;&amp; au.hasMission()) {</span>
<span class="nc" id="L2072">				g.setColor(Color.WHITE);</span>
<span class="nc" id="L2073">				g.drawString(au.getMission().toString(), 0, 25);</span>
			}
		}
<span class="nc" id="L2076">	}</span>

	/**
	 * Gets the coordinates to draw a unit in a given tile.
	 *
	 * @param unitImage
	 *            The unit's image
	 * @return The coordinates where the unit should be drawn onscreen
	 */
	private Point calculateUnitImagePositionInTile(BufferedImage unitImage) {
<span class="nc" id="L2086">		int unitX = (tileWidth - unitImage.getWidth()) / 2;</span>
<span class="nc" id="L2087">		int unitY = (tileHeight - unitImage.getHeight()) / 2 - (int) (UNIT_OFFSET * lib.getScaleFactor());</span>

<span class="nc" id="L2089">		return new Point(unitX, unitY);</span>
	}

	/**
	 * Display cursor.
	 *
	 * @param g
	 *            the g
	 */
	private void displayCursor(Graphics2D g) {
<span class="nc" id="L2099">		BufferedImage cursorImage = lib.getMiscImage(ImageLibrary.UNIT_SELECT);</span>
<span class="nc" id="L2100">		g.drawImage(cursorImage, 0, 0, null);</span>
<span class="nc" id="L2101">	}</span>

	/**
	 * Draws the borders of a territory on the given Tile. The territory is
	 * either a country or a region.
	 *
	 * @param g
	 *            a &lt;code&gt;Graphics2D&lt;/code&gt;
	 * @param tile
	 *            a &lt;code&gt;Tile&lt;/code&gt;
	 * @param type
	 *            a &lt;code&gt;BorderType&lt;/code&gt;
	 * @param opaque
	 *            a &lt;code&gt;boolean&lt;/code&gt;
	 */
	private void displayTerritorialBorders(Graphics2D g, Tile tile, BorderType type, boolean opaque) {
<span class="nc" id="L2117">		Player owner = tile.getOwner();</span>
<span class="nc" id="L2118">		Region region = tile.getRegion();</span>
<span class="nc bnc" id="L2119" title="All 8 branches missed.">		if ((type == BorderType.COUNTRY &amp;&amp; owner != null) || (type == BorderType.REGION &amp;&amp; region != null)) {</span>
<span class="nc" id="L2120">			Stroke oldStroke = g.getStroke();</span>
<span class="nc" id="L2121">			g.setStroke(borderStroke);</span>
<span class="nc" id="L2122">			Color oldColor = g.getColor();</span>
<span class="nc" id="L2123">			Color c = null;</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">			if (type == BorderType.COUNTRY)</span>
<span class="nc" id="L2125">				c = owner.getNationColor();</span>
<span class="nc bnc" id="L2126" title="All 2 branches missed.">			if (c == null)</span>
<span class="nc" id="L2127">				c = Color.WHITE;</span>
<span class="nc bnc" id="L2128" title="All 2 branches missed.">			Color newColor = new Color(c.getRed(), c.getGreen(), c.getBlue(), (opaque) ? 255 : 100);</span>
<span class="nc" id="L2129">			g.setColor(newColor);</span>
<span class="nc" id="L2130">			GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);</span>
<span class="nc" id="L2131">			path.moveTo(borderPoints.get(Direction.longSides.get(0)).x, borderPoints.get(Direction.longSides.get(0)).y);</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">			for (Direction d : Direction.longSides) {</span>
<span class="nc" id="L2133">				Tile otherTile = tile.getNeighbourOrNull(d);</span>
<span class="nc" id="L2134">				Direction next = d.getNextDirection();</span>
<span class="nc" id="L2135">				Direction next2 = next.getNextDirection();</span>
<span class="nc bnc" id="L2136" title="All 8 branches missed.">				if (otherTile == null || (type == BorderType.COUNTRY &amp;&amp; !owner.owns(otherTile))</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">						|| (type == BorderType.REGION &amp;&amp; otherTile.getRegion() != region)) {</span>
<span class="nc" id="L2138">					Tile tile1 = tile.getNeighbourOrNull(next);</span>
<span class="nc" id="L2139">					Tile tile2 = tile.getNeighbourOrNull(next2);</span>
<span class="nc bnc" id="L2140" title="All 8 branches missed.">					if (tile2 == null || (type == BorderType.COUNTRY &amp;&amp; !owner.owns(tile2))</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">							|| (type == BorderType.REGION &amp;&amp; tile2.getRegion() != region)) {</span>
						// small corner
<span class="nc" id="L2143">						path.lineTo(borderPoints.get(next).x, borderPoints.get(next).y);</span>
<span class="nc" id="L2144">						path.quadTo(controlPoints.get(next).x, controlPoints.get(next).y, borderPoints.get(next2).x,</span>
<span class="nc" id="L2145">								borderPoints.get(next2).y);</span>
					} else {
<span class="nc" id="L2147">						int dx = 0, dy = 0;</span>
<span class="nc bnc" id="L2148" title="All 5 branches missed.">						switch (d) {</span>
						case NW:
<span class="nc" id="L2150">							dx = halfWidth;</span>
<span class="nc" id="L2151">							dy = -halfHeight;</span>
<span class="nc" id="L2152">							break;</span>
						case NE:
<span class="nc" id="L2154">							dx = halfWidth;</span>
<span class="nc" id="L2155">							dy = halfHeight;</span>
<span class="nc" id="L2156">							break;</span>
						case SE:
<span class="nc" id="L2158">							dx = -halfWidth;</span>
<span class="nc" id="L2159">							dy = halfHeight;</span>
<span class="nc" id="L2160">							break;</span>
						case SW:
<span class="nc" id="L2162">							dx = -halfWidth;</span>
<span class="nc" id="L2163">							dy = -halfHeight;</span>
<span class="nc" id="L2164">							break;</span>
						default:
							break;
						}
<span class="nc bnc" id="L2168" title="All 8 branches missed.">						if (tile1 != null &amp;&amp; ((type == BorderType.COUNTRY &amp;&amp; owner.owns(tile1))</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">								|| (type == BorderType.REGION &amp;&amp; tile1.getRegion() == region))) {</span>
							// short straight line
<span class="nc" id="L2171">							path.lineTo(borderPoints.get(next).x, borderPoints.get(next).y);</span>
							// big corner
<span class="nc" id="L2173">							Direction previous = d.getPreviousDirection();</span>
<span class="nc" id="L2174">							Direction previous2 = previous.getPreviousDirection();</span>
<span class="nc" id="L2175">							int ddx = 0, ddy = 0;</span>
<span class="nc bnc" id="L2176" title="All 5 branches missed.">							switch (d) {</span>
							case NW:
<span class="nc" id="L2178">								ddy = -tileHeight;</span>
<span class="nc" id="L2179">								break;</span>
							case NE:
<span class="nc" id="L2181">								ddx = tileWidth;</span>
<span class="nc" id="L2182">								break;</span>
							case SE:
<span class="nc" id="L2184">								ddy = tileHeight;</span>
<span class="nc" id="L2185">								break;</span>
							case SW:
<span class="nc" id="L2187">								ddx = -tileWidth;</span>
<span class="nc" id="L2188">								break;</span>
							default:
								break;
							}
<span class="nc" id="L2192">							path.quadTo(controlPoints.get(previous).x + dx, controlPoints.get(previous).y + dy,</span>
<span class="nc" id="L2193">									borderPoints.get(previous2).x + ddx, borderPoints.get(previous2).y + ddy);</span>
<span class="nc" id="L2194">						} else {</span>
							// straight line
<span class="nc" id="L2196">							path.lineTo(borderPoints.get(d).x + dx, borderPoints.get(d).y + dy);</span>
						}
					}
<span class="nc" id="L2199">				} else {</span>
<span class="nc" id="L2200">					path.moveTo(borderPoints.get(next2).x, borderPoints.get(next2).y);</span>
				}
<span class="nc" id="L2202">			}</span>
<span class="nc" id="L2203">			g.draw(path);</span>
<span class="nc" id="L2204">			g.setColor(oldColor);</span>
<span class="nc" id="L2205">			g.setStroke(oldStroke);</span>
		}
<span class="nc" id="L2207">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>