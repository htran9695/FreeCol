<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Messages.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.i18n</a> &gt; <span class="el_source">Messages.java</span></div><h1>Messages.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.i18n;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Locale;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.logging.Logger;

import javax.swing.UIManager;

import net.sf.freecol.common.ObjectWithId;
import net.sf.freecol.common.io.FreeColDirectories;
import net.sf.freecol.common.io.FreeColDataFile;
import net.sf.freecol.common.io.FreeColModFile;
import net.sf.freecol.common.io.Mods;
import net.sf.freecol.common.model.Named;
import net.sf.freecol.common.model.Role;
import net.sf.freecol.common.model.StringTemplate;
import net.sf.freecol.common.model.StringTemplate.TemplateType;
import static net.sf.freecol.common.util.CollectionUtils.*;

/**
 * Represents a collection of messages in a particular locale.
 *
 * The individual messages are read from property files in the
 * &lt;code&gt;data/strings&lt;/code&gt; directory. The property files are called
 * &quot;FreeColMessages[_LANGUAGE[_COUNTRY[_VARIANT]]].properties&quot;, where LANGUAGE
 * should be an ISO 639-2 or ISO 639-3 language code, COUNTRY should be an ISO
 * 3166-2 country code, and VARIANT is an arbitrary string. The encoding of the
 * property files is UTF-8. Since the Java Properties class is unable to handle
 * UTF-8 directly, this class uses its own implementation.
 *
 * The individual messages may include variables, which must be delimited by
 * percent characters (e.g. &quot;%nation%&quot;), and will be replaced when the message
 * is formatted. Furthermore, the messages may include choice formats consisting
 * of a tag followed by a colon (&quot;:&quot;), a selector and one or several choices
 * separated from the selector and each other by pipe characters (&quot;|&quot;). The
 * entire choice format must be enclosed in double brackets (&quot;{{&quot; and &quot;}}&quot;,
 * respectively).
 *
 * Each choice must consist of a key and a value separated by an equals
 * character (&quot;=&quot;), unless it is a variable, in which case the variable must
 * resolve to another choice format. The selector may also be a variable. If the
 * selector is omitted, then one of the choices should use the key &quot;default&quot;.
 * Choice formats may be nested.
 *
 * &lt;pre&gt;
 *   key1=%colony% tuottaa tuotetta {{tag:acc|%goods%}}.
 *   key2={{plural:%amount%|one=ruoka|other=ruokaa|default={{tag:|acc=viljaa|default=Vilja}}}}
 *   key3={{tag:|acc=viljaa|default={{plural:%amount%|one=ruoka|other=ruokaa|default=Ruoka}}}}
 * &lt;/pre&gt;
 *
 * This class is NOT thread-safe. (CO: I cannot find any place that really has a
 * problem)
 */
<span class="nc" id="L84">public class Messages {</span>

	/** The Constant logger. */
<span class="fc" id="L87">	private static final Logger logger = Logger.getLogger(Messages.class.getName());</span>

	/** The Constant MESSAGE_FILE_PREFIX. */
	public static final String MESSAGE_FILE_PREFIX = &quot;FreeColMessages&quot;;

	/** The Constant MOD_MESSAGE_FILE_PREFIX. */
	public static final String MOD_MESSAGE_FILE_PREFIX = &quot;ModMessages&quot;;

	/** The Constant MESSAGE_FILE_SUFFIX. */
	public static final String MESSAGE_FILE_SUFFIX = &quot;.properties&quot;;

	/** The Constant DESCRIPTION_SUFFIX. */
	public static final String DESCRIPTION_SUFFIX = &quot;.description&quot;;

	/** The Constant SHORT_DESCRIPTION_SUFFIX. */
	public static final String SHORT_DESCRIPTION_SUFFIX = &quot;.shortDescription&quot;;

	/** The Constant NAME_SUFFIX. */
	public static final String NAME_SUFFIX = &quot;.name&quot;;

	/** The Constant RULER_SUFFIX. */
	public static final String RULER_SUFFIX = &quot;.ruler&quot;;

	/** The Constant DESCRIPTION_KEYS. */
<span class="fc" id="L111">	private static final String[] DESCRIPTION_KEYS = { DESCRIPTION_SUFFIX, SHORT_DESCRIPTION_SUFFIX, NAME_SUFFIX };</span>

	/** Automatic language choice from default locale. */
	public static final String AUTOMATIC = &quot;automatic&quot;;

	/**
	 * The mapping from language-independent key to localized message for the
	 * established locale.
	 */
<span class="fc" id="L120">	private static final Map&lt;String, String&gt; messageBundle = new HashMap&lt;&gt;();</span>

	/**
	 * A map with Selector values and the tag keys used in choice formats.
	 */
<span class="fc" id="L125">	private static final Map&lt;String, Selector&gt; tagMap = new HashMap&lt;&gt;();</span>

	// Message bundle initialization

	/**
	 * Gets the Selector with the given tag.
	 *
	 * @param tag
	 *            The tag to check.
	 * @return A suitable &lt;code&gt;Selector&lt;/code&gt;.
	 */
	private static Selector getSelector(String tag) {
<span class="fc" id="L137">		return tagMap.get(tag.toLowerCase(Locale.US));</span>
	}

	/**
	 * Set the grammatical number rule.
	 *
	 * @param number
	 *            a &lt;code&gt;Number&lt;/code&gt; value
	 */
	public static void setGrammaticalNumber(Number number) {
<span class="fc" id="L147">		tagMap.put(&quot;plural&quot;, number);</span>
<span class="fc" id="L148">	}</span>

	/**
	 * Get a list of candidate message file names for a given locale.
	 *
	 * @param locale
	 *            The &lt;code&gt;Locale&lt;/code&gt; to generate file names for.
	 * @return A list of message file names.
	 */
	private static List&lt;String&gt; getMessageFileNames(Locale locale) {
<span class="fc" id="L158">		return FreeColDataFile.getFileNames(MESSAGE_FILE_PREFIX, MESSAGE_FILE_SUFFIX, locale);</span>
	}

	/**
	 * Get a list of candidate mod message file names for a given locale.
	 *
	 * @param locale
	 *            The &lt;code&gt;Locale&lt;/code&gt; to generate file names for.
	 * @return A list of mod message file names.
	 */
	private static List&lt;String&gt; getModMessageFileNames(Locale locale) {
<span class="nc" id="L169">		return FreeColDataFile.getFileNames(MOD_MESSAGE_FILE_PREFIX, MESSAGE_FILE_SUFFIX, locale);</span>
	}

	/**
	 * Load the message bundle for the given locale
	 *
	 * Error messages have to go to System.err as this routine is called before
	 * logging is enabled.
	 *
	 * @param locale
	 *            The &lt;code&gt;Locale&lt;/code&gt; to set resources for.
	 */
	public static void loadMessageBundle(Locale locale) {
<span class="fc" id="L182">		messageBundle.clear(); // Reset the message bundle.</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">		if (!Locale.getDefault().equals(locale)) {</span>
<span class="fc" id="L185">			Locale.setDefault(locale);</span>
		}

<span class="fc" id="L188">		File i18nDirectory = FreeColDirectories.getI18nDirectory();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (!NumberRules.isInitialized()) {</span>
			// attempt to read grammatical rules
<span class="fc" id="L191">			File cldr = new File(i18nDirectory, &quot;plurals.xml&quot;);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">			if (cldr.exists()) {</span>
				try {
<span class="pc" id="L194">					try (FileInputStream in = new FileInputStream(cldr)) {</span>
<span class="fc" id="L195">						NumberRules.load(in);</span>
<span class="pc bpc" id="L196" title="6 of 8 branches missed.">					}</span>
<span class="nc" id="L197">				} catch (IOException e) {</span>
<span class="nc" id="L198">					System.err.println(&quot;Failed to read CLDR rules: &quot; + e.getMessage());</span>
<span class="pc" id="L199">				}</span>
			} else {
<span class="nc" id="L201">				System.err.println(&quot;Could not find CLDR rules: &quot; + cldr.getPath());</span>
			}
		}

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">		Locale loc = (AUTOMATIC.equalsIgnoreCase(locale.getLanguage())) ? Locale.getDefault() : locale;</span>
<span class="fc" id="L206">		setGrammaticalNumber(NumberRules.getNumberForLanguage(loc.getLanguage()));</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">		for (String name : getMessageFileNames(locale)) {</span>
<span class="fc" id="L209">			File file = new File(i18nDirectory, name);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">			if (!file.exists())</span>
<span class="fc" id="L211">				continue; // Expected</span>
			try {
<span class="fc" id="L213">				loadMessages(new FileInputStream(file));</span>
<span class="nc" id="L214">			} catch (IOException e) {</span>
<span class="nc" id="L215">				System.err.println(&quot;Failed to load messages from &quot; + name + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L216">			}</span>
<span class="fc" id="L217">		}</span>
<span class="fc" id="L218">	}</span>

	/**
	 * Loads messages from a resource file into the current message bundle.
	 * 
	 * Public for the test suite.
	 *
	 * @param is
	 *            The &lt;code&gt;InputStream&lt;/code&gt; to read from.
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 */
	public static void loadMessages(InputStream is) throws IOException {
		InputStreamReader inputReader;
		try {
<span class="fc" id="L233">			inputReader = new InputStreamReader(is, &quot;UTF-8&quot;);</span>
<span class="nc" id="L234">		} catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L235">			return; // We have big problems if UTF-8 is not supported.</span>
<span class="fc" id="L236">		}</span>
<span class="fc" id="L237">		BufferedReader in = new BufferedReader(inputReader);</span>

<span class="fc" id="L239">		String line = null;</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">		while ((line = in.readLine()) != null) {</span>
<span class="fc" id="L241">			line = line.trim();</span>
<span class="fc" id="L242">			int index = line.indexOf('#');</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">			if (index == 0)</span>
<span class="fc" id="L244">				continue;</span>
<span class="fc" id="L245">			index = line.indexOf('=');</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">			if (index &gt; 0) {</span>
<span class="fc" id="L247">				String key = line.substring(0, index).trim();</span>
<span class="fc" id="L248">				String value = line.substring(index + 1).trim().replace(&quot;\\n&quot;, &quot;\n&quot;).replace(&quot;\\t&quot;, &quot;\t&quot;);</span>
<span class="fc" id="L249">				messageBundle.put(key, value);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">				if (key.startsWith(&quot;FileChooser.&quot;)) {</span>
<span class="nc" id="L251">					UIManager.put(key, value);</span>
				}
			}
<span class="fc" id="L254">		}</span>
<span class="fc" id="L255">	}</span>

	/**
	 * Load localized messages for all mods.
	 *
	 * We can not initially load resources from mods because not all mods can be
	 * loaded until the user mod directory is initialized, which depends on the
	 * command line processing, which in turn requires at least the basic
	 * localized message resources to be loaded. So this routine is called
	 * separately when the mods are finally loaded.
	 *
	 * @param locale
	 *            The &lt;code&gt;Locale&lt;/code&gt; to load resources for.
	 */
	public static void loadModMessageBundle(Locale locale) {
<span class="nc" id="L270">		List&lt;FreeColModFile&gt; allMods = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L271">		allMods.addAll(Mods.getAllMods());</span>
<span class="nc" id="L272">		allMods.addAll(Mods.getRuleSets());</span>

<span class="nc" id="L274">		List&lt;String&gt; filenames = getMessageFileNames(locale);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">		for (FreeColModFile fcmf : allMods) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">			for (String name : filenames) {</span>
				try {
<span class="nc" id="L278">					loadMessages(fcmf.getInputStream(name));</span>
<span class="nc" id="L279">				} catch (IOException e) {</span>
<span class="nc" id="L280">				} // Failures expected</span>
<span class="nc" id="L281">			}</span>
<span class="nc" id="L282">		}</span>
<span class="nc" id="L283">	}</span>

	/**
	 * Load messages specific to active mods.
	 *
	 * Called when the spec is updated with the selected mods.
	 *
	 * @param mods
	 *            The list of &lt;code&gt;FreeColModFile&lt;/code&gt; for the active mods.
	 * @param locale
	 *            The &lt;code&gt;Locale&lt;/code&gt; to load resources for.
	 */
	public static void loadActiveModMessageBundle(List&lt;FreeColModFile&gt; mods, Locale locale) {
<span class="nc bnc" id="L296" title="All 2 branches missed.">		for (FreeColModFile fcmf : mods) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">			for (String name : getModMessageFileNames(locale)) {</span>
				try {
<span class="nc" id="L299">					loadMessages(fcmf.getInputStream(name));</span>
<span class="nc" id="L300">				} catch (IOException e) {</span>
<span class="nc" id="L301">				} // Failures expected</span>
<span class="nc" id="L302">			}</span>
<span class="nc" id="L303">		}</span>
<span class="nc" id="L304">	}</span>

	/**
	 * Get the &lt;code&gt;Locale&lt;/code&gt; corresponding to a given language name.
	 *
	 * Public as this is needed for language option processing and the initial
	 * locale setting.
	 *
	 * @param languageID
	 *            An underscore separated language/country/variant tuple.
	 * @return The &lt;code&gt;Locale&lt;/code&gt; for the specified language.
	 */
	public static Locale getLocale(String languageID) {
<span class="fc" id="L317">		String language, country = &quot;&quot;, variant = &quot;&quot;;</span>
<span class="fc" id="L318">		StringTokenizer st = new StringTokenizer(languageID, &quot;_&quot;, true);</span>
<span class="fc" id="L319">		language = st.nextToken();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">		if (st.hasMoreTokens()) {</span>
			// Skip _
<span class="fc" id="L322">			st.nextToken();</span>
		}
<span class="fc bfc" id="L324" title="All 2 branches covered.">		if (st.hasMoreTokens()) {</span>
<span class="fc" id="L325">			String token = st.nextToken();</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">			if (!&quot;_&quot;.equals(token)) {</span>
<span class="fc" id="L327">				country = token;</span>
			}
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">			if (st.hasMoreTokens()) {</span>
<span class="nc" id="L330">				token = st.nextToken();</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">				if (&quot;_&quot;.equals(token) &amp;&amp; st.hasMoreTokens()) {</span>
<span class="nc" id="L332">					token = st.nextToken();</span>
				}
<span class="nc bnc" id="L334" title="All 2 branches missed.">				if (!&quot;_&quot;.equals(token)) {</span>
<span class="nc" id="L335">					variant = token;</span>
				}
			}
		}
<span class="fc" id="L339">		return new Locale(language, country, variant);</span>
	}

	// Shortcut message accessors

	/**
	 * Name key.
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	public static String nameKey(String id) {
<span class="fc" id="L352">		return id + NAME_SUFFIX;</span>
	}

	/**
	 * Name key.
	 *
	 * @param object
	 *            the object
	 * @return the string
	 */
	public static String nameKey(ObjectWithId object) {
<span class="nc" id="L363">		return nameKey(object.getId());</span>
	}

	/**
	 * Gets the name.
	 *
	 * @param id
	 *            the id
	 * @return the name
	 */
	public static String getName(String id) {
<span class="nc" id="L374">		return message(nameKey(id));</span>
	}

	/**
	 * Gets the name.
	 *
	 * @param named
	 *            the named
	 * @return the name
	 */
	public static String getName(Named named) {
<span class="nc" id="L385">		return message(named.getNameKey());</span>
	}

	/**
	 * Description key.
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	public static String descriptionKey(String id) {
<span class="fc" id="L396">		return id + DESCRIPTION_SUFFIX;</span>
	}

	/**
	 * Description key.
	 *
	 * @param object
	 *            the object
	 * @return the string
	 */
	public static String descriptionKey(ObjectWithId object) {
<span class="nc" id="L407">		return descriptionKey(object.getId());</span>
	}

	/**
	 * Gets the description.
	 *
	 * @param id
	 *            the id
	 * @return the description
	 */
	public static String getDescription(String id) {
<span class="nc" id="L418">		return message(descriptionKey(id));</span>
	}

	/**
	 * Gets the description.
	 *
	 * @param object
	 *            the object
	 * @return the description
	 */
	public static String getDescription(ObjectWithId object) {
<span class="nc" id="L429">		return message(descriptionKey(object));</span>
	}

	/**
	 * Short description key.
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	public static String shortDescriptionKey(String id) {
<span class="nc" id="L440">		return id + SHORT_DESCRIPTION_SUFFIX;</span>
	}

	/**
	 * Gets the short description.
	 *
	 * @param id
	 *            the id
	 * @return the short description
	 */
	public static String getShortDescription(String id) {
<span class="nc" id="L451">		return message(shortDescriptionKey(id));</span>
	}

	/**
	 * Gets the short description.
	 *
	 * @param object
	 *            the object
	 * @return the short description
	 */
	public static String getShortDescription(ObjectWithId object) {
<span class="nc" id="L462">		return getShortDescription(object.getId());</span>
	}

	/**
	 * Ruler key.
	 *
	 * @param id
	 *            the id
	 * @return the string
	 */
	public static String rulerKey(String id) {
<span class="fc" id="L473">		return id + RULER_SUFFIX;</span>
	}

	/**
	 * Gets the ruler name.
	 *
	 * @param id
	 *            the id
	 * @return the ruler name
	 */
	public static String getRulerName(String id) {
<span class="nc" id="L484">		return message(rulerKey(id));</span>
	}

	/**
	 * Does the message bundle contain the given key?.
	 *
	 * @param key
	 *            The key &lt;code&gt;String&lt;/code&gt; to check.
	 * @return True if there is a message present with the given key.
	 */
	public static boolean containsKey(String key) {
<span class="fc bfc" id="L495" title="All 2 branches covered.">		return messageBundle.get(key) != null;</span>
	}

	/**
	 * Returns the preferred key if it is contained in the message bundle and
	 * the default key otherwise. This should be used to select the most
	 * specific message key available.
	 *
	 * @param preferredKey
	 *            a &lt;code&gt;String&lt;/code&gt; value
	 * @param defaultKey
	 *            a &lt;code&gt;String&lt;/code&gt; value
	 * @return a &lt;code&gt;String&lt;/code&gt; value
	 */
	public static String getKey(String preferredKey, String defaultKey) {
<span class="nc bnc" id="L510" title="All 2 branches missed.">		if (containsKey(preferredKey)) {</span>
<span class="nc" id="L511">			return preferredKey;</span>
		} else {
<span class="nc" id="L513">			return defaultKey;</span>
		}
	}

	/**
	 * Gets the best description.
	 *
	 * @param object
	 *            the object
	 * @return the best description
	 */
	public static String getBestDescription(ObjectWithId object) {
<span class="nc" id="L525">		return getBestDescription(object.getId());</span>
	}

	/**
	 * Gets the best description.
	 *
	 * @param id
	 *            the id
	 * @return the best description
	 */
	public static String getBestDescription(String id) {
<span class="nc" id="L536">		String key = find(map(DESCRIPTION_KEYS, s -&gt; id + s), k -&gt; containsKey(k), null);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">		return (key == null) ? id : message(key);</span>
	}

	/**
	 * Get the name and best description for a given named object.
	 *
	 * Favour the .name form, but degrade gracefully if it is not present. If
	 * .name is present, also look for a description.
	 *
	 * @param named
	 *            The &lt;code&gt;Named&lt;/code&gt; to look up.
	 * @return A 2-element array of name and description found.
	 */
	public static String[] getBestNameAndDescription(Named named) {
<span class="nc" id="L551">		return getBestNameAndDescription(named.getNameKey());</span>
	}

	/**
	 * Get the name and best description for a given identifier.
	 *
	 * Favour the .name form, but degrade gracefully if it is not present. If
	 * .name is present, also look for a description.
	 *
	 * @param id
	 *            The identifier to look up.
	 * @return A 2-element array of name and description found.
	 */
	public static String[] getBestNameAndDescription(String id) {
<span class="nc bnc" id="L565" title="All 4 branches missed.">		if (id != null &amp;&amp; id.endsWith(NAME_SUFFIX)) { // Temporary hack</span>
<span class="nc" id="L566">			id = id.substring(0, id.length() - NAME_SUFFIX.length());</span>
		}
<span class="nc bnc" id="L568" title="All 2 branches missed.">		String name = (containsKey(nameKey(id))) ? getName(id) : null;</span>
<span class="nc" id="L569">		String desc = null;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		if (name == null) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">			name = (containsKey(id)) ? message(id) : null;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">			if (name == null)</span>
<span class="nc" id="L573">				name = id;</span>
		} else {
<span class="nc" id="L575">			desc = getBestDescription(id);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">			if (id.equals(desc))</span>
<span class="nc" id="L577">				desc = null;</span>
		}
<span class="nc" id="L579">		return new String[] { name, desc };</span>
	}

	// Special purpose unit labelling

	/**
	 * Get a label for a collection of units given a name, type, number, nation,
	 * role and extra annotation.
	 *
	 * @param name
	 *            An optional unit name.
	 * @param typeId
	 *            The unit type identifier.
	 * @param number
	 *            The number of units.
	 * @param nationId
	 *            An optional nation identifier.
	 * @param roleId
	 *            The unit role identifier.
	 * @param extra
	 *            An optional extra annotation.
	 * @return A &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
	 */
	public static StringTemplate getUnitLabel(String name, String typeId, int number, String nationId, String roleId,
			StringTemplate extra) {
		// Check for special role-specific key, which will not have a
		// role argument. These exist so we can avoid mentioning
		// the role twice, e.g. &quot;Seasoned Scout Scout&quot;.
		StringTemplate type;
		String roleKey;
<span class="fc" id="L609">		String baseKey = typeId + &quot;.&quot; + Role.getRoleSuffix(roleId);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">		if (containsKey(baseKey)) {</span>
<span class="fc" id="L611">			type = StringTemplate.template(baseKey).addAmount(&quot;%number%&quot;, number);</span>
<span class="fc" id="L612">			roleKey = null;</span>
		} else {
<span class="fc" id="L614">			type = StringTemplate.template(nameKey(typeId)).addAmount(&quot;%number%&quot;, number);</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">			roleKey = (Role.isDefaultRoleId(roleId)) ? null : roleId;</span>
		}

		StringTemplate ret;
<span class="fc bfc" id="L619" title="All 2 branches covered.">		if (name == null) {</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">			if (nationId == null) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">				if (roleKey == null) {</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">					if (extra == null) {</span>
						// %type% | &quot;Free Colonist&quot;
<span class="fc" id="L624">						ret = type;</span>
					} else {
						// %type% (%extra%) | &quot;Treasure Train (5000 gold)&quot;
<span class="nc" id="L627">						ret = StringTemplate.label(&quot;&quot;).addStringTemplate(type).addName(&quot; (&quot;).addStringTemplate(extra)</span>
<span class="nc" id="L628">								.addName(&quot;)&quot;);</span>
					}
				} else {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">					if (extra == null) {</span>
						// %role% (%type%) | &quot;Soldier (Free Colonist)&quot;
<span class="fc" id="L633">						ret = StringTemplate.label(&quot;&quot;).add(nameKey(roleKey)).addName(&quot; (&quot;).addStringTemplate(type)</span>
<span class="fc" id="L634">								.addName(&quot;)&quot;);</span>
					} else {
						// %role% (%type%/%extra%) | &quot;Soldier (Free Colonist/50
						// muskets)&quot;
<span class="nc" id="L638">						ret = StringTemplate.label(&quot;&quot;).add(nameKey(roleKey)).addName(&quot; (&quot;).addStringTemplate(type)</span>
<span class="nc" id="L639">								.addName(&quot;/&quot;).addStringTemplate(extra).addName(&quot;)&quot;);</span>
					}
				}
			} else {
<span class="fc bfc" id="L643" title="All 2 branches covered.">				if (roleKey == null) {</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">					if (extra == null) {</span>
						// %nation% %type% | &quot;Dutch Free Colonist&quot;
<span class="fc" id="L646">						ret = StringTemplate.label(&quot;&quot;).add(nameKey(nationId)).addName(&quot; &quot;).addStringTemplate(type);</span>
					} else {
						// %nation% %type% (%extra%) | &quot;Dutch Treasure Train
						// (5000 gold)&quot;
<span class="fc" id="L650">						ret = StringTemplate.label(&quot;&quot;).add(nameKey(nationId)).addName(&quot; &quot;).addStringTemplate(type)</span>
<span class="fc" id="L651">								.addName(&quot; (&quot;).addStringTemplate(extra).addName(&quot;)&quot;);</span>
					}
				} else {
<span class="fc bfc" id="L654" title="All 2 branches covered.">					if (extra == null) {</span>
						// %nation% %role% (%type%) | &quot;Dutch Soldier (Free
						// Colonist)&quot;
<span class="fc" id="L657">						ret = StringTemplate.label(&quot;&quot;).add(nameKey(nationId)).addName(&quot; &quot;).add(nameKey(roleKey))</span>
<span class="fc" id="L658">								.addName(&quot; (&quot;).addStringTemplate(type).addName(&quot;)&quot;);</span>
					} else {
						// %nation% %role% (%type%/%extra%) | &quot;Dutch Soldier
						// (Free Colonist/50 muskets)&quot;
<span class="fc" id="L662">						ret = StringTemplate.label(&quot;&quot;).add(nameKey(nationId)).addName(&quot; &quot;).add(nameKey(roleKey))</span>
<span class="fc" id="L663">								.addName(&quot; (&quot;).addStringTemplate(type).addName(&quot;/&quot;).addStringTemplate(extra)</span>
<span class="fc" id="L664">								.addName(&quot;)&quot;);</span>
					}
				}
			}
		} else {
<span class="fc bfc" id="L669" title="All 2 branches covered.">			if (nationId == null) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">				if (roleKey == null) {</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">					if (extra == null) {</span>
						// %name% (%type%) | &quot;Bob (Free Colonist)&quot;
<span class="fc" id="L673">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).addStringTemplate(type).addName(&quot;)&quot;);</span>
					} else {
						// %name% (%type%/%extra%) | &quot;Moolah (Treasure
						// Train/5000 gold)&quot;
<span class="nc" id="L677">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).addStringTemplate(type).addName(&quot;/&quot;)</span>
<span class="nc" id="L678">								.addStringTemplate(extra).addName(&quot;)&quot;);</span>
					}
				} else {
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">					if (extra == null) {</span>
						// %name% (%role%/%type%) | &quot;Bob (Soldier/Free
						// Colonist)&quot;
<span class="fc" id="L684">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).add(nameKey(roleKey)).addName(&quot;/&quot;)</span>
<span class="fc" id="L685">								.addStringTemplate(type).addName(&quot;)&quot;);</span>
					} else {
						// %name% (%role%/%type%/%extra%) | &quot;Bob (Soldier/Free
						// Colonist/50 muskets)&quot;
<span class="nc" id="L689">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).add(nameKey(roleKey)).addName(&quot;/&quot;)</span>
<span class="nc" id="L690">								.addStringTemplate(type).addName(&quot;/&quot;).addStringTemplate(extra).addName(&quot;)&quot;);</span>
					}
				}
			} else {
<span class="fc bfc" id="L694" title="All 2 branches covered.">				if (roleKey == null) {</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">					if (extra == null) {</span>
						// %name% (%nation% %type%) | &quot;Bob (Dutch Free
						// Colonist)&quot;
<span class="fc" id="L698">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).add(nameKey(nationId)).addName(&quot; &quot;)</span>
<span class="fc" id="L699">								.addStringTemplate(type).addName(&quot;)&quot;);</span>
					} else {
						// %name% (%nation% %type%/%extra%) | &quot;Moolah (Dutch
						// Treasure Train/5000 gold)&quot;
<span class="fc" id="L703">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).add(nameKey(nationId)).addName(&quot; &quot;)</span>
<span class="fc" id="L704">								.addStringTemplate(type).addName(&quot;/&quot;).addStringTemplate(extra).addName(&quot;)&quot;);</span>
					}
				} else {
<span class="fc bfc" id="L707" title="All 2 branches covered.">					if (extra == null) {</span>
						// %name% (%nation% %role%/%type%) | &quot;Bob (Dutch
						// Soldier/Free Colonist)&quot;
<span class="fc" id="L710">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).add(nameKey(nationId)).addName(&quot; &quot;)</span>
<span class="fc" id="L711">								.add(nameKey(roleKey)).addName(&quot;/&quot;).addStringTemplate(type).addName(&quot;)&quot;);</span>
					} else {
						// %name% (%nation% %role%/%type%/%extra%) | &quot;Bob (Dutch
						// Soldier/Free Colonist/50 muskets)&quot;
<span class="fc" id="L715">						ret = StringTemplate.label(&quot;&quot;).addName(name).addName(&quot; (&quot;).add(nameKey(nationId)).addName(&quot; &quot;)</span>
<span class="fc" id="L716">								.add(nameKey(roleKey)).addName(&quot;/&quot;).addStringTemplate(type).addName(&quot;/&quot;)</span>
<span class="fc" id="L717">								.addStringTemplate(extra).addName(&quot;)&quot;);</span>
					}
				}
			}
		}
<span class="fc" id="L722">		return ret;</span>
	}

	// message(). The fundamental i18n routine, and its support.

	/**
	 * Get the text mapping for a particular identifier in the default locale
	 * message bundle. Returns the key as the value if there is no mapping
	 * found!
	 *
	 * @param messageId
	 *            The key of the message to find.
	 * @return String text mapping or the key
	 */
	public static String message(String messageId) {
		// Check that all the values are correct.
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">		if (messageId == null) {</span>
<span class="nc" id="L739">			throw new NullPointerException(&quot;Message id must not be null!&quot;);</span>
		}

		// return key as value if there is no mapping found
<span class="fc" id="L743">		String message = messageBundle.get(messageId);</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">		if (message == null)</span>
<span class="fc" id="L745">			return messageId;</span>

		// otherwise replace variables in the text
<span class="fc" id="L748">		message = replaceChoices(message, null);</span>
<span class="fc" id="L749">		return message.trim();</span>
	}

	/**
	 * Localizes a StringTemplate.
	 *
	 * @param template
	 *            The &lt;code&gt;StringTemplate&lt;/code&gt; to localize.
	 * @return The localized string.
	 */
	public static String message(StringTemplate template) {
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">		if (template == null)</span>
<span class="nc" id="L761">			return null;</span>
<span class="fc" id="L762">		String result = &quot;&quot;;</span>
<span class="pc bfc" id="L763" title="All 4 branches covered.">		switch (template.getTemplateType()) {</span>
		case LABEL:
<span class="fc" id="L765">			List&lt;StringTemplate&gt; replacements = template.getReplacements();</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">			if (replacements.isEmpty()) {</span>
<span class="nc" id="L767">				result = message(template.getId());</span>
			} else {
<span class="fc bfc" id="L769" title="All 2 branches covered.">				for (StringTemplate other : replacements) {</span>
<span class="fc" id="L770">					result += template.getId() + message(other);</span>
<span class="fc" id="L771">				}</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">				if (result.length() &gt;= template.getId().length()) {</span>
<span class="fc" id="L773">					result = result.substring(template.getId().length());</span>
				} else {
<span class="nc" id="L775">					logger.warning(&quot;incorrect use of template &quot; + template);</span>
				}
			}
<span class="nc" id="L778">			break;</span>
		case TEMPLATE:
<span class="fc bfc" id="L780" title="All 2 branches covered.">			if (containsKey(template.getId())) {</span>
<span class="fc" id="L781">				result = messageBundle.get(template.getId());</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">			} else if (template.getDefaultId() != null) {</span>
<span class="fc" id="L783">				result = messageBundle.get(template.getDefaultId());</span>
			}
<span class="fc" id="L785">			result = replaceChoices(result, template);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">			for (String key : template.getKeys()) {</span>
<span class="fc" id="L787">				result = result.replace(key, message(template.getReplacement(key)));</span>
<span class="fc" id="L788">			}</span>
<span class="fc" id="L789">			break;</span>
		case KEY:
<span class="fc" id="L791">			String key = messageBundle.get(template.getId());</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">			result = (key == null) ? template.getId() : replaceChoices(key, null);</span>
<span class="fc" id="L793">			break;</span>
		case NAME:
		default:
<span class="fc" id="L796">			result = template.getId();</span>
			break;
		}
<span class="fc" id="L799">		return result;</span>
	}

	/**
	 * Replace all choice formats in the given string, using keys and
	 * replacement values from the given template, which may be null.
	 *
	 * A choice format is enclosed in double brackets and consists of a tag,
	 * followed by a colon, followed by an optional selector, followed by a pipe
	 * character, followed by one or several choices separated by pipe
	 * characters. If there is only one choice, it must be a message identifier
	 * or a variable. Otherwise, each choice consists of a key and a value
	 * separated by an assignment character. Example:
	 * &quot;{{tag:selector|key1=val1|key2=val2}}&quot;.
	 *
	 * @param input
	 *            a &lt;code&gt;String&lt;/code&gt; value
	 * @param template
	 *            a &lt;code&gt;StringTemplate&lt;/code&gt; value
	 * @return a &lt;code&gt;String&lt;/code&gt; value
	 */
	private static String replaceChoices(String input, StringTemplate template) {
<span class="fc" id="L821">		int openChoice = 0;</span>
<span class="fc" id="L822">		int closeChoice = 0;</span>
<span class="fc" id="L823">		int highWaterMark = 0;</span>
<span class="fc" id="L824">		StringBuilder result = new StringBuilder();</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">		while ((openChoice = input.indexOf(&quot;{{&quot;, highWaterMark)) &gt;= 0) {</span>
<span class="fc" id="L826">			result.append(input.substring(highWaterMark, openChoice));</span>
<span class="fc" id="L827">			closeChoice = findMatchingBracket(input, openChoice + 2);</span>
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">			if (closeChoice &lt; 0) {</span>
				// no closing brackets found
<span class="nc" id="L830">				logger.warning(&quot;Mismatched brackets: &quot; + input);</span>
<span class="nc" id="L831">				return result.toString();</span>
			}
<span class="fc" id="L833">			highWaterMark = closeChoice + 2;</span>
<span class="fc" id="L834">			int colonIndex = input.indexOf(':', openChoice + 2);</span>
<span class="pc bpc" id="L835" title="1 of 4 branches missed.">			if (colonIndex &lt; 0 || colonIndex &gt; closeChoice) {</span>
<span class="fc" id="L836">				logger.warning(&quot;No tag found: &quot; + input);</span>
<span class="fc" id="L837">				continue;</span>
			}
<span class="fc" id="L839">			String tag = input.substring(openChoice + 2, colonIndex);</span>
<span class="fc" id="L840">			int pipeIndex = input.indexOf('|', colonIndex + 1);</span>
<span class="pc bpc" id="L841" title="2 of 4 branches missed.">			if (pipeIndex &lt; 0 || pipeIndex &gt; closeChoice) {</span>
<span class="nc" id="L842">				logger.warning(&quot;No choices found: &quot; + input);</span>
<span class="nc" id="L843">				continue;</span>
			}
<span class="fc" id="L845">			String selector = input.substring(colonIndex + 1, pipeIndex);</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">			if (selector.isEmpty()) {</span>
<span class="fc" id="L847">				selector = &quot;default&quot;;</span>
<span class="pc bpc" id="L848" title="1 of 4 branches missed.">			} else if (selector.startsWith(&quot;%&quot;) &amp;&amp; selector.endsWith(&quot;%&quot;)) {</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">				if (template == null) {</span>
<span class="fc" id="L850">					selector = &quot;default&quot;;</span>
				} else {
<span class="fc" id="L852">					StringTemplate replacement = template.getReplacement(selector);</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">					if (replacement == null) {</span>
<span class="nc" id="L854">						logger.warning(&quot;Failed to find replacement for &quot; + selector);</span>
<span class="nc" id="L855">						continue;</span>
					} else {
<span class="fc" id="L857">						selector = message(replacement);</span>
<span class="fc" id="L858">						Selector taggedSelector = getSelector(tag);</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">						if (taggedSelector != null) {</span>
<span class="fc" id="L860">							selector = taggedSelector.getKey(selector, input);</span>
						}
					}
<span class="fc" id="L863">				}</span>
			} else {
<span class="fc" id="L865">				Selector taggedSelector = getSelector(tag);</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">				if (taggedSelector != null) {</span>
<span class="nc" id="L867">					selector = taggedSelector.getKey(selector, input);</span>
				}
			}
<span class="fc" id="L870">			int keyIndex = input.indexOf(selector, pipeIndex + 1);</span>
<span class="pc bpc" id="L871" title="1 of 4 branches missed.">			if (keyIndex &lt; 0 || keyIndex &gt; closeChoice) {</span>
				// key not found, choice might be a key itself
<span class="fc" id="L873">				String otherKey = input.substring(pipeIndex + 1, closeChoice);</span>
<span class="pc bpc" id="L874" title="2 of 6 branches missed.">				if (otherKey.startsWith(&quot;%&quot;) &amp;&amp; otherKey.endsWith(&quot;%&quot;) &amp;&amp; template != null) {</span>
<span class="fc" id="L875">					StringTemplate replacement = template.getReplacement(otherKey);</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">					if (replacement == null) {</span>
<span class="nc" id="L877">						logger.warning(&quot;Failed to find replacement for &quot; + otherKey);</span>
<span class="nc" id="L878">						continue;</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">					} else if (replacement.getTemplateType() == TemplateType.KEY) {</span>
<span class="fc" id="L880">						otherKey = messageBundle.get(replacement.getId());</span>
<span class="fc" id="L881">						keyIndex = otherKey.indexOf(&quot;{{&quot;);</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">						if (keyIndex &lt; 0) {</span>
							// not a choice format
<span class="fc" id="L884">							result.append(otherKey);</span>
						} else {
<span class="fc" id="L886">							keyIndex = otherKey.indexOf(selector, keyIndex);</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">							if (keyIndex &lt; 0) {</span>
<span class="nc" id="L888">								logger.warning(</span>
<span class="nc" id="L889">										&quot;Failed to find key &quot; + selector + &quot; in replacement &quot; + replacement.getId());</span>
<span class="nc" id="L890">								continue;</span>
							} else {
<span class="fc" id="L892">								result.append(getChoice(otherKey, selector));</span>
							}
						}
					} else {
<span class="nc" id="L896">						logger.warning(&quot;Choice substitution attempted, but template type was &quot;</span>
<span class="nc" id="L897">								+ replacement.getTemplateType());</span>
<span class="nc" id="L898">						continue;</span>
					}
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">				} else if (containsKey(otherKey)) {</span>
<span class="nc" id="L901">					otherKey = getChoice(messageBundle.get(otherKey), selector);</span>
<span class="nc" id="L902">					result.append(otherKey);</span>
				} else {
<span class="fc" id="L904">					logger.warning(&quot;Unknown key or untagged choice: '&quot; + otherKey + &quot;', selector was '&quot; + selector</span>
							+ &quot;', trying 'default' instead&quot;);
<span class="fc" id="L906">					int defaultStart = otherKey.indexOf(&quot;default=&quot;);</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">					if (defaultStart &gt;= 0) {</span>
<span class="fc" id="L908">						defaultStart += 8;</span>
<span class="fc" id="L909">						int defaultEnd = otherKey.indexOf('|', defaultStart);</span>
						String defaultChoice;
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">						if (defaultEnd &lt; 0) {</span>
<span class="fc" id="L912">							defaultChoice = otherKey.substring(defaultStart);</span>
						} else {
<span class="nc" id="L914">							defaultChoice = otherKey.substring(defaultStart, defaultEnd);</span>
						}
<span class="fc" id="L916">						result.append(defaultChoice);</span>
<span class="fc" id="L917">					} else {</span>
<span class="nc" id="L918">						logger.warning(&quot;No default choice found.&quot;);</span>
<span class="nc" id="L919">						continue;</span>
					}
				}
<span class="fc" id="L922">			} else {</span>
<span class="fc" id="L923">				int start = keyIndex + selector.length() + 1;</span>
<span class="fc" id="L924">				int replacementIndex = input.indexOf('|', start);</span>
<span class="fc" id="L925">				int nextOpenIndex = input.indexOf(&quot;{{&quot;, start);</span>
<span class="pc bpc" id="L926" title="1 of 4 branches missed.">				if (nextOpenIndex &gt;= 0 &amp;&amp; nextOpenIndex &lt; replacementIndex) {</span>
<span class="fc" id="L927">					replacementIndex = input.indexOf('|', findMatchingBracket(input, nextOpenIndex + 2) + 2);</span>
				}
<span class="fc bfc" id="L929" title="All 4 branches covered.">				int end = (replacementIndex &lt; 0 || replacementIndex &gt; closeChoice) ? closeChoice : replacementIndex;</span>
<span class="fc" id="L930">				String replacement = input.substring(start, end);</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">				if (!replacement.contains(&quot;{{&quot;)) {</span>
<span class="fc" id="L932">					result.append(replacement);</span>
				} else {
<span class="fc" id="L934">					result.append(replaceChoices(replacement, template));</span>
				}
			}
<span class="fc" id="L937">		}</span>
<span class="fc" id="L938">		result.append(input.substring(highWaterMark));</span>
<span class="fc" id="L939">		return result.toString();</span>
	}

	/**
	 * Return the choice tagged with the given key, or null, if the given input
	 * string does not contain the key.
	 *
	 * @param input
	 *            a &lt;code&gt;String&lt;/code&gt; value
	 * @param key
	 *            a &lt;code&gt;String&lt;/code&gt; value
	 * @return a &lt;code&gt;String&lt;/code&gt; value
	 */
	private static String getChoice(String input, String key) {
<span class="fc" id="L953">		int keyIndex = input.indexOf(key);</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">		if (keyIndex &lt; 0) {</span>
<span class="nc" id="L955">			return null;</span>
		} else {
<span class="fc" id="L957">			int start = keyIndex + key.length() + 1;</span>
<span class="fc" id="L958">			int end = input.indexOf('|', start);</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">			if (end &lt; 0) {</span>
<span class="fc" id="L960">				end = input.indexOf(&quot;}}&quot;, start);</span>
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">				if (end &lt; 0) {</span>
<span class="nc" id="L962">					logger.warning(&quot;Failed to find end of choice for key &quot; + key + &quot; in input &quot; + input);</span>
<span class="nc" id="L963">					return null;</span>
				}
			}
<span class="fc" id="L966">			return input.substring(start, end);</span>
		}
	}

	/**
	 * Return the index of the matching pair of brackets, or -1 if none is
	 * found.
	 *
	 * @param input
	 *            a &lt;code&gt;String&lt;/code&gt; value
	 * @param start
	 *            an &lt;code&gt;int&lt;/code&gt; value
	 * @return an &lt;code&gt;int&lt;/code&gt; value
	 */
	private static int findMatchingBracket(String input, int start) {
<span class="fc" id="L981">		char last = 0;</span>
<span class="fc" id="L982">		int level = 0;</span>
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">		for (int index = start; index &lt; input.length(); index++) {</span>
<span class="fc bfc" id="L984" title="All 3 branches covered.">			switch (input.charAt(index)) {</span>
			case '{':
<span class="fc bfc" id="L986" title="All 2 branches covered.">				if (last == '{') {</span>
<span class="fc" id="L987">					last = 0;</span>
<span class="fc" id="L988">					level++;</span>
				} else {
<span class="fc" id="L990">					last = '{';</span>
				}
<span class="fc" id="L992">				break;</span>
			case '}':
<span class="fc bfc" id="L994" title="All 2 branches covered.">				if (last == '}') {</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">					if (level == 0) {</span>
<span class="fc" id="L996">						return index - 1;</span>
					} else {
<span class="fc" id="L998">						last = 0;</span>
<span class="fc" id="L999">						level--;</span>
					}
				} else {
<span class="fc" id="L1002">					last = '}';</span>
				}
<span class="fc" id="L1004">				break;</span>
			default:
				break;
			}
		}
		// found no matching bracket
<span class="nc" id="L1010">		return -1;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>