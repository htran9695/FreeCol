<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mission.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.ai.mission</a> &gt; <span class="el_source">Mission.java</span></div><h1>Mission.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.ai.mission;

import java.util.Random;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.Europe;
import net.sf.freecol.common.model.FreeColGameObject;
import net.sf.freecol.common.model.Locatable;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.Map;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.Ownable;
import net.sf.freecol.common.model.PathNode;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Stance;
import net.sf.freecol.common.model.Settlement;
import net.sf.freecol.common.model.Tension;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.Unit.MoveType;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.util.LogBuilder;
import static net.sf.freecol.common.util.StringUtils.*;
import net.sf.freecol.server.ai.AIMain;
import net.sf.freecol.server.ai.AIMessage;
import net.sf.freecol.server.ai.AIObject;
import net.sf.freecol.server.ai.AIPlayer;
import net.sf.freecol.server.ai.AIUnit;
import net.sf.freecol.server.ai.EuropeanAIPlayer;
import net.sf.freecol.server.ai.TransportableAIObject;

/**
 * A mission describes what a unit should do; attack, build colony, wander etc.
 * Every {@link AIUnit} should have a mission. By extending this class, you
 * create different missions.
 */
public abstract class Mission extends AIObject {

	/** The Constant logger. */
<span class="fc" id="L66">	private static final Logger logger = Logger.getLogger(Mission.class.getName());</span>

	/** A transport can be used. */
	protected static final int MINIMUM_TRANSPORT_PRIORITY = 60;

	/** Transport is required. */
	protected static final int NORMAL_TRANSPORT_PRIORITY = 100;

	/** The Constant NO_MORE_MOVES_LEFT. */
	protected static final int NO_PATH_TO_TARGET = -2, NO_MORE_MOVES_LEFT = -1;

	/** The Constant AIUNITNULL. */
	// Common mission invalidity reasons.
	protected static final String AIUNITNULL = &quot;aiUnit-null&quot;;

	/** The Constant TARGETNULL. */
	protected static final String TARGETNULL = &quot;target-null&quot;;

	/** The Constant TARGETINVALID. */
	protected static final String TARGETINVALID = &quot;target-invalid&quot;;

	/** The Constant TARGETOWNERSHIP. */
	protected static final String TARGETOWNERSHIP = &quot;target-ownership&quot;;

	/** The Constant TARGETNOTFOUND. */
	protected static final String TARGETNOTFOUND = &quot;target-not-found&quot;;

	/** The Constant UNITNOTAPERSON. */
	protected static final String UNITNOTAPERSON = &quot;unit-not-a-person&quot;;

	/** The Constant UNITNOTOFFENSIVE. */
	protected static final String UNITNOTOFFENSIVE = &quot;unit-not-offensive&quot;;

	/** The Constant UNITNOTONMAP. */
	protected static final String UNITNOTONMAP = &quot;unit-not-on-map&quot;;

	/** The unit to undertake the mission. */
	private final AIUnit aiUnit;

	/**
	 * Creates a mission for the given &lt;code&gt;AIUnit&lt;/code&gt;.
	 *
	 * Note that missions are attached to their units, and thus do not need AI
	 * ids, hence the plain superclass constructor.
	 *
	 * @param aiMain
	 *            The main AI-object.
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; this mission is created for.
	 */
	protected Mission(AIMain aiMain, AIUnit aiUnit) {
<span class="fc" id="L117">		super(aiMain);</span>

<span class="fc" id="L119">		this.aiUnit = aiUnit;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		this.uninitialized = aiUnit == null;</span>
<span class="fc" id="L121">	}</span>

	/**
	 * Creates a mission for the given &lt;code&gt;AIUnit&lt;/code&gt; and target.
	 *
	 * Note that missions are attached to their units, and thus do not need AI
	 * ids, hence the plain superclass constructor.
	 *
	 * @param aiMain
	 *            The main AI-object.
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; this mission is created for.
	 * @param target
	 *            The initial target &lt;code&gt;Location&lt;/code&gt;.
	 */
	protected Mission(AIMain aiMain, AIUnit aiUnit, Location target) {
<span class="fc" id="L137">		this(aiMain, aiUnit);</span>

<span class="fc" id="L139">		setTarget(target);</span>
<span class="pc bpc" id="L140" title="2 of 4 branches missed.">		if (aiUnit != null &amp;&amp; aiUnit.getMission() != this) {</span>
<span class="fc" id="L141">			aiUnit.changeMission(this);</span>
		}
<span class="fc" id="L143">	}</span>

	/**
	 * Gets the AI-unit this mission has been created for.
	 *
	 * @return The &lt;code&gt;AIUnit&lt;/code&gt;.
	 */
	public final AIUnit getAIUnit() {
<span class="fc" id="L151">		return aiUnit;</span>
	}

	/**
	 * Gets the unit this mission has been created for.
	 *
	 * @return The &lt;code&gt;Unit&lt;/code&gt;.
	 */
	public final Unit getUnit() {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">		return (aiUnit == null) ? null : aiUnit.getUnit();</span>
	}

	/**
	 * Convenience accessor for the owning player.
	 *
	 * @return The &lt;code&gt;Player&lt;/code&gt; that owns the mission unit.
	 */
	protected final Player getPlayer() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">		return (getUnit() == null) ? null : getUnit().getOwner();</span>
	}

	/**
	 * Convenience accessor for the owning AI player.
	 *
	 * @return The &lt;code&gt;AIPlayer&lt;/code&gt;.
	 */
	protected final AIPlayer getAIPlayer() {
<span class="nc" id="L178">		return getAIMain().getAIPlayer(getUnit().getOwner());</span>
	}

	/**
	 * Convenience accessor for the owning European AI player.
	 *
	 * @return The &lt;code&gt;EuropeanAIPlayer&lt;/code&gt;.
	 */
	protected final EuropeanAIPlayer getEuropeanAIPlayer() {
<span class="fc" id="L187">		Player player = getUnit().getOwner();</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		if (!player.isEuropean()) {</span>
<span class="nc" id="L189">			throw new IllegalArgumentException(&quot;Not a European player: &quot; + player);</span>
		}
<span class="fc" id="L191">		return (EuropeanAIPlayer) getAIMain().getAIPlayer(player);</span>
	}

	/**
	 * Convenience accessor for the unit/player PRNG.
	 *
	 * @return A &lt;code&gt;Random&lt;/code&gt; to use.
	 */
	protected final Random getAIRandom() {
<span class="nc" id="L200">		return aiUnit.getAIRandom();</span>
	}

	/**
	 * Is this mission valid?.
	 *
	 * @return True if the mission is valid.
	 */
	public final boolean isValid() {
<span class="fc bfc" id="L209" title="All 2 branches covered.">		return invalidReason() == null;</span>
	}

	/**
	 * Is an invalidity reason due to a target failure?.
	 *
	 * @param reason
	 *            the reason
	 * @return True if the reason starts with &quot;target-&quot;.
	 */
	public static boolean isTargetReason(String reason) {
<span class="nc bnc" id="L220" title="All 4 branches missed.">		return reason != null &amp;&amp; reason.startsWith(&quot;target-&quot;);</span>
	}

	/**
	 * Is a unit able to perform a mission of a particular type?.
	 *
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @return A reason for mission invalidity, or null if none found.
	 */
	public static String invalidUnitReason(Unit unit) {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">		return (unit == null) ? &quot;unit-null&quot;</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">				: (unit.isUninitialized()) ? &quot;unit-uninitialized&quot;</span>
<span class="pc bpc" id="L233" title="1 of 4 branches missed.">						: (unit.isDisposed()) ? &quot;unit-disposed&quot; : (unit.isDamaged()) ? &quot;unit-under-repair&quot; : null;</span>
	}

	/**
	 * Is an AI unit able to perform a mission of a particular type?.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to check.
	 * @return A reason for mission invalidity, or null if none found.
	 */
	public static String invalidAIUnitReason(AIUnit aiUnit) {
		String reason;
<span class="pc bpc" id="L245" title="1 of 4 branches missed.">		return (aiUnit == null) ? AIUNITNULL : ((reason = invalidUnitReason(aiUnit.getUnit())) != null) ? reason : null;</span>
	}

	/**
	 * Is an AI unable to perform a new mission because it already has a valid,
	 * non-onetime mission?.
	 *
	 * @param aiUnit
	 *            the ai unit
	 * @return &quot;mission-exists&quot; if a valid mission is found, or null if none
	 *         found.
	 */
	public static String invalidNewMissionReason(AIUnit aiUnit) {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">		return (aiUnit == null) ? AIUNITNULL</span>
<span class="pc bpc" id="L259" title="3 of 6 branches missed.">				: (aiUnit.hasMission() &amp;&amp; !aiUnit.getMission().isOneTime() &amp;&amp; aiUnit.getMission().isValid())</span>
						? &quot;mission-exists&quot; : null;
	}

	/**
	 * Is a target a valid mission target?.
	 *
	 * @param target
	 *            The target &lt;code&gt;Location&lt;/code&gt; to check.
	 * @return A reason for the target to be invalid, or null if none found.
	 */
	public static String invalidTargetReason(Location target) {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">		return (target == null) ? Mission.TARGETNULL</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">				: (((FreeColGameObject) target).isDisposed()) ? &quot;target-disposed&quot; : null;</span>
	}

	/**
	 * Is a target a valid mission target?.
	 *
	 * @param target
	 *            The target &lt;code&gt;Location&lt;/code&gt; to check.
	 * @param owner
	 *            A &lt;code&gt;Player&lt;/code&gt; that should own the target.
	 * @return A reason for the target to be invalid, or null if none found.
	 */
	public static String invalidTargetReason(Location target, Player owner) {
<span class="fc" id="L285">		String reason = invalidTargetReason(target);</span>
<span class="pc bpc" id="L286" title="1 of 4 branches missed.">		return (reason != null) ? reason</span>
<span class="pc bpc" id="L287" title="1 of 4 branches missed.">				: (target instanceof Europe &amp;&amp; !owner.owns((Europe) target)) ? Mission.TARGETOWNERSHIP</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">						: (target instanceof Settlement &amp;&amp; !owner.owns((Settlement) target)) ? Mission.TARGETOWNERSHIP</span>
								: null;
	}

	/**
	 * Is there a reason to invalidate mission to move a transportable?.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to check.
	 * @return A reason for the transport to be invalid, or null if none found.
	 */
	public static String invalidTransportableReason(TransportableAIObject t) {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">		if (t == null)</span>
<span class="nc" id="L301">			return &quot;null-transportable&quot;;</span>
<span class="fc" id="L302">		final Locatable l = t.getTransportLocatable();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if (l == null)</span>
<span class="nc" id="L304">			return &quot;null-locatable&quot;;</span>

<span class="fc bfc" id="L306" title="All 2 branches covered.">		final Unit carrier = (l.getLocation() instanceof Unit) ? (Unit) (l.getLocation()) : null;</span>
<span class="fc" id="L307">		final AIUnit transport = t.getTransport();</span>
		Player owner;
		Location loc;
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">		boolean checkSrc = transport == null;</span>

<span class="pc bpc" id="L312" title="2 of 6 branches missed.">		if (carrier != null &amp;&amp; transport != null &amp;&amp; carrier != transport.getUnit()) {</span>
<span class="nc" id="L313">			return &quot;transportable-on-other-carrier&quot;;</span>
		}

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">		if (checkSrc) {</span>
			Settlement s;
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if ((loc = t.getTransportSource()) == null) {</span>
<span class="nc" id="L319">				return &quot;transportable-source-missing-&quot; + t;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">			} else if (((FreeColGameObject) loc).isDisposed()) {</span>
<span class="nc" id="L321">				return &quot;transportable-source-disposed&quot;;</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">			} else if (loc instanceof Settlement &amp;&amp; l instanceof Ownable</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">					&amp;&amp; !((Ownable) l).getOwner().owns(s = (Settlement) loc)) {</span>
<span class="nc" id="L324">				return &quot;transportable-source-&quot; + s.getName() + &quot;-captured-by-&quot; + s.getOwner().getDebugName();</span>
			}
<span class="nc" id="L326">		} else {</span>
<span class="fc" id="L327">			loc = t.getTransportDestination();</span>
<span class="pc bpc" id="L328" title="2 of 4 branches missed.">			if (loc != null &amp;&amp; ((FreeColGameObject) loc).isDisposed()) {</span>
<span class="nc" id="L329">				return &quot;transportable-destination-disposed&quot;;</span>
			}
		}
<span class="fc" id="L332">		return null;</span>
	}

	/**
	 * Is another player a valid attack target?.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; that will attack.
	 * @param other
	 *            The &lt;code&gt;Player&lt;/code&gt; to attack.
	 * @return A reason why the attack would be invalid, or null if none found.
	 */
	public static String invalidAttackReason(AIUnit aiUnit, Player other) {
<span class="fc" id="L345">		final Unit unit = aiUnit.getUnit();</span>
<span class="fc" id="L346">		final Player player = unit.getOwner();</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">		return (player == other) ? Mission.TARGETOWNERSHIP</span>
<span class="pc bpc" id="L348" title="1 of 4 branches missed.">				: (player.isIndian() &amp;&amp; player.getTension(other).getLevel().compareTo(Tension.Level.CONTENT) &lt;= 0)</span>
						? &quot;target-native-tension-too-low&quot;
<span class="fc bfc" id="L350" title="All 4 branches covered.">						: (player.isEuropean() &amp;&amp; !(player.getStance(other) == Stance.WAR</span>
<span class="pc bpc" id="L351" title="3 of 4 branches missed.">								|| (unit.hasAbility(Ability.PIRACY) &amp;&amp; player.getStance(other) != Stance.ALLIANCE)))</span>
										? &quot;target-european-war-absent&quot; : null;
	}

	/**
	 * Is an AI unit able to perform a different mission?
	 *
	 * AIPlayers will call FooMission.invalidReason(aiUnit) to determine whether
	 * it is valid to assign some unit to a FooMission, so `interesting' Mission
	 * subclasses with complex validity requirements must implement a routine
	 * with this signature. Conversely, simple Missions that are always possible
	 * need not.
	 *
	 * Implementations should usually start by calling this routine (i.e.
	 * Mission.invalidReason(AIUnit)).
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to check.
	 * @return A reason for mission invalidity, or null if none found.
	 */
	public static String invalidReason(AIUnit aiUnit) {
<span class="fc" id="L372">		return invalidAIUnitReason(aiUnit);</span>
	}

	/**
	 * Is an AI unit able to perform a mission with a specified target?
	 *
	 * Specific Missions can be invalid for target-related reasons. Such
	 * Missions need to implement a routine with this signature, as it will be
	 * called by the GoalDeciders in map path find/searches to choose a Mission
	 * target.
	 *
	 * Implementations should usually start by calling either
	 * invalidAIUnitReason() or this routine if the target checking is trivial.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to check.
	 * @param loc
	 *            The target &lt;code&gt;Location&lt;/code&gt; to check.
	 * @return A reason for mission invalidity, or null if none found.
	 */
	public static String invalidReason(AIUnit aiUnit, Location loc) {
<span class="nc" id="L393">		String reason = invalidAIUnitReason(aiUnit);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">		return (reason != null) ? reason : invalidTargetReason(loc);</span>
	}

	// Mission logging support

	/**
	 * State where a unit is.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return This &lt;code&gt;Mission&lt;/code&gt;.
	 */
	protected Mission lbAt(LogBuilder lb) {
<span class="fc" id="L407">		final Unit unit = getUnit();</span>
<span class="fc" id="L408">		lb.add(&quot;, at &quot;, Location.upLoc(unit.getLocation()));</span>
<span class="fc" id="L409">		return this;</span>
	}

	/**
	 * State that the unit has made an attack.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @param what
	 *            What is being attacked (a &lt;code&gt;Unit&lt;/code&gt; or
	 *            &lt;code&gt;Settlement&lt;/code&gt;).
	 * @return This &lt;code&gt;Mission&lt;/code&gt;.
	 */
	protected Mission lbAttack(LogBuilder lb, Location what) {
<span class="nc" id="L423">		lb.add(&quot;, attacking &quot;, what);</span>
<span class="nc" id="L424">		return this;</span>
	}

	/**
	 * State that the unit is dodging.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return This &lt;code&gt;Mission&lt;/code&gt;.
	 */
	protected Mission lbDodge(LogBuilder lb) {
<span class="nc" id="L435">		final Unit unit = getUnit();</span>
<span class="nc" id="L436">		lb.add(&quot;, dodging at &quot;, unit.getLocation());</span>
<span class="nc" id="L437">		unit.setMovesLeft(0);</span>
<span class="nc" id="L438">		return this;</span>
	}

	/**
	 * State that this mission has completed successfully.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @param cont
	 *            If true, the mission should continue, otherwise drop the
	 *            mission.
	 * @param reasons
	 *            Reasons for the successful completion.
	 * @return The current &lt;code&gt;Mission&lt;/code&gt; of the unit, which may now be
	 *         different from &lt;code&gt;this&lt;/code&gt;.
	 */
	protected Mission lbDone(LogBuilder lb, boolean cont, Object... reasons) {
<span class="nc" id="L455">		lb.add(&quot;, COMPLETED: &quot;, reasons);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">		return (cont) ? aiUnit.getMission() : lbDrop(lb);</span>
	}

	/**
	 * Drop the current mission.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @param reasons
	 *            Optional reasons to drop the mission.
	 * @return Null, which is now the current &lt;code&gt;Mission&lt;/code&gt; of this unit.
	 */
	protected Mission lbDrop(LogBuilder lb, Object... reasons) {
<span class="fc" id="L469">		lb.add(&quot;, DROPPED&quot;, reasons);</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">		return (aiUnit == null) ? null : aiUnit.changeMission(null);</span>
	}

	/**
	 * The current mission has failed.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @param cont
	 *            If true, the mission should continue, otherwise drop the
	 *            mission.
	 * @param reasons
	 *            Reasons for the successful completion.
	 * @return The current &lt;code&gt;Mission&lt;/code&gt; of the unit, which may not be
	 *         different from &lt;code&gt;this&lt;/code&gt;.
	 */
	protected Mission lbFail(LogBuilder lb, boolean cont, Object... reasons) {
<span class="fc" id="L487">		lb.add(&quot;, FAILED: &quot;, reasons);</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">		return (cont) ? aiUnit.getMission() : lbDrop(lb);</span>
	}

	/**
	 * State that a bad move has occurred.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @param mt
	 *            The bad &lt;code&gt;MoveType&lt;/code&gt;.
	 * @return This &lt;code&gt;Mission&lt;/code&gt;.
	 */
	protected Mission lbMove(LogBuilder lb, Unit.MoveType mt) {
<span class="nc" id="L501">		lb.add(&quot;, bad move type at &quot;, getUnit().getLocation(), &quot;: &quot;, mt);</span>
<span class="nc" id="L502">		return this;</span>
	}

	/**
	 * State that the mission has been retargeted.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return This &lt;code&gt;Mission&lt;/code&gt;.
	 */
	protected Mission lbRetarget(LogBuilder lb) {
<span class="nc" id="L513">		lb.add(&quot;, retargeted &quot;, getTarget());</span>
<span class="nc" id="L514">		return this;</span>
	}

	/**
	 * State that the unit is waiting for something.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @param reasons
	 *            Reasons for the wait.
	 * @return This &lt;code&gt;Mission&lt;/code&gt;.
	 */
	protected Mission lbWait(LogBuilder lb, Object... reasons) {
<span class="fc" id="L527">		lb.add(reasons);</span>
<span class="fc" id="L528">		getUnit().setMovesLeft(0);</span>
<span class="fc" id="L529">		return this;</span>
	}

	/**
	 * Finds a target for a unit without considering its movement abilities.
	 * This is used by missions when the current unit can not find a target with
	 * the normal path finding routines, and thus should consider targets that
	 * may require a carrier.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; that is searching.
	 * @param gd
	 *            The &lt;code&gt;GoalDecider&lt;/code&gt; that selects targets.
	 * @param radius
	 *            A maximum radius from the unit location to search within.
	 * @param deferOK
	 *            If true, fall back to the nearest port to Europe.
	 * @return The best target &lt;code&gt;Tile&lt;/code&gt; found, or null if none.
	 */
	protected static Location findCircleTarget(final AIUnit aiUnit, final GoalDecider gd, final int radius,
			boolean deferOK) {
<span class="fc" id="L550">		final Unit unit = aiUnit.getUnit();</span>
<span class="fc" id="L551">		final Tile start = unit.getTile();</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">		if (start == null) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">			if (!deferOK)</span>
<span class="nc" id="L554">				return null;</span>
<span class="nc" id="L555">			Settlement settlement = unit.getOwner().getClosestPortForEurope();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">			return (settlement == null) ? null : settlement;</span>
		}
<span class="fc" id="L558">		return unit.getGame().getMap().searchCircle(start, gd, radius);</span>
	}

	/**
	 * We have been blocked on the way to a target. Is it valid to attack the
	 * blockage, or should it just be avoided?
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; that was blocked.
	 * @param target
	 *            The target &lt;code&gt;Location&lt;/code&gt;.
	 * @return The blockage to attack, or null if not.
	 */
	public static Location resolveBlockage(AIUnit aiUnit, Location target) {
<span class="nc" id="L572">		final Unit unit = aiUnit.getUnit();</span>
<span class="nc" id="L573">		PathNode path = unit.findPath(target);</span>
<span class="nc" id="L574">		Direction d = null;</span>
<span class="nc bnc" id="L575" title="All 4 branches missed.">		if (path != null &amp;&amp; path.next != null) {</span>
<span class="nc" id="L576">			Tile tile = path.next.getTile();</span>
<span class="nc" id="L577">			Settlement settlement = tile.getSettlement();</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">			Location blocker = (settlement != null) ? settlement : tile.getDefendingUnit(unit);</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			if (UnitSeekAndDestroyMission.invalidReason(aiUnit, blocker) == null)</span>
<span class="nc" id="L580">				return blocker;</span>
		}
<span class="nc" id="L582">		return null;</span>
	}

	/**
	 * Moves a unit one step randomly.
	 *
	 * @param logMe
	 *            A string to log the random number generation with.
	 * @param direction
	 *            An optional preferred &lt;code&gt;Direction&lt;/code&gt;.
	 * @return The direction of the move, or null if no move was made.
	 */
	protected Direction moveRandomly(String logMe, Direction direction) {
<span class="nc" id="L595">		final Unit unit = getUnit();</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">		if (unit.getMovesLeft() &lt;= 0 || !unit.hasTile())</span>
<span class="nc" id="L597">			return null;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">		if (logMe == null)</span>
<span class="nc" id="L599">			logMe = &quot;moveRandomly&quot;;</span>

<span class="nc" id="L601">		Random aiRandom = getAIRandom();</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">		if (direction == null) {</span>
<span class="nc" id="L603">			direction = Direction.getRandomDirection(logMe, logger, aiRandom);</span>
		}

<span class="nc" id="L606">		Direction[] directions = direction.getClosestDirections(logMe, logger, aiRandom);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">		for (Direction d : directions) {</span>
<span class="nc" id="L608">			Tile moveTo = unit.getTile().getNeighbourOrNull(d);</span>
<span class="nc bnc" id="L609" title="All 6 branches missed.">			if (moveTo != null &amp;&amp; unit.getMoveType(d) == MoveType.MOVE &amp;&amp; aiUnit.move(d))</span>
<span class="nc" id="L610">				return d;</span>
		}
<span class="nc" id="L612">		return null; // Stuck!</span>
	}

	/**
	 * Moves a unit randomly for the rest of its turn.
	 *
	 * @param logMe
	 *            A string to log the random number generation with.
	 */
	protected void moveRandomlyTurn(String logMe) {
<span class="nc" id="L622">		Direction direction = null;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">		while ((direction = moveRandomly(logMe, direction)) != null)</span>
<span class="nc" id="L624">			;</span>
<span class="nc" id="L625">		getUnit().setMovesLeft(0);</span>
<span class="nc" id="L626">	}</span>

	/**
	 * Finds the best existing settlement to use as a target. Useful for
	 * missions where the unit might be in Europe, but should go to a safe spot
	 * in the New World and proceed from there.
	 *
	 * @param player
	 *            The &lt;code&gt;Player&lt;/code&gt; that is searching.
	 * @return A good settlement to restart a Mission from.
	 */
	protected static Settlement getBestSettlement(Player player) {
<span class="nc" id="L638">		int bestValue = -1;</span>
<span class="nc" id="L639">		Settlement best = null;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">		for (Settlement settlement : player.getSettlements()) {</span>
<span class="nc" id="L641">			int value = settlement.getUnitCount() + settlement.getTile().getUnitCount();</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">			if (settlement instanceof Colony) {</span>
<span class="nc" id="L643">				Colony colony = (Colony) settlement;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">				value += ((colony.isConnectedPort()) ? 10 : 0) // Favour coastal</span>
<span class="nc" id="L645">						+ colony.getAvailableWorkLocations().size();</span>
			}
<span class="nc bnc" id="L647" title="All 2 branches missed.">			if (value &gt; bestValue) {</span>
<span class="nc" id="L648">				bestValue = value;</span>
<span class="nc" id="L649">				best = settlement;</span>
			}
<span class="nc" id="L651">		}</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">		return (best == null) ? null : best;</span>
	}

	/**
	 * Tries to move this mission's unit to a target location.
	 *
	 * First check for units in transit, that is units on a carrier that are
	 * going to but not yet in Europe, or going to but not yet at a Tile and
	 * whose path still requires the carrier. These need to be handled by the
	 * carrier's TransportMission, not by the unit's Mission.
	 *
	 * Similarly check for units not in transit but should be, that is units not
	 * on a carrier but can not get to their target without one. These must just
	 * wait.
	 *
	 * If there is no impediment to the unit moving towards the target, do so.
	 * Return an indicative MoveType for the result of the travel. - MOVE if the
	 * unit has arrived at the target, although it may have exhausted its moves
	 * - MOVE_HIGH_SEAS if the unit has set sail to/from Europe - MOVE_NO_MOVES
	 * is underway but ran out of moves - MOVE_NO_ACCESS_EMBARK if progress
	 * depends on a carrier, either currently boarded or due to collect the unit
	 * - MOVE_NO_REPAIR if the unit died for whatever reason - MOVE_NO_TILE if
	 * there is no path (usually transitory on rivers) - MOVE_ILLEGAL if there
	 * is an error or permanent restriction - other legal results (e.g.
	 * ENTER_INDIAN_SETTLEMENT*) if that would occur if the unit proceeded. Such
	 * moves require special handling and are not performed here, the calling
	 * mission code must handle them.
	 *
	 * @param target
	 *            The destination &lt;code&gt;Location&lt;/code&gt;.
	 * @param costDecider
	 *            The &lt;code&gt;CostDecider&lt;/code&gt; to use in any path finding.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return The type of move the unit stopped at.
	 */
	protected MoveType travelToTarget(Location target, CostDecider costDecider, LogBuilder lb) {
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">		if (target == null)</span>
<span class="nc" id="L690">			return MoveType.MOVE_ILLEGAL;</span>
<span class="fc" id="L691">		final Tile targetTile = target.getTile();</span>
<span class="pc bpc" id="L692" title="1 of 4 branches missed.">		if (!(target instanceof Europe) &amp;&amp; targetTile == null) {</span>
<span class="nc" id="L693">			throw new IllegalStateException(&quot;Target neither Europe nor Tile&quot;);</span>
		}
<span class="fc" id="L695">		final Unit unit = getUnit();</span>
<span class="fc" id="L696">		final AIUnit aiUnit = getAIUnit();</span>
<span class="fc" id="L697">		AIUnit aiCarrier = aiUnit.getTransport();</span>
<span class="fc" id="L698">		final Map map = unit.getGame().getMap();</span>
<span class="fc" id="L699">		PathNode path = null;</span>
<span class="fc" id="L700">		boolean useTransport = false;</span>
<span class="fc" id="L701">		target = Location.upLoc(target);</span>

		// Consider where the unit is starting.
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">		if (unit.isAtSea()) {</span>
			// Wait for carrier to arrive on the map or in Europe.
<span class="nc" id="L706">			lb.add(&quot;, at sea&quot;);</span>
<span class="nc" id="L707">			return MoveType.MOVE_HIGH_SEAS;</span>

<span class="pc bpc" id="L709" title="1 of 2 branches missed.">		} else if (unit.isOnCarrier()) {</span>
			// Transport mission will disembark the unit when it
			// arrives at the drop point.
<span class="nc" id="L712">			lb.add(&quot;, on carrier&quot;);</span>
<span class="nc" id="L713">			return MoveType.MOVE_NO_ACCESS_EMBARK;</span>

<span class="pc bpc" id="L715" title="1 of 2 branches missed.">		} else if (unit.isAtLocation(target)) {</span>
			// Arrived!
<span class="nc" id="L717">			return MoveType.MOVE;</span>

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">		} else if (unit.isInEurope()) {</span>
			// Leave, or require transport.
<span class="nc bnc" id="L721" title="All 2 branches missed.">			if (!unit.getOwner().canMoveToEurope()) {</span>
<span class="nc" id="L722">				lb.add(&quot;, impossible move from Europe&quot;);</span>
<span class="nc" id="L723">				return MoveType.MOVE_ILLEGAL;</span>
			}
<span class="nc bnc" id="L725" title="All 2 branches missed.">			if (unit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L726">				unit.setDestination(target);</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">				if (AIMessage.askMoveTo(aiUnit, map)) {</span>
<span class="nc" id="L728">					lb.add(&quot;, sailed for &quot;, target);</span>
<span class="nc" id="L729">					return MoveType.MOVE_HIGH_SEAS;</span>
				} else {
<span class="nc" id="L731">					lb.add(&quot;, failed to sail for &quot;, target);</span>
<span class="nc" id="L732">					return MoveType.MOVE_ILLEGAL;</span>
				}
			}
<span class="nc" id="L735">			useTransport = true;</span>

<span class="pc bpc" id="L737" title="1 of 2 branches missed.">		} else if (!unit.hasTile()) {</span>
			// Fail!
<span class="nc" id="L739">			return MoveType.MOVE_ILLEGAL;</span>

		} else {
			// On map. Either find a path or decide to use transport.
<span class="fc bfc" id="L743" title="All 2 branches covered.">			if (target instanceof Europe) {</span>
				// Going to Europe.
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">				if (!unit.getOwner().canMoveToEurope()) {</span>
<span class="nc" id="L746">					lb.add(&quot;, impossible move to Europe&quot;);</span>
<span class="nc" id="L747">					return MoveType.MOVE_ILLEGAL;</span>
				}
<span class="pc bpc" id="L749" title="2 of 4 branches missed.">				if (!unit.getType().canMoveToHighSeas() || aiCarrier != null) {</span>
<span class="nc" id="L750">					useTransport = true;</span>
				} else {
<span class="fc" id="L752">					path = unit.findPath(unit.getLocation(), target, null, costDecider);</span>
				}
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">			} else if (aiCarrier != null) {</span>
				// Transport already allocated.
<span class="nc" id="L756">				useTransport = true;</span>

<span class="pc bpc" id="L758" title="1 of 4 branches missed.">			} else if (!unit.getType().canMoveToHighSeas() &amp;&amp; !Map.isSameContiguity(target, unit.getLocation())) {</span>
				// Transport necessary.
<span class="nc" id="L760">				useTransport = true;</span>

			} else {
				// Should not need transport within the same contiguity.
<span class="fc" id="L764">				path = unit.findPath(unit.getLocation(), target, null, costDecider);</span>
			}
		}

<span class="pc bpc" id="L768" title="1 of 2 branches missed.">		if (useTransport) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">			if (aiCarrier != null) {</span>
				// A carrier has been assigned. Try to go to the
				// collection point.
				Location pick;
				TransportMission tm;
<span class="nc" id="L774">				boolean waiting = false;</span>
				PathNode ownPath;
				int pathTurns, ownTurns;

<span class="nc bnc" id="L778" title="All 2 branches missed.">				if ((tm = aiCarrier.getMission(TransportMission.class)) == null) {</span>
					// Carrier has no transport mission?!? Bogus.
<span class="nc" id="L780">					lb.add(&quot;, had bogus carrier &quot;, aiCarrier.getUnit());</span>
<span class="nc" id="L781">					logger.warning(unit + &quot; has transport &quot; + aiCarrier + &quot; without transport mission&quot;);</span>
<span class="nc" id="L782">					aiUnit.dropTransport();</span>
<span class="nc" id="L783">					aiCarrier = null;</span>

<span class="nc bnc" id="L785" title="All 2 branches missed.">				} else if ((pick = tm.getTransportTarget(aiUnit)) == null) {</span>
					// No collection point for this unit? Bogus.
<span class="nc" id="L787">					lb.add(&quot;, had bogus transport on &quot;, aiCarrier.getUnit());</span>
<span class="nc" id="L788">					logger.warning(unit + &quot; has transport &quot; + aiCarrier</span>
<span class="nc" id="L789">							+ &quot; with transport mission but null transport target\n&quot; + tm.toFullString());</span>
<span class="nc" id="L790">					aiUnit.dropTransport();</span>
<span class="nc" id="L791">					aiCarrier = null;</span>

<span class="nc bnc" id="L793" title="All 2 branches missed.">				} else if (Map.isSameLocation(pick, unit.getLocation())) {</span>
					// Waiting for the carrier at the collection point.
<span class="nc" id="L795">					waiting = true;</span>

<span class="nc bnc" id="L797" title="All 2 branches missed.">				} else if ((path = unit.findPath(unit.getLocation(), pick, null, costDecider)) == null) {</span>
					// No path to the collection point.
<span class="nc" id="L799">					lbAt(lb);</span>
<span class="nc" id="L800">					lb.add(&quot;, no path to meet &quot;, aiCarrier.getUnit(), &quot; at &quot;, pick);</span>
<span class="nc" id="L801">					path = unit.findPath(unit.getLocation(), target, null, costDecider);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">					if (path == null) {</span>
						// Unable to fall back to going direct.
						// Return failure in the hope that it is a
						// transient blockage.
<span class="nc" id="L806">						return MoveType.MOVE_NO_TILE;</span>
					}
					// Fall back to going direct to the target.
<span class="nc" id="L809">					lb.add(&quot;, dropped carrier&quot;);</span>
<span class="nc" id="L810">					aiUnit.dropTransport();</span>
<span class="nc" id="L811">					aiCarrier = null;</span>
<span class="nc" id="L812">					useTransport = false;</span>

<span class="nc bnc" id="L814" title="All 2 branches missed.">				} else if ((ownPath = unit.findPath(unit.getLocation(), target, null, costDecider)) == null</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">						|| (ownTurns = ownPath.getTotalTurns()) &gt; (pathTurns = path.getTotalTurns())) {</span>
					// Either there is no direct path to the target or
					// a path exists but takes longer than using the
					// carrier. This confirms that it is not only
					// possible to travel to the collection point, it
					// is also the best plan.
<span class="nc" id="L821">					MoveType ret = followMapPath(path.next, lb);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">					if (ret != MoveType.MOVE)</span>
<span class="nc" id="L823">						return ret;</span>
<span class="nc" id="L824">					waiting = true; // Arrived for collection.</span>

<span class="nc" id="L826">				} else {</span>
					// It is quicker to cancel the transport and go to
					// the target directly.
<span class="nc" id="L829">					lb.add(&quot;, dropping carrier&quot;, aiCarrier.getUnit(), &quot; as it is faster (&quot;, ownTurns, &quot;&lt;&quot;, pathTurns,</span>
							&quot; without it&quot;);
<span class="nc" id="L831">					aiUnit.dropTransport();</span>
<span class="nc" id="L832">					aiCarrier = null;</span>
<span class="nc" id="L833">					path = ownPath;</span>
<span class="nc" id="L834">					useTransport = false;</span>
				}

<span class="nc bnc" id="L837" title="All 2 branches missed.">				if (waiting) {</span>
					// If waiting for the carrier, signal that this
					// unit can be reexamined if the carrier is still
					// moving.
<span class="nc" id="L841">					lbAt(lb);</span>
<span class="nc" id="L842">					lb.add(&quot;, wait for &quot;, aiCarrier.getUnit());</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">					return (aiCarrier.getUnit().getMovesLeft() &gt; 0) ? MoveType.MOVE_NO_ACCESS_EMBARK</span>
							: MoveType.MOVE_NO_MOVES;
				}
			}

<span class="nc bnc" id="L848" title="All 4 branches missed.">			if (useTransport &amp;&amp; aiCarrier == null) {</span>
				// Still interested in transport but no carrier.
<span class="nc" id="L850">				lb.add(&quot;, needs transport to &quot;, target);</span>
<span class="nc" id="L851">				return MoveType.MOVE_NO_ACCESS_EMBARK;</span>
			}
		}

		// Follow the path to the target. If there is one.
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">		if (path == null) {</span>
<span class="nc" id="L857">			lbAt(lb);</span>
<span class="nc" id="L858">			lb.add(&quot;, no path to &quot;, target);</span>
<span class="nc" id="L859">			return MoveType.MOVE_NO_TILE;</span>
		}
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">		if (path.next == null) {</span>
			// This should not happen, the isAtLocation() test above
			// should have succeeded.
<span class="nc" id="L864">			throw new IllegalStateException(&quot;Trivial path found &quot; + path.fullPathToString() + &quot; from &quot;</span>
<span class="nc" id="L865">					+ unit.getLocation() + &quot; to target &quot; + target + &quot; result=&quot; + unit.isAtLocation(target));</span>
		}
<span class="fc" id="L867">		return followMapPath(path.next, lb);</span>
	}

	/**
	 * Follow a path that is on the map (except perhaps the last node) and does
	 * not use a carrier.
	 *
	 * @param path
	 *            The &lt;code&gt;PathNode&lt;/code&gt; to follow.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return The type of move the unit stopped at.
	 */
	private MoveType followMapPath(PathNode path, LogBuilder lb) {
<span class="fc" id="L881">		final Unit unit = getUnit();</span>
<span class="fc" id="L882">		final AIUnit aiUnit = getAIUnit();</span>
<span class="fc" id="L883">		final Location target = path.getLastNode().getLocation();</span>

<span class="pc bpc" id="L885" title="1 of 2 branches missed.">		for (; path != null; path = path.next) {</span>
			// Check for immediate failure
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">			if (unit.isDisposed()) {</span>
<span class="nc" id="L888">				lb.add(&quot;, died going to &quot;, Location.upLoc(path.getLocation()));</span>
<span class="nc" id="L889">				return MoveType.MOVE_NO_REPAIR;</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">			} else if (unit.getMovesLeft() &lt;= 0) {</span>
<span class="nc" id="L891">				lbAt(lb);</span>
<span class="nc" id="L892">				lb.add(&quot;, en route to &quot;, Location.upLoc(target));</span>
<span class="nc" id="L893">				return MoveType.MOVE_NO_MOVES;</span>
			}

<span class="pc bpc" id="L896" title="1 of 2 branches missed.">			if (path.getLocation() instanceof Europe) {</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">				if (AIMessage.askMoveTo(aiUnit, path.getLocation())) {</span>
<span class="nc" id="L898">					lb.add(&quot;, sailed to Europe&quot;);</span>
<span class="nc" id="L899">					return MoveType.MOVE_HIGH_SEAS;</span>
				} else {
<span class="nc" id="L901">					lb.add(&quot;, failed to sail for Europe&quot;);</span>
<span class="nc" id="L902">					return MoveType.MOVE_ILLEGAL;</span>
				}
			}
<span class="fc" id="L905">			MoveType mt = unit.getMoveType(path.getDirection());</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">			if (mt == MoveType.MOVE_NO_MOVES) {</span>
<span class="nc" id="L907">				unit.setMovesLeft(0);</span>
<span class="nc" id="L908">				lbAt(lb);</span>
<span class="nc" id="L909">				return MoveType.MOVE_NO_MOVES;</span>
			}
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">			if (!mt.isProgress()) {</span>
<span class="nc" id="L912">				return mt; // Special handling required, no log.</span>
			}
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">			if (!aiUnit.move(path.getDirection())) {</span>
<span class="fc" id="L915">				lbAt(lb);</span>
<span class="fc" id="L916">				lb.add(&quot;, failed to move to &quot;, Location.upLoc(path.getLocation()));</span>
<span class="fc" id="L917">				return MoveType.MOVE_ILLEGAL;</span>
			}
		}
<span class="nc" id="L920">		return MoveType.MOVE; // Must have completed path normally, no log.</span>
	}

	/**
	 * Retarget a mission because of some problem.
	 *
	 * @param reason
	 *            The reason for the retarget.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return The current &lt;code&gt;Mission&lt;/code&gt;, which has been set to null on
	 *         failure to retarget.
	 */
	public Mission retargetMission(String reason, LogBuilder lb) {
<span class="nc" id="L934">		lb.add(&quot;, failing(&quot;, reason, &quot;)&quot;);</span>

<span class="nc" id="L936">		Location newTarget = findTarget();</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">		if (newTarget != null) {</span>
<span class="nc" id="L938">			setTarget(newTarget);</span>
<span class="nc" id="L939">			return lbRetarget(lb);</span>
		}
<span class="nc" id="L941">		lb.add(&quot;, retarget failed&quot;);</span>
<span class="nc" id="L942">		return lbDrop(lb);</span>
	}

	// Mission interface to be implemented/overridden by descendants.
	// TransportableAIObject delegates some functionality here when
	// a mission is available.

	/**
	 * Disposes this mission by removing any references to it.
	 */
	@Override
	public void dispose() {
		// Nothing to do yet.
<span class="fc" id="L955">	}</span>

	/**
	 * Get the base transport priority for the unit performing this mission.
	 *
	 * @return A base transport priority.
	 */
	public int getBaseTransportPriority() {
<span class="fc" id="L963">		return 0;</span>
	}

	/**
	 * Gets the destination of a required transport.
	 *
	 * Override this in the child mission classes if there is a useful
	 * intermediate point to deliver the unit distinct from the target.
	 *
	 * @return The mission target, or null if the mission is invalid, otherwise
	 *         lacks a target (e.g. UnitWanderHostile), or the unit does not
	 *         need transport.
	 */
	public Location getTransportDestination() {
		Location loc;
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">		return (!isValid()) ? null</span>
<span class="pc bpc" id="L979" title="2 of 4 branches missed.">				: ((loc = getTarget()) == null) ? null : (!getUnit().shouldTakeTransportTo(loc)) ? null : loc;</span>
	}

	/**
	 * Gets the target of this mission, if any.
	 *
	 * @return The target of this mission, or null if none.
	 */
	public abstract Location getTarget();

	/**
	 * Sets the target of this mission, if any.
	 *
	 * @param target
	 *            The new target of this mission, or null if none.
	 */
	public abstract void setTarget(Location target);

	/**
	 * Finds a new target for this mission.
	 *
	 * @return A new target for this mission.
	 */
	public abstract Location findTarget();

	/**
	 * Should this mission be considered a mere fallback to be replaced at will?
	 *
	 * Missions are not one-time by default, true one-time missions must
	 * override this routine.
	 *
	 * @return False.
	 */
	public boolean isOneTime() {
<span class="nc" id="L1013">		return false;</span>
	}

	/**
	 * Why is this mission invalid?
	 *
	 * Mission subclasses must implement this routine, which probably should
	 * start by checking invalidAIUnitReason.
	 * 
	 * A mission can be invalid for a number of subclass-specific reasons. For
	 * example: a seek-and-destroy mission could be invalid because of a
	 * improved stance towards the targeted player.
	 *
	 * @return A reason for mission invalidity, or null if none found.
	 */
	public abstract String invalidReason();

	/**
	 * Performs the mission.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return The &lt;code&gt;Mission&lt;/code&gt; to continue with, or null if the current
	 *         mission has completed.
	 */
	public abstract Mission doMission(LogBuilder lb);

	// Serialization

	/**
	 * {@inheritDoc}
	 */
	@Override
	public final void toXML(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">		if (isValid())</span>
<span class="nc" id="L1048">			toXML(xw, getXMLTagName());</span>
<span class="nc" id="L1049">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
		// This routine might look redundant, but if you let it
		// default out up the tree, you reach
		// FreeColObject.writeAttributes, which complains about
		// objects without an identifier. Missions do not have
		// identifiers.
<span class="nc" id="L1061">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
		// This routine might look redundant, but if you let it
		// default out up the tree, you reach
		// FreeColObject.readAttributes, which expects to find an id
		// attribute. Missions do not have ids.
<span class="nc" id="L1072">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="fc" id="L1079">		LogBuilder lb = new LogBuilder(64);</span>
<span class="fc" id="L1080">		lb.add(lastPart(getClass().getName(), &quot;.&quot;), &quot;@&quot;, hashCode(), &quot;-&quot;, aiUnit.getUnit(), &quot;-&gt;&quot;, getTarget());</span>
<span class="fc" id="L1081">		return lb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>