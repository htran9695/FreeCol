<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransportMission.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.ai.mission</a> &gt; <span class="el_source">TransportMission.java</span></div><h1>TransportMission.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.ai.mission;

import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.FreeColException;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.CombatModel;
import net.sf.freecol.common.model.Europe;
import net.sf.freecol.common.model.Goods;
import net.sf.freecol.common.model.GoodsType;
import net.sf.freecol.common.model.Locatable;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.Map;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.PathNode;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.util.LogBuilder;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.server.ai.AIColony;
import net.sf.freecol.server.ai.AIGoods;
import net.sf.freecol.server.ai.AIMain;
import net.sf.freecol.server.ai.AIMessage;
import net.sf.freecol.server.ai.AIUnit;
import net.sf.freecol.server.ai.Cargo;
import net.sf.freecol.server.ai.EuropeanAIPlayer;
import net.sf.freecol.server.ai.TransportableAIObject;

/**
 * Mission for transporting units and goods on a carrier.
 *
 * @see net.sf.freecol.common.model.Unit Unit
 */
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">public class TransportMission extends Mission {</span>

	/** The Constant logger. */
<span class="fc" id="L65">	private static final Logger logger = Logger.getLogger(TransportMission.class.getName());</span>

	/** The Constant tag. */
	private static final String tag = &quot;AI transport&quot;;

	/**
	 * The Enum CargoResult.
	 */
<span class="pc" id="L73">	private static enum CargoResult {</span>

		/** The tcontinue. */
<span class="fc" id="L76">		TCONTINUE,</span>
		/** The tdone. */
		// Cargo should continue
<span class="fc" id="L79">		TDONE,</span>
		/** The tfail. */
		// Cargo completed successfully
<span class="fc" id="L82">		TFAIL,</span>
		/** The tnext. */
		// Cargo failed badly
<span class="fc" id="L85">		TNEXT,</span>
		/** The tretry. */
		// Cargo changed to its next state
<span class="fc" id="L88">		TRETRY // Cargo has blocked, retry</span>
	}

	/**
	 * Insist transport lists remain simple by imposing an upper bound on the
	 * distinct destination locations to visit.
	 */
	private static final int DESTINATION_UPPER_BOUND = 4;

	/** The Constant MINIMUM_GOLD_TO_STAY_IN_EUROPE. */
	private static final int MINIMUM_GOLD_TO_STAY_IN_EUROPE = 600;

	/** A list of &lt;code&gt;Cargo&lt;/code&gt;s to work on. */
<span class="pc" id="L101">	private final List&lt;Cargo&gt; cargoes = new ArrayList&lt;&gt;();</span>

	/** The current target location to travel to. */
	private Location target;

	/**
	 * Creates a mission for the given &lt;code&gt;AIUnit&lt;/code&gt;.
	 *
	 * @param aiMain
	 *            The main AI-object.
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; this mission is created for.
	 */
	public TransportMission(AIMain aiMain, AIUnit aiUnit) {
<span class="fc" id="L115">		super(aiMain, aiUnit, aiUnit.getTrivialTarget());</span>
<span class="fc" id="L116">	}</span>

	/**
	 * Creates a new &lt;code&gt;TransportMission&lt;/code&gt; and reads the given element.
	 *
	 * @param aiMain
	 *            The main AI-object.
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; this mission is created for.
	 * @param xr
	 *            The input stream containing the XML.
	 * @throws XMLStreamException
	 *             if a problem was encountered during parsing.
	 * @see net.sf.freecol.server.ai.AIObject#readFromXML
	 */
	public TransportMission(AIMain aiMain, AIUnit aiUnit, FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L132">		super(aiMain, aiUnit);</span>

<span class="nc" id="L134">		readFromXML(xr);</span>
<span class="nc" id="L135">	}</span>

	/**
	 * Disposes of this &lt;code&gt;Mission&lt;/code&gt;.
	 */
	@Override
	public void dispose() {
<span class="fc" id="L142">		logger.finest(tag + &quot; disposing (&quot; + clearCargoes() + &quot;): &quot; + this</span>
		// + &quot;\n&quot; +
		// net.sf.freecol.common.debug.FreeColDebugger.stackTraceToString()
		);
<span class="fc" id="L146">		super.dispose();</span>
<span class="fc" id="L147">	}</span>

	// Simple internal utilities

	/**
	 * Checks if the carrier using this mission is carrying the given
	 * &lt;code&gt;TransportableAIObject&lt;/code&gt;.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to check.
	 * @return True if the carrier is carrying the transportable.
	 */
	private boolean isCarrying(TransportableAIObject t) {
<span class="pc bpc" id="L160" title="1 of 4 branches missed.">		return t != null &amp;&amp; t.getLocation() == getUnit();</span>
	}

	/**
	 * Is a transportable waiting for delivery on the cargoes list?.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to check.
	 * @return True if the transportable is queued in this mission.
	 */
	public boolean isTransporting(TransportableAIObject t) {
<span class="nc bnc" id="L171" title="All 2 branches missed.">		return tFind(t) != null;</span>
	}

	/**
	 * Decide if this unit has a good chance of defeating another. If there is
	 * cargo aboard, be more conservative.
	 *
	 * FIXME: magic numbers to the spec.
	 *
	 * @param other
	 *            The other &lt;code&gt;Unit&lt;/code&gt; to attack.
	 * @return True if the attack should proceed.
	 */
	private boolean shouldAttack(Unit other) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">		if (invalidAttackReason(getAIUnit(), other.getOwner()) != null)</span>
<span class="nc" id="L186">			return false;</span>
<span class="nc" id="L187">		final Unit carrier = getUnit();</span>
<span class="nc" id="L188">		final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">		double offence = cm.getOffencePower(carrier, other) * ((carrier.hasCargo()) ? 0.3 : 0.80);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">		return offence &gt; cm.getOffencePower(other, carrier);</span>
	}

	// Cargoes handling.
	// *Nothing* should touch &quot;cargoes&quot; but these.
	// It needs synchronization because of possible changes due to the
	// carrier being destroyed.

	/**
	 * Gets the cargoes.
	 *
	 * @return A copy of the list of cargoes.
	 */
	private List&lt;Cargo&gt; tCopy() {
<span class="fc" id="L204">		synchronized (cargoes) {</span>
<span class="fc" id="L205">			return new ArrayList&lt;&gt;(cargoes);</span>
<span class="nc" id="L206">		}</span>
	}

	/**
	 * Clears the cargoes list.
	 *
	 * @return The old cargoes list.
	 */
	private List&lt;Cargo&gt; tClear() {
<span class="fc" id="L215">		List&lt;Cargo&gt; old = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L216">		synchronized (cargoes) {</span>
<span class="fc" id="L217">			old.addAll(cargoes);</span>
<span class="fc" id="L218">			cargoes.clear();</span>
<span class="pc" id="L219">		}</span>
<span class="fc" id="L220">		return old;</span>
	}

	/**
	 * Sets the cargoes to a new list.
	 *
	 * @param nxt
	 *            The new cargoes list.
	 * @param setSpace
	 *            If true, call tSpace to reset the space left values.
	 * @return The old cargoes list.
	 */
	private List&lt;Cargo&gt; tSet(List&lt;Cargo&gt; nxt, boolean setSpace) {
<span class="nc" id="L233">		List&lt;Cargo&gt; old = tCopy();</span>
<span class="nc" id="L234">		synchronized (cargoes) {</span>
<span class="nc" id="L235">			cargoes.clear();</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">			for (Cargo c : nxt) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">				if (c.isValid())</span>
<span class="nc" id="L238">					cargoes.add(c);</span>
<span class="nc" id="L239">			}</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">			if (setSpace)</span>
<span class="nc" id="L241">				tSpace();</span>
<span class="nc" id="L242">		}</span>
<span class="nc" id="L243">		tRetarget();</span>
<span class="nc" id="L244">		return old;</span>
	}

	/**
	 * Gets the size of the cargoes.
	 *
	 * @return The size of the cargoes.
	 */
	private int tSize() {
		int size;
<span class="nc" id="L254">		synchronized (cargoes) {</span>
<span class="nc" id="L255">			size = cargoes.size();</span>
<span class="nc" id="L256">		}</span>
<span class="nc" id="L257">		return size;</span>
	}

	/**
	 * Find a &lt;code&gt;Cargo&lt;/code&gt; with the given
	 * &lt;code&gt;TransportableAIObject&lt;/code&gt;.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to look for.
	 * @return The &lt;code&gt;Cargo&lt;/code&gt; found, or null if none found.
	 */
	private Cargo tFind(TransportableAIObject t) {
<span class="fc" id="L269">		synchronized (cargoes) {</span>
<span class="pc bnc" id="L270" title="All 2 branches missed.">			return find(cargoes, c -&gt; c.getTransportable() == t);</span>
<span class="nc" id="L271">		}</span>
	}

	/**
	 * Gets the first cargo.
	 *
	 * @return The first valid cargo, or null if none found.
	 */
	private Cargo tFirst() {
<span class="fc" id="L280">		synchronized (cargoes) {</span>
<span class="fc" id="L281">			return find(cargoes, Cargo::isValid);</span>
<span class="nc" id="L282">		}</span>
	}

	/**
	 * Adds a cargo to the cargoes list.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to add.
	 * @param index
	 *            The position to add it.
	 * @return True if the addition succeeded or the cargo was already present.
	 */
	private boolean tAdd(Cargo cargo, int index) {
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">		if (!cargo.isValid())</span>
<span class="nc" id="L296">			return false;</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">		if (tFind(cargo.getTransportable()) != null)</span>
<span class="nc" id="L298">			return true;</span>
<span class="fc" id="L299">		boolean change = false;</span>
<span class="fc" id="L300">		synchronized (cargoes) {</span>
<span class="pc bpc" id="L301" title="3 of 4 branches missed.">			change = cargoes.isEmpty() || index == 0;</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">			if (index &gt;= 0) {</span>
<span class="fc" id="L303">				cargoes.add(index, cargo);</span>
			} else {
<span class="nc" id="L305">				cargoes.add(cargo);</span>
			}
<span class="fc" id="L307">			tSpace();</span>
<span class="pc" id="L308">		}</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">		if (change)</span>
<span class="fc" id="L310">			tRetarget();</span>
<span class="fc" id="L311">		return true;</span>
	}

	/**
	 * Remove a cargo from the cargoes list.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to remove.
	 * @return True if the remove succeeded.
	 */
	private boolean tRemove(Cargo cargo) {
<span class="nc" id="L322">		boolean result = false, change = false;</span>
<span class="nc" id="L323">		final TransportableAIObject t = cargo.getTransportable();</span>
<span class="nc" id="L324">		synchronized (cargoes) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">			for (int i = 0; i &lt; cargoes.size(); i++) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">				if (cargoes.get(i).getTransportable() == t) {</span>
<span class="nc" id="L327">					cargoes.remove(i);</span>
<span class="nc" id="L328">					tSpace();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">					change = i == 0;</span>
<span class="nc" id="L330">					result = true;</span>
<span class="nc" id="L331">					break;</span>
				}
			}
<span class="nc" id="L334">		}</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">		if (change)</span>
<span class="nc" id="L336">			tRetarget();</span>
<span class="nc" id="L337">		return result;</span>
	}

	/**
	 * Sets the spaceLeft fields in the cargoes. To be called with synchronized
	 * (cargoes).
	 */
	private void tSpace() {
<span class="fc" id="L345">		final Unit carrier = getUnit();</span>
<span class="fc" id="L346">		final int maxHolds = carrier.getCargoCapacity();</span>
<span class="fc" id="L347">		int holds = carrier.getCargoSpaceTaken();</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">		for (Cargo cargo : cargoes) {</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">			if (!cargo.isValid())</span>
<span class="nc" id="L350">				continue;</span>
<span class="fc" id="L351">			holds += cargo.getNewSpace();</span>
<span class="fc" id="L352">			cargo.setSpaceLeft(maxHolds - holds);</span>
<span class="fc" id="L353">		}</span>
<span class="fc" id="L354">	}</span>

	/**
	 * Reset the carrier target after a change to the first cargo.
	 */
	private void tRetarget() {
		Cargo c;
<span class="fc" id="L361">		synchronized (cargoes) {</span>
<span class="fc" id="L362">			c = find(cargoes, Cargo::isValid);</span>
<span class="pc" id="L363">		}</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">		setTarget(Location.upLoc((c == null) ? getAIUnit().getTrivialTarget() : c.getCarrierTarget()));</span>
<span class="fc" id="L365">	}</span>

	// Medium-level cargo and target manipulation, should be kept
	// private to TransportMission.

	/**
	 * Count distinct non-adjacent destinations in a list of cargoes.
	 *
	 * @return The number of distinct destinations.
	 */
	private int destinationCount() {
<span class="nc" id="L376">		Location now = null;</span>
<span class="nc" id="L377">		int ret = 0;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">		for (Cargo cargo : tCopy()) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">			if (!Map.isSameLocation(now, cargo.getCarrierTarget())) {</span>
<span class="nc" id="L380">				ret++;</span>
<span class="nc" id="L381">				now = cargo.getCarrierTarget();</span>
			}
<span class="nc" id="L383">		}</span>
<span class="nc" id="L384">		return ret;</span>
	}

	/**
	 * How many more destinations are desirable on the current cargoes list?
	 * Must be public! This is checked in European AI player.
	 *
	 * @return The number of desired extra destinations.
	 */
	public int destinationCapacity() {
<span class="nc" id="L394">		return DESTINATION_UPPER_BOUND - destinationCount();</span>
	}

	/**
	 * If this carrier is the current carrier of a transportable, drop it.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to check.
	 */
	private void dropTransportable(TransportableAIObject t) {
<span class="nc" id="L404">		AIUnit carrier = getAIUnit();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (t.getTransport() == carrier)</span>
<span class="nc" id="L406">			t.setTransport(null);</span>
<span class="nc" id="L407">	}</span>

	/**
	 * If this carrier is the not the current carrier of a transportable, make
	 * it so.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to check.
	 */
	private void takeTransportable(TransportableAIObject t) {
<span class="fc" id="L417">		AIUnit carrier = getAIUnit();</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">		if (t.getTransport() != carrier)</span>
<span class="fc" id="L419">			t.setTransport(carrier);</span>
<span class="fc" id="L420">	}</span>

	/**
	 * Get the collection location for an uncollected transportable.
	 *
	 * Public so that mobile transportables (units) can move to the collection
	 * point.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to collect.
	 * @return The collection &lt;code&gt;Location&lt;code&gt;, or null if not found.
	 */
	public Location getTransportTarget(TransportableAIObject t) {
<span class="nc bnc" id="L433" title="All 2 branches missed.">		if (isCarrying(t))</span>
<span class="nc" id="L434">			return null;</span>
<span class="nc" id="L435">		Cargo cargo = tFind(t);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">		return (cargo == null) ? null : cargo.getTransportTarget();</span>
	}

	/**
	 * Get the expected turns for an uncollected transport
	 *
	 * Public so that mobile transportables (units) can renege on transport if
	 * they find themselves better able to get there themselves.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to collect.
	 * @return The expected transport turns.
	 */
	public int getTransportTurns(TransportableAIObject t) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (isCarrying(t))</span>
<span class="nc" id="L451">			return INFINITY;</span>
<span class="nc" id="L452">		Cargo cargo = tFind(t);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">		return (cargo == null) ? INFINITY : cargo.getTurns();</span>
	}

	/**
	 * Wrap up the compatible cargoes in a list. O(N^2) alas.
	 *
	 * @return A wrapped list of cargoes.
	 */
	private List&lt;Cargo&gt; wrapCargoes() {
<span class="nc" id="L462">		List&lt;Cargo&gt; ts = tCopy();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">		for (int i = 0; i &lt; ts.size() - 1; i++) {</span>
<span class="nc" id="L464">			Cargo head = ts.get(i);</span>
<span class="nc bnc" id="L465" title="All 4 branches missed.">			while (i + 1 &lt; ts.size() &amp;&amp; head.couldWrap(ts.get(i + 1))) {</span>
<span class="nc" id="L466">				head.wrap(ts.remove(i + 1));</span>
			}
		}
<span class="nc" id="L469">		return ts;</span>
	}

	/**
	 * Unwrap a wrapped list of cargoes.
	 *
	 * @param ts
	 *            The list of &lt;code&gt;Cargo&lt;/code&gt;s to unwrap.
	 * @return The unwrapped list of cargoes.
	 */
	private List&lt;Cargo&gt; unwrapCargoes(List&lt;Cargo&gt; ts) {
<span class="nc bnc" id="L480" title="All 2 branches missed.">		for (int i = 0; i &lt; ts.size(); i++) {</span>
<span class="nc" id="L481">			Cargo t = ts.get(i);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">			if (t.hasWrapped()) {</span>
<span class="nc" id="L483">				List&lt;Cargo&gt; tl = t.unwrap();</span>
<span class="nc" id="L484">				ts.addAll(i + 1, tl);</span>
<span class="nc" id="L485">				i += tl.size();</span>
			}
		}
<span class="nc" id="L488">		return ts;</span>
	}

	/**
	 * Clears all the cargoes.
	 *
	 * @return A message about the cargoes being cleared.
	 */
	private String clearCargoes() {
<span class="fc" id="L497">		String log = &quot;cargoes cleared: &quot;;</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">		for (Cargo cargo : tClear()) {</span>
<span class="nc" id="L499">			dropTransportable(cargo.getTransportable());</span>
<span class="nc" id="L500">			log += &quot; &quot; + cargo;</span>
<span class="nc" id="L501">		}</span>
<span class="fc" id="L502">		tRetarget();</span>
<span class="fc" id="L503">		return log;</span>
	}

	/**
	 * Is there nothing currently queued for this carrier?.
	 *
	 * @return True if there is no work allocated to this carrier.
	 */
	public boolean isEmpty() {
<span class="nc bnc" id="L512" title="All 2 branches missed.">		return tSize() == 0;</span>
	}

	/**
	 * For a given transportable, work out where the carrier has to go to
	 * advance the cargo (target), and what to do there (mode), allowing a new
	 * &lt;code&gt;Cargo&lt;/code&gt; to be defined.
	 *
	 * AIUnit cargo is harder than AIGoods, because AIUnits might have their own
	 * inland paths, and thus we need to consider drop nodes.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to consider.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return A new &lt;code&gt;Cargo&lt;/code&gt; defining the action to take with the
	 *         &lt;code&gt;TransportableAIObject&lt;/code&gt;, or null if impossible.
	 */
	public Cargo makeCargo(TransportableAIObject t, LogBuilder lb) {
<span class="fc" id="L531">		final Unit carrier = getUnit();</span>
		String reason;
<span class="fc" id="L533">		Cargo cargo = null;</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">		if (t.getTransportDestination() == null) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">			if (!isCarrying(t)) {</span>
<span class="nc" id="L536">				reason = &quot;null transport destination&quot;;</span>
			} else {
				// Can happen with carriers with units transferred in
				// Spanish succession.
<span class="nc" id="L540">				PathNode path = carrier.getTrivialPath();</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">				if (path == null) {</span>
<span class="nc" id="L542">					reason = &quot;null transport destination&quot;;</span>
				} else {
					try {
<span class="nc" id="L545">						reason = null;</span>
<span class="nc" id="L546">						cargo = Cargo.newCargo(t, carrier, path.getLastNode().getLocation(), true);</span>
<span class="nc" id="L547">					} catch (FreeColException fce) {</span>
<span class="nc" id="L548">						reason = fce.getMessage();</span>
<span class="nc" id="L549">						cargo = null;</span>
<span class="nc" id="L550">					}</span>
				}
<span class="nc" id="L552">			}</span>
<span class="pc bpc" id="L553" title="1 of 4 branches missed.">		} else if (!isCarrying(t) &amp;&amp; !t.carriableBy(carrier)) {</span>
<span class="nc" id="L554">			reason = &quot;carrier &quot; + carrier.toShortString() + &quot; can not carry&quot;;</span>
		} else {
			try {
<span class="fc" id="L557">				reason = null;</span>
<span class="fc" id="L558">				cargo = Cargo.newCargo(t, carrier);</span>
<span class="fc" id="L559">			} catch (FreeColException fce) {</span>
<span class="fc" id="L560">				reason = fce.getMessage();</span>
<span class="fc" id="L561">				cargo = null;</span>
<span class="fc" id="L562">			}</span>
		}
<span class="fc bfc" id="L564" title="All 2 branches covered.">		if (reason == null) {</span>
<span class="fc" id="L565">			lb.add(&quot;, made &quot;, cargo.toShortString());</span>
<span class="fc" id="L566">			return cargo;</span>
		} else {
<span class="fc" id="L568">			lb.add(&quot;, failed to make cargo for &quot;, t, &quot; (&quot;, reason, &quot;)&quot;);</span>
<span class="fc" id="L569">			return null;</span>
		}
	}

	/**
	 * Add the given Cargo to the cargoes list.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to add.
	 * @param index
	 *            The index of where to add the cargo.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the cargo was added.
	 */
	private boolean addCargo(Cargo cargo, int index, LogBuilder lb) {
<span class="fc" id="L585">		boolean result = tAdd(cargo, index);</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">		if (result)</span>
<span class="fc" id="L587">			takeTransportable(cargo.getTransportable());</span>

<span class="pc bpc" id="L589" title="1 of 2 branches missed.">		if (result) {</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">			lb.add(&quot;, added &quot;, cargo.toShortString(), &quot; at &quot;, ((index &lt; 0) ? &quot;end&quot; : Integer.toString(index)));</span>
		} else {
<span class="nc" id="L592">			lb.add(&quot;, failed to add &quot;, cargo.toShortString());</span>
		}
<span class="fc" id="L594">		return result;</span>
	}

	/**
	 * Removes the given Cargo from the cargoes list.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to remove.
	 */
	private void removeCargo(Cargo cargo) {
<span class="nc bnc" id="L604" title="All 2 branches missed.">		if (!tRemove(cargo)) {</span>
<span class="nc" id="L605">			throw new RuntimeException(&quot;removeCargo &quot; + cargo.toShortString());</span>
		}
<span class="nc" id="L607">		dropTransportable(cargo.getTransportable());</span>
<span class="nc" id="L608">	}</span>

	/**
	 * Is there space available for a new cargo?.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to check.
	 * @return True if there is space available for this cargo.
	 */
	public boolean spaceAvailable(Cargo cargo) {
<span class="nc" id="L618">		return spaceAvailable(cargo.getTransportable());</span>
	}

	/**
	 * Is there space available for a new cargo?.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to check.
	 * @return True if there is space available for this transportable.
	 */
	public boolean spaceAvailable(TransportableAIObject t) {
<span class="nc" id="L629">		final List&lt;Cargo&gt; ts = tCopy();</span>
<span class="nc" id="L630">		final int newSpace = t.getSpaceTaken();</span>

<span class="nc bnc" id="L632" title="All 2 branches missed.">		for (int i = ts.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">			if (ts.get(i).getSpaceLeft() &lt; newSpace)</span>
<span class="nc" id="L634">				return false;</span>
		}
<span class="nc" id="L636">		return true;</span>
	}

	/**
	 * Incrementally queue a cargo to the cargoes list.
	 *
	 * If the carrier is at the collection point favour immediate collection.
	 * Otherwise try to place it with other cargoes with the same target, but do
	 * not break the space restrictions. If this does not work, it has to go at
	 * the end.
	 *
	 * @param cargo
	 *            The new &lt;code&gt;Cargo&lt;/code&gt; to add.
	 * @param requireMatch
	 *            Fail if an existing destination is not matched.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the cargo was queued.
	 */
	private boolean queueCargo(Cargo cargo, boolean requireMatch, LogBuilder lb) {
<span class="fc" id="L656">		final Unit carrier = getUnit();</span>
<span class="fc" id="L657">		final int maxHolds = carrier.getCargoCapacity();</span>
<span class="fc" id="L658">		final List&lt;Cargo&gt; ts = tCopy();</span>
<span class="fc" id="L659">		final int newSpace = cargo.getNewSpace();</span>
<span class="fc" id="L660">		int candidate = -1;</span>

<span class="pc bpc" id="L662" title="1 of 2 branches missed.">		if (ts.isEmpty() // Trivial case</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">				|| (Map.isSameLocation(carrier.getLocation(), // Carrier here?</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">						cargo.getCarrierTarget()) &amp;&amp; cargo.canQueueAt(carrier, 0, ts))) {</span>
<span class="fc" id="L665">			candidate = 0;</span>
		}

<span class="pc bpc" id="L668" title="1 of 2 branches missed.">		if (candidate &lt; 0) { // Match an existing target?</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">			outer: for (int i = 0; i &lt; ts.size(); i++) {</span>
<span class="nc" id="L670">				Cargo tr = ts.get(i);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">				if (Map.isSameLocation(tr.getCarrierTarget(), cargo.getCarrierTarget())) {</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">					if (!cargo.canQueueAt(carrier, i, ts))</span>
<span class="nc" id="L673">						continue outer;</span>
<span class="nc" id="L674">					candidate = i;</span>
<span class="nc" id="L675">					break;</span>
				}
			}
		}

<span class="pc bpc" id="L680" title="1 of 2 branches missed.">		if (candidate &lt; 0) { // Queue at end unless match required</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">			if (requireMatch)</span>
<span class="nc" id="L682">				return false;</span>
<span class="nc" id="L683">			candidate = ts.size();</span>
		}
<span class="fc" id="L685">		return addCargo(cargo, candidate, lb);</span>
	}

	/**
	 * Dump a currently carried cargo.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to dump.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the cargo is no longer on board and not on the transport
	 *         list, or is on board but is scheduled to be dumped.
	 */
	public boolean dumpCargo(Cargo cargo, LogBuilder lb) {
<span class="nc" id="L699">		TransportableAIObject t = cargo.getTransportable();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">		if (isCarrying(t))</span>
<span class="nc" id="L701">			t.leaveTransport();</span>
<span class="nc bnc" id="L702" title="All 4 branches missed.">		if (!isCarrying(t) &amp;&amp; tFind(t) != null)</span>
<span class="nc" id="L703">			removeCargo(cargo);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">		if (tFind(t) != null) {</span>
<span class="nc" id="L705">			String reason = cargo.dump();</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">			if (reason != null) {</span>
<span class="nc" id="L707">				lb.add(&quot;, dump failed(&quot;, reason, &quot;)&quot;);</span>
<span class="nc" id="L708">				return false;</span>
			} else {
<span class="nc" id="L710">				lb.add(&quot;, dumping&quot;);</span>
			}
		}
<span class="nc" id="L713">		return true;</span>
	}

	/**
	 * Requeue an existing cargo. Typically done when the target changes.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to requeue.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the queuing succeeded.
	 */
	public boolean requeueCargo(Cargo cargo, LogBuilder lb) {
<span class="nc" id="L726">		final TransportableAIObject t = cargo.getTransportable();</span>
<span class="nc" id="L727">		boolean ret = false;</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">		assert tFind(t) == cargo;</span>
<span class="nc" id="L729">		String reason = cargo.update();</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">		if (reason != null) {</span>
<span class="nc" id="L731">			lb.add(&quot; requeue/update fail(&quot;, reason, &quot;) &quot;, cargo.toShortString());</span>
<span class="nc" id="L732">			dumpCargo(cargo, lb);</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">		} else if (!tRemove(cargo)) {</span>
<span class="nc" id="L734">			lb.add(&quot; requeue/remove fail &quot;, cargo.toShortString());</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">		} else if (!queueCargo(cargo, false, lb)) {</span>
<span class="nc" id="L736">			lb.add(&quot; requeue/queue fail &quot;, cargo.toShortString());</span>
<span class="nc" id="L737">			dropTransportable(t);</span>
		} else {
<span class="nc" id="L739">			lb.add(&quot; requeued(&quot;, cargo.getTransportTarget(), &quot;) &quot;, cargo.toShortString());</span>
<span class="nc" id="L740">			takeTransportable(t);</span>
<span class="nc" id="L741">			ret = true;</span>
		}
<span class="nc" id="L743">		return ret;</span>
	}

	/**
	 * Checks for invalid cargoes, and units and goods on board but not in the
	 * cargoes list. On exit from this routine, every cargo on board should be
	 * on the cargoes list but the list is not necessarily going to be in a
	 * sensible order.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 */
	private void checkCargoes(LogBuilder lb) {
<span class="fc" id="L756">		final Unit carrier = getUnit();</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">		if (carrier.isAtSea())</span>
<span class="nc" id="L758">			return; // Let it emerge.</span>
<span class="fc" id="L759">		final AIUnit aiCarrier = getAIUnit();</span>

<span class="fc" id="L761">		List&lt;Unit&gt; unitsPresent = carrier.getUnitList();</span>
<span class="fc" id="L762">		List&lt;Goods&gt; goodsPresent = carrier.getCompactGoods();</span>
<span class="fc" id="L763">		List&lt;TransportableAIObject&gt; todo = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L764">		List&lt;TransportableAIObject&gt; drop = new ArrayList&lt;&gt;();</span>

		String reason;
		PathNode path;
		boolean dump;
<span class="fc" id="L769">		lb.add(&quot; [check&quot;);</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">		for (Cargo cargo : tCopy()) {</span>
<span class="fc" id="L771">			dump = false;</span>
<span class="fc" id="L772">			TransportableAIObject t = cargo.getTransportable();</span>
<span class="fc" id="L773">			reason = invalidReason(aiCarrier, cargo.getCarrierTarget());</span>
<span class="pc bpc" id="L774" title="2 of 4 branches missed.">			if (reason != null || (reason = cargo.check(aiCarrier)) != null) {</span>
				// Just remove, it is invalid
<span class="nc" id="L776">				removeCargo(cargo);</span>
<span class="nc" id="L777">				lb.add(&quot;, INVALID(&quot;, reason, &quot;) &quot;, cargo.toShortString());</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">			} else if (cargo.isDelivered()) {</span>
<span class="nc" id="L779">				removeCargo(cargo);</span>
<span class="nc" id="L780">				lb.add(&quot;, COMPLETED &quot;, cargo.toShortString());</span>
<span class="pc bpc" id="L781" title="3 of 4 branches missed.">			} else if (!cargo.hasPath() &amp;&amp; !cargo.retry()) {</span>
<span class="nc" id="L782">				reason = &quot; no-path&quot;;</span>
<span class="nc" id="L783">				dump = true;</span>
<span class="pc bpc" id="L784" title="2 of 4 branches missed.">			} else if (carrier.hasTile() &amp;&amp; (reason = cargo.update()) != null) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">				if (reason.startsWith(&quot;invalid&quot;)) {</span>
<span class="nc" id="L786">					removeCargo(cargo);</span>
<span class="nc" id="L787">					lb.add(&quot;, FAIL(&quot;, reason, &quot;) &quot;, cargo.toShortString());</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">				} else if (cargo.retry()) {</span>
<span class="nc" id="L789">					lb.add(&quot;, retry-&quot;, cargo.getTries(), &quot;(&quot;, reason, &quot;)&quot;);</span>
				} else {
<span class="nc" id="L791">					dump = true;</span>
				}
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">			} else if (cargo.isCollectable()) {</span>
<span class="nc" id="L794">				lb.add(&quot;, collect &quot;, cargo.toShortString());</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">			} else if (cargo.isDeliverable()) {</span>
<span class="nc" id="L796">				lb.add(&quot;, deliver &quot;, cargo.toShortString());</span>
			} else {
<span class="fc" id="L798">				lb.add(&quot;, ok &quot;, cargo.toShortString()); // Good</span>
<span class="fc" id="L799">				cargo.resetTries();</span>
			}
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">			if (dump) {</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">				if (cargo.isCarried()) {</span>
<span class="nc" id="L803">					dumpCargo(cargo, lb); // FIXME: can fail</span>
				} else {
<span class="nc" id="L805">					removeCargo(cargo);</span>
<span class="nc" id="L806">					lb.add(&quot;, dropped(&quot;, reason, &quot;) &quot;, cargo.toShortString());</span>
				}
			}
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">			if (t instanceof AIUnit) {</span>
<span class="nc" id="L810">				unitsPresent.remove(((AIUnit) t).getUnit());</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">			} else if (t instanceof AIGoods) {</span>
<span class="fc" id="L812">				Goods goods = ((AIGoods) t).getGoods();</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">				if (goods != null) {</span>
<span class="fc" id="L814">					Iterator&lt;Goods&gt; gi = goodsPresent.iterator();</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">					while (gi.hasNext()) {</span>
<span class="nc" id="L816">						Goods g = gi.next();</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">						if (g.getType() == goods.getType()) {</span>
<span class="nc" id="L818">							gi.remove();</span>
<span class="nc" id="L819">							break;</span>
						}
<span class="nc" id="L821">					}</span>
				}
			}
<span class="fc" id="L824">		}</span>

		// Find anything that was not on the cargoes list
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">		if (!unitsPresent.isEmpty()) {</span>
<span class="nc" id="L828">			lb.add(&quot;, found unexpected units&quot;);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">			for (Unit u : unitsPresent) {</span>
<span class="nc" id="L830">				AIUnit aiu = getAIMain().getAIUnit(u);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">				if (aiu == null)</span>
<span class="nc" id="L832">					throw new IllegalStateException(&quot;Bogus:&quot; + u);</span>
<span class="nc" id="L833">				todo.add(aiu);</span>
<span class="nc" id="L834">			}</span>
		}
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">		if (!goodsPresent.isEmpty()) {</span>
<span class="nc" id="L837">			lb.add(&quot;, found unexpected goods&quot;);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">			for (Goods g : goodsPresent) {</span>
<span class="nc" id="L839">				AIGoods aig = new AIGoods(getAIMain(), carrier, g.getType(), g.getAmount(), null);</span>
<span class="nc" id="L840">				todo.add(aig);</span>
<span class="nc" id="L841">			}</span>
		}

		// Try to queue the surprise transportables.
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">		while (!todo.isEmpty()) {</span>
<span class="nc" id="L846">			TransportableAIObject t = todo.remove(0);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">			if (!queueTransportable(t, false, lb))</span>
<span class="nc" id="L848">				drop.add(t);</span>
<span class="nc" id="L849">		}</span>

		// Drop transportables on the drop list, or queue them to be
		// dropped at the next port.
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">		if (!drop.isEmpty()) {</span>
<span class="nc" id="L854">			path = carrier.getTrivialPath();</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">			Location end = (path == null) ? null : path.getLastNode().getLocation();</span>

<span class="nc bnc" id="L857" title="All 2 branches missed.">			while (!drop.isEmpty()) {</span>
<span class="nc" id="L858">				TransportableAIObject t = drop.remove(0);</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">				if (t.leaveTransport()) {</span>
<span class="nc" id="L860">					lb.add(&quot; &quot;, t, &quot; left&quot;);</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">				} else if (end != null) {</span>
					try {
<span class="nc" id="L863">						Cargo cargo = Cargo.newCargo(t, carrier, end, false);</span>
<span class="nc" id="L864">						boolean result = queueCargo(cargo, false, lb);</span>
<span class="nc" id="L865">						lb.add(&quot; to drop at &quot;, Location.upLoc(end), &quot;=&quot;, result);</span>
<span class="nc" id="L866">					} catch (FreeColException fce) {</span>
<span class="nc" id="L867">						lb.add(&quot; &quot;, t, &quot; drop-fail(&quot;, fce.getMessage(), &quot;)&quot;);</span>
<span class="nc" id="L868">					}</span>
				} else {
<span class="nc" id="L870">					lb.add(&quot; &quot;, t, &quot; stuck&quot;);</span>
				}
<span class="nc" id="L872">			}</span>
		}

<span class="fc" id="L875">		lb.add(&quot;]&quot;);</span>
<span class="fc" id="L876">	}</span>

	/**
	 * Check a &lt;code&gt;Cargo&lt;/code&gt; for continued validity and whether action is
	 * needed at the current location.
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to check.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return TCONTINUE if the &lt;code&gt;Cargo&lt;/code&gt; should continue, TDONE if it
	 *         has completed, TFAIL if it has failed, TNEXT if it has progressed
	 *         to the next stage, TRETRY if a blockage has occurred and it
	 *         should be retried,
	 */
	private CargoResult tryCargo(Cargo cargo, LogBuilder lb) {
<span class="nc" id="L892">		final Unit carrier = getUnit();</span>
<span class="nc" id="L893">		final Location here = carrier.getLocation();</span>
<span class="nc" id="L894">		final TransportableAIObject t = cargo.getTransportable();</span>
<span class="nc" id="L895">		final Locatable l = t.getTransportLocatable();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">		if (l == null) {</span>
<span class="nc" id="L897">			logger.warning(&quot;Null-locatable: &quot; + cargo);</span>
<span class="nc" id="L898">			return CargoResult.TDONE;</span>
		}
<span class="nc bnc" id="L900" title="All 2 branches missed.">		if (!Map.isSameLocation(here, cargo.getCarrierTarget())) {</span>
<span class="nc" id="L901">			lb.add(&quot;, &quot;, t, &quot; unready&quot;);</span>
<span class="nc" id="L902">			return CargoResult.TCONTINUE;</span>
		}
<span class="nc" id="L904">		Direction d = null;</span>
<span class="nc" id="L905">		Location tloc = here;</span>

<span class="pc bnc" id="L907" title="All 6 branches missed.">		switch (cargo.getMode()) {</span>
		case PICKUP:
<span class="nc bnc" id="L909" title="All 2 branches missed.">			if (!t.canMove()) {</span>
<span class="nc" id="L910">				lb.add(&quot;, &quot;, t, &quot; out of moves&quot;);</span>
<span class="nc" id="L911">				return CargoResult.TCONTINUE;</span>
			}
<span class="nc bnc" id="L913" title="All 2 branches missed.">			if ((d = cargo.getJoinDirection()) == null) {</span>
<span class="nc" id="L914">				logger.warning(&quot;Null pickup direction&quot; + &quot; for &quot; + cargo.toShortString() + &quot; at &quot;</span>
<span class="nc" id="L915">						+ t.getLocation().toString() + &quot; to &quot; + carrier);</span>
<span class="nc" id="L916">				return CargoResult.TFAIL;</span>
			}
<span class="nc" id="L918">			tloc = tloc.getTile().getNeighbourOrNull(d.getReverseDirection());</span>
			// Fall through
		case LOAD:
<span class="nc bnc" id="L921" title="All 2 branches missed.">			if (!Map.isSameLocation(tloc, t.getLocation())) {</span>
<span class="nc" id="L922">				lb.add(&quot;, &quot;, t, &quot; at &quot;, t.getLocation(), &quot; not &quot;, tloc, &quot; # &quot;, cargo.toShortString());</span>
<span class="nc" id="L923">				return CargoResult.TCONTINUE;</span>
			}
<span class="pc bnc" id="L925" title="All 4 branches missed.">			switch (carrier.getNoAddReason(l)) {</span>
			case NONE:
<span class="nc bnc" id="L927" title="All 2 branches missed.">				if (!t.joinTransport(carrier, d)) {</span>
<span class="nc" id="L928">					lb.add(&quot;, &quot;, t, &quot; NO-JOIN&quot;);</span>
<span class="nc" id="L929">					return CargoResult.TFAIL;</span>
				}
				break;
			case ALREADY_PRESENT:
<span class="nc" id="L933">				break;</span>
			case CAPACITY_EXCEEDED:
<span class="nc" id="L935">				lb.add(&quot;, &quot;, t, &quot; NO-ROOM on &quot;, carrier);</span>
<span class="nc" id="L936">				return CargoResult.TFAIL;</span>
			default:
<span class="nc" id="L938">				lb.add(&quot;, &quot;, t, &quot; retry-&quot;, carrier.getNoAddReason(l));</span>
<span class="nc" id="L939">				return CargoResult.TRETRY;</span>
			}

<span class="nc" id="L942">			String reason = cargo.update();</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">			if (reason != null) {</span>
<span class="nc" id="L944">				lb.add(&quot;, &quot;, t, &quot; NO-UPDATE(&quot;, reason, &quot;)&quot;);</span>
<span class="nc" id="L945">				return CargoResult.TFAIL;</span>
			}
<span class="nc" id="L947">			lb.add(&quot;, &quot;, t, &quot; collected&quot;);</span>
<span class="nc" id="L948">			return CargoResult.TNEXT;</span>

		case DROPOFF:
<span class="nc bnc" id="L951" title="All 2 branches missed.">			if (!t.canMove()) {</span>
<span class="nc" id="L952">				lb.add(&quot;, &quot;, t, &quot; about to leave&quot;);</span>
<span class="nc" id="L953">				return CargoResult.TCONTINUE;</span>
			}
<span class="nc bnc" id="L955" title="All 2 branches missed.">			if ((d = cargo.getLeaveDirection()) == null) {</span>
<span class="nc" id="L956">				Unit.MoveType mt = ((AIUnit) t).getUnit().getSimpleMoveType(t.getLocation().getTile(),</span>
<span class="nc" id="L957">						cargo.getTransportTarget().getTile());</span>
<span class="pc bnc" id="L958" title="All 2 branches missed.">				switch (mt) {</span>
				case ATTACK_UNIT:
				case MOVE_NO_ATTACK_CIVILIAN:
<span class="nc" id="L961">					return CargoResult.TRETRY;</span>
				default:
<span class="nc" id="L963">					PathNode path = t.getDeliveryPath(carrier, cargo.getTransportTarget());</span>
<span class="nc" id="L964">					logger.warning(&quot;Null direction&quot; + &quot; for &quot; + cargo.toShortString() + &quot; at &quot;</span>
<span class="nc" id="L965">							+ t.getLocation().toShortString() + &quot;/&quot; + carrier.getLocation().toShortString() + &quot; to &quot;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">							+ cargo.getTransportTarget() + &quot; mov=&quot; + mt + &quot; path=&quot;</span>
<span class="nc" id="L967">							+ ((path == null) ? &quot;null&quot; : path.fullPathToString()));</span>
<span class="nc" id="L968">					return CargoResult.TFAIL;</span>
				}
			}
			// Fall through
		case UNLOAD:
<span class="nc bnc" id="L973" title="All 4 branches missed.">			if (isCarrying(t) &amp;&amp; !t.leaveTransport(d)) {</span>
				// lb.add(&quot;, &quot;, t, &quot; NO-LEAVE&quot;);
<span class="nc" id="L975">				PathNode pn = t.getDeliveryPath(carrier, t.getTransportDestination());</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">				lb.add(&quot;, &quot;, t, &quot; NO-LEAVE(&quot;, here, &quot;~&quot;, cargo.getLeaveDirection(), &quot;~&quot;, t.getTransportDestination(),</span>
<span class="nc" id="L977">						&quot; &quot;, ((pn == null) ? &quot;no-path&quot; : pn.fullPathToString()));</span>
<span class="nc" id="L978">				return CargoResult.TRETRY;</span>
			}
<span class="nc" id="L980">			lb.add(&quot;, &quot;, t, &quot; COMPLETED&quot;);</span>
<span class="nc" id="L981">			break;</span>

		case DUMP:
<span class="nc bnc" id="L984" title="All 2 branches missed.">			if (!t.leaveTransport()) {</span>
<span class="nc" id="L985">				lb.add(&quot;, &quot;, t, &quot; STUCK&quot;);</span>
<span class="nc" id="L986">				return CargoResult.TCONTINUE;</span>
			}
<span class="nc" id="L988">			lb.add(&quot;, &quot;, t, &quot; DUMPED at &quot;, t.getLocation());</span>
			break;
		}

		// Check for goods completing a wish
		Colony colony;
		AIColony aiColony;
<span class="nc bnc" id="L995" title="All 4 branches missed.">		if ((colony = (t.getLocation() == null) ? null : t.getLocation().getColony()) != null</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">				&amp;&amp; (aiColony = getAIMain().getAIColony(colony)) != null &amp;&amp; aiColony.completeWish(t, lb)) {</span>
<span class="nc" id="L997">			aiColony.requestRearrange();</span>
		}
<span class="nc" id="L999">		return CargoResult.TDONE;</span>
	}

	/**
	 * Perform the transport load/unload operations on arrival at the target for
	 * the top cargo.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 */
	private void doTransport(LogBuilder lb) {
<span class="nc" id="L1010">		final Unit unit = getUnit();</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">		if (tSize() &gt; 0) {</span>
			// Arrived at a target. Deliver what can be delivered.
			// Check other deliveries, we might be in port so this is
			// a good time to decide to fail to deliver something.
<span class="nc" id="L1015">			lbAt(lb);</span>
<span class="nc" id="L1016">			lb.add(&quot;, delivering&quot;);</span>
<span class="nc" id="L1017">			List&lt;Cargo&gt; cont = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1018">			List&lt;Cargo&gt; next = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1019">			List&lt;Cargo&gt; curr = tClear();</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">			for (Cargo cargo : curr) {</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">				CargoResult result = (cargo.getMode().isCollection()) ? CargoResult.TCONTINUE : tryCargo(cargo, lb);</span>
<span class="pc bnc" id="L1022" title="All 5 branches missed.">				switch (result) {</span>
				case TCONTINUE:
<span class="nc" id="L1024">					cont.add(cargo);</span>
<span class="nc" id="L1025">					break;</span>
				case TRETRY: // will check again below
<span class="nc bnc" id="L1027" title="All 2 branches missed.">					if (cargo.retry()) {</span>
<span class="nc" id="L1028">						cont.add(cargo);</span>
<span class="nc" id="L1029">						break;</span>
					}
					// Fall through
				case TFAIL:
<span class="nc bnc" id="L1033" title="All 2 branches missed.">					if (cargo.isCarried()) {</span>
<span class="nc" id="L1034">						cargo.dump();</span>
<span class="nc" id="L1035">						break;</span>
					}
					// Fall through
				case TDONE:
<span class="nc" id="L1039">					dropTransportable(cargo.getTransportable());</span>
<span class="nc" id="L1040">					cargo.clear();</span>
<span class="nc" id="L1041">					break;</span>
				case TNEXT:
				default:
<span class="nc" id="L1044">					throw new IllegalStateException(&quot;Can not happen&quot;);</span>
				}
<span class="nc" id="L1046">			}</span>
<span class="nc" id="L1047">			curr.clear();</span>
			// Rebuild the cargo list with the original members,
			// less the transportables that were dropped.
<span class="nc" id="L1050">			tSet(cont, true);</span>

			// Now try again, this time collecting as well as
			// delivering.
<span class="nc" id="L1054">			lb.add(&quot;, collecting&quot;);</span>
<span class="nc" id="L1055">			cont.clear();</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">			for (Cargo cargo : tClear()) {</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">				CargoResult result = (cargo.getMode().isCollection()) ? tryCargo(cargo, lb) : CargoResult.TCONTINUE;</span>
<span class="nc bnc" id="L1058" title="All 5 branches missed.">				switch (result) {</span>
				case TCONTINUE:
<span class="nc" id="L1060">					cont.add(cargo);</span>
<span class="nc" id="L1061">					break;</span>
				case TNEXT:
<span class="nc" id="L1063">					cont.add(cargo);</span>
<span class="nc" id="L1064">					break;</span>
				case TRETRY:
<span class="nc bnc" id="L1066" title="All 2 branches missed.">					if (cargo.retry()) { // Can not reach the target.</span>
<span class="nc" id="L1067">						next.add(cargo); // Try again next turn.</span>
<span class="nc" id="L1068">						break;</span>
					}
					// Fall through
				case TFAIL:
				case TDONE:
<span class="nc" id="L1073">					dropTransportable(cargo.getTransportable());</span>
<span class="nc" id="L1074">					cargo.clear();</span>
<span class="nc" id="L1075">					break;</span>
				default:
<span class="nc" id="L1077">					throw new IllegalStateException(&quot;Can not happen&quot;);</span>
				}
<span class="nc" id="L1079">			}</span>

			// Rebuild the cargo list with the original members,
			// less the transportables that were dropped.
<span class="nc" id="L1083">			tSet(cont, true);</span>

			// Add the new and blocked cargoes incrementally with
			// the current arrangement, which is likely to put them
			// at the end.
<span class="nc bnc" id="L1088" title="All 2 branches missed.">			if (!next.isEmpty()) {</span>
<span class="nc" id="L1089">				lb.add(&quot;, requeue&quot;);</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">				for (Cargo c : next)</span>
<span class="nc" id="L1091">					queueCargo(c, false, lb);</span>
			}

			// Delivering might have invalidated other cargo missions.
			// It may be rare, but there have been cases where a scout
			// has disembarked onto an LCR, invalidating the mission
			// of a scout further down the transport list. Run check
			// cargoes again to handle this. Then optimize.
<span class="nc" id="L1099">			checkCargoes(lb);</span>
<span class="nc" id="L1100">			optimizeCargoes(lb);</span>
		}

		// Replenish cargoes up to available destination capacity
		// and 50% above maximum cargoes (FIXME: longer?)
<span class="nc" id="L1105">		final EuropeanAIPlayer euaip = getEuropeanAIPlayer();</span>
<span class="nc bnc" id="L1106" title="All 4 branches missed.">		while (destinationCapacity() &gt; 0 &amp;&amp; tSize() &lt; unit.getCargoCapacity() * 3 / 2) {</span>
<span class="nc" id="L1107">			Cargo cargo = getBestCargo(unit);</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">			if (cargo == null)</span>
<span class="nc" id="L1109">				break;</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">			if (!queueCargo(cargo, false, lb))</span>
<span class="nc" id="L1111">				break;</span>
<span class="nc" id="L1112">			euaip.claimTransportable(cargo.getTransportable());</span>
<span class="nc" id="L1113">		}</span>
<span class="nc" id="L1114">	}</span>

	/**
	 * Calculates a score for a proposed list of &lt;code&gt;Cargo&lt;/code&gt;s using the
	 * current unit. Disallows routes that would overfill the carrier.
	 *
	 * Useful for comparing proposed cargo delivery routes. The score is based
	 * primarily on the number of turns it takes, but to break ties we also
	 * consider the hold*turn product to reduce the risk of losses due to enemy
	 * action.
	 *
	 * @param initialLocation
	 *            The initial &lt;code&gt;Location&lt;/code&gt;.
	 * @param order
	 *            An ordering of &lt;code&gt;Cargo&lt;/code&gt;s.
	 * @return A score for the cargo ordering.
	 */
	private float scoreCargoOrder(Location initialLocation, List&lt;Cargo&gt; order) {
<span class="nc" id="L1132">		final Unit carrier = getUnit();</span>
<span class="nc" id="L1133">		final int maxHolds = carrier.getCargoCapacity();</span>
<span class="nc" id="L1134">		int holds = carrier.getCargoSpaceTaken();</span>
<span class="nc" id="L1135">		Location now = initialLocation;</span>
<span class="nc" id="L1136">		float totalHoldTurns = 0.0f;</span>
<span class="nc" id="L1137">		float totalTurns = 0.0f;</span>
<span class="nc" id="L1138">		float favourEarly = 1.0f;</span>

<span class="nc bnc" id="L1140" title="All 2 branches missed.">		for (Cargo cargo : order) {</span>
<span class="nc" id="L1141">			int turns = carrier.getTurnsToReach(now, cargo.getCarrierTarget());</span>
<span class="nc" id="L1142">			totalTurns += turns; // Might be MANY_TURNS!</span>
<span class="nc" id="L1143">			totalHoldTurns += holds * turns * favourEarly;</span>
<span class="nc" id="L1144">			holds += cargo.getNewSpace();</span>
<span class="nc bnc" id="L1145" title="All 4 branches missed.">			if (holds &lt; 0 || holds &gt; maxHolds)</span>
<span class="nc" id="L1146">				return -1.0f;</span>
<span class="nc" id="L1147">			now = cargo.getCarrierTarget();</span>
<span class="nc" id="L1148">			favourEarly += 0.1f; // Slight preference for large loads first</span>
<span class="nc" id="L1149">		}</span>
<span class="nc" id="L1150">		return totalTurns + 0.001f * totalHoldTurns;</span>
	}

	/**
	 * Sets the current target. Tries all permutations of cargoes and picks the
	 * fastest/safest one.
	 *
	 * Leaves the cargoes in the order they are expected to execute, with valid
	 * spaceLeft values.
	 *
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 */
	private void optimizeCargoes(LogBuilder lb) {
<span class="nc" id="L1164">		lb.add(&quot;, optimize&quot;);</span>
<span class="nc" id="L1165">		Location oldTarget = getTarget();</span>

		// We wrap/unwrap the list to minimize the number of nodes
		// that need consideration.
<span class="nc" id="L1169">		List&lt;Cargo&gt; ts = wrapCargoes();</span>
<span class="nc" id="L1170">		List&lt;Cargo&gt; best = null;</span>
<span class="nc bnc" id="L1171" title="All 4 branches missed.">		if (1 &lt; ts.size() &amp;&amp; ts.size() &lt;= DESTINATION_UPPER_BOUND) {</span>
			// Try all the permutations of visiting order for the
			// locations, and set the target to the first location
			// of the best scoring route.
			//
			// The target may get recomputed every time a cargo change
			// occurs, so there is no guarantee that the route chosen
			// here is actually executed. This seems rather
			// inefficient, but we need to be adaptable.
			//
<span class="nc" id="L1181">			final Location current = getUnit().getLocation();</span>
<span class="nc" id="L1182">			float bestValue = INFINITY;</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">			for (List&lt;Cargo&gt; tl : getPermutations(ts)) {</span>
<span class="nc" id="L1184">				float value = scoreCargoOrder(current, tl);</span>
<span class="nc bnc" id="L1185" title="All 4 branches missed.">				if (value &gt; 0.0f &amp;&amp; bestValue &gt; value) {</span>
<span class="nc" id="L1186">					bestValue = value;</span>
<span class="nc" id="L1187">					best = tl;</span>
				}
<span class="nc" id="L1189">			}</span>
		}
<span class="nc bnc" id="L1191" title="All 2 branches missed.">		if (best != null) {</span>
<span class="nc" id="L1192">			tSet(unwrapCargoes(best), true);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">			if (oldTarget != getTarget())</span>
<span class="nc" id="L1194">				lb.add(&quot;-&gt;&quot;, getTarget());</span>
		} else {
<span class="nc" id="L1196">			tSet(unwrapCargoes(ts), false);</span>
		}
<span class="nc" id="L1198">	}</span>

	/**
	 * What is the best transportable for a carrier to collect?.
	 *
	 * @param carrier
	 *            The carrier &lt;code&gt;Unit&lt;/code&gt; to consider.
	 * @return The best available new &lt;code&gt;Cargo&lt;/code&gt;, or null if none found.
	 */
	private Cargo getBestCargo(Unit carrier) {
<span class="nc" id="L1208">		final EuropeanAIPlayer euaip = getEuropeanAIPlayer();</span>
<span class="nc" id="L1209">		Cargo bestDirect = null, bestFallback = null;</span>
<span class="nc" id="L1210">		float bestDirectValue = 0.0f, bestFallbackValue = 0.0f;</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">		for (TransportableAIObject t : euaip.getUrgentTransportables()) {</span>
<span class="nc bnc" id="L1212" title="All 4 branches missed.">			if (t.isDisposed() || !t.carriableBy(carrier))</span>
<span class="nc" id="L1213">				continue;</span>
<span class="nc" id="L1214">			Location loc = t.getTransportSource();</span>
			Cargo cargo;
			try {
<span class="nc" id="L1217">				cargo = Cargo.newCargo(t, carrier);</span>
<span class="nc" id="L1218">			} catch (FreeColException fce) {</span>
<span class="nc" id="L1219">				cargo = null;</span>
<span class="nc" id="L1220">			}</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">			if (cargo == null)</span>
<span class="nc" id="L1222">				continue;</span>
<span class="nc" id="L1223">			float value = t.getTransportPriority() / (cargo.getTurns() + 1.0f);</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">			if (cargo.isFallback()) {</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">				if (bestFallbackValue &lt; value) {</span>
<span class="nc" id="L1226">					bestFallbackValue = value;</span>
<span class="nc" id="L1227">					bestFallback = cargo;</span>
				}
			} else {
<span class="nc bnc" id="L1230" title="All 2 branches missed.">				if (bestDirectValue &lt; value) {</span>
<span class="nc" id="L1231">					bestDirectValue = value;</span>
<span class="nc" id="L1232">					bestDirect = cargo;</span>
				}
			}
<span class="nc" id="L1235">		}</span>
<span class="nc bnc" id="L1236" title="All 4 branches missed.">		return (bestDirect != null) ? bestDirect : (bestFallback != null) ? bestFallback : null;</span>
	}

	/**
	 * Why would an TransportMission be invalid with the given unit?.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to test.
	 * @return A reason why the mission would be invalid with the unit, or null
	 *         if none found.
	 */
	private static String invalidMissionReason(AIUnit aiUnit) {
<span class="fc" id="L1248">		String reason = invalidAIUnitReason(aiUnit);</span>
<span class="pc bpc" id="L1249" title="1 of 4 branches missed.">		return (reason != null) ? reason : (!aiUnit.getUnit().isCarrier()) ? &quot;unit-not-a-carrier&quot; : null;</span>
	}

	/**
	 * Why would this mission be invalid with a given cargo? Checks the cargo
	 * locations. A location becomes invalid if: - step is a null location -
	 * step is disposed - step is a captured settlement
	 *
	 * @param cargo
	 *            The &lt;code&gt;Cargo&lt;/code&gt; to test.
	 * @return A reason why the mission would be invalid, or null if none found.
	 */
	private static String invalidCargoReason(Cargo cargo) {
<span class="fc" id="L1262">		final TransportableAIObject t = cargo.getTransportable();</span>
		String reason;
<span class="pc bpc" id="L1264" title="2 of 4 branches missed.">		return (t == null) ? &quot;null-transportable&quot; : ((reason = t.invalidReason()) != null) ? &quot;cargo-&quot; + reason : null;</span>
	}

	/**
	 * Why would this mission be invalid with the given AI unit and location?.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to check.
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; to check.
	 * @return A reason for invalidity, or null if none found.
	 */
	public static String invalidReason(AIUnit aiUnit, Location loc) {
		String reason;
<span class="pc bpc" id="L1278" title="2 of 8 branches missed.">		return ((reason = invalidMissionReason(aiUnit)) != null) ? reason</span>
				: (loc instanceof Tile) ? null
						: (loc instanceof Europe || loc instanceof Colony)
<span class="pc" id="L1281">								? invalidTargetReason(loc, aiUnit.getUnit().getOwner()) : Mission.TARGETINVALID;</span>
	}

	/**
	 * Why would this mission be invalid with the given AI unit?.
	 *
	 * @param aiUnit
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to check.
	 * @return A reason for mission invalidity, or null if none found.
	 */
	public static String invalidReason(AIUnit aiUnit) {
<span class="fc" id="L1292">		return invalidMissionReason(aiUnit);</span>
	}

	// End of cargoes handling.

	// Publically accessible routines to manipulate a TransportableAIObject.

	/**
	 * Removes the given &lt;code&gt;TransportableAIObject&lt;/code&gt; from the cargo list.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to remove.
	 * @return True if the removal succeeded.
	 */
	public boolean removeTransportable(TransportableAIObject t) {
<span class="nc" id="L1307">		Cargo cargo = tFind(t);</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">		return (cargo == null) ? false : tRemove(cargo);</span>
	}

	/**
	 * Retargets a transportable that should already be on board the carrier.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to retarget.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the retargeting succeeded.
	 */
	public boolean requeueTransportable(TransportableAIObject t, LogBuilder lb) {
<span class="nc" id="L1321">		Cargo cargo = tFind(t);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">		return (cargo == null) ? queueTransportable(t, false, lb) : requeueCargo(cargo, lb);</span>
	}

	/**
	 * Wrapper for queueCargo. Public for the benefit of
	 * EuropeanAIPlayer.allocateTransportables and
	 * CashInTreasureTrain.doMission.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to add.
	 * @param requireMatch
	 *            Fail if an existing destination is not matched.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the transportable was queued.
	 */
	public boolean queueTransportable(TransportableAIObject t, boolean requireMatch, LogBuilder lb) {
<span class="fc" id="L1339">		Cargo cargo = makeCargo(t, lb);</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">		return (cargo == null) ? false : queueCargo(cargo, requireMatch, lb);</span>
	}

	/**
	 * Dump a transportable.
	 *
	 * @param t
	 *            The &lt;code&gt;TransportableAIObject&lt;/code&gt; to dump.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the transportable is no longer on board, queued, or was
	 *         reset to be dumped at the next stop.
	 */
	public boolean dumpTransportable(TransportableAIObject t, LogBuilder lb) {
<span class="nc bnc" id="L1354" title="All 2 branches missed.">		if (t == null)</span>
<span class="nc" id="L1355">			return true;</span>
<span class="nc" id="L1356">		Cargo cargo = tFind(t);</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">		if (cargo == null)</span>
<span class="nc" id="L1358">			return true;</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">		if (!isCarrying(t)) {</span>
<span class="nc" id="L1360">			removeTransportable(t);</span>
<span class="nc" id="L1361">			return true;</span>
		}
<span class="nc" id="L1363">		return dumpCargo(cargo, lb);</span>
	}

	/**
	 * Drop all collections so that cargo is delivered only, then collect this
	 * unit. Useful for prioritizing treasure collection.
	 *
	 * @param aiu
	 *            The &lt;code&gt;AIUnit&lt;/code&gt; to collect.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 * @return True if the unit was queued.
	 */
	public boolean forceCollection(AIUnit aiu, LogBuilder lb) {
<span class="nc bnc" id="L1377" title="All 2 branches missed.">		for (Cargo c : tCopy()) {</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">			if (c.getMode().isCollection())</span>
<span class="nc" id="L1379">				removeCargo(c);</span>
<span class="nc" id="L1380">		}</span>
<span class="nc" id="L1381">		return queueTransportable(aiu, false, lb);</span>
	}

	/**
	 * Suppress European trade in a type of goods which is about to be
	 * boycotted.
	 *
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; to suppress.
	 * @param lb
	 *            A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
	 */
	public void suppressEuropeanTrade(GoodsType type, LogBuilder lb) {
<span class="nc bnc" id="L1394" title="All 2 branches missed.">		for (Cargo c : tCopy()) {</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">			if (c.isEuropeanTrade(type))</span>
<span class="nc" id="L1396">				removeCargo(c);</span>
<span class="nc" id="L1397">		}</span>
<span class="nc" id="L1398">	}</span>

	// End of public TransportableAIObject manipulations

	// Implement Mission
	// Inherit dispose, getBaseTransportPriority, isOneTime

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Tile getTransportDestination() {
<span class="nc" id="L1410">		return null; // Can not transport a carrier unit.</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location getTarget() {
<span class="fc" id="L1418">		return target;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setTarget(Location target) {
<span class="fc" id="L1426">		this.target = target;</span>
<span class="fc" id="L1427">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Location findTarget() {
		// A noop. The target is defined by the cargoes.
<span class="nc" id="L1435">		return null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String invalidReason() {
<span class="fc" id="L1443">		final AIUnit aiUnit = getAIUnit();</span>
<span class="fc" id="L1444">		String reason = invalidReason(aiUnit, getTarget());</span>
		Cargo cargo;
<span class="fc bfc" id="L1446" title="All 4 branches covered.">		return (reason != null) ? reason : ((cargo = tFirst()) == null) ? null : invalidCargoReason(cargo);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Mission doMission(LogBuilder lb) {
<span class="fc" id="L1454">		lb.add(tag);</span>
<span class="fc" id="L1455">		checkCargoes(lb);</span>
<span class="fc" id="L1456">		String reason = invalidReason();</span>
<span class="fc bfc" id="L1457" title="All 2 branches covered.">		if (reason != null)</span>
<span class="fc" id="L1458">			return lbFail(lb, false, reason);</span>

<span class="fc" id="L1460">		final AIUnit aiCarrier = getAIUnit();</span>
<span class="fc" id="L1461">		final Unit unit = getUnit();</span>
<span class="fc" id="L1462">		final CostDecider fallBackDecider = CostDeciders.avoidSettlementsAndBlockingUnits();</span>
<span class="fc" id="L1463">		final EuropeanAIPlayer euaip = getEuropeanAIPlayer();</span>
<span class="fc" id="L1464">		CostDecider costDecider = CostDeciders.defaultCostDeciderFor(unit);</span>
		for (;;) {
<span class="fc" id="L1466">			Unit.MoveType mt = travelToTarget(target, costDecider, lb);</span>
<span class="pc bpc" id="L1467" title="5 of 6 branches missed.">			switch (mt) {</span>
			case MOVE: // Arrived at transport target
<span class="nc" id="L1469">				doTransport(lb);</span>
<span class="nc bnc" id="L1470" title="All 4 branches missed.">				if (isEmpty() &amp;&amp; unit.isOffensiveUnit()) {</span>
<span class="nc" id="L1471">					Mission m = euaip.getPrivateerMission(aiCarrier, null);</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">					if (m != null)</span>
<span class="nc" id="L1473">						return lbDone(lb, false, &quot;going pirate&quot;);</span>
				}
<span class="nc bnc" id="L1475" title="All 2 branches missed.">				if ((reason = invalidReason()) != null) {</span>
<span class="nc" id="L1476">					logger.warning(tag + &quot; post-stop failure(&quot; + reason + &quot;): &quot; + this.toFullString());</span>
<span class="nc" id="L1477">					return lbFail(lb, false, reason);</span>
				}
<span class="nc bnc" id="L1479" title="All 2 branches missed.">				if (unit.isAtLocation(target)) {</span>
<span class="nc" id="L1480">					return lbWait(lb, &quot;, waiting at &quot;, target);</span>
				}
				break;

			case MOVE_HIGH_SEAS:
			case MOVE_NO_MOVES:
			case MOVE_NO_REPAIR:
			case MOVE_ILLEGAL:
<span class="fc" id="L1488">				return lbWait(lb);</span>

			case MOVE_NO_TILE: // Another unit is blocking a river?
<span class="nc" id="L1491">				moveRandomly(tag, null);</span>
<span class="nc" id="L1492">				return lbDodge(lb);</span>

			case ATTACK_UNIT:
<span class="nc" id="L1495">				Location blocker = resolveBlockage(aiCarrier, target);</span>
<span class="nc bnc" id="L1496" title="All 4 branches missed.">				if (blocker instanceof Unit &amp;&amp; shouldAttack((Unit) blocker)) {</span>
<span class="nc" id="L1497">					AIMessage.askAttack(aiCarrier, unit.getTile().getDirection(blocker.getTile()));</span>
<span class="nc" id="L1498">					return lbAttack(lb, blocker);</span>
				}
				// Fall through
			case MOVE_NO_ATTACK_CIVILIAN:
				// FIXME: See if the transportable can get around the
				// blockage using its own path finding.
<span class="nc bnc" id="L1504" title="All 4 branches missed.">				if (unit.getTile().isAdjacent(target.getTile()) || costDecider == fallBackDecider) {</span>
<span class="nc" id="L1505">					moveRandomly(tag, null);</span>
<span class="nc" id="L1506">					return lbDodge(lb);</span>
				}
<span class="nc" id="L1508">				costDecider = fallBackDecider; // Retry</span>
<span class="nc" id="L1509">				lb.add(&quot;, retry blockage at &quot;, unit.getLocation());</span>
<span class="nc" id="L1510">				break;</span>

			case MOVE_NO_ACCESS_EMBARK:
			default:
<span class="nc" id="L1514">				return lbMove(lb, mt);</span>
			}
<span class="nc" id="L1516">		}</span>
	}

	// Serialization

	/** The Constant TARGET_TAG. */
	private static final String TARGET_TAG = &quot;target&quot;;

	/** The Constant OLD_TRANSPORTABLE_TAG. */
	// @compat 0.10.5
	private static final String OLD_TRANSPORTABLE_TAG = &quot;transportable&quot;;
	// end @compat

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc" id="L1534">		super.writeAttributes(xw);</span>

<span class="nc bnc" id="L1536" title="All 2 branches missed.">		if (target != null) {</span>
<span class="nc" id="L1537">			xw.writeLocationAttribute(TARGET_TAG, target);</span>
		}
<span class="nc" id="L1539">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc" id="L1546">		final AIUnit aiCarrier = getAIUnit();</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">		for (Cargo cargo : tCopy()) {</span>
			// Sanity check first. Another nation might have captured
			// or destroyed a target colony.
<span class="nc" id="L1550">			String reason = cargo.check(aiCarrier);</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">			if (reason != null)</span>
<span class="nc" id="L1552">				continue;</span>
			// Do not bother writing cargoes that will be dumped.
			// On restore, checkCargoes will work out what to do with them.
<span class="nc bnc" id="L1555" title="All 2 branches missed.">			if (cargo.getMode() == Cargo.CargoMode.DUMP)</span>
<span class="nc" id="L1556">				continue;</span>
<span class="nc" id="L1557">			cargo.toXML(xw);</span>
<span class="nc" id="L1558">		}</span>
<span class="nc" id="L1559">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L1566">		super.readAttributes(xr);</span>

<span class="nc" id="L1568">		target = xr.getLocationAttribute(getGame(), TARGET_TAG, false);</span>
<span class="nc" id="L1569">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
		// Clear containers.
<span class="nc" id="L1577">		tClear();</span>

<span class="nc" id="L1579">		super.readChildren(xr);</span>
<span class="nc" id="L1580">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L1587">		final String tag = xr.getLocalName();</span>

<span class="nc bnc" id="L1589" title="All 2 branches missed.">		if (Cargo.getXMLElementTagName().equals(tag)) {</span>
<span class="nc" id="L1590">			tAdd(new Cargo(getAIMain(), xr), -1);</span>

			// @compat 0.10.5
<span class="nc bnc" id="L1593" title="All 2 branches missed.">		} else if (OLD_TRANSPORTABLE_TAG.equals(tag)) {</span>
			// Ignore the old format, let checkCargoes sort it out
<span class="nc" id="L1595">			xr.closeTag(OLD_TRANSPORTABLE_TAG);</span>
			// end @compat

		} else {
<span class="nc" id="L1599">			super.readChild(xr);</span>
		}
<span class="nc" id="L1601">	}</span>

	/**
	 * More verbose version of toString().
	 *
	 * @return A summary of this mission including its transportables.
	 */
	public String toFullString() {
<span class="nc" id="L1609">		LogBuilder lb = new LogBuilder(64);</span>
<span class="nc" id="L1610">		lb.add(this);</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">		for (Cargo cargo : tCopy())</span>
<span class="nc" id="L1612">			lb.add(&quot;\n  -&gt;&quot;, cargo);</span>
<span class="nc" id="L1613">		return lb.toString();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getXMLTagName() {
<span class="nc" id="L1621">		return getXMLElementTagName();</span>
	}

	/**
	 * Gets the tag name of the root element representing this object.
	 *
	 * @return &quot;transportMission&quot;.
	 */
	public static String getXMLElementTagName() {
<span class="nc" id="L1630">		return &quot;transportMission&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>