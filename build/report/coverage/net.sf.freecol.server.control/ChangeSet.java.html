<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChangeSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacocoReport</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.control</a> &gt; <span class="el_source">ChangeSet.java</span></div><h1>ChangeSet.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.control;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.Feature;
import net.sf.freecol.common.model.FoundingFather;
import net.sf.freecol.common.model.FreeColGameObject;
import net.sf.freecol.common.model.FreeColObject;
import net.sf.freecol.common.model.Game;
import net.sf.freecol.common.model.GoodsType;
import net.sf.freecol.common.model.HistoryEvent;
import net.sf.freecol.common.model.LastSale;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.ModelMessage;
import net.sf.freecol.common.model.Modifier;
import net.sf.freecol.common.model.Ownable;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Stance;
import net.sf.freecol.common.model.Settlement;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.TradeRoute;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.WorkLocation;
import net.sf.freecol.common.networking.DOMMessage;
import net.sf.freecol.server.model.ServerPlayer;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;

/**
 * Changes to be sent to the client.
 */
public class ChangeSet {

	/** Compare changes by ascending priority. */
<span class="fc" id="L62">	private static final Comparator&lt;Change&gt; changeComparator = Comparator.comparingInt(Change::getPriority);</span>

	// Convenient way to specify the relative priorities of the fixed
	/**
	 * The Enum ChangePriority.
	 */
	// change types in one place.
<span class="pc" id="L69">	public static enum ChangePriority {</span>

		/** The change attribute. */
<span class="fc" id="L72">		CHANGE_ATTRIBUTE(-1),</span>
		/** The change animation. */
		// N/A
<span class="fc" id="L75">		CHANGE_ANIMATION(0),</span>
		/** The change remove. */
		// Do animations first
<span class="fc" id="L78">		CHANGE_REMOVE(100),</span>
		/** The change stance. */
		// Do removes last
<span class="fc" id="L81">		CHANGE_STANCE(5),</span>
		/** The change owned. */
		// Do stance before updates
<span class="fc" id="L84">		CHANGE_OWNED(20),</span>
		/** The change update. */
		// Do owned changes after updates
<span class="fc" id="L87">		CHANGE_UPDATE(10), // There are a lot of updates</span>
		/** The change early. */
		// Symbolic priorities used by various non-fixed types
<span class="fc" id="L90">		CHANGE_EARLY(1),</span>

		/** The change normal. */
<span class="fc" id="L93">		CHANGE_NORMAL(15),</span>

		/** The change late. */
<span class="fc" id="L96">		CHANGE_LATE(90);</span>

		/** The level. */
		private final int level;

		/**
		 * Instantiates a new change priority.
		 *
		 * @param level
		 *            the level
		 */
<span class="fc" id="L107">		ChangePriority(int level) {</span>
<span class="fc" id="L108">			this.level = level;</span>
<span class="fc" id="L109">		}</span>

		/**
		 * Gets the priority.
		 *
		 * @return the priority
		 */
		public int getPriority() {
<span class="fc" id="L117">			return level;</span>
		}
	}

	/** The changes. */
	private final ArrayList&lt;Change&gt; changes;

	/**
	 * Class to control the visibility of a change.
	 */
	public static class See {

		/** The Constant ALL. */
		private static final int ALL = 1;

		/** The Constant PERHAPS. */
		private static final int PERHAPS = 0;

		/** The Constant ONLY. */
		private static final int ONLY = -1;

		/** The see always. */
		private ServerPlayer seeAlways;

		/** The see perhaps. */
		private ServerPlayer seePerhaps;

		/** The see never. */
		private ServerPlayer seeNever;

		/** The type. */
		private final int type;

		/**
		 * Instantiates a new see.
		 *
		 * @param type
		 *            the type
		 */
<span class="fc" id="L156">		private See(int type) {</span>
<span class="fc" id="L157">			this.seeAlways = this.seePerhaps = this.seeNever = null;</span>
<span class="fc" id="L158">			this.type = type;</span>
<span class="fc" id="L159">		}</span>

		/**
		 * Check this visibility with respect to a player.
		 *
		 * @param player
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
		 * @param perhapsResult
		 *            The result if the visibility is ambiguous.
		 * @return True if the player satisfies the visibility test.
		 */
		public boolean check(ServerPlayer player, boolean perhapsResult) {
<span class="pc bpc" id="L171" title="1 of 10 branches missed.">			return (seeNever == player) ? false</span>
					: (seeAlways == player) ? true
							: (seePerhaps == player) ? perhapsResult
									: (type == ONLY) ? false : (type == ALL) ? true : perhapsResult;
		}

		// Use these public constructor-like functions to define the
		// visibility of changes.

		/**
		 * Make this change visible to all players.
		 *
		 * @return a &lt;code&gt;See&lt;/code&gt; value
		 */
		public static See all() {
<span class="fc" id="L186">			return new See(ALL);</span>
		}

		/**
		 * Make this change visible to all players, provided they can see the
		 * objects that are being changed.
		 *
		 * @return a &lt;code&gt;See&lt;/code&gt; value
		 */
		public static See perhaps() {
<span class="fc" id="L196">			return new See(PERHAPS);</span>
		}

		/**
		 * Make this change visible only to the given player.
		 *
		 * @param player
		 *            a &lt;code&gt;ServerPlayer&lt;/code&gt; value
		 * @return a &lt;code&gt;See&lt;/code&gt; value
		 */
		public static See only(ServerPlayer player) {
<span class="fc" id="L207">			return new See(ONLY).always(player);</span>
		}

		// Use these to modify a See visibility.

		/**
		 * Make this change visible to the given player.
		 *
		 * @param player
		 *            a &lt;code&gt;ServerPlayer&lt;/code&gt; value
		 * @return a &lt;code&gt;See&lt;/code&gt; value
		 */
		public See always(ServerPlayer player) {
<span class="fc" id="L220">			seeAlways = player;</span>
<span class="fc" id="L221">			return this;</span>
		}

		/**
		 * Make this change visible to the given player, provided the player can
		 * see the objects being changed.
		 *
		 * @param player
		 *            a &lt;code&gt;ServerPlayer&lt;/code&gt; value
		 * @return a &lt;code&gt;See&lt;/code&gt; value
		 */
		public See perhaps(ServerPlayer player) {
<span class="nc" id="L233">			seePerhaps = player;</span>
<span class="nc" id="L234">			return this;</span>
		}

		/**
		 * Make this change invisible to the given player.
		 *
		 * @param player
		 *            a &lt;code&gt;ServerPlayer&lt;/code&gt; value
		 * @return a &lt;code&gt;See&lt;/code&gt; value
		 */
		public See except(ServerPlayer player) {
<span class="fc" id="L245">			seeNever = player;</span>
<span class="fc" id="L246">			return this;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L254">			StringBuilder sb = new StringBuilder(64);</span>
<span class="nc bnc" id="L255" title="All 6 branches missed.">			sb.append((type == ALL) ? &quot;ALL&quot; : (type == PERHAPS) ? &quot;PERHAPS&quot; : (type == ONLY) ? &quot;ONLY&quot; : &quot;BADTYPE&quot;);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (seeAlways != null) {</span>
<span class="nc" id="L257">				sb.append(&quot;,always(&quot;).append(seeAlways.getId()).append(&quot;)&quot;);</span>
			}
<span class="nc bnc" id="L259" title="All 2 branches missed.">			if (seePerhaps != null) {</span>
<span class="nc" id="L260">				sb.append(&quot;,perhaps(&quot;).append(seePerhaps.getId()).append(&quot;)&quot;);</span>
			}
<span class="nc bnc" id="L262" title="All 2 branches missed.">			if (seeNever != null) {</span>
<span class="nc" id="L263">				sb.append(&quot;,never(&quot;).append(seeNever.getId()).append(&quot;)&quot;);</span>
			}
<span class="nc" id="L265">			return sb.toString();</span>
		}
	}

	/**
	 * Abstract template for all types of Change.
	 */
	private abstract static class Change {

		/**
		 * The visibility of the change.
		 */
		protected final See see;

		/**
		 * Make a new Change.
		 *
		 * @param see
		 *            the see
		 */
<span class="fc" id="L285">		public Change(See see) {</span>
<span class="fc" id="L286">			this.see = see;</span>
<span class="fc" id="L287">		}</span>

		/**
		 * Does this Change operate on the given object?.
		 *
		 * @param fcgo
		 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; to check.
		 * @return True if the object is a subject of this change.
		 */
		public boolean matches(FreeColGameObject fcgo) {
<span class="fc" id="L297">			return false;</span>
		}

		/**
		 * Gets the sort priority of a change, to be used by the
		 * changeComparator.
		 *
		 * @return the priority
		 */
		public abstract int getPriority();

		/**
		 * Should a player be notified of this Change?.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
		 * @return True if this &lt;code&gt;Change&lt;/code&gt; should be sent.
		 */
		public boolean isNotifiable(ServerPlayer serverPlayer) {
<span class="fc" id="L316">			return see.check(serverPlayer, isPerhapsNotifiable(serverPlayer));</span>
		}

		/**
		 * Should a player be notified of a Change for which the visibility is
		 * delegated to the change type, allowing special change-specific
		 * overrides.
		 *
		 * This is false by default, subclasses should override when special
		 * case handling is required.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
		 * @return False.
		 */
		public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="fc" id="L332">			return false;</span>
		}

		/**
		 * Are the secondary changes consequent to this Change?.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
		 * @return A list of secondary &lt;code&gt;Change&lt;/code&gt;s or the empty list if
		 *         there are none, which is usually the case.
		 */
		public List&lt;Change&gt; consequences(ServerPlayer serverPlayer) {
<span class="fc" id="L344">			return Collections.&lt;Change&gt;emptyList();</span>
		}

		/**
		 * Can this Change be directly converted to an Element?.
		 *
		 * @return True if this change can be directly converted to an Element.
		 */
		public boolean convertsToElement() {
<span class="fc" id="L353">			return true;</span>
		}

		/**
		 * Specialize a Change for a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt; to build the element in.
		 * @return An &lt;code&gt;Element&lt;/code&gt; encapsulating this change.
		 */
		public abstract Element toElement(ServerPlayer serverPlayer, Document doc);

		/**
		 * Some changes can not be directly specialized, but need to be directly
		 * attached to an element.
		 *
		 * @param element
		 *            The &lt;code&gt;Element&lt;/code&gt; to attach to.
		 */
		public abstract void attachToElement(Element element);
	}

	/**
	 * Encapsulate an attack.
	 */
	private static class AttackChange extends Change {

		/** The attacker. */
		private final Unit attacker;

		/** The defender. */
		private final Unit defender;

		/** The success. */
		private final boolean success;

		/** The defender in settlement. */
		private final boolean defenderInSettlement;

		/**
		 * Build a new AttackChange.
		 *
		 * Note that we must copy attackers and defenders because a successful
		 * attacker can move, any an unsuccessful participant can die, and
		 * unsuccessful defenders can be captured. Furthermore for defenders,
		 * insufficient information is serialized when a unit is inside a
		 * settlement, but if unscoped too much is disclosed. So we make a copy
		 * and neuter it.
		 *
		 * We have to remember if the defender was in a settlement because by
		 * the time serialization occurs the settlement might have been
		 * destroyed.
		 *
		 * We just have to accept that combat animation is an exception to the
		 * normal visibility rules.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param attacker
		 *            The &lt;code&gt;Unit&lt;/code&gt; that is attacking.
		 * @param defender
		 *            The &lt;code&gt;Unit&lt;/code&gt; that is defending.
		 * @param success
		 *            Did the attack succeed.
		 */
		public AttackChange(See see, Unit attacker, Unit defender, boolean success) {
<span class="fc" id="L421">			super(see);</span>
<span class="fc" id="L422">			Game game = attacker.getGame();</span>
<span class="fc" id="L423">			this.defenderInSettlement = defender.getTile().hasSettlement();</span>
<span class="fc" id="L424">			this.attacker = attacker.copy(game, Unit.class);</span>
<span class="fc" id="L425">			this.attacker.setLocationNoUpdate(this.attacker.getTile());</span>
<span class="fc" id="L426">			this.defender = defender.copy(game, Unit.class);</span>
<span class="fc" id="L427">			this.defender.setLocationNoUpdate(this.defender.getTile());</span>
<span class="fc" id="L428">			this.success = success;</span>
<span class="fc" id="L429">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_ANIMATION&quot;.
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L438">			return ChangePriority.CHANGE_ANIMATION.getPriority();</span>
		}

		/**
		 * Should a player perhaps be notified of this attack? Do not use
		 * canSeeUnit because that gives a false negative for units in
		 * settlements, which should be animated.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
		 * @return True if the player should be notified.
		 */
		@Override
		public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="fc bfc" id="L452" title="All 4 branches covered.">			return serverPlayer == attacker.getOwner() || serverPlayer == defender.getOwner()</span>
<span class="pc bpc" id="L453" title="3 of 4 branches missed.">					|| (serverPlayer.canSee(attacker.getTile()) &amp;&amp; serverPlayer.canSee(defender.getTile()));</span>
		}

		/**
		 * Specialize a AttackChange into an &quot;animateAttack&quot; element for a
		 * particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An &quot;animateAttack&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L468">			final Game game = serverPlayer.getGame();</span>
<span class="fc" id="L469">			Element element = doc.createElement(&quot;animateAttack&quot;);</span>
<span class="fc" id="L470">			element.setAttribute(&quot;attacker&quot;, attacker.getId());</span>
<span class="fc" id="L471">			element.setAttribute(&quot;defender&quot;, defender.getId());</span>
<span class="fc" id="L472">			element.setAttribute(&quot;attackerTile&quot;, attacker.getTile().getId());</span>
<span class="fc" id="L473">			element.setAttribute(&quot;defenderTile&quot;, defender.getTile().getId());</span>
<span class="fc" id="L474">			element.setAttribute(&quot;success&quot;, Boolean.toString(success));</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">			if (!canSeeUnit(serverPlayer, attacker)) {</span>
<span class="fc" id="L476">				element.appendChild(attacker.toXMLElement(doc));</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">				if (attacker.getLocation() instanceof Unit) {</span>
<span class="nc" id="L478">					Unit loc = (Unit) attacker.getLocation();</span>
<span class="nc" id="L479">					element.appendChild(loc.toXMLElement(doc, serverPlayer));</span>
				}
			}
<span class="fc bfc" id="L482" title="All 4 branches covered.">			if (!canSeeUnit(serverPlayer, defender) || this.defenderInSettlement) {</span>
<span class="fc" id="L483">				defender.setWorkType(null);</span>
<span class="fc" id="L484">				element.appendChild(defender.toXMLElement(doc));</span>
			}
<span class="fc" id="L486">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L494">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L501">			StringBuilder sb = new StringBuilder(64);</span>
<span class="nc" id="L502">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L503">					.append(&quot; &quot;).append(attacker.getId()).append(&quot;@&quot;).append(attacker.getTile().getId()).append(&quot; &quot;)</span>
<span class="nc" id="L504">					.append(success).append(&quot; &quot;).append(defender.getId()).append(&quot;@&quot;).append(defender.getTile().getId())</span>
<span class="nc" id="L505">					.append(&quot;]&quot;);</span>
<span class="nc" id="L506">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate an attribute change.
	 */
	private static class AttributeChange extends Change {

		/** The key. */
		private final String key;

		/** The value. */
		private final String value;

		/**
		 * Build a new AttributeChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param key
		 *            A key &lt;code&gt;String&lt;/code&gt;.
		 * @param value
		 *            The corresponding value as a &lt;code&gt;String&lt;/code&gt;.
		 */
		public AttributeChange(See see, String key, String value) {
<span class="fc" id="L532">			super(see);</span>
<span class="fc" id="L533">			this.key = key;</span>
<span class="fc" id="L534">			this.value = value;</span>
<span class="fc" id="L535">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_ATTRIBUTE&quot;, attributes are special.
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L544">			return ChangePriority.CHANGE_ATTRIBUTE.getPriority();</span>
		}

		/**
		 * AttributeChanges are tacked onto the final Element, not converted
		 * directly.
		 *
		 * @return false.
		 */
		@Override
		public boolean convertsToElement() {
<span class="fc" id="L555">			return false;</span>
		}

		/**
		 * We do not specialize AttributeChanges.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return Null.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L569">			return null;</span>
		}

		/**
		 * Tack attributes onto the element.
		 *
		 * @param element
		 *            The &lt;code&gt;Element&lt;/code&gt; to attach to.
		 */
		@Override
		public void attachToElement(Element element) {
<span class="fc" id="L580">			element.setAttribute(key, value);</span>
<span class="fc" id="L581">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L588">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L589">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L590">					.append(&quot; &quot;).append(key).append(&quot;=&quot;).append(value).append(&quot;]&quot;);</span>
<span class="nc" id="L591">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a Message.
	 */
	private static class MessageChange extends Change {

		/** The priority. */
		private final ChangePriority priority;

		/** The message. */
		private final DOMMessage message;

		/**
		 * Build a new MessageChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param priority
		 *            The priority of the change.
		 * @param message
		 *            The &lt;code&gt;Message&lt;/code&gt; to add.
		 */
		public MessageChange(See see, ChangePriority priority, DOMMessage message) {
<span class="fc" id="L617">			super(see);</span>
<span class="fc" id="L618">			this.priority = priority;</span>
<span class="fc" id="L619">			this.message = message;</span>
<span class="fc" id="L620">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return The priority.
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L629">			return priority.getPriority();</span>
		}

		/**
		 * Specialize a MessageChange to a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L643">			Element element = message.toXMLElement();</span>
<span class="fc" id="L644">			return (Element) doc.importNode(element, true);</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L652">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L659">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L660">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L661">					.append(&quot; &quot;).append(message).append(&quot;]&quot;);</span>
<span class="nc" id="L662">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a move.
	 */
	private static class MoveChange extends Change {

		/** The unit. */
		private final Unit unit;

		/** The old location. */
		private final Location oldLocation;

		/** The new tile. */
		private final Tile newTile;

		/**
		 * See old.
		 *
		 * @param serverPlayer
		 *            the server player
		 * @return true, if successful
		 */
		private boolean seeOld(ServerPlayer serverPlayer) {
<span class="fc" id="L688">			Tile oldTile = oldLocation.getTile();</span>
<span class="pc bpc" id="L689" title="1 of 6 branches missed.">			return serverPlayer.owns(unit) || (oldTile != null &amp;&amp; serverPlayer.canSee(oldTile)</span>
<span class="pc bpc" id="L690" title="1 of 4 branches missed.">					&amp;&amp; !oldTile.hasSettlement() &amp;&amp; !(oldLocation instanceof Unit));</span>
		}

		/**
		 * See new.
		 *
		 * @param serverPlayer
		 *            the server player
		 * @return true, if successful
		 */
		private boolean seeNew(ServerPlayer serverPlayer) {
<span class="fc" id="L701">			return canSeeUnit(serverPlayer, unit);</span>
		}

		/**
		 * Build a new MoveChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param unit
		 *            The &lt;code&gt;Unit&lt;/code&gt; that is moving.
		 * @param oldLocation
		 *            The location from which the unit is moving.
		 * @param newTile
		 *            The &lt;code&gt;Tile&lt;/code&gt; to which the unit is moving.
		 */
		public MoveChange(See see, Unit unit, Location oldLocation, Tile newTile) {
<span class="fc" id="L717">			super(see);</span>
<span class="fc" id="L718">			this.unit = unit;</span>
<span class="fc" id="L719">			this.oldLocation = oldLocation;</span>
<span class="fc" id="L720">			this.newTile = newTile;</span>
<span class="fc" id="L721">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_ANIMATION&quot;
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L730">			return ChangePriority.CHANGE_ANIMATION.getPriority();</span>
		}

		/**
		 * Should a player perhaps be notified of this move?.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
		 * @return True if the player should be notified.
		 */
		@Override
		public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="fc bfc" id="L742" title="All 4 branches covered.">			return seeOld(serverPlayer) || seeNew(serverPlayer);</span>
		}

		/**
		 * There are consequences to a move. If the player can not see the unit
		 * after the move, it should be removed.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
		 * @return A RemoveChange if the unit disappears (but not if it is
		 *         destroyed, that is handled elsewhere).
		 */
		@Override
		public List&lt;Change&gt; consequences(ServerPlayer serverPlayer) {
<span class="pc bpc" id="L756" title="3 of 6 branches missed.">			if (seeOld(serverPlayer) &amp;&amp; !seeNew(serverPlayer) &amp;&amp; !unit.isDisposed()) {</span>
<span class="nc" id="L757">				List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L758">				units.add(unit);</span>
<span class="nc" id="L759">				List&lt;Change&gt; changes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L760">				changes.add(new RemoveChange(See.only(serverPlayer), unit.getLocation(), units));</span>
<span class="nc" id="L761">				return changes;</span>
			}
<span class="fc" id="L763">			return Collections.&lt;Change&gt;emptyList();</span>
		}

		/**
		 * Specialize a MoveChange into an &quot;animateMove&quot; element for a
		 * particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An &quot;animateMove&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L778">			Element element = doc.createElement(&quot;animateMove&quot;);</span>
<span class="fc" id="L779">			element.setAttribute(&quot;unit&quot;, unit.getId());</span>
<span class="fc" id="L780">			element.setAttribute(&quot;oldTile&quot;, oldLocation.getTile().getId());</span>
<span class="fc" id="L781">			element.setAttribute(&quot;newTile&quot;, newTile.getId());</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">			if (!seeOld(serverPlayer)) {</span>
				// We can not rely on the unit that is about to move
				// being present on the client side, and it is needed
				// before we can run the animation, so it is attached
				// to animateMove.
<span class="fc" id="L787">				element.appendChild(unit.toXMLElement(doc, serverPlayer));</span>
			}
<span class="fc" id="L789">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L797">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L804">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L805">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L806">					.append(&quot; &quot;).append(unit.getId()).append(&quot; &quot;).append(oldLocation.getId()).append(&quot; &quot;)</span>
<span class="nc" id="L807">					.append(newTile.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L808">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a FreeColGameObject update.
	 */
	private static class ObjectChange extends Change {

		/** The fcgo. */
		protected final FreeColGameObject fcgo;

		/**
		 * Build a new ObjectChange for a single object.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param fcgo
		 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
		 */
		public ObjectChange(See see, FreeColGameObject fcgo) {
<span class="fc" id="L829">			super(see);</span>
<span class="fc" id="L830">			this.fcgo = fcgo;</span>
<span class="fc" id="L831">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean matches(FreeColGameObject fcgo) {
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">			return this.fcgo == fcgo;</span>
		}

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_UPDATE&quot;
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L848">			return ChangePriority.CHANGE_UPDATE.getPriority();</span>
		}

		/**
		 * Should a player perhaps be notified of this update?.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
		 * @return True if the object update can is notifiable.
		 */
		@Override
		public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="fc bfc" id="L860" title="All 2 branches covered.">			if (fcgo instanceof Unit) {</span>
				// Units have a precise test, use that rather than
				// the more general interface-based tests.
<span class="fc" id="L863">				return canSeeUnit(serverPlayer, (Unit) fcgo);</span>
			}
			// If we own it, we can see it.
<span class="fc bfc" id="L866" title="All 4 branches covered.">			if (fcgo instanceof Ownable &amp;&amp; serverPlayer.owns((Ownable) fcgo)) {</span>
<span class="fc" id="L867">				return true;</span>
			}
			// We do not own it, so the only way we could see it is if
			// it is on the map. Would like to use getTile() to
			// decide that, but this will include ColonyTiles, which
			// report the colony center tile, yet should never be visible.
			// So just brutally disallow WorkLocations which should always
			// be invisible inside colonies.
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">			if (fcgo instanceof WorkLocation) {</span>
<span class="nc" id="L876">				return false;</span>
			}
<span class="fc bfc" id="L878" title="All 2 branches covered.">			if (fcgo instanceof Location) {</span>
<span class="fc" id="L879">				Tile tile = ((Location) fcgo).getTile();</span>
<span class="fc" id="L880">				return serverPlayer.canSee(tile);</span>
			}
<span class="fc" id="L882">			return false;</span>
		}

		/**
		 * Specialize a ObjectChange to a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An &quot;update&quot; element, or null if the update should not be
		 *         visible to the player.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L897">			Element element = doc.createElement(&quot;update&quot;);</span>
<span class="fc" id="L898">			element.appendChild(fcgo.toXMLElement(doc, serverPlayer));</span>
<span class="fc" id="L899">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L907">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L914">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L915">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L916">					.append(&quot; &quot;).append(fcgo.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L917">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a partial update of a FreeColGameObject.
	 */
	private static class PartialObjectChange extends ObjectChange {

		/** The fields. */
		private final String[] fields;

		/**
		 * Build a new PartialObjectChange for a single object.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param fcgo
		 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
		 * @param fields
		 *            The fields to update.
		 */
		public PartialObjectChange(See see, FreeColGameObject fcgo, String... fields) {
<span class="fc" id="L940">			super(see, fcgo);</span>
<span class="fc" id="L941">			this.fields = fields;</span>
<span class="fc" id="L942">		}</span>

		/**
		 * Should a player perhaps be notified of this update?.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
		 * @return False. Revert to default from ObjectChange special case.
		 */
		@Override
		public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="fc" id="L953">			return false;</span>
		}

		/**
		 * Specialize a PartialObjectChange to a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An &quot;update&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L967">			Element element = doc.createElement(&quot;update&quot;);</span>
<span class="fc" id="L968">			element.appendChild(fcgo.toXMLElementPartial(doc, fields));</span>
<span class="fc" id="L969">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L977">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L978">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L979">					.append(&quot; &quot;).append(fcgo.getId());</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">			for (String f : fields)</span>
<span class="nc" id="L981">				sb.append(&quot; &quot;).append(f);</span>
<span class="nc" id="L982">			sb.append(&quot;]&quot;);</span>
<span class="nc" id="L983">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a new player change.
	 */
	private static class PlayerChange extends Change {

		/** The player. */
		private final ServerPlayer player;

		/**
		 * Build a new PlayerChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param player
		 *            The &lt;code&gt;Player&lt;/code&gt; to add.
		 */
		public PlayerChange(See see, ServerPlayer player) {
<span class="fc" id="L1004">			super(see);</span>
<span class="fc" id="L1005">			this.player = player;</span>
<span class="fc" id="L1006">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_EARLY&quot;.
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L1015">			return ChangePriority.CHANGE_EARLY.getPriority();</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public boolean isNotifiable(ServerPlayer serverPlayer) {
<span class="fc" id="L1023">			return true;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L1031">			final Game game = serverPlayer.getGame();</span>
<span class="fc" id="L1032">			Element element = doc.createElement(&quot;addPlayer&quot;);</span>
<span class="fc" id="L1033">			element.appendChild(this.player.toXMLElement(doc, serverPlayer));</span>
<span class="fc" id="L1034">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1042">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1049">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1050">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1051">					.append(&quot; &quot;).append(player.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L1052">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulates removing some objects.
	 *
	 * -vis: If removing settlements or units, visibility changes.
	 */
	private static class RemoveChange extends Change {

		/** The tile. */
		private final Tile tile;

		/** The fcgo. */
		private final FreeColGameObject fcgo;

		/** The contents. */
		private final List&lt;? extends FreeColGameObject&gt; contents;

		/**
		 * Build a new RemoveChange for an object that is disposed.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param loc
		 *            The &lt;code&gt;Location&lt;/code&gt; where the object was.
		 * @param objects
		 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt;s to remove.
		 */
		public RemoveChange(See see, Location loc, List&lt;? extends FreeColGameObject&gt; objects) {
<span class="fc" id="L1083">			super(see);</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">			this.tile = (loc instanceof Tile) ? (Tile) loc : null;</span>
<span class="fc" id="L1085">			this.fcgo = objects.remove(objects.size() - 1);</span>
<span class="fc" id="L1086">			this.contents = objects;</span>
<span class="fc" id="L1087">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_REMOVE&quot;
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L1096">			return ChangePriority.CHANGE_REMOVE.getPriority();</span>
		}

		/**
		 * Should a player perhaps be notified of this removal? They should if
		 * they can see the tile, and there is no other-player settlement
		 * present.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
		 * @return True if the player should be notified.
		 */
		@Override
		public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
			Settlement settlement;
<span class="fc bfc" id="L1111" title="All 6 branches covered.">			return tile != null &amp;&amp; serverPlayer.canSee(tile) &amp;&amp; ((settlement = tile.getSettlement()) == null</span>
<span class="pc bpc" id="L1112" title="1 of 4 branches missed.">					|| settlement.isDisposed() || serverPlayer.owns(settlement));</span>
		}

		/**
		 * Specialize a RemoveChange to a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return A &quot;remove&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L1126">			Element element = doc.createElement(&quot;remove&quot;);</span>
			// The main object may be visible, but the contents are
			// only visible if the deeper ownership test succeeds.
<span class="pc bpc" id="L1129" title="1 of 4 branches missed.">			if (fcgo instanceof Ownable &amp;&amp; serverPlayer.owns((Ownable) fcgo)) {</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">				for (FreeColGameObject o : contents) {</span>
<span class="fc" id="L1131">					element.appendChild(o.toXMLElementPartial(doc));</span>
<span class="fc" id="L1132">				}</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">				element.setAttribute(&quot;divert&quot;, (tile != null) ? tile.getId() : serverPlayer.getId());</span>
			}
<span class="fc" id="L1135">			element.appendChild(fcgo.toXMLElementPartial(doc));</span>
<span class="fc" id="L1136">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1144">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1151">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1152">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">					.append(&quot; &quot;).append(((tile == null) ? &quot;&lt;null&gt;&quot; : tile.getId()));</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">			for (FreeColGameObject f : contents) {</span>
<span class="nc" id="L1155">				sb.append(&quot; &quot;).append(f.getId());</span>
<span class="nc" id="L1156">			}</span>
<span class="nc" id="L1157">			sb.append(&quot; &quot;).append(fcgo.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L1158">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate an owned object change.
	 */
	private static class OwnedChange extends Change {

		/** The fco. */
		private final FreeColObject fco;

		/**
		 * Build a new OwnedChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param fco
		 *            The &lt;code&gt;FreeColObject&lt;/code&gt; to update.
		 */
		public OwnedChange(See see, FreeColObject fco) {
<span class="fc" id="L1179">			super(see);</span>
<span class="fc" id="L1180">			this.fco = fco;</span>
<span class="fc" id="L1181">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_OWNER&quot;
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L1190">			return ChangePriority.CHANGE_OWNED.getPriority();</span>
		}

		/**
		 * Specialize a OwnedChange into an &quot;addObject&quot; element for a particular
		 * player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An &quot;addObject&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L1205">			Element element = doc.createElement(&quot;addObject&quot;);</span>
<span class="fc" id="L1206">			Element child = fco.toXMLElement(doc, serverPlayer);</span>
<span class="fc" id="L1207">			child.setAttribute(&quot;owner&quot;, serverPlayer.getId());</span>
<span class="fc" id="L1208">			element.appendChild(child);</span>
<span class="fc" id="L1209">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1217">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1224">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1225">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1226">					.append(&quot; &quot;).append(fco.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L1227">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a feature change.
	 */
	private static class FeatureChange extends Change {

		/** The object. */
		private final FreeColGameObject object;

		/** The feature. */
		private final Feature feature;

		/** The add. */
		private final boolean add;

		/**
		 * Build a new FeatureChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param object
		 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
		 * @param feature
		 *            a &lt;code&gt;Feature&lt;/code&gt; value to add or remove.
		 * @param add
		 *            a &lt;code&gt;boolean&lt;/code&gt; value
		 */
		public FeatureChange(See see, FreeColGameObject object, Feature feature, boolean add) {
<span class="nc" id="L1258">			super(see);</span>
<span class="nc" id="L1259">			this.object = object;</span>
<span class="nc" id="L1260">			this.feature = feature;</span>
<span class="nc" id="L1261">			this.add = add;</span>
<span class="nc" id="L1262">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_OWNER&quot;
		 */
		@Override
		public int getPriority() {
<span class="nc" id="L1271">			return ChangePriority.CHANGE_OWNED.getPriority();</span>
		}

		/**
		 * Specialize a feature change into an element for a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An &quot;addObject&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1285">			Element element = doc.createElement(&quot;featureChange&quot;);</span>
<span class="nc" id="L1286">			element.setAttribute(&quot;add&quot;, Boolean.toString(add));</span>
<span class="nc" id="L1287">			element.setAttribute(FreeColObject.ID_ATTRIBUTE_TAG, object.getId());</span>
<span class="nc" id="L1288">			Element child = feature.toXMLElement(doc);</span>
<span class="nc" id="L1289">			element.appendChild(child);</span>
<span class="nc" id="L1290">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1298">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1305">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1306">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc bnc" id="L1307" title="All 4 branches missed.">					.append(&quot; &quot;).append((add) ? &quot;add&quot; : &quot;remove&quot;).append(&quot; &quot;).append(feature).append(&quot; &quot;)</span>
<span class="nc" id="L1308">					.append((add) ? &quot;to&quot; : &quot;from&quot;).append(&quot; &quot;).append(object.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L1309">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulates a spying action.
	 */
	private static class SpyChange extends Change {

		/** The tile. */
		private final Tile tile;

		/**
		 * Build a new SpyChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param settlement
		 *            The &lt;code&gt;Settlement&lt;/code&gt; to spy on.
		 */
		public SpyChange(See see, Settlement settlement) {
<span class="nc" id="L1330">			super(see);</span>
<span class="nc" id="L1331">			tile = settlement.getTile();</span>
<span class="nc" id="L1332">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return priority.
		 */
		@Override
		public int getPriority() {
<span class="nc" id="L1341">			return ChangePriority.CHANGE_NORMAL.getPriority();</span>
		}

		/**
		 * Specialize a SpyChange into an element with the supplied name.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1355">			Element element = doc.createElement(&quot;spyResult&quot;);</span>
<span class="nc" id="L1356">			element.setAttribute(&quot;tile&quot;, tile.getId());</span>
			// Have to tack on two copies of the settlement tile.
			// One full version, one ordinary version to restore.
<span class="nc" id="L1359">			element.appendChild(tile.toXMLElement(doc));</span>
<span class="nc" id="L1360">			element.appendChild(tile.getCachedTile(serverPlayer).toXMLElement(doc, serverPlayer));</span>
<span class="nc" id="L1361">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1369">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1376">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1377">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1378">					.append(&quot; &quot;).append(tile.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L1379">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate a stance change.
	 */
	private static class StanceChange extends Change {

		/** The first. */
		private final Player first;

		/** The stance. */
		private final Stance stance;

		/** The second. */
		private final Player second;

		/**
		 * Build a new StanceChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param first
		 *            The &lt;code&gt;Player&lt;/code&gt; changing stance.
		 * @param stance
		 *            The &lt;code&gt;Stance&lt;/code&gt; to change to.
		 * @param second
		 *            The &lt;code&gt;Player&lt;/code&gt; wrt with to change.
		 */
		public StanceChange(See see, Player first, Stance stance, Player second) {
<span class="fc" id="L1410">			super(see);</span>
<span class="fc" id="L1411">			this.first = first;</span>
<span class="fc" id="L1412">			this.stance = stance;</span>
<span class="fc" id="L1413">			this.second = second;</span>
<span class="fc" id="L1414">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return &quot;CHANGE_STANCE&quot;
		 */
		@Override
		public int getPriority() {
<span class="fc" id="L1423">			return ChangePriority.CHANGE_STANCE.getPriority();</span>
		}

		/**
		 * Specialize a StanceChange to a particular player.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return A &quot;setStance&quot; element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="fc" id="L1437">			Element element = doc.createElement(&quot;setStance&quot;);</span>
<span class="fc" id="L1438">			element.setAttribute(&quot;stance&quot;, stance.toString());</span>
<span class="fc" id="L1439">			element.setAttribute(&quot;first&quot;, first.getId());</span>
<span class="fc" id="L1440">			element.setAttribute(&quot;second&quot;, second.getId());</span>
<span class="fc" id="L1441">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1449">		} // Noop</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1456">			StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1457">			sb.append(&quot;[&quot;).append(getClass().getName()).append(&quot; &quot;).append(see).append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1458">					.append(&quot; &quot;).append(first.getId()).append(&quot; &quot;).append(stance).append(&quot; &quot;).append(second.getId())</span>
<span class="nc" id="L1459">					.append(&quot;]&quot;);</span>
<span class="nc" id="L1460">			return sb.toString();</span>
		}
	}

	/**
	 * Encapsulate trivial element, which will only have attributes apart from
	 * its name.
	 */
	private static class TrivialChange extends Change {

		/** The priority. */
		private final int priority;

		/** The name. */
		private final String name;

		/** The attributes. */
		private final String[] attributes;

		/**
		 * Build a new TrivialChange.
		 *
		 * @param see
		 *            The visibility of this change.
		 * @param name
		 *            The name of the element.
		 * @param priority
		 *            The sort priority of this change.
		 * @param attributes
		 *            the attributes
		 */
		public TrivialChange(See see, String name, int priority, String[] attributes) {
<span class="nc" id="L1492">			super(see);</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">			if ((attributes.length &amp; 1) == 1) {</span>
<span class="nc" id="L1494">				throw new IllegalArgumentException(&quot;Attributes must be even sized&quot;);</span>
			}
<span class="nc" id="L1496">			this.name = name;</span>
<span class="nc" id="L1497">			this.priority = priority;</span>
<span class="nc" id="L1498">			this.attributes = attributes;</span>
<span class="nc" id="L1499">		}</span>

		/**
		 * Gets the sort priority.
		 *
		 * @return priority.
		 */
		@Override
		public int getPriority() {
<span class="nc" id="L1508">			return priority;</span>
		}

		/**
		 * Specialize a TrivialChange into an element with the supplied name.
		 *
		 * @param serverPlayer
		 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
		 * @param doc
		 *            The owner &lt;code&gt;Document&lt;/code&gt;.
		 * @return An element.
		 */
		@Override
		public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1522">			Element element = doc.createElement(name);</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">			for (int i = 0; i &lt; attributes.length; i += 2) {</span>
<span class="nc" id="L1524">				element.setAttribute(attributes[i], attributes[i + 1]);</span>
			}
<span class="nc" id="L1526">			return element;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public void attachToElement(Element element) {
<span class="nc" id="L1534">		} // Noop</span>

		/**
		 * Debug helper.
		 *
		 * @return the string
		 */
		@Override
		public String toString() {
<span class="nc" id="L1543">			String ret = &quot;[&quot; + getClass().getName() + &quot; &quot; + see + &quot; #&quot; + getPriority() + &quot; &quot; + name;</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">			for (String a : attributes)</span>
<span class="nc" id="L1545">				ret += &quot; &quot; + a;</span>
<span class="nc" id="L1546">			return ret + &quot;]&quot;;</span>
		}
	}

	/**
	 * Simple constructor.
	 */
<span class="fc" id="L1553">	public ChangeSet() {</span>
<span class="fc" id="L1554">		changes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1555">	}</span>

	/**
	 * Copying constructor.
	 *
	 * @param other
	 *            The other &lt;code&gt;ChangeSet&lt;/code&gt; to copy.
	 */
<span class="nc" id="L1563">	public ChangeSet(ChangeSet other) {</span>
<span class="nc" id="L1564">		changes = new ArrayList&lt;&gt;(other.changes);</span>
<span class="nc" id="L1565">	}</span>

	// Helper routines that should be used to construct a change set.

	/**
	 * Sometimes we need to backtrack on making a change.
	 *
	 * @param fcgo
	 *            A &lt;code&gt;FreeColGameObject&lt;/code&gt; to remove a matching change
	 *            for.
	 */
	public void remove(FreeColGameObject fcgo) {
<span class="fc" id="L1577">		Iterator&lt;Change&gt; ci = changes.iterator();</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">		while (ci.hasNext()) {</span>
<span class="fc" id="L1579">			Change c = ci.next();</span>
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">			if (c.matches(fcgo))</span>
<span class="nc" id="L1581">				ci.remove();</span>
<span class="fc" id="L1582">		}</span>
<span class="fc" id="L1583">	}</span>

	/**
	 * Helper function to add updates for multiple objects to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param objects
	 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt;s that changed.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet add(See see, FreeColGameObject... objects) {
<span class="fc bfc" id="L1595" title="All 2 branches covered.">		for (FreeColGameObject o : objects) {</span>
<span class="fc" id="L1596">			changes.add(new ObjectChange(see, o));</span>
		}
<span class="fc" id="L1598">		return this;</span>
	}

	/**
	 * Helper function to add updates for multiple objects to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param objects
	 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt;s that changed.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet add(See see, Collection&lt;? extends FreeColGameObject&gt; objects) {
<span class="fc bfc" id="L1611" title="All 2 branches covered.">		for (FreeColGameObject o : objects) {</span>
<span class="fc" id="L1612">			changes.add(new ObjectChange(see, o));</span>
<span class="fc" id="L1613">		}</span>
<span class="fc" id="L1614">		return this;</span>
	}

	/**
	 * Helper function to add a Message to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param cp
	 *            The priority of this change.
	 * @param message
	 *            The &lt;code&gt;Message&lt;/code&gt; to add.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet add(See see, ChangePriority cp, DOMMessage message) {
<span class="fc" id="L1629">		changes.add(new MessageChange(see, cp, message));</span>
<span class="fc" id="L1630">		return this;</span>
	}

	/**
	 * Helper function to add an attack to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param attacker
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is attacking.
	 * @param defender
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is defending.
	 * @param success
	 *            Did the attack succeed?
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addAttack(See see, Unit attacker, Unit defender, boolean success) {
<span class="fc" id="L1647">		changes.add(new AttackChange(see, attacker, defender, success));</span>
<span class="fc" id="L1648">		return this;</span>
	}

	/**
	 * Helper function to add an attribute setting to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param key
	 *            A key &lt;code&gt;String&lt;/code&gt;.
	 * @param value
	 *            The corresponding value as a &lt;code&gt;String&lt;/code&gt;.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addAttribute(See see, String key, String value) {
<span class="fc" id="L1663">		changes.add(new AttributeChange(see, key, value));</span>
<span class="fc" id="L1664">		return this;</span>
	}

	/**
	 * Helper function to add a dead player event to a ChangeSet. Deaths are
	 * public knowledge.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; that died.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addDead(ServerPlayer serverPlayer) {
<span class="nc" id="L1676">		addTrivial(See.all(), &quot;setDead&quot;, ChangePriority.CHANGE_EARLY, &quot;player&quot;, serverPlayer.getId());</span>
<span class="nc" id="L1677">		return this;</span>
	}

	/**
	 * Helper function to add a removal for an object that disappears (that is,
	 * moves where it can not be seen) to a ChangeSet.
	 *
	 * @param owner
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; that owns this object.
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; where the object was.
	 * @param fcgo
	 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; that disappears.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addDisappear(ServerPlayer owner, Tile tile, FreeColGameObject fcgo) {
<span class="fc" id="L1693">		List&lt;FreeColGameObject&gt; objects = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1694">		objects.add(fcgo);</span>
<span class="fc" id="L1695">		changes.add(new RemoveChange(See.perhaps().except(owner), tile, objects));</span>
<span class="fc" id="L1696">		changes.add(new ObjectChange(See.perhaps().except(owner), tile));</span>
<span class="fc" id="L1697">		return this;</span>
	}

	/**
	 * Helper function to add a founding father addition event to a ChangeSet.
	 * Also adds the father to the owner.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; adding the father.
	 * @param father
	 *            The &lt;code&gt;FoundingFather&lt;/code&gt; to add.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addFather(ServerPlayer serverPlayer, FoundingFather father) {
<span class="fc" id="L1711">		changes.add(new OwnedChange(See.only(serverPlayer), father));</span>
<span class="fc" id="L1712">		serverPlayer.addFather(father);</span>
<span class="fc" id="L1713">		return this;</span>
	}

	/**
	 * Helper function to add an Ability to a FreeColGameObject, or remove it.
	 *
	 * @param serverPlayer
	 *            a &lt;code&gt;ServerPlayer&lt;/code&gt; value
	 * @param object
	 *            a &lt;code&gt;FreeColGameObject&lt;/code&gt; value
	 * @param ability
	 *            an &lt;code&gt;Ability&lt;/code&gt; value
	 * @param add
	 *            a &lt;code&gt;boolean&lt;/code&gt; value
	 * @return a &lt;code&gt;ChangeSet&lt;/code&gt; value
	 */
	public ChangeSet addFeatureChange(ServerPlayer serverPlayer, FreeColGameObject object, Ability ability,
			boolean add) {
<span class="nc" id="L1731">		changes.add(new FeatureChange(See.only(serverPlayer), object, ability, add));</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">		if (add) {</span>
<span class="nc" id="L1733">			object.addAbility(ability);</span>
		} else {
<span class="nc" id="L1735">			object.removeAbility(ability);</span>
		}
<span class="nc" id="L1737">		return this;</span>
	}

	/**
	 * Helper function to add a Modifier to a FreeColGameObject, or remove it.
	 *
	 * @param serverPlayer
	 *            a &lt;code&gt;ServerPlayer&lt;/code&gt; value
	 * @param object
	 *            a &lt;code&gt;FreeColGameObject&lt;/code&gt; value
	 * @param modifier
	 *            a &lt;code&gt;Modifier&lt;/code&gt; value
	 * @param add
	 *            a &lt;code&gt;boolean&lt;/code&gt; value
	 * @return a &lt;code&gt;ChangeSet&lt;/code&gt; value
	 */
	public ChangeSet addFeatureChange(ServerPlayer serverPlayer, FreeColGameObject object, Modifier modifier,
			boolean add) {
<span class="nc" id="L1755">		changes.add(new FeatureChange(See.only(serverPlayer), object, modifier, add));</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">		if (add) {</span>
<span class="nc" id="L1757">			object.addModifier(modifier);</span>
		} else {
<span class="nc" id="L1759">			object.removeModifier(modifier);</span>
		}
<span class="nc" id="L1761">		return this;</span>
	}

	/**
	 * Helper function to add a global history event to a ChangeSet. Also adds
	 * the history to all the European players.
	 *
	 * @param game
	 *            The &lt;code&gt;Game&lt;/code&gt; to find players in.
	 * @param history
	 *            The &lt;code&gt;HistoryEvent&lt;/code&gt; to add.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addGlobalHistory(Game game, HistoryEvent history) {
<span class="nc" id="L1775">		changes.add(new OwnedChange(See.all(), history));</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">		for (Player p : game.getLiveEuropeanPlayers(null)) {</span>
<span class="nc" id="L1777">			p.addHistory(history);</span>
<span class="nc" id="L1778">		}</span>
<span class="nc" id="L1779">		return this;</span>
	}

	/**
	 * Helper function to add a history event to a ChangeSet. Also adds the
	 * history to the owner.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; making history.
	 * @param history
	 *            The &lt;code&gt;HistoryEvent&lt;/code&gt; to add.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addHistory(ServerPlayer serverPlayer, HistoryEvent history) {
<span class="fc" id="L1793">		changes.add(new OwnedChange(See.only(serverPlayer), history));</span>
<span class="fc" id="L1794">		serverPlayer.addHistory(history);</span>
<span class="fc" id="L1795">		return this;</span>
	}

	/**
	 * Helper function to add a message to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param message
	 *            The &lt;code&gt;ModelMessage&lt;/code&gt; to add.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addMessage(See see, ModelMessage message) {
<span class="fc" id="L1808">		changes.add(new OwnedChange(see, message));</span>
<span class="fc" id="L1809">		return this;</span>
	}

	/**
	 * Helper function to add a move to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; that is moving.
	 * @param loc
	 *            The location from which the unit is moving.
	 * @param tile
	 *            The &lt;code&gt;Tile&lt;/code&gt; to which the unit is moving.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addMove(See see, Unit unit, Location loc, Tile tile) {
<span class="fc" id="L1826">		changes.add(new MoveChange(see, unit, loc, tile));</span>
<span class="fc" id="L1827">		return this;</span>
	}

	/**
	 * Helper function to add a partial update change for an object to a
	 * ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param fcgo
	 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
	 * @param fields
	 *            The fields to update.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addPartial(See see, FreeColGameObject fcgo, String... fields) {
<span class="fc" id="L1843">		changes.add(new PartialObjectChange(see, fcgo, fields));</span>
<span class="fc" id="L1844">		return this;</span>
	}

	/**
	 * Helper function to add a new player to a ChangeSet.
	 *
	 * @param serverPlayer
	 *            The new &lt;code&gt;ServerPlayer&lt;/code&gt; to add.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addPlayer(ServerPlayer serverPlayer) {
<span class="fc" id="L1855">		changes.add(new PlayerChange(See.all().except(serverPlayer), serverPlayer));</span>
<span class="fc" id="L1856">		return this;</span>
	}

	/**
	 * Helper function to add a removal to a ChangeSet.
	 *
	 * -vis: If disposing of units or colonies, this routine changes player
	 * visibility.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; where the object was.
	 * @param obj
	 *            The &lt;code&gt;FreeColGameObject&lt;/code&gt; to remove.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addRemove(See see, Location loc, FreeColGameObject obj) {
<span class="fc" id="L1874">		changes.add(new RemoveChange(see, loc, obj.getDisposeList()));// -vis</span>
<span class="fc" id="L1875">		return this;</span>
	}

	/**
	 * Helper function to add removals for several objects to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param loc
	 *            The &lt;code&gt;Location&lt;/code&gt; where the object was.
	 * @param objects
	 *            A list of &lt;code&gt;FreeColGameObject&lt;/code&gt;s to remove.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addRemoves(See see, Location loc, List&lt;? extends FreeColGameObject&gt; objects) {
<span class="fc bfc" id="L1890" title="All 2 branches covered.">		for (FreeColGameObject fcgo : objects) {</span>
<span class="fc" id="L1891">			changes.add(new RemoveChange(see, loc, fcgo.getDisposeList()));</span>
<span class="fc" id="L1892">		}</span>
<span class="fc" id="L1893">		return this;</span>
	}

	/**
	 * Helper function to add a sale change to a ChangeSet.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; making the sale.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; that is buying.
	 * @param type
	 *            The &lt;code&gt;GoodsType&lt;/code&gt; bought.
	 * @param price
	 *            The per unit price.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addSale(ServerPlayer serverPlayer, Settlement settlement, GoodsType type, int price) {
<span class="nc" id="L1910">		Game game = settlement.getGame();</span>
<span class="nc" id="L1911">		LastSale sale = new LastSale(settlement, type, game.getTurn(), price);</span>
<span class="nc" id="L1912">		changes.add(new OwnedChange(See.only(serverPlayer), sale));</span>
<span class="nc" id="L1913">		serverPlayer.addLastSale(sale);</span>
<span class="nc" id="L1914">		return this;</span>
	}

	/**
	 * Helper function to add a spying change to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param settlement
	 *            The &lt;code&gt;Settlement&lt;/code&gt; to spy on.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addSpy(See see, Settlement settlement) {
<span class="nc" id="L1927">		changes.add(new SpyChange(see, settlement));</span>
<span class="nc" id="L1928">		return this;</span>
	}

	/**
	 * Helper function to add a stance change to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param first
	 *            The &lt;code&gt;Player&lt;/code&gt; changing stance.
	 * @param stance
	 *            The &lt;code&gt;Stance&lt;/code&gt; to change to.
	 * @param second
	 *            The &lt;code&gt;Player&lt;/code&gt; wrt with to change.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addStance(See see, Player first, Stance stance, Player second) {
<span class="fc" id="L1945">		changes.add(new StanceChange(see, first, stance, second));</span>
<span class="fc" id="L1946">		return this;</span>
	}

	/**
	 * Helper function to add a new trade route change to a ChangeSet. Also adds
	 * the trade route to the player.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; adding the route.
	 * @param tradeRoute
	 *            The new &lt;code&gt;TradeRoute&lt;/code&gt;.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addTradeRoute(ServerPlayer serverPlayer, TradeRoute tradeRoute) {
<span class="nc" id="L1960">		changes.add(new OwnedChange(See.only(serverPlayer), tradeRoute));</span>
<span class="nc" id="L1961">		return this;</span>
	}

	/**
	 * Helper function to add a trivial element to a ChangeSet.
	 *
	 * @param see
	 *            The visibility of this change.
	 * @param name
	 *            The name of the element.
	 * @param cp
	 *            The &lt;code&gt;ChangePriority&lt;/code&gt; for this change.
	 * @param attributes
	 *            Attributes to add to this trivial change.
	 * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
	 */
	public ChangeSet addTrivial(See see, String name, ChangePriority cp, String... attributes) {
<span class="nc" id="L1978">		changes.add(new TrivialChange(see, name, cp.getPriority(), attributes));</span>
<span class="nc" id="L1979">		return this;</span>
	}

	// Conversion of a change set to a corresponding element.

	/**
	 * Checks if a player can see a unit.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; looking for the unit.
	 * @param unit
	 *            The &lt;code&gt;Unit&lt;/code&gt; to check.
	 * @return True if the &lt;code&gt;Unit&lt;/code&gt; is visible to the player.
	 */
	private static boolean canSeeUnit(ServerPlayer serverPlayer, Unit unit) {
		Tile tile;
<span class="fc bfc" id="L1995" title="All 2 branches covered.">		return (serverPlayer.owns(unit)) ? true</span>
<span class="fc bfc" id="L1996" title="All 2 branches covered.">				: ((tile = unit.getTile()) == null) ? false</span>
<span class="fc bfc" id="L1997" title="All 2 branches covered.">						: (!serverPlayer.canSee(tile)) ? false</span>
<span class="fc bfc" id="L1998" title="All 4 branches covered.">								: (tile.hasSettlement()) ? false : (unit.isOnCarrier()) ? false : true;</span>
	}

	/**
	 * Collapse one element into another.
	 *
	 * @param head
	 *            The &lt;code&gt;Element&lt;/code&gt; to collapse into.
	 * @param tail
	 *            The &lt;code&gt;Element&lt;/code&gt; to extract nodes from.
	 */
	private static void collapseElements(Element head, Element tail) {
<span class="fc bfc" id="L2010" title="All 2 branches covered.">		while (tail.hasChildNodes()) {</span>
<span class="fc" id="L2011">			head.appendChild(tail.removeChild(tail.getFirstChild()));</span>
		}
<span class="fc" id="L2013">	}</span>

	/**
	 * Can two elements be collapsed? They need to have the same name and
	 * attributes.
	 *
	 * @param e1
	 *            The first &lt;code&gt;Element&lt;/code&gt;.
	 * @param e2
	 *            The second &lt;code&gt;Element&lt;/code&gt;.
	 * @return True if they can be collapsed.
	 */
	private static boolean collapseOK(Element e1, Element e2) {
<span class="fc bfc" id="L2026" title="All 2 branches covered.">		if (!e1.getTagName().equals(e2.getTagName()))</span>
<span class="fc" id="L2027">			return false;</span>
<span class="fc" id="L2028">		NamedNodeMap nnm1 = e1.getAttributes();</span>
<span class="fc" id="L2029">		NamedNodeMap nnm2 = e2.getAttributes();</span>
<span class="pc bpc" id="L2030" title="1 of 2 branches missed.">		if (nnm1.getLength() != nnm2.getLength())</span>
<span class="nc" id="L2031">			return false;</span>
<span class="pc bfc" id="L2032" title="All 2 branches covered.">		for (int i = 0; i &lt; nnm1.getLength(); i++) {</span>
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">			if (nnm1.item(i).getNodeType() != nnm2.item(i).getNodeType()) {</span>
<span class="nc" id="L2034">				return false;</span>
			}
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">			if (!nnm1.item(i).getNodeName().equals(nnm2.item(i).getNodeName())) {</span>
<span class="nc" id="L2037">				return false;</span>
			}
<span class="pc bpc" id="L2039" title="1 of 2 branches missed.">			if (!nnm1.item(i).getNodeValue().equals(nnm2.item(i).getNodeValue())) {</span>
<span class="fc" id="L2040">				return false;</span>
			}
		}
<span class="fc" id="L2043">		return true;</span>
	}

	/**
	 * Collapse adjacent elements in a list with the same tag.
	 *
	 * @param elements
	 *            The list of &lt;code&gt;Element&lt;/code&gt;s to consider.
	 * @return A collapsed list of elements.
	 */
	private static List&lt;Element&gt; collapseElementList(List&lt;Element&gt; elements) {
<span class="fc" id="L2054">		List&lt;Element&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2055" title="All 2 branches covered.">		if (!elements.isEmpty()) {</span>
<span class="fc" id="L2056">			Element head = elements.remove(0);</span>
<span class="fc bfc" id="L2057" title="All 2 branches covered.">			while (!elements.isEmpty()) {</span>
<span class="fc" id="L2058">				Element e = elements.remove(0);</span>
<span class="fc bfc" id="L2059" title="All 2 branches covered.">				if (collapseOK(head, e)) {</span>
<span class="fc" id="L2060">					collapseElements(head, e);</span>
				} else {
<span class="fc" id="L2062">					results.add(head);</span>
<span class="fc" id="L2063">					head = e;</span>
				}
<span class="fc" id="L2065">			}</span>
<span class="fc" id="L2066">			results.add(head);</span>
		}
<span class="fc" id="L2068">		return results;</span>
	}

	/**
	 * Build a generalized update. Beware that removing an object does not
	 * necessarily update its tile correctly on the client side--- if a tile
	 * update is needed the tile should be supplied in the objects list.
	 *
	 * @param serverPlayer
	 *            The &lt;code&gt;ServerPlayer&lt;/code&gt; to send the update to.
	 * @return An element encapsulating an update of the objects to consider, or
	 *         null if there is nothing to report.
	 */
	public Element build(ServerPlayer serverPlayer) {
<span class="fc" id="L2082">		List&lt;Change&gt; c = new ArrayList&lt;&gt;(changes);</span>
<span class="fc" id="L2083">		List&lt;Element&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2084">		List&lt;Change&gt; diverted = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2085">		Document doc = DOMMessage.createNewDocument();</span>

		// For all sorted changes, if it is notifiable to the target
		// player then convert it to an Element, or divert for later
		// attachment. Then add all consequence changes to the list.
<span class="fc" id="L2090">		Collections.sort(c, changeComparator);</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">		while (!c.isEmpty()) {</span>
<span class="fc" id="L2092">			Change change = c.remove(0);</span>
<span class="fc bfc" id="L2093" title="All 2 branches covered.">			if (change.isNotifiable(serverPlayer)) {</span>
<span class="fc bfc" id="L2094" title="All 2 branches covered.">				if (change.convertsToElement()) {</span>
<span class="fc" id="L2095">					elements.add(change.toElement(serverPlayer, doc));</span>
				} else {
<span class="fc" id="L2097">					diverted.add(change);</span>
				}
<span class="fc" id="L2099">				c.addAll(change.consequences(serverPlayer));</span>
			}
<span class="fc" id="L2101">		}</span>
<span class="fc" id="L2102">		elements = collapseElementList(elements);</span>

		// Decide what to return. If there are several parts with
		// children then return multiple, if there is one viable part,
		// return that, if there is none return null unless there are
		// attributes in which case they become viable as an update.
		Element result;
<span class="fc bfc" id="L2109" title="All 3 branches covered.">		switch (elements.size()) {</span>
		case 0:
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">			if (diverted.isEmpty())</span>
<span class="fc" id="L2112">				return null;</span>
<span class="nc" id="L2113">			result = doc.createElement(&quot;update&quot;);</span>
<span class="nc" id="L2114">			break;</span>
		case 1:
<span class="fc" id="L2116">			result = elements.get(0);</span>
<span class="fc" id="L2117">			break;</span>
		default:
<span class="fc" id="L2119">			result = doc.createElement(&quot;multiple&quot;);</span>
<span class="fc bfc" id="L2120" title="All 2 branches covered.">			for (Element e : elements)</span>
<span class="fc" id="L2121">				result.appendChild(e);</span>
			break;
		}
<span class="fc" id="L2124">		doc.appendChild(result);</span>
<span class="fc bfc" id="L2125" title="All 2 branches covered.">		for (Change change : diverted)</span>
<span class="fc" id="L2126">			change.attachToElement(result);</span>
<span class="fc" id="L2127">		return result;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="nc" id="L2135">		StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2136">		Collections.sort(changes, changeComparator);</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">		for (Change c : changes)</span>
<span class="nc" id="L2138">			sb.append(c).append(&quot;\n&quot;);</span>
<span class="nc" id="L2139">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>